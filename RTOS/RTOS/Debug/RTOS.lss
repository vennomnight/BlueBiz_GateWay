
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009c  00800100  000030e0  00003174  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000030e0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c34  0080019c  0080019c  00003210  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003210  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003240  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000008e0  00000000  00000000  00003280  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b580  00000000  00000000  00003b60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003206  00000000  00000000  0000f0e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000051e2  00000000  00000000  000122e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000017dc  00000000  00000000  000174c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000032f5  00000000  00000000  00018ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007f1a  00000000  00000000  0001bf99  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008b8  00000000  00000000  00023eb3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	88 c3       	rjmp	.+1808   	; 0x716 <__vector_1>
       6:	00 00       	nop
       8:	60 c0       	rjmp	.+192    	; 0xca <__bad_interrupt>
       a:	00 00       	nop
       c:	5e c0       	rjmp	.+188    	; 0xca <__bad_interrupt>
       e:	00 00       	nop
      10:	5c c0       	rjmp	.+184    	; 0xca <__bad_interrupt>
      12:	00 00       	nop
      14:	5a c0       	rjmp	.+180    	; 0xca <__bad_interrupt>
      16:	00 00       	nop
      18:	58 c0       	rjmp	.+176    	; 0xca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	56 c0       	rjmp	.+172    	; 0xca <__bad_interrupt>
      1e:	00 00       	nop
      20:	54 c0       	rjmp	.+168    	; 0xca <__bad_interrupt>
      22:	00 00       	nop
      24:	4b c4       	rjmp	.+2198   	; 0x8bc <__vector_9>
      26:	00 00       	nop
      28:	50 c0       	rjmp	.+160    	; 0xca <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4e c0       	rjmp	.+156    	; 0xca <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 9a 0f 	jmp	0x1f34	; 0x1f34 <__vector_12>
      34:	4a c0       	rjmp	.+148    	; 0xca <__bad_interrupt>
      36:	00 00       	nop
      38:	48 c0       	rjmp	.+144    	; 0xca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	e1 c1       	rjmp	.+962    	; 0x400 <__vector_15>
      3e:	00 00       	nop
      40:	44 c0       	rjmp	.+136    	; 0xca <__bad_interrupt>
      42:	00 00       	nop
      44:	42 c0       	rjmp	.+132    	; 0xca <__bad_interrupt>
      46:	00 00       	nop
      48:	d5 c2       	rjmp	.+1450   	; 0x5f4 <__vector_18>
      4a:	00 00       	nop
      4c:	3e c0       	rjmp	.+124    	; 0xca <__bad_interrupt>
      4e:	00 00       	nop
      50:	3c c0       	rjmp	.+120    	; 0xca <__bad_interrupt>
      52:	00 00       	nop
      54:	3a c0       	rjmp	.+116    	; 0xca <__bad_interrupt>
      56:	00 00       	nop
      58:	38 c0       	rjmp	.+112    	; 0xca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	36 c0       	rjmp	.+108    	; 0xca <__bad_interrupt>
      5e:	00 00       	nop
      60:	34 c0       	rjmp	.+104    	; 0xca <__bad_interrupt>
      62:	00 00       	nop
      64:	32 c0       	rjmp	.+100    	; 0xca <__bad_interrupt>
      66:	00 00       	nop
      68:	30 c0       	rjmp	.+96     	; 0xca <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2e c0       	rjmp	.+92     	; 0xca <__bad_interrupt>
      6e:	00 00       	nop
      70:	22 c3       	rjmp	.+1604   	; 0x6b6 <__vector_28>
      72:	00 00       	nop
      74:	2a c0       	rjmp	.+84     	; 0xca <__bad_interrupt>
      76:	00 00       	nop
      78:	ed c2       	rjmp	.+1498   	; 0x654 <__vector_30>
      7a:	00 00       	nop
      7c:	26 c0       	rjmp	.+76     	; 0xca <__bad_interrupt>
      7e:	00 00       	nop
      80:	24 c0       	rjmp	.+72     	; 0xca <__bad_interrupt>
      82:	00 00       	nop
      84:	22 c0       	rjmp	.+68     	; 0xca <__bad_interrupt>
      86:	00 00       	nop
      88:	20 c0       	rjmp	.+64     	; 0xca <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e0 ee       	ldi	r30, 0xE0	; 224
      a0:	f0 e3       	ldi	r31, 0x30	; 48
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 39       	cpi	r26, 0x9C	; 156
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2d e0       	ldi	r18, 0x0D	; 13
      b4:	ac e9       	ldi	r26, 0x9C	; 156
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 3d       	cpi	r26, 0xD0	; 208
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <main>
      c6:	0c 94 6e 18 	jmp	0x30dc	; 0x30dc <_exit>

000000ca <__bad_interrupt>:
      ca:	9a cf       	rjmp	.-204    	; 0x0 <__vectors>

000000cc <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      cc:	fc 01       	movw	r30, r24
      ce:	68 0f       	add	r22, r24
      d0:	79 1f       	adc	r23, r25
      d2:	8f ef       	ldi	r24, 0xFF	; 255
      d4:	9f ef       	ldi	r25, 0xFF	; 255
      d6:	e6 17       	cp	r30, r22
      d8:	f7 07       	cpc	r31, r23
      da:	99 f0       	breq	.+38     	; 0x102 <_Z5CRC16Phi+0x36>
      dc:	21 91       	ld	r18, Z+
      de:	82 27       	eor	r24, r18
      e0:	28 e0       	ldi	r18, 0x08	; 8
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	ac 01       	movw	r20, r24
      e6:	41 70       	andi	r20, 0x01	; 1
      e8:	55 27       	eor	r21, r21
      ea:	96 95       	lsr	r25
      ec:	87 95       	ror	r24
      ee:	45 2b       	or	r20, r21
      f0:	21 f0       	breq	.+8      	; 0xfa <_Z5CRC16Phi+0x2e>
      f2:	41 e0       	ldi	r20, 0x01	; 1
      f4:	84 27       	eor	r24, r20
      f6:	40 ea       	ldi	r20, 0xA0	; 160
      f8:	94 27       	eor	r25, r20
      fa:	21 50       	subi	r18, 0x01	; 1
      fc:	31 09       	sbc	r19, r1
      fe:	91 f7       	brne	.-28     	; 0xe4 <_Z5CRC16Phi+0x18>
     100:	ea cf       	rjmp	.-44     	; 0xd6 <_Z5CRC16Phi+0xa>
     102:	08 95       	ret

00000104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	dc 01       	movw	r26, r24
     10a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     10c:	8c 91       	ld	r24, X
     10e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     110:	11 96       	adiw	r26, 0x01	; 1
     112:	8c 91       	ld	r24, X
     114:	11 97       	sbiw	r26, 0x01	; 1
     116:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     118:	13 96       	adiw	r26, 0x03	; 3
     11a:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     11c:	92 e0       	ldi	r25, 0x02	; 2
     11e:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     120:	e8 2f       	mov	r30, r24
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	ee 0f       	add	r30, r30
     126:	ff 1f       	adc	r31, r31
     128:	e4 0f       	add	r30, r20
     12a:	f5 1f       	adc	r31, r21
     12c:	81 81       	ldd	r24, Z+1	; 0x01
     12e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     130:	80 81       	ld	r24, Z
     132:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     134:	65 e0       	ldi	r22, 0x05	; 5
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	ce 01       	movw	r24, r28
     13a:	c8 df       	rcall	.-112    	; 0xcc <_Z5CRC16Phi>
	function04->CRC = crc16;
     13c:	9e 83       	std	Y+6, r25	; 0x06
     13e:	8d 83       	std	Y+5, r24	; 0x05
}
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	08 95       	ret

00000146 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     146:	cf 93       	push	r28
     148:	df 93       	push	r29
     14a:	fc 01       	movw	r30, r24
     14c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     14e:	80 81       	ld	r24, Z
     150:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     156:	82 81       	ldd	r24, Z+2	; 0x02
     158:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     15a:	83 81       	ldd	r24, Z+3	; 0x03
     15c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     15e:	84 81       	ldd	r24, Z+4	; 0x04
     160:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     162:	85 81       	ldd	r24, Z+5	; 0x05
     164:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     166:	66 e0       	ldi	r22, 0x06	; 6
     168:	70 e0       	ldi	r23, 0x00	; 0
     16a:	ce 01       	movw	r24, r28
     16c:	af df       	rcall	.-162    	; 0xcc <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     16e:	9f 83       	std	Y+7, r25	; 0x07
     170:	8e 83       	std	Y+6, r24	; 0x06
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	fc 01       	movw	r30, r24
     17e:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     180:	80 81       	ld	r24, Z
     182:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     184:	81 81       	ldd	r24, Z+1	; 0x01
     186:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     18c:	83 81       	ldd	r24, Z+3	; 0x03
     18e:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     190:	94 81       	ldd	r25, Z+4	; 0x04
     192:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     194:	95 81       	ldd	r25, Z+5	; 0x05
     196:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     198:	96 81       	ldd	r25, Z+6	; 0x06
     19a:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     19c:	27 81       	ldd	r18, Z+7	; 0x07
     19e:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1a0:	90 85       	ldd	r25, Z+8	; 0x08
     1a2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1a4:	e8 2f       	mov	r30, r24
     1a6:	f0 e0       	ldi	r31, 0x00	; 0
     1a8:	ee 0f       	add	r30, r30
     1aa:	ff 1f       	adc	r31, r31
     1ac:	e4 0f       	add	r30, r20
     1ae:	f5 1f       	adc	r31, r21
     1b0:	89 2f       	mov	r24, r25
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	92 2b       	or	r25, r18
     1b6:	91 83       	std	Z+1, r25	; 0x01
     1b8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1ba:	69 e0       	ldi	r22, 0x09	; 9
     1bc:	70 e0       	ldi	r23, 0x00	; 0
     1be:	ce 01       	movw	r24, r28
     1c0:	85 df       	rcall	.-246    	; 0xcc <_Z5CRC16Phi>
	function10->CRC = crc16;
     1c2:	9a 87       	std	Y+10, r25	; 0x0a
     1c4:	89 87       	std	Y+9, r24	; 0x09
}
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	08 95       	ret

000001cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	fc 01       	movw	r30, r24
     1d2:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1d4:	80 81       	ld	r24, Z
     1d6:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1d8:	81 81       	ldd	r24, Z+1	; 0x01
     1da:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1dc:	82 81       	ldd	r24, Z+2	; 0x02
     1de:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1e0:	83 81       	ldd	r24, Z+3	; 0x03
     1e2:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     1e8:	85 81       	ldd	r24, Z+5	; 0x05
     1ea:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     1ec:	66 e0       	ldi	r22, 0x06	; 6
     1ee:	70 e0       	ldi	r23, 0x00	; 0
     1f0:	ce 01       	movw	r24, r28
     1f2:	6c df       	rcall	.-296    	; 0xcc <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     1f4:	9f 83       	std	Y+7, r25	; 0x07
     1f6:	8e 83       	std	Y+6, r24	; 0x06
}
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	08 95       	ret

000001fe <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     204:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     206:	81 e8       	ldi	r24, 0x81	; 129
     208:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     20a:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     20c:	63 e0       	ldi	r22, 0x03	; 3
     20e:	70 e0       	ldi	r23, 0x00	; 0
     210:	ce 01       	movw	r24, r28
     212:	5c df       	rcall	.-328    	; 0xcc <_Z5CRC16Phi>
	Exception->CRC = crc16;
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	08 95       	ret

0000021e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     21e:	1f 93       	push	r17
     220:	cf 93       	push	r28
     222:	df 93       	push	r29
     224:	ec 01       	movw	r28, r24
     226:	cb 01       	movw	r24, r22
     228:	14 2f       	mov	r17, r20
     22a:	fe 01       	movw	r30, r28
     22c:	ea 57       	subi	r30, 0x7A	; 122
     22e:	ff 4f       	sbci	r31, 0xFF	; 255
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	64 2f       	mov	r22, r20
     236:	c8 d1       	rcall	.+912    	; 0x5c8 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     238:	88 23       	and	r24, r24
     23a:	71 f0       	breq	.+28     	; 0x258 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     23c:	fe 01       	movw	r30, r28
     23e:	eb 57       	subi	r30, 0x7B	; 123
     240:	ff 4f       	sbci	r31, 0xFF	; 255
     242:	10 83       	st	Z, r17
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	10 82       	st	Z, r1
     248:	34 97       	sbiw	r30, 0x04	; 4
     24a:	11 82       	std	Z+1, r1	; 0x01
     24c:	10 82       	st	Z, r1
     24e:	ce 57       	subi	r28, 0x7E	; 126
     250:	df 4f       	sbci	r29, 0xFF	; 255
     252:	19 82       	std	Y+1, r1	; 0x01
     254:	18 82       	st	Y, r1
     256:	04 c0       	rjmp	.+8      	; 0x260 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     258:	ca 57       	subi	r28, 0x7A	; 122
     25a:	df 4f       	sbci	r29, 0xFF	; 255
     25c:	19 82       	std	Y+1, r1	; 0x01
     25e:	18 82       	st	Y, r1
     260:	df 91       	pop	r29
     262:	cf 91       	pop	r28
     264:	1f 91       	pop	r17
     266:	08 95       	ret

00000268 <_ZN12SerialBuffernwEj>:
     268:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
     26c:	08 95       	ret

0000026e <_ZN12SerialBuffer11SerialstoreEc>:
     26e:	fc 01       	movw	r30, r24
     270:	e0 58       	subi	r30, 0x80	; 128
     272:	ff 4f       	sbci	r31, 0xFF	; 255
     274:	20 81       	ld	r18, Z
     276:	2f 5f       	subi	r18, 0xFF	; 255
     278:	2f 77       	andi	r18, 0x7F	; 127
     27a:	19 f4       	brne	.+6      	; 0x282 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     27c:	11 82       	std	Z+1, r1	; 0x01
     27e:	10 82       	st	Z, r1
     280:	21 e0       	ldi	r18, 0x01	; 1
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	fc 01       	movw	r30, r24
     286:	ee 57       	subi	r30, 0x7E	; 126
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	40 81       	ld	r20, Z
     28c:	51 81       	ldd	r21, Z+1	; 0x01
     28e:	24 17       	cp	r18, r20
     290:	35 07       	cpc	r19, r21
     292:	89 f0       	breq	.+34     	; 0x2b6 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     294:	dc 01       	movw	r26, r24
     296:	a0 58       	subi	r26, 0x80	; 128
     298:	bf 4f       	sbci	r27, 0xFF	; 255
     29a:	ed 91       	ld	r30, X+
     29c:	fc 91       	ld	r31, X
     29e:	11 97       	sbiw	r26, 0x01	; 1
     2a0:	e8 0f       	add	r30, r24
     2a2:	f9 1f       	adc	r31, r25
     2a4:	61 83       	std	Z+1, r22	; 0x01
     2a6:	2d 93       	st	X+, r18
     2a8:	3c 93       	st	X, r19
     2aa:	fc 01       	movw	r30, r24
     2ac:	ec 57       	subi	r30, 0x7C	; 124
     2ae:	ff 4f       	sbci	r31, 0xFF	; 255
     2b0:	80 81       	ld	r24, Z
     2b2:	8f 5f       	subi	r24, 0xFF	; 255
     2b4:	80 83       	st	Z, r24
     2b6:	08 95       	ret

000002b8 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	1f 93       	push	r17
     2c8:	cf 93       	push	r28
     2ca:	8c 01       	movw	r16, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	7a 01       	movw	r14, r20
     2d0:	dc 01       	movw	r26, r24
     2d2:	ab 57       	subi	r26, 0x7B	; 123
     2d4:	bf 4f       	sbci	r27, 0xFF	; 255
     2d6:	fc 01       	movw	r30, r24
     2d8:	ea 57       	subi	r30, 0x7A	; 122
     2da:	ff 4f       	sbci	r31, 0xFF	; 255
     2dc:	6c 91       	ld	r22, X
     2de:	80 81       	ld	r24, Z
     2e0:	91 81       	ldd	r25, Z+1	; 0x01
     2e2:	7f d1       	rcall	.+766    	; 0x5e2 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2e4:	89 2b       	or	r24, r25
     2e6:	d1 f0       	breq	.+52     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2e8:	1e 14       	cp	r1, r14
     2ea:	1f 04       	cpc	r1, r15
     2ec:	bc f4       	brge	.+46     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2ee:	c0 e0       	ldi	r28, 0x00	; 0
     2f0:	58 01       	movw	r10, r16
     2f2:	85 e8       	ldi	r24, 0x85	; 133
     2f4:	a8 0e       	add	r10, r24
     2f6:	b1 1c       	adc	r11, r1
     2f8:	0a 57       	subi	r16, 0x7A	; 122
     2fa:	1f 4f       	sbci	r17, 0xFF	; 255
     2fc:	f6 01       	movw	r30, r12
     2fe:	ec 0f       	add	r30, r28
     300:	f1 1d       	adc	r31, r1
     302:	40 81       	ld	r20, Z
     304:	f5 01       	movw	r30, r10
     306:	60 81       	ld	r22, Z
     308:	f8 01       	movw	r30, r16
     30a:	80 81       	ld	r24, Z
     30c:	91 81       	ldd	r25, Z+1	; 0x01
     30e:	15 d1       	rcall	.+554    	; 0x53a <_ZN11Dev_Manager5WriteE8Dev_typec>
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	2c 2f       	mov	r18, r28
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	2e 15       	cp	r18, r14
     318:	3f 05       	cpc	r19, r15
     31a:	84 f3       	brlt	.-32     	; 0x2fc <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	bf 90       	pop	r11
     32c:	af 90       	pop	r10
     32e:	08 95       	ret

00000330 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     330:	fc 01       	movw	r30, r24
     332:	ee 57       	subi	r30, 0x7E	; 126
     334:	ff 4f       	sbci	r31, 0xFF	; 255
     336:	20 81       	ld	r18, Z
     338:	31 81       	ldd	r19, Z+1	; 0x01
     33a:	32 97       	sbiw	r30, 0x02	; 2
     33c:	40 81       	ld	r20, Z
     33e:	51 81       	ldd	r21, Z+1	; 0x01
     340:	42 17       	cp	r20, r18
     342:	53 07       	cpc	r21, r19
     344:	e9 f0       	breq	.+58     	; 0x380 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	3f 4f       	sbci	r19, 0xFF	; 255
     34a:	fc 01       	movw	r30, r24
     34c:	e2 0f       	add	r30, r18
     34e:	f3 1f       	adc	r31, r19
     350:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     352:	2f 77       	andi	r18, 0x7F	; 127
     354:	33 27       	eor	r19, r19
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	31 83       	std	Z+1, r19	; 0x01
     35e:	20 83       	st	Z, r18
		if (ib.tail == num)
     360:	32 96       	adiw	r30, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	26 17       	cp	r18, r22
     368:	37 07       	cpc	r19, r23
     36a:	61 f4       	brne	.+24     	; 0x384 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     36c:	32 97       	sbiw	r30, 0x02	; 2
     36e:	11 82       	std	Z+1, r1	; 0x01
     370:	10 82       	st	Z, r1
			ib.head = 0;
     372:	32 97       	sbiw	r30, 0x02	; 2
     374:	11 82       	std	Z+1, r1	; 0x01
     376:	10 82       	st	Z, r1
			num = 0;
     378:	34 96       	adiw	r30, 0x04	; 4
     37a:	10 82       	st	Z, r1
		}
		return data;
     37c:	84 2f       	mov	r24, r20
     37e:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     384:	84 2f       	mov	r24, r20
	}
}
     386:	08 95       	ret

00000388 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     388:	dc 01       	movw	r26, r24
     38a:	a0 58       	subi	r26, 0x80	; 128
     38c:	bf 4f       	sbci	r27, 0xFF	; 255
     38e:	fc 01       	movw	r30, r24
     390:	ee 57       	subi	r30, 0x7E	; 126
     392:	ff 4f       	sbci	r31, 0xFF	; 255
     394:	8c 91       	ld	r24, X
     396:	90 81       	ld	r25, Z
     398:	89 1b       	sub	r24, r25
}
     39a:	8f 77       	andi	r24, 0x7F	; 127
     39c:	08 95       	ret

0000039e <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     39e:	fc 01       	movw	r30, r24
     3a0:	ee 57       	subi	r30, 0x7E	; 126
     3a2:	ff 4f       	sbci	r31, 0xFF	; 255
     3a4:	11 82       	std	Z+1, r1	; 0x01
     3a6:	10 82       	st	Z, r1
	ib.head = 0;
     3a8:	32 97       	sbiw	r30, 0x02	; 2
     3aa:	11 82       	std	Z+1, r1	; 0x01
     3ac:	10 82       	st	Z, r1
	num = 0;
     3ae:	34 96       	adiw	r30, 0x04	; 4
     3b0:	10 82       	st	Z, r1
     3b2:	08 95       	ret

000003b4 <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
     3b4:	8c e0       	ldi	r24, 0x0C	; 12
     3b6:	83 bf       	out	0x33, r24	; 51
     3b8:	8c e7       	ldi	r24, 0x7C	; 124
     3ba:	81 bf       	out	0x31, r24	; 49
     3bc:	87 b7       	in	r24, 0x37	; 55
     3be:	82 60       	ori	r24, 0x02	; 2
     3c0:	87 bf       	out	0x37, r24	; 55
     3c2:	08 95       	ret

000003c4 <Alarm_Stop>:
     3c4:	87 b7       	in	r24, 0x37	; 55
     3c6:	8d 7f       	andi	r24, 0xFD	; 253
     3c8:	87 bf       	out	0x37, r24	; 55
     3ca:	08 95       	ret

000003cc <Alarm_Start>:
     3cc:	87 b7       	in	r24, 0x37	; 55
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	87 bf       	out	0x37, r24	; 55
     3d2:	08 95       	ret

000003d4 <Alarm_Open>:
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	fc 01       	movw	r30, r24
     3d8:	ee 0f       	add	r30, r30
     3da:	ff 1f       	adc	r31, r31
     3dc:	df 01       	movw	r26, r30
     3de:	a8 0f       	add	r26, r24
     3e0:	b9 1f       	adc	r27, r25
     3e2:	aa 0f       	add	r26, r26
     3e4:	bb 1f       	adc	r27, r27
     3e6:	a4 56       	subi	r26, 0x64	; 100
     3e8:	be 4f       	sbci	r27, 0xFE	; 254
     3ea:	11 96       	adiw	r26, 0x01	; 1
     3ec:	7c 93       	st	X, r23
     3ee:	6e 93       	st	-X, r22
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	1c 92       	st	X, r1
     3f4:	1e 92       	st	-X, r1
     3f6:	12 97       	sbiw	r26, 0x02	; 2
     3f8:	fd 01       	movw	r30, r26
     3fa:	55 83       	std	Z+5, r21	; 0x05
     3fc:	44 83       	std	Z+4, r20	; 0x04
     3fe:	08 95       	ret

00000400 <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
     400:	1f 92       	push	r1
     402:	0f 92       	push	r0
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	0f 92       	push	r0
     408:	11 24       	eor	r1, r1
     40a:	0b b6       	in	r0, 0x3b	; 59
     40c:	0f 92       	push	r0
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	1f 93       	push	r17
     416:	2f 93       	push	r18
     418:	3f 93       	push	r19
     41a:	4f 93       	push	r20
     41c:	5f 93       	push	r21
     41e:	6f 93       	push	r22
     420:	7f 93       	push	r23
     422:	8f 93       	push	r24
     424:	9f 93       	push	r25
     426:	af 93       	push	r26
     428:	bf 93       	push	r27
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	ef 93       	push	r30
     430:	ff 93       	push	r31
     432:	cc e9       	ldi	r28, 0x9C	; 156
     434:	d1 e0       	ldi	r29, 0x01	; 1
     436:	0f 2e       	mov	r0, r31
     438:	fa eb       	ldi	r31, 0xBA	; 186
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 e0       	ldi	r31, 0x01	; 1
     43e:	ff 2e       	mov	r15, r31
     440:	f0 2d       	mov	r31, r0
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
     442:	ec 81       	ldd	r30, Y+4	; 0x04
     444:	fd 81       	ldd	r31, Y+5	; 0x05
     446:	30 97       	sbiw	r30, 0x00	; 0
     448:	79 f0       	breq	.+30     	; 0x468 <__vector_15+0x68>
		{
			AlarmTable[i].Time++;
     44a:	8a 81       	ldd	r24, Y+2	; 0x02
     44c:	9b 81       	ldd	r25, Y+3	; 0x03
     44e:	01 96       	adiw	r24, 0x01	; 1
     450:	9b 83       	std	Y+3, r25	; 0x03
     452:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
     454:	28 81       	ld	r18, Y
     456:	39 81       	ldd	r19, Y+1	; 0x01
     458:	82 17       	cp	r24, r18
     45a:	93 07       	cpc	r25, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <__vector_15+0x68>
			{
				AlarmTable[i].Time = 0;
     45e:	1b 82       	std	Y+3, r1	; 0x03
     460:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
     462:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
     464:	1d 82       	std	Y+5, r1	; 0x05
     466:	1c 82       	std	Y+4, r1	; 0x04
     468:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
     46a:	ce 15       	cp	r28, r14
     46c:	df 05       	cpc	r29, r15
     46e:	49 f7       	brne	.-46     	; 0x442 <__vector_15+0x42>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
     470:	ff 91       	pop	r31
     472:	ef 91       	pop	r30
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	bf 91       	pop	r27
     47a:	af 91       	pop	r26
     47c:	9f 91       	pop	r25
     47e:	8f 91       	pop	r24
     480:	7f 91       	pop	r23
     482:	6f 91       	pop	r22
     484:	5f 91       	pop	r21
     486:	4f 91       	pop	r20
     488:	3f 91       	pop	r19
     48a:	2f 91       	pop	r18
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	ff 90       	pop	r15
     492:	ef 90       	pop	r14
     494:	0f 90       	pop	r0
     496:	0b be       	out	0x3b, r0	; 59
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0
     49e:	1f 90       	pop	r1
     4a0:	18 95       	reti

000004a2 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	08 95       	ret

000004a6 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
	virtual void Device_Writes(const char* data){}
     4a6:	08 95       	ret

000004a8 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
     4a8:	08 95       	ret

000004aa <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
     4aa:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
     4ac:	8f ef       	ldi	r24, 0xFF	; 255
     4ae:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
     4b0:	ea e6       	ldi	r30, 0x6A	; 106
     4b2:	f0 e0       	ldi	r31, 0x00	; 0
     4b4:	80 81       	ld	r24, Z
     4b6:	82 60       	ori	r24, 0x02	; 2
     4b8:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
     4ba:	80 81       	ld	r24, Z
     4bc:	8e 7f       	andi	r24, 0xFE	; 254
     4be:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
     4c0:	89 b7       	in	r24, 0x39	; 57
     4c2:	81 60       	ori	r24, 0x01	; 1
     4c4:	89 bf       	out	0x39, r24	; 57
     4c6:	08 95       	ret

000004c8 <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
     4c8:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
}
     4cc:	08 95       	ret

000004ce <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     4ce:	28 e0       	ldi	r18, 0x08	; 8
     4d0:	dc 01       	movw	r26, r24
     4d2:	e2 2f       	mov	r30, r18
     4d4:	1d 92       	st	X+, r1
     4d6:	ea 95       	dec	r30
     4d8:	e9 f7       	brne	.-6      	; 0x4d4 <_ZN11Dev_ManagerC1Ev+0x6>
     4da:	fc 01       	movw	r30, r24
     4dc:	38 96       	adiw	r30, 0x08	; 8
     4de:	df 01       	movw	r26, r30
     4e0:	1d 92       	st	X+, r1
     4e2:	2a 95       	dec	r18
     4e4:	e9 f7       	brne	.-6      	; 0x4e0 <_ZN11Dev_ManagerC1Ev+0x12>
     4e6:	90 93 bb 01 	sts	0x01BB, r25	; 0x8001bb <_ZN11Dev_Manager4instE+0x1>
     4ea:	80 93 ba 01 	sts	0x01BA, r24	; 0x8001ba <_ZN11Dev_Manager4instE>
     4ee:	08 95       	ret

000004f0 <_ZN11Dev_Manager11getInstanceEv>:
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <_ZN11Dev_Manager4instE>
     4f8:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <_ZN11Dev_Manager4instE+0x1>
     4fc:	89 2b       	or	r24, r25
     4fe:	51 f4       	brne	.+20     	; 0x514 <_ZN11Dev_Manager11getInstanceEv+0x24>
     500:	80 e1       	ldi	r24, 0x10	; 16
     502:	90 e0       	ldi	r25, 0x00	; 0
     504:	0e 94 89 0d 	call	0x1b12	; 0x1b12 <pvPortMalloc>
     508:	ec 01       	movw	r28, r24
     50a:	e1 df       	rcall	.-62     	; 0x4ce <_ZN11Dev_ManagerC1Ev>
     50c:	d0 93 bb 01 	sts	0x01BB, r29	; 0x8001bb <_ZN11Dev_Manager4instE+0x1>
     510:	c0 93 ba 01 	sts	0x01BA, r28	; 0x8001ba <_ZN11Dev_Manager4instE>
     514:	80 91 ba 01 	lds	r24, 0x01BA	; 0x8001ba <_ZN11Dev_Manager4instE>
     518:	90 91 bb 01 	lds	r25, 0x01BB	; 0x8001bb <_ZN11Dev_Manager4instE+0x1>
     51c:	df 91       	pop	r29
     51e:	cf 91       	pop	r28
     520:	08 95       	ret

00000522 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     522:	50 e0       	ldi	r21, 0x00	; 0
     524:	44 0f       	add	r20, r20
     526:	55 1f       	adc	r21, r21
     528:	84 0f       	add	r24, r20
     52a:	95 1f       	adc	r25, r21
     52c:	fc 01       	movw	r30, r24
     52e:	71 83       	std	Z+1, r23	; 0x01
     530:	60 83       	st	Z, r22
     532:	08 95       	ret

00000534 <_ZN11Dev_ManagernwEj>:
     534:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
     538:	08 95       	ret

0000053a <_ZN11Dev_Manager5WriteE8Dev_typec>:
     53a:	26 2f       	mov	r18, r22
     53c:	30 e0       	ldi	r19, 0x00	; 0
     53e:	22 0f       	add	r18, r18
     540:	33 1f       	adc	r19, r19
     542:	82 0f       	add	r24, r18
     544:	93 1f       	adc	r25, r19
     546:	dc 01       	movw	r26, r24
     548:	8d 91       	ld	r24, X+
     54a:	9c 91       	ld	r25, X
     54c:	00 97       	sbiw	r24, 0x00	; 0
     54e:	41 f0       	breq	.+16     	; 0x560 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     550:	64 2f       	mov	r22, r20
     552:	dc 01       	movw	r26, r24
     554:	ed 91       	ld	r30, X+
     556:	fc 91       	ld	r31, X
     558:	06 80       	ldd	r0, Z+6	; 0x06
     55a:	f7 81       	ldd	r31, Z+7	; 0x07
     55c:	e0 2d       	mov	r30, r0
     55e:	09 95       	icall
     560:	08 95       	ret

00000562 <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     562:	26 2f       	mov	r18, r22
     564:	30 e0       	ldi	r19, 0x00	; 0
     566:	22 0f       	add	r18, r18
     568:	33 1f       	adc	r19, r19
     56a:	82 0f       	add	r24, r18
     56c:	93 1f       	adc	r25, r19
     56e:	dc 01       	movw	r26, r24
     570:	8d 91       	ld	r24, X+
     572:	9c 91       	ld	r25, X
     574:	00 97       	sbiw	r24, 0x00	; 0
     576:	41 f0       	breq	.+16     	; 0x588 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     578:	ba 01       	movw	r22, r20
     57a:	dc 01       	movw	r26, r24
     57c:	ed 91       	ld	r30, X+
     57e:	fc 91       	ld	r31, X
     580:	04 80       	ldd	r0, Z+4	; 0x04
     582:	f5 81       	ldd	r31, Z+5	; 0x05
     584:	e0 2d       	mov	r30, r0
     586:	09 95       	icall
     588:	08 95       	ret

0000058a <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	66 0f       	add	r22, r22
     58e:	77 1f       	adc	r23, r23
     590:	86 0f       	add	r24, r22
     592:	97 1f       	adc	r25, r23
     594:	dc 01       	movw	r26, r24
     596:	8d 91       	ld	r24, X+
     598:	9c 91       	ld	r25, X
     59a:	00 97       	sbiw	r24, 0x00	; 0
     59c:	39 f0       	breq	.+14     	; 0x5ac <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     59e:	dc 01       	movw	r26, r24
     5a0:	ed 91       	ld	r30, X+
     5a2:	fc 91       	ld	r31, X
     5a4:	01 90       	ld	r0, Z+
     5a6:	f0 81       	ld	r31, Z
     5a8:	e0 2d       	mov	r30, r0
     5aa:	09 95       	icall
     5ac:	08 95       	ret

000005ae <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     5ae:	e6 2f       	mov	r30, r22
     5b0:	f0 e0       	ldi	r31, 0x00	; 0
     5b2:	ee 0f       	add	r30, r30
     5b4:	ff 1f       	adc	r31, r31
     5b6:	e8 0f       	add	r30, r24
     5b8:	f9 1f       	adc	r31, r25
     5ba:	80 81       	ld	r24, Z
     5bc:	91 81       	ldd	r25, Z+1	; 0x01
     5be:	89 2b       	or	r24, r25
     5c0:	11 f0       	breq	.+4      	; 0x5c6 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     5c2:	51 87       	std	Z+9, r21	; 0x09
     5c4:	40 87       	std	Z+8, r20	; 0x08
     5c6:	08 95       	ret

000005c8 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     5c8:	70 e0       	ldi	r23, 0x00	; 0
     5ca:	66 0f       	add	r22, r22
     5cc:	77 1f       	adc	r23, r23
     5ce:	fc 01       	movw	r30, r24
     5d0:	e6 0f       	add	r30, r22
     5d2:	f7 1f       	adc	r31, r23
     5d4:	81 e0       	ldi	r24, 0x01	; 1
     5d6:	20 81       	ld	r18, Z
     5d8:	31 81       	ldd	r19, Z+1	; 0x01
     5da:	23 2b       	or	r18, r19
     5dc:	09 f4       	brne	.+2      	; 0x5e0 <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	08 95       	ret

000005e2 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
const DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     5e2:	70 e0       	ldi	r23, 0x00	; 0
     5e4:	66 0f       	add	r22, r22
     5e6:	77 1f       	adc	r23, r23
     5e8:	86 0f       	add	r24, r22
     5ea:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     5ec:	fc 01       	movw	r30, r24
     5ee:	80 81       	ld	r24, Z
     5f0:	91 81       	ldd	r25, Z+1	; 0x01
     5f2:	08 95       	ret

000005f4 <__vector_18>:
ISR(USART0_RX_vect)
{
     5f4:	1f 92       	push	r1
     5f6:	0f 92       	push	r0
     5f8:	0f b6       	in	r0, 0x3f	; 63
     5fa:	0f 92       	push	r0
     5fc:	11 24       	eor	r1, r1
     5fe:	0b b6       	in	r0, 0x3b	; 59
     600:	0f 92       	push	r0
     602:	2f 93       	push	r18
     604:	3f 93       	push	r19
     606:	4f 93       	push	r20
     608:	5f 93       	push	r21
     60a:	6f 93       	push	r22
     60c:	7f 93       	push	r23
     60e:	8f 93       	push	r24
     610:	9f 93       	push	r25
     612:	af 93       	push	r26
     614:	bf 93       	push	r27
     616:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     618:	ff 93       	push	r31
     61a:	6a df       	rcall	.-300    	; 0x4f0 <_ZN11Dev_Manager11getInstanceEv>
     61c:	6c b1       	in	r22, 0x0c	; 12
     61e:	70 e0       	ldi	r23, 0x00	; 0
     620:	dc 01       	movw	r26, r24
     622:	18 96       	adiw	r26, 0x08	; 8
     624:	ed 91       	ld	r30, X+
     626:	fc 91       	ld	r31, X
     628:	19 97       	sbiw	r26, 0x09	; 9
     62a:	80 e0       	ldi	r24, 0x00	; 0
}
     62c:	09 95       	icall
     62e:	ff 91       	pop	r31
     630:	ef 91       	pop	r30
     632:	bf 91       	pop	r27
     634:	af 91       	pop	r26
     636:	9f 91       	pop	r25
     638:	8f 91       	pop	r24
     63a:	7f 91       	pop	r23
     63c:	6f 91       	pop	r22
     63e:	5f 91       	pop	r21
     640:	4f 91       	pop	r20
     642:	3f 91       	pop	r19
     644:	2f 91       	pop	r18
     646:	0f 90       	pop	r0
     648:	0b be       	out	0x3b, r0	; 59
     64a:	0f 90       	pop	r0
     64c:	0f be       	out	0x3f, r0	; 63
     64e:	0f 90       	pop	r0
     650:	1f 90       	pop	r1
     652:	18 95       	reti

00000654 <__vector_30>:
ISR(USART1_RX_vect)
{
     654:	1f 92       	push	r1
     656:	0f 92       	push	r0
     658:	0f b6       	in	r0, 0x3f	; 63
     65a:	0f 92       	push	r0
     65c:	11 24       	eor	r1, r1
     65e:	0b b6       	in	r0, 0x3b	; 59
     660:	0f 92       	push	r0
     662:	2f 93       	push	r18
     664:	3f 93       	push	r19
     666:	4f 93       	push	r20
     668:	5f 93       	push	r21
     66a:	6f 93       	push	r22
     66c:	7f 93       	push	r23
     66e:	8f 93       	push	r24
     670:	9f 93       	push	r25
     672:	af 93       	push	r26
     674:	bf 93       	push	r27
     676:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     678:	ff 93       	push	r31
     67a:	3a df       	rcall	.-396    	; 0x4f0 <_ZN11Dev_Manager11getInstanceEv>
     67c:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     680:	70 e0       	ldi	r23, 0x00	; 0
     682:	dc 01       	movw	r26, r24
     684:	1a 96       	adiw	r26, 0x0a	; 10
     686:	ed 91       	ld	r30, X+
     688:	fc 91       	ld	r31, X
     68a:	1b 97       	sbiw	r26, 0x0b	; 11
     68c:	81 e0       	ldi	r24, 0x01	; 1
}
     68e:	09 95       	icall
     690:	ff 91       	pop	r31
     692:	ef 91       	pop	r30
     694:	bf 91       	pop	r27
     696:	af 91       	pop	r26
     698:	9f 91       	pop	r25
     69a:	8f 91       	pop	r24
     69c:	7f 91       	pop	r23
     69e:	6f 91       	pop	r22
     6a0:	5f 91       	pop	r21
     6a2:	4f 91       	pop	r20
     6a4:	3f 91       	pop	r19
     6a6:	2f 91       	pop	r18
     6a8:	0f 90       	pop	r0
     6aa:	0b be       	out	0x3b, r0	; 59
     6ac:	0f 90       	pop	r0
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	0f 90       	pop	r0
     6b2:	1f 90       	pop	r1
     6b4:	18 95       	reti

000006b6 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     6b6:	1f 92       	push	r1
     6b8:	0f 92       	push	r0
     6ba:	0f b6       	in	r0, 0x3f	; 63
     6bc:	0f 92       	push	r0
     6be:	11 24       	eor	r1, r1
     6c0:	0b b6       	in	r0, 0x3b	; 59
     6c2:	0f 92       	push	r0
     6c4:	2f 93       	push	r18
     6c6:	3f 93       	push	r19
     6c8:	4f 93       	push	r20
     6ca:	5f 93       	push	r21
     6cc:	6f 93       	push	r22
     6ce:	7f 93       	push	r23
     6d0:	8f 93       	push	r24
     6d2:	9f 93       	push	r25
     6d4:	af 93       	push	r26
     6d6:	bf 93       	push	r27
     6d8:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
     6da:	ff 93       	push	r31
     6dc:	09 df       	rcall	.-494    	; 0x4f0 <_ZN11Dev_Manager11getInstanceEv>
     6de:	dc 01       	movw	r26, r24
     6e0:	1c 96       	adiw	r26, 0x0c	; 12
     6e2:	ed 91       	ld	r30, X+
     6e4:	fc 91       	ld	r31, X
     6e6:	1d 97       	sbiw	r26, 0x0d	; 13
     6e8:	60 e0       	ldi	r22, 0x00	; 0
     6ea:	70 e0       	ldi	r23, 0x00	; 0
     6ec:	82 e0       	ldi	r24, 0x02	; 2
}
     6ee:	09 95       	icall
     6f0:	ff 91       	pop	r31
     6f2:	ef 91       	pop	r30
     6f4:	bf 91       	pop	r27
     6f6:	af 91       	pop	r26
     6f8:	9f 91       	pop	r25
     6fa:	8f 91       	pop	r24
     6fc:	7f 91       	pop	r23
     6fe:	6f 91       	pop	r22
     700:	5f 91       	pop	r21
     702:	4f 91       	pop	r20
     704:	3f 91       	pop	r19
     706:	2f 91       	pop	r18
     708:	0f 90       	pop	r0
     70a:	0b be       	out	0x3b, r0	; 59
     70c:	0f 90       	pop	r0
     70e:	0f be       	out	0x3f, r0	; 63
     710:	0f 90       	pop	r0
     712:	1f 90       	pop	r1
     714:	18 95       	reti

00000716 <__vector_1>:
ISR(INT0_vect)
{
     716:	1f 92       	push	r1
     718:	0f 92       	push	r0
     71a:	0f b6       	in	r0, 0x3f	; 63
     71c:	0f 92       	push	r0
     71e:	11 24       	eor	r1, r1
     720:	0b b6       	in	r0, 0x3b	; 59
     722:	0f 92       	push	r0
     724:	2f 93       	push	r18
     726:	3f 93       	push	r19
     728:	4f 93       	push	r20
     72a:	5f 93       	push	r21
     72c:	6f 93       	push	r22
     72e:	7f 93       	push	r23
     730:	8f 93       	push	r24
     732:	9f 93       	push	r25
     734:	af 93       	push	r26
     736:	bf 93       	push	r27
     738:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
     73a:	ff 93       	push	r31
     73c:	d9 de       	rcall	.-590    	; 0x4f0 <_ZN11Dev_Manager11getInstanceEv>
     73e:	dc 01       	movw	r26, r24
     740:	1e 96       	adiw	r26, 0x0e	; 14
     742:	ed 91       	ld	r30, X+
     744:	fc 91       	ld	r31, X
     746:	1f 97       	sbiw	r26, 0x0f	; 15
     748:	60 e0       	ldi	r22, 0x00	; 0
     74a:	70 e0       	ldi	r23, 0x00	; 0
     74c:	83 e0       	ldi	r24, 0x03	; 3
     74e:	09 95       	icall
     750:	ff 91       	pop	r31
     752:	ef 91       	pop	r30
     754:	bf 91       	pop	r27
     756:	af 91       	pop	r26
     758:	9f 91       	pop	r25
     75a:	8f 91       	pop	r24
     75c:	7f 91       	pop	r23
     75e:	6f 91       	pop	r22
     760:	5f 91       	pop	r21
     762:	4f 91       	pop	r20
     764:	3f 91       	pop	r19
     766:	2f 91       	pop	r18
     768:	0f 90       	pop	r0
     76a:	0b be       	out	0x3b, r0	; 59
     76c:	0f 90       	pop	r0
     76e:	0f be       	out	0x3f, r0	; 63
     770:	0f 90       	pop	r0
     772:	1f 90       	pop	r1
     774:	18 95       	reti

00000776 <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
     776:	80 e4       	ldi	r24, 0x40	; 64
     778:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
     77c:	84 e0       	ldi	r24, 0x04	; 4
     77e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
     782:	88 e0       	ldi	r24, 0x08	; 8
     784:	9d e3       	ldi	r25, 0x3D	; 61
     786:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     78a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
     78e:	82 e0       	ldi	r24, 0x02	; 2
     790:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     794:	08 95       	ret

00000796 <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
     796:	27 e1       	ldi	r18, 0x17	; 23
     798:	31 e0       	ldi	r19, 0x01	; 1
     79a:	fc 01       	movw	r30, r24
     79c:	31 83       	std	Z+1, r19	; 0x01
     79e:	20 83       	st	Z, r18
     7a0:	08 95       	ret

000007a2 <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
     7a2:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
}
     7a6:	08 95       	ret

000007a8 <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
     7ac:	ec 01       	movw	r28, r24
     7ae:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     7b2:	88 e9       	ldi	r24, 0x98	; 152
     7b4:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     7b8:	86 e0       	ldi	r24, 0x06	; 6
     7ba:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     7be:	be 01       	movw	r22, r28
     7c0:	6e 5f       	subi	r22, 0xFE	; 254
     7c2:	7f 4f       	sbci	r23, 0xFF	; 255
     7c4:	ce 01       	movw	r24, r28
     7c6:	19 d1       	rcall	.+562    	; 0x9fa <_ZN4Ubbr10Ubbr_ValueERKj>
     7c8:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     7cc:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     7d0:	81 e0       	ldi	r24, 0x01	; 1
     7d2:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueCreateMutex>
     7d6:	9f 83       	std	Y+7, r25	; 0x07
     7d8:	8e 83       	std	Y+6, r24	; 0x06
     7da:	81 e0       	ldi	r24, 0x01	; 1
     7dc:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueCreateMutex>
     7e0:	9d 83       	std	Y+5, r25	; 0x05
     7e2:	8c 83       	std	Y+4, r24	; 0x04
     7e4:	df 91       	pop	r29
     7e6:	cf 91       	pop	r28
     7e8:	08 95       	ret

000007ea <_ZN11RS485DriverC1Ev>:
     7ea:	23 e2       	ldi	r18, 0x23	; 35
     7ec:	31 e0       	ldi	r19, 0x01	; 1
     7ee:	fc 01       	movw	r30, r24
     7f0:	31 83       	std	Z+1, r19	; 0x01
     7f2:	20 83       	st	Z, r18
     7f4:	20 e8       	ldi	r18, 0x80	; 128
     7f6:	35 e2       	ldi	r19, 0x25	; 37
     7f8:	33 83       	std	Z+3, r19	; 0x03
     7fa:	22 83       	std	Z+2, r18	; 0x02
     7fc:	20 91 bc 01 	lds	r18, 0x01BC	; 0x8001bc <_ZN11RS485Driver4instE>
     800:	30 91 bd 01 	lds	r19, 0x01BD	; 0x8001bd <_ZN11RS485Driver4instE+0x1>
     804:	23 2b       	or	r18, r19
     806:	21 f4       	brne	.+8      	; 0x810 <_ZN11RS485DriverC1Ev+0x26>
     808:	90 93 bd 01 	sts	0x01BD, r25	; 0x8001bd <_ZN11RS485Driver4instE+0x1>
     80c:	80 93 bc 01 	sts	0x01BC, r24	; 0x8001bc <_ZN11RS485Driver4instE>
     810:	08 95       	ret

00000812 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     812:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
}
     816:	08 95       	ret

00000818 <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     818:	1f 93       	push	r17
     81a:	cf 93       	push	r28
     81c:	df 93       	push	r29
     81e:	ec 01       	movw	r28, r24
     820:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	44 e6       	ldi	r20, 0x64	; 100
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	60 e0       	ldi	r22, 0x00	; 0
     82a:	70 e0       	ldi	r23, 0x00	; 0
     82c:	8c 81       	ldd	r24, Y+4	; 0x04
     82e:	9d 81       	ldd	r25, Y+5	; 0x05
     830:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xQueueGenericReceive>
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	81 f4       	brne	.+32     	; 0x858 <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     838:	eb e9       	ldi	r30, 0x9B	; 155
     83a:	f0 e0       	ldi	r31, 0x00	; 0
     83c:	80 81       	ld	r24, Z
     83e:	85 ff       	sbrs	r24, 5
     840:	fd cf       	rjmp	.-6      	; 0x83c <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     842:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     846:	20 e0       	ldi	r18, 0x00	; 0
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	60 e0       	ldi	r22, 0x00	; 0
     84e:	70 e0       	ldi	r23, 0x00	; 0
     850:	8c 81       	ldd	r24, Y+4	; 0x04
     852:	9d 81       	ldd	r25, Y+5	; 0x05
     854:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueGenericSend>
	}
}
     858:	df 91       	pop	r29
     85a:	cf 91       	pop	r28
     85c:	1f 91       	pop	r17
     85e:	08 95       	ret

00000860 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     860:	db cf       	rjmp	.-74     	; 0x818 <_ZN11RS485Driver12UART_PutcharEc>
     862:	08 95       	ret

00000864 <_ZN11RS485Driver14UART_PutStringEPKc>:
     864:	0f 93       	push	r16
     866:	1f 93       	push	r17
     868:	cf 93       	push	r28
     86a:	df 93       	push	r29
     86c:	8c 01       	movw	r16, r24
     86e:	eb 01       	movw	r28, r22
     870:	20 e0       	ldi	r18, 0x00	; 0
     872:	44 e6       	ldi	r20, 0x64	; 100
     874:	50 e0       	ldi	r21, 0x00	; 0
     876:	60 e0       	ldi	r22, 0x00	; 0
     878:	70 e0       	ldi	r23, 0x00	; 0
     87a:	fc 01       	movw	r30, r24
     87c:	86 81       	ldd	r24, Z+6	; 0x06
     87e:	97 81       	ldd	r25, Z+7	; 0x07
     880:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xQueueGenericReceive>
     884:	81 30       	cpi	r24, 0x01	; 1
     886:	99 f4       	brne	.+38     	; 0x8ae <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     888:	68 81       	ld	r22, Y
     88a:	66 23       	and	r22, r22
     88c:	31 f0       	breq	.+12     	; 0x89a <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     88e:	21 96       	adiw	r28, 0x01	; 1
     890:	c8 01       	movw	r24, r16
     892:	c2 df       	rcall	.-124    	; 0x818 <_ZN11RS485Driver12UART_PutcharEc>
     894:	69 91       	ld	r22, Y+
     896:	61 11       	cpse	r22, r1
     898:	fb cf       	rjmp	.-10     	; 0x890 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     89a:	20 e0       	ldi	r18, 0x00	; 0
     89c:	40 e0       	ldi	r20, 0x00	; 0
     89e:	50 e0       	ldi	r21, 0x00	; 0
     8a0:	60 e0       	ldi	r22, 0x00	; 0
     8a2:	70 e0       	ldi	r23, 0x00	; 0
     8a4:	f8 01       	movw	r30, r16
     8a6:	86 81       	ldd	r24, Z+6	; 0x06
     8a8:	97 81       	ldd	r25, Z+7	; 0x07
     8aa:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueGenericSend>
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	08 95       	ret

000008b8 <_ZN11RS485Driver13Device_WritesEPKc>:
     8b8:	d5 cf       	rjmp	.-86     	; 0x864 <_ZN11RS485Driver14UART_PutStringEPKc>
     8ba:	08 95       	ret

000008bc <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
     8bc:	1f 92       	push	r1
     8be:	0f 92       	push	r0
     8c0:	0f b6       	in	r0, 0x3f	; 63
     8c2:	0f 92       	push	r0
     8c4:	11 24       	eor	r1, r1
     8c6:	0b b6       	in	r0, 0x3b	; 59
     8c8:	0f 92       	push	r0
     8ca:	8f 93       	push	r24
     8cc:	9f 93       	push	r25
     8ce:	ef 93       	push	r30
     8d0:	ff 93       	push	r31
	mem4[3]++;
     8d2:	e7 ee       	ldi	r30, 0xE7	; 231
     8d4:	f3 e0       	ldi	r31, 0x03	; 3
     8d6:	86 81       	ldd	r24, Z+6	; 0x06
     8d8:	97 81       	ldd	r25, Z+7	; 0x07
     8da:	01 96       	adiw	r24, 0x01	; 1
     8dc:	97 83       	std	Z+7, r25	; 0x07
     8de:	86 83       	std	Z+6, r24	; 0x06
}
     8e0:	ff 91       	pop	r31
     8e2:	ef 91       	pop	r30
     8e4:	9f 91       	pop	r25
     8e6:	8f 91       	pop	r24
     8e8:	0f 90       	pop	r0
     8ea:	0b be       	out	0x3b, r0	; 59
     8ec:	0f 90       	pop	r0
     8ee:	0f be       	out	0x3f, r0	; 63
     8f0:	0f 90       	pop	r0
     8f2:	1f 90       	pop	r1
     8f4:	18 95       	reti

000008f6 <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     8f6:	cf 93       	push	r28
     8f8:	df 93       	push	r29
     8fa:	ec 01       	movw	r28, r24
     8fc:	88 e9       	ldi	r24, 0x98	; 152
     8fe:	8a b9       	out	0x0a, r24	; 10
     900:	86 e0       	ldi	r24, 0x06	; 6
     902:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     906:	be 01       	movw	r22, r28
     908:	6e 5f       	subi	r22, 0xFE	; 254
     90a:	7f 4f       	sbci	r23, 0xFF	; 255
     90c:	ce 01       	movw	r24, r28
     90e:	75 d0       	rcall	.+234    	; 0x9fa <_ZN4Ubbr10Ubbr_ValueERKj>
     910:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     914:	99 b9       	out	0x09, r25	; 9
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueCreateMutex>
     91c:	9f 83       	std	Y+7, r25	; 0x07
     91e:	8e 83       	std	Y+6, r24	; 0x06
     920:	81 e0       	ldi	r24, 0x01	; 1
     922:	0e 94 52 11 	call	0x22a4	; 0x22a4 <xQueueCreateMutex>
     926:	9d 83       	std	Y+5, r25	; 0x05
     928:	8c 83       	std	Y+4, r24	; 0x04
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	08 95       	ret

00000930 <_ZN10UartDriverC1Ev>:
     930:	2f e2       	ldi	r18, 0x2F	; 47
     932:	31 e0       	ldi	r19, 0x01	; 1
     934:	fc 01       	movw	r30, r24
     936:	31 83       	std	Z+1, r19	; 0x01
     938:	20 83       	st	Z, r18
     93a:	20 ec       	ldi	r18, 0xC0	; 192
     93c:	32 e1       	ldi	r19, 0x12	; 18
     93e:	33 83       	std	Z+3, r19	; 0x03
     940:	22 83       	std	Z+2, r18	; 0x02
     942:	20 91 be 01 	lds	r18, 0x01BE	; 0x8001be <_ZN10UartDriver4instE>
     946:	30 91 bf 01 	lds	r19, 0x01BF	; 0x8001bf <_ZN10UartDriver4instE+0x1>
     94a:	23 2b       	or	r18, r19
     94c:	21 f4       	brne	.+8      	; 0x956 <_ZN10UartDriverC1Ev+0x26>
     94e:	90 93 bf 01 	sts	0x01BF, r25	; 0x8001bf <_ZN10UartDriver4instE+0x1>
     952:	80 93 be 01 	sts	0x01BE, r24	; 0x8001be <_ZN10UartDriver4instE>
     956:	08 95       	ret

00000958 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     958:	0c 94 89 0d 	jmp	0x1b12	; 0x1b12 <pvPortMalloc>
}
     95c:	08 95       	ret

0000095e <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     95e:	1f 93       	push	r17
     960:	cf 93       	push	r28
     962:	df 93       	push	r29
     964:	ec 01       	movw	r28, r24
     966:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     968:	20 e0       	ldi	r18, 0x00	; 0
     96a:	44 e6       	ldi	r20, 0x64	; 100
     96c:	50 e0       	ldi	r21, 0x00	; 0
     96e:	60 e0       	ldi	r22, 0x00	; 0
     970:	70 e0       	ldi	r23, 0x00	; 0
     972:	8c 81       	ldd	r24, Y+4	; 0x04
     974:	9d 81       	ldd	r25, Y+5	; 0x05
     976:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xQueueGenericReceive>
     97a:	81 30       	cpi	r24, 0x01	; 1
     97c:	61 f4       	brne	.+24     	; 0x996 <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     97e:	5d 9b       	sbis	0x0b, 5	; 11
     980:	fe cf       	rjmp	.-4      	; 0x97e <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     982:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     984:	20 e0       	ldi	r18, 0x00	; 0
     986:	40 e0       	ldi	r20, 0x00	; 0
     988:	50 e0       	ldi	r21, 0x00	; 0
     98a:	60 e0       	ldi	r22, 0x00	; 0
     98c:	70 e0       	ldi	r23, 0x00	; 0
     98e:	8c 81       	ldd	r24, Y+4	; 0x04
     990:	9d 81       	ldd	r25, Y+5	; 0x05
     992:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueGenericSend>
	}
}
     996:	df 91       	pop	r29
     998:	cf 91       	pop	r28
     99a:	1f 91       	pop	r17
     99c:	08 95       	ret

0000099e <_ZN10UartDriver12Device_WriteEc>:
     99e:	df cf       	rjmp	.-66     	; 0x95e <_ZN10UartDriver12UART_PutcharEc>
     9a0:	08 95       	ret

000009a2 <_ZN10UartDriver14UART_PutStringEPKc>:
     9a2:	0f 93       	push	r16
     9a4:	1f 93       	push	r17
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	8c 01       	movw	r16, r24
     9ac:	eb 01       	movw	r28, r22
     9ae:	20 e0       	ldi	r18, 0x00	; 0
     9b0:	44 e6       	ldi	r20, 0x64	; 100
     9b2:	50 e0       	ldi	r21, 0x00	; 0
     9b4:	60 e0       	ldi	r22, 0x00	; 0
     9b6:	70 e0       	ldi	r23, 0x00	; 0
     9b8:	fc 01       	movw	r30, r24
     9ba:	86 81       	ldd	r24, Z+6	; 0x06
     9bc:	97 81       	ldd	r25, Z+7	; 0x07
     9be:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <xQueueGenericReceive>
     9c2:	81 30       	cpi	r24, 0x01	; 1
     9c4:	99 f4       	brne	.+38     	; 0x9ec <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     9c6:	68 81       	ld	r22, Y
     9c8:	66 23       	and	r22, r22
     9ca:	31 f0       	breq	.+12     	; 0x9d8 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     9cc:	21 96       	adiw	r28, 0x01	; 1
     9ce:	c8 01       	movw	r24, r16
     9d0:	c6 df       	rcall	.-116    	; 0x95e <_ZN10UartDriver12UART_PutcharEc>
     9d2:	69 91       	ld	r22, Y+
     9d4:	61 11       	cpse	r22, r1
     9d6:	fb cf       	rjmp	.-10     	; 0x9ce <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     9d8:	20 e0       	ldi	r18, 0x00	; 0
     9da:	40 e0       	ldi	r20, 0x00	; 0
     9dc:	50 e0       	ldi	r21, 0x00	; 0
     9de:	60 e0       	ldi	r22, 0x00	; 0
     9e0:	70 e0       	ldi	r23, 0x00	; 0
     9e2:	f8 01       	movw	r30, r16
     9e4:	86 81       	ldd	r24, Z+6	; 0x06
     9e6:	97 81       	ldd	r25, Z+7	; 0x07
     9e8:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueGenericSend>
     9ec:	df 91       	pop	r29
     9ee:	cf 91       	pop	r28
     9f0:	1f 91       	pop	r17
     9f2:	0f 91       	pop	r16
     9f4:	08 95       	ret

000009f6 <_ZN10UartDriver13Device_WritesEPKc>:
     9f6:	d5 cf       	rjmp	.-86     	; 0x9a2 <_ZN10UartDriver14UART_PutStringEPKc>
     9f8:	08 95       	ret

000009fa <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     9fa:	cf 92       	push	r12
     9fc:	df 92       	push	r13
     9fe:	ef 92       	push	r14
     a00:	ff 92       	push	r15
     a02:	cf 93       	push	r28
     a04:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
     a06:	fb 01       	movw	r30, r22
     a08:	20 81       	ld	r18, Z
     a0a:	31 81       	ldd	r19, Z+1	; 0x01
     a0c:	c9 01       	movw	r24, r18
     a0e:	a0 e0       	ldi	r26, 0x00	; 0
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	88 0f       	add	r24, r24
     a14:	99 1f       	adc	r25, r25
     a16:	aa 1f       	adc	r26, r26
     a18:	bb 1f       	adc	r27, r27
     a1a:	88 0f       	add	r24, r24
     a1c:	99 1f       	adc	r25, r25
     a1e:	aa 1f       	adc	r26, r26
     a20:	bb 1f       	adc	r27, r27
     a22:	9c 01       	movw	r18, r24
     a24:	ad 01       	movw	r20, r26
     a26:	22 0f       	add	r18, r18
     a28:	33 1f       	adc	r19, r19
     a2a:	44 1f       	adc	r20, r20
     a2c:	55 1f       	adc	r21, r21
     a2e:	22 0f       	add	r18, r18
     a30:	33 1f       	adc	r19, r19
     a32:	44 1f       	adc	r20, r20
     a34:	55 1f       	adc	r21, r21
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	74 e2       	ldi	r23, 0x24	; 36
     a3a:	84 ef       	ldi	r24, 0xF4	; 244
     a3c:	90 e0       	ldi	r25, 0x00	; 0
     a3e:	0e 94 2a 18 	call	0x3054	; 0x3054 <__udivmodsi4>
     a42:	ca 01       	movw	r24, r20
     a44:	b9 01       	movw	r22, r18
     a46:	61 50       	subi	r22, 0x01	; 1
     a48:	71 09       	sbc	r23, r1
     a4a:	81 09       	sbc	r24, r1
     a4c:	91 09       	sbc	r25, r1
     a4e:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <__floatunsisf>
     a52:	20 e0       	ldi	r18, 0x00	; 0
     a54:	30 e0       	ldi	r19, 0x00	; 0
     a56:	40 e0       	ldi	r20, 0x00	; 0
     a58:	5f e3       	ldi	r21, 0x3F	; 63
     a5a:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <__addsf3>
     a5e:	6b 01       	movw	r12, r22
     a60:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     a62:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <__fixunssfsi>
     a66:	d6 2f       	mov	r29, r22
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	cf 2f       	mov	r28, r31
     a6c:	c7 01       	movw	r24, r14
     a6e:	b6 01       	movw	r22, r12
     a70:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <__fixunssfsi>
}
     a74:	ce 01       	movw	r24, r28
     a76:	86 2b       	or	r24, r22
     a78:	df 91       	pop	r29
     a7a:	cf 91       	pop	r28
     a7c:	ff 90       	pop	r15
     a7e:	ef 90       	pop	r14
     a80:	df 90       	pop	r13
     a82:	cf 90       	pop	r12
     a84:	08 95       	ret

00000a86 <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     a86:	c0 98       	cbi	0x18, 0	; 24
     a88:	96 2f       	mov	r25, r22
     a8a:	6f 71       	andi	r22, 0x1F	; 31
     a8c:	86 2b       	or	r24, r22
     a8e:	8f b9       	out	0x0f, r24	; 15
     a90:	77 9b       	sbis	0x0e, 7	; 14
     a92:	fe cf       	rjmp	.-4      	; 0xa90 <_Z14enc28j60ReadOphh+0xa>
     a94:	1f b8       	out	0x0f, r1	; 15
     a96:	77 9b       	sbis	0x0e, 7	; 14
     a98:	fe cf       	rjmp	.-4      	; 0xa96 <_Z14enc28j60ReadOphh+0x10>
     a9a:	99 23       	and	r25, r25
     a9c:	1c f4       	brge	.+6      	; 0xaa4 <_Z14enc28j60ReadOphh+0x1e>
     a9e:	1f b8       	out	0x0f, r1	; 15
     aa0:	77 9b       	sbis	0x0e, 7	; 14
     aa2:	fe cf       	rjmp	.-4      	; 0xaa0 <_Z14enc28j60ReadOphh+0x1a>
     aa4:	c0 9a       	sbi	0x18, 0	; 24
     aa6:	8f b1       	in	r24, 0x0f	; 15
     aa8:	08 95       	ret

00000aaa <_Z15enc28j60WriteOphhh>:
     aaa:	c0 98       	cbi	0x18, 0	; 24
     aac:	6f 71       	andi	r22, 0x1F	; 31
     aae:	86 2b       	or	r24, r22
     ab0:	8f b9       	out	0x0f, r24	; 15
     ab2:	77 9b       	sbis	0x0e, 7	; 14
     ab4:	fe cf       	rjmp	.-4      	; 0xab2 <_Z15enc28j60WriteOphhh+0x8>
     ab6:	4f b9       	out	0x0f, r20	; 15
     ab8:	77 9b       	sbis	0x0e, 7	; 14
     aba:	fe cf       	rjmp	.-4      	; 0xab8 <_Z15enc28j60WriteOphhh+0xe>
     abc:	c0 9a       	sbi	0x18, 0	; 24
     abe:	08 95       	ret

00000ac0 <_Z18enc28j60ReadBufferjPh>:
     ac0:	fb 01       	movw	r30, r22
     ac2:	c0 98       	cbi	0x18, 0	; 24
     ac4:	2a e3       	ldi	r18, 0x3A	; 58
     ac6:	2f b9       	out	0x0f, r18	; 15
     ac8:	77 9b       	sbis	0x0e, 7	; 14
     aca:	fe cf       	rjmp	.-4      	; 0xac8 <_Z18enc28j60ReadBufferjPh+0x8>
     acc:	00 97       	sbiw	r24, 0x00	; 0
     ace:	61 f0       	breq	.+24     	; 0xae8 <_Z18enc28j60ReadBufferjPh+0x28>
     ad0:	df 01       	movw	r26, r30
     ad2:	a8 0f       	add	r26, r24
     ad4:	b9 1f       	adc	r27, r25
     ad6:	1f b8       	out	0x0f, r1	; 15
     ad8:	77 9b       	sbis	0x0e, 7	; 14
     ada:	fe cf       	rjmp	.-4      	; 0xad8 <_Z18enc28j60ReadBufferjPh+0x18>
     adc:	9f b1       	in	r25, 0x0f	; 15
     ade:	91 93       	st	Z+, r25
     ae0:	ae 17       	cp	r26, r30
     ae2:	bf 07       	cpc	r27, r31
     ae4:	c1 f7       	brne	.-16     	; 0xad6 <_Z18enc28j60ReadBufferjPh+0x16>
     ae6:	01 c0       	rjmp	.+2      	; 0xaea <_Z18enc28j60ReadBufferjPh+0x2a>
     ae8:	df 01       	movw	r26, r30
     aea:	1c 92       	st	X, r1
     aec:	c0 9a       	sbi	0x18, 0	; 24
     aee:	08 95       	ret

00000af0 <_Z19enc28j60WriteBufferjPh>:
     af0:	fb 01       	movw	r30, r22
     af2:	c0 98       	cbi	0x18, 0	; 24
     af4:	2a e7       	ldi	r18, 0x7A	; 122
     af6:	2f b9       	out	0x0f, r18	; 15
     af8:	77 9b       	sbis	0x0e, 7	; 14
     afa:	fe cf       	rjmp	.-4      	; 0xaf8 <_Z19enc28j60WriteBufferjPh+0x8>
     afc:	00 97       	sbiw	r24, 0x00	; 0
     afe:	61 f0       	breq	.+24     	; 0xb18 <_Z19enc28j60WriteBufferjPh+0x28>
     b00:	9f 01       	movw	r18, r30
     b02:	28 0f       	add	r18, r24
     b04:	39 1f       	adc	r19, r25
     b06:	03 c0       	rjmp	.+6      	; 0xb0e <_Z19enc28j60WriteBufferjPh+0x1e>
     b08:	2e 17       	cp	r18, r30
     b0a:	3f 07       	cpc	r19, r31
     b0c:	29 f0       	breq	.+10     	; 0xb18 <_Z19enc28j60WriteBufferjPh+0x28>
     b0e:	91 91       	ld	r25, Z+
     b10:	9f b9       	out	0x0f, r25	; 15
     b12:	77 9b       	sbis	0x0e, 7	; 14
     b14:	fe cf       	rjmp	.-4      	; 0xb12 <_Z19enc28j60WriteBufferjPh+0x22>
     b16:	f8 cf       	rjmp	.-16     	; 0xb08 <_Z19enc28j60WriteBufferjPh+0x18>
     b18:	c0 9a       	sbi	0x18, 0	; 24
     b1a:	08 95       	ret

00000b1c <_Z15enc28j60SetBankh>:
     b1c:	1f 93       	push	r17
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	18 2f       	mov	r17, r24
     b24:	10 76       	andi	r17, 0x60	; 96
     b26:	c1 2f       	mov	r28, r17
     b28:	d0 e0       	ldi	r29, 0x00	; 0
     b2a:	80 91 c2 01 	lds	r24, 0x01C2	; 0x8001c2 <_ZL12Enc28j60Bank>
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	c8 17       	cp	r28, r24
     b32:	d9 07       	cpc	r29, r25
     b34:	a1 f0       	breq	.+40     	; 0xb5e <_Z15enc28j60SetBankh+0x42>
     b36:	43 e0       	ldi	r20, 0x03	; 3
     b38:	6f e1       	ldi	r22, 0x1F	; 31
     b3a:	80 ea       	ldi	r24, 0xA0	; 160
     b3c:	b6 df       	rcall	.-148    	; 0xaaa <_Z15enc28j60WriteOphhh>
     b3e:	ae 01       	movw	r20, r28
     b40:	55 95       	asr	r21
     b42:	47 95       	ror	r20
     b44:	55 95       	asr	r21
     b46:	47 95       	ror	r20
     b48:	55 95       	asr	r21
     b4a:	47 95       	ror	r20
     b4c:	55 95       	asr	r21
     b4e:	47 95       	ror	r20
     b50:	55 95       	asr	r21
     b52:	47 95       	ror	r20
     b54:	6f e1       	ldi	r22, 0x1F	; 31
     b56:	80 e8       	ldi	r24, 0x80	; 128
     b58:	a8 df       	rcall	.-176    	; 0xaaa <_Z15enc28j60WriteOphhh>
     b5a:	10 93 c2 01 	sts	0x01C2, r17	; 0x8001c2 <_ZL12Enc28j60Bank>
     b5e:	df 91       	pop	r29
     b60:	cf 91       	pop	r28
     b62:	1f 91       	pop	r17
     b64:	08 95       	ret

00000b66 <_Z12enc28j60Readh>:
     b66:	cf 93       	push	r28
     b68:	c8 2f       	mov	r28, r24
     b6a:	d8 df       	rcall	.-80     	; 0xb1c <_Z15enc28j60SetBankh>
     b6c:	6c 2f       	mov	r22, r28
     b6e:	80 e0       	ldi	r24, 0x00	; 0
     b70:	8a df       	rcall	.-236    	; 0xa86 <_Z14enc28j60ReadOphh>
     b72:	cf 91       	pop	r28
     b74:	08 95       	ret

00000b76 <_Z13enc28j60Writehh>:
     b76:	cf 93       	push	r28
     b78:	df 93       	push	r29
     b7a:	c8 2f       	mov	r28, r24
     b7c:	d6 2f       	mov	r29, r22
     b7e:	ce df       	rcall	.-100    	; 0xb1c <_Z15enc28j60SetBankh>
     b80:	4d 2f       	mov	r20, r29
     b82:	6c 2f       	mov	r22, r28
     b84:	80 e4       	ldi	r24, 0x40	; 64
     b86:	91 df       	rcall	.-222    	; 0xaaa <_Z15enc28j60WriteOphhh>
     b88:	df 91       	pop	r29
     b8a:	cf 91       	pop	r28
     b8c:	08 95       	ret

00000b8e <_Z16enc28j60PhyWritehj>:
     b8e:	cf 93       	push	r28
     b90:	df 93       	push	r29
     b92:	d6 2f       	mov	r29, r22
     b94:	c7 2f       	mov	r28, r23
     b96:	68 2f       	mov	r22, r24
     b98:	84 ed       	ldi	r24, 0xD4	; 212
     b9a:	ed df       	rcall	.-38     	; 0xb76 <_Z13enc28j60Writehh>
     b9c:	6d 2f       	mov	r22, r29
     b9e:	86 ed       	ldi	r24, 0xD6	; 214
     ba0:	ea df       	rcall	.-44     	; 0xb76 <_Z13enc28j60Writehh>
     ba2:	6c 2f       	mov	r22, r28
     ba4:	87 ed       	ldi	r24, 0xD7	; 215
     ba6:	e7 df       	rcall	.-50     	; 0xb76 <_Z13enc28j60Writehh>
     ba8:	8a ee       	ldi	r24, 0xEA	; 234
     baa:	dd df       	rcall	.-70     	; 0xb66 <_Z12enc28j60Readh>
     bac:	80 ff       	sbrs	r24, 0
     bae:	04 c0       	rjmp	.+8      	; 0xbb8 <_Z16enc28j60PhyWritehj+0x2a>
     bb0:	85 e0       	ldi	r24, 0x05	; 5
     bb2:	8a 95       	dec	r24
     bb4:	f1 f7       	brne	.-4      	; 0xbb2 <_Z16enc28j60PhyWritehj+0x24>
     bb6:	f8 cf       	rjmp	.-16     	; 0xba8 <_Z16enc28j60PhyWritehj+0x1a>
     bb8:	df 91       	pop	r29
     bba:	cf 91       	pop	r28
     bbc:	08 95       	ret

00000bbe <_Z14enc28j60clkouth>:
     bbe:	68 2f       	mov	r22, r24
     bc0:	67 70       	andi	r22, 0x07	; 7
     bc2:	85 e7       	ldi	r24, 0x75	; 117
     bc4:	d8 cf       	rjmp	.-80     	; 0xb76 <_Z13enc28j60Writehh>
     bc6:	08 95       	ret

00000bc8 <_Z12enc28j60InitPh>:
     bc8:	cf 93       	push	r28
     bca:	df 93       	push	r29
     bcc:	ec 01       	movw	r28, r24
     bce:	b8 9a       	sbi	0x17, 0	; 23
     bd0:	c0 9a       	sbi	0x18, 0	; 24
     bd2:	a6 d2       	rcall	.+1356   	; 0x1120 <_Z8spi_initv>
     bd4:	4f ef       	ldi	r20, 0xFF	; 255
     bd6:	60 e0       	ldi	r22, 0x00	; 0
     bd8:	8f ef       	ldi	r24, 0xFF	; 255
     bda:	67 df       	rcall	.-306    	; 0xaaa <_Z15enc28j60WriteOphhh>
     bdc:	82 e3       	ldi	r24, 0x32	; 50
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	a9 d2       	rcall	.+1362   	; 0x1134 <_Z8delay_msj>
     be2:	10 92 c1 01 	sts	0x01C1, r1	; 0x8001c1 <_ZL13NextPacketPtr+0x1>
     be6:	10 92 c0 01 	sts	0x01C0, r1	; 0x8001c0 <_ZL13NextPacketPtr>
     bea:	60 e0       	ldi	r22, 0x00	; 0
     bec:	88 e0       	ldi	r24, 0x08	; 8
     bee:	c3 df       	rcall	.-122    	; 0xb76 <_Z13enc28j60Writehh>
     bf0:	60 e0       	ldi	r22, 0x00	; 0
     bf2:	89 e0       	ldi	r24, 0x09	; 9
     bf4:	c0 df       	rcall	.-128    	; 0xb76 <_Z13enc28j60Writehh>
     bf6:	60 e0       	ldi	r22, 0x00	; 0
     bf8:	8c e0       	ldi	r24, 0x0C	; 12
     bfa:	bd df       	rcall	.-134    	; 0xb76 <_Z13enc28j60Writehh>
     bfc:	60 e0       	ldi	r22, 0x00	; 0
     bfe:	8d e0       	ldi	r24, 0x0D	; 13
     c00:	ba df       	rcall	.-140    	; 0xb76 <_Z13enc28j60Writehh>
     c02:	6e ef       	ldi	r22, 0xFE	; 254
     c04:	8a e0       	ldi	r24, 0x0A	; 10
     c06:	b7 df       	rcall	.-146    	; 0xb76 <_Z13enc28j60Writehh>
     c08:	69 e1       	ldi	r22, 0x19	; 25
     c0a:	8b e0       	ldi	r24, 0x0B	; 11
     c0c:	b4 df       	rcall	.-152    	; 0xb76 <_Z13enc28j60Writehh>
     c0e:	6f ef       	ldi	r22, 0xFF	; 255
     c10:	84 e0       	ldi	r24, 0x04	; 4
     c12:	b1 df       	rcall	.-158    	; 0xb76 <_Z13enc28j60Writehh>
     c14:	69 e1       	ldi	r22, 0x19	; 25
     c16:	85 e0       	ldi	r24, 0x05	; 5
     c18:	ae df       	rcall	.-164    	; 0xb76 <_Z13enc28j60Writehh>
     c1a:	6f ef       	ldi	r22, 0xFF	; 255
     c1c:	86 e0       	ldi	r24, 0x06	; 6
     c1e:	ab df       	rcall	.-170    	; 0xb76 <_Z13enc28j60Writehh>
     c20:	6f e1       	ldi	r22, 0x1F	; 31
     c22:	87 e0       	ldi	r24, 0x07	; 7
     c24:	a8 df       	rcall	.-176    	; 0xb76 <_Z13enc28j60Writehh>
     c26:	60 eb       	ldi	r22, 0xB0	; 176
     c28:	88 e3       	ldi	r24, 0x38	; 56
     c2a:	a5 df       	rcall	.-182    	; 0xb76 <_Z13enc28j60Writehh>
     c2c:	6f e3       	ldi	r22, 0x3F	; 63
     c2e:	88 e2       	ldi	r24, 0x28	; 40
     c30:	a2 df       	rcall	.-188    	; 0xb76 <_Z13enc28j60Writehh>
     c32:	60 e3       	ldi	r22, 0x30	; 48
     c34:	89 e2       	ldi	r24, 0x29	; 41
     c36:	9f df       	rcall	.-194    	; 0xb76 <_Z13enc28j60Writehh>
     c38:	69 ef       	ldi	r22, 0xF9	; 249
     c3a:	80 e3       	ldi	r24, 0x30	; 48
     c3c:	9c df       	rcall	.-200    	; 0xb76 <_Z13enc28j60Writehh>
     c3e:	67 ef       	ldi	r22, 0xF7	; 247
     c40:	81 e3       	ldi	r24, 0x31	; 49
     c42:	99 df       	rcall	.-206    	; 0xb76 <_Z13enc28j60Writehh>
     c44:	6d e0       	ldi	r22, 0x0D	; 13
     c46:	80 ec       	ldi	r24, 0xC0	; 192
     c48:	96 df       	rcall	.-212    	; 0xb76 <_Z13enc28j60Writehh>
     c4a:	60 e0       	ldi	r22, 0x00	; 0
     c4c:	81 ec       	ldi	r24, 0xC1	; 193
     c4e:	93 df       	rcall	.-218    	; 0xb76 <_Z13enc28j60Writehh>
     c50:	42 e3       	ldi	r20, 0x32	; 50
     c52:	62 ec       	ldi	r22, 0xC2	; 194
     c54:	80 e8       	ldi	r24, 0x80	; 128
     c56:	29 df       	rcall	.-430    	; 0xaaa <_Z15enc28j60WriteOphhh>
     c58:	62 e1       	ldi	r22, 0x12	; 18
     c5a:	86 ec       	ldi	r24, 0xC6	; 198
     c5c:	8c df       	rcall	.-232    	; 0xb76 <_Z13enc28j60Writehh>
     c5e:	6c e0       	ldi	r22, 0x0C	; 12
     c60:	87 ec       	ldi	r24, 0xC7	; 199
     c62:	89 df       	rcall	.-238    	; 0xb76 <_Z13enc28j60Writehh>
     c64:	62 e1       	ldi	r22, 0x12	; 18
     c66:	84 ec       	ldi	r24, 0xC4	; 196
     c68:	86 df       	rcall	.-244    	; 0xb76 <_Z13enc28j60Writehh>
     c6a:	6c ed       	ldi	r22, 0xDC	; 220
     c6c:	8a ec       	ldi	r24, 0xCA	; 202
     c6e:	83 df       	rcall	.-250    	; 0xb76 <_Z13enc28j60Writehh>
     c70:	65 e0       	ldi	r22, 0x05	; 5
     c72:	8b ec       	ldi	r24, 0xCB	; 203
     c74:	80 df       	rcall	.-256    	; 0xb76 <_Z13enc28j60Writehh>
     c76:	68 81       	ld	r22, Y
     c78:	84 ee       	ldi	r24, 0xE4	; 228
     c7a:	7d df       	rcall	.-262    	; 0xb76 <_Z13enc28j60Writehh>
     c7c:	69 81       	ldd	r22, Y+1	; 0x01
     c7e:	85 ee       	ldi	r24, 0xE5	; 229
     c80:	7a df       	rcall	.-268    	; 0xb76 <_Z13enc28j60Writehh>
     c82:	6a 81       	ldd	r22, Y+2	; 0x02
     c84:	82 ee       	ldi	r24, 0xE2	; 226
     c86:	77 df       	rcall	.-274    	; 0xb76 <_Z13enc28j60Writehh>
     c88:	6b 81       	ldd	r22, Y+3	; 0x03
     c8a:	83 ee       	ldi	r24, 0xE3	; 227
     c8c:	74 df       	rcall	.-280    	; 0xb76 <_Z13enc28j60Writehh>
     c8e:	6c 81       	ldd	r22, Y+4	; 0x04
     c90:	80 ee       	ldi	r24, 0xE0	; 224
     c92:	71 df       	rcall	.-286    	; 0xb76 <_Z13enc28j60Writehh>
     c94:	6d 81       	ldd	r22, Y+5	; 0x05
     c96:	81 ee       	ldi	r24, 0xE1	; 225
     c98:	6e df       	rcall	.-292    	; 0xb76 <_Z13enc28j60Writehh>
     c9a:	60 e0       	ldi	r22, 0x00	; 0
     c9c:	71 e0       	ldi	r23, 0x01	; 1
     c9e:	80 e1       	ldi	r24, 0x10	; 16
     ca0:	76 df       	rcall	.-276    	; 0xb8e <_Z16enc28j60PhyWritehj>
     ca2:	8f e1       	ldi	r24, 0x1F	; 31
     ca4:	3b df       	rcall	.-394    	; 0xb1c <_Z15enc28j60SetBankh>
     ca6:	40 ec       	ldi	r20, 0xC0	; 192
     ca8:	6b e1       	ldi	r22, 0x1B	; 27
     caa:	80 e8       	ldi	r24, 0x80	; 128
     cac:	fe de       	rcall	.-516    	; 0xaaa <_Z15enc28j60WriteOphhh>
     cae:	44 e0       	ldi	r20, 0x04	; 4
     cb0:	6f e1       	ldi	r22, 0x1F	; 31
     cb2:	80 e8       	ldi	r24, 0x80	; 128
     cb4:	fa de       	rcall	.-524    	; 0xaaa <_Z15enc28j60WriteOphhh>
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	08 95       	ret

00000cbc <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     cbc:	0f 93       	push	r16
     cbe:	1f 93       	push	r17
     cc0:	cf 93       	push	r28
     cc2:	df 93       	push	r29
     cc4:	ec 01       	movw	r28, r24
     cc6:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     cc8:	6f ef       	ldi	r22, 0xFF	; 255
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	54 df       	rcall	.-344    	; 0xb76 <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     cce:	69 e1       	ldi	r22, 0x19	; 25
     cd0:	83 e0       	ldi	r24, 0x03	; 3
     cd2:	51 df       	rcall	.-350    	; 0xb76 <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     cd4:	6c 2f       	mov	r22, r28
     cd6:	61 50       	subi	r22, 0x01	; 1
     cd8:	86 e0       	ldi	r24, 0x06	; 6
     cda:	4d df       	rcall	.-358    	; 0xb76 <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     cdc:	ce 01       	movw	r24, r28
     cde:	81 50       	subi	r24, 0x01	; 1
     ce0:	96 4e       	sbci	r25, 0xE6	; 230
     ce2:	69 2f       	mov	r22, r25
     ce4:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     ce6:	47 df       	rcall	.-370    	; 0xb76 <_Z13enc28j60Writehh>
     ce8:	40 e0       	ldi	r20, 0x00	; 0
     cea:	60 e0       	ldi	r22, 0x00	; 0
     cec:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     cee:	dd de       	rcall	.-582    	; 0xaaa <_Z15enc28j60WriteOphhh>
     cf0:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     cf2:	ce 01       	movw	r24, r28
     cf4:	fd de       	rcall	.-518    	; 0xaf0 <_Z19enc28j60WriteBufferjPh>
     cf6:	48 e0       	ldi	r20, 0x08	; 8
     cf8:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     cfa:	80 e8       	ldi	r24, 0x80	; 128
     cfc:	d6 de       	rcall	.-596    	; 0xaaa <_Z15enc28j60WriteOphhh>
     cfe:	8c e1       	ldi	r24, 0x1C	; 28
     d00:	32 df       	rcall	.-412    	; 0xb66 <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     d02:	81 ff       	sbrs	r24, 1
     d04:	04 c0       	rjmp	.+8      	; 0xd0e <_Z18enc28j60PacketSendjPh+0x52>
     d06:	48 e0       	ldi	r20, 0x08	; 8
     d08:	6f e1       	ldi	r22, 0x1F	; 31
     d0a:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     d0c:	ce de       	rcall	.-612    	; 0xaaa <_Z15enc28j60WriteOphhh>
     d0e:	df 91       	pop	r29
     d10:	cf 91       	pop	r28
     d12:	1f 91       	pop	r17
     d14:	0f 91       	pop	r16
     d16:	08 95       	ret

00000d18 <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     d18:	9f 92       	push	r9
     d1a:	af 92       	push	r10
     d1c:	bf 92       	push	r11
     d1e:	cf 92       	push	r12
     d20:	df 92       	push	r13
     d22:	ef 92       	push	r14
     d24:	ff 92       	push	r15
     d26:	0f 93       	push	r16
     d28:	1f 93       	push	r17
     d2a:	cf 93       	push	r28
     d2c:	df 93       	push	r29
     d2e:	5c 01       	movw	r10, r24
     d30:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     d32:	89 e3       	ldi	r24, 0x39	; 57
     d34:	18 df       	rcall	.-464    	; 0xb66 <_Z12enc28j60Readh>
     d36:	88 23       	and	r24, r24
     d38:	09 f4       	brne	.+2      	; 0xd3c <_Z21enc28j60PacketReceivejPh+0x24>
     d3a:	45 c0       	rjmp	.+138    	; 0xdc6 <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     d3c:	60 91 c0 01 	lds	r22, 0x01C0	; 0x8001c0 <_ZL13NextPacketPtr>
     d40:	c0 91 c1 01 	lds	r28, 0x01C1	; 0x8001c1 <_ZL13NextPacketPtr+0x1>
     d44:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     d46:	17 df       	rcall	.-466    	; 0xb76 <_Z13enc28j60Writehh>
     d48:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d4a:	81 e0       	ldi	r24, 0x01	; 1
     d4c:	14 df       	rcall	.-472    	; 0xb76 <_Z13enc28j60Writehh>
     d4e:	60 e0       	ldi	r22, 0x00	; 0
     d50:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d52:	99 de       	rcall	.-718    	; 0xa86 <_Z14enc28j60ReadOphh>
     d54:	c8 2f       	mov	r28, r24
     d56:	60 e0       	ldi	r22, 0x00	; 0
     d58:	8a e3       	ldi	r24, 0x3A	; 58
     d5a:	95 de       	rcall	.-726    	; 0xa86 <_Z14enc28j60ReadOphh>
     d5c:	d0 e0       	ldi	r29, 0x00	; 0
     d5e:	d8 2b       	or	r29, r24
     d60:	d0 93 c1 01 	sts	0x01C1, r29	; 0x8001c1 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d64:	c0 93 c0 01 	sts	0x01C0, r28	; 0x8001c0 <_ZL13NextPacketPtr>
     d68:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d6a:	8a e3       	ldi	r24, 0x3A	; 58
     d6c:	8c de       	rcall	.-744    	; 0xa86 <_Z14enc28j60ReadOphh>
     d6e:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d70:	60 e0       	ldi	r22, 0x00	; 0
     d72:	8a e3       	ldi	r24, 0x3A	; 58
     d74:	88 de       	rcall	.-752    	; 0xa86 <_Z14enc28j60ReadOphh>
     d76:	98 2e       	mov	r9, r24
     d78:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     d7a:	8a e3       	ldi	r24, 0x3A	; 58
     d7c:	84 de       	rcall	.-760    	; 0xa86 <_Z14enc28j60ReadOphh>
     d7e:	c8 2e       	mov	r12, r24
     d80:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     d82:	8a e3       	ldi	r24, 0x3A	; 58
     d84:	80 de       	rcall	.-768    	; 0xa86 <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     d86:	c7 fe       	sbrs	r12, 7
     d88:	0f c0       	rjmp	.+30     	; 0xda8 <_Z21enc28j60PacketReceivejPh+0x90>
     d8a:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d8c:	a8 1a       	sub	r10, r24
     d8e:	b1 08       	sbc	r11, r1
     d90:	10 e0       	ldi	r17, 0x00	; 0
     d92:	19 29       	or	r17, r9
     d94:	04 50       	subi	r16, 0x04	; 4
     d96:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     d98:	a0 16       	cp	r10, r16
     d9a:	b1 06       	cpc	r11, r17
     d9c:	08 f4       	brcc	.+2      	; 0xda0 <_Z21enc28j60PacketReceivejPh+0x88>
     d9e:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     da0:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     da2:	c8 01       	movw	r24, r16
     da4:	8d de       	rcall	.-742    	; 0xac0 <_Z18enc28j60ReadBufferjPh>
     da6:	02 c0       	rjmp	.+4      	; 0xdac <_Z21enc28j60PacketReceivejPh+0x94>
     da8:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     daa:	10 e0       	ldi	r17, 0x00	; 0
     dac:	6c 2f       	mov	r22, r28
     dae:	8c e0       	ldi	r24, 0x0C	; 12
     db0:	e2 de       	rcall	.-572    	; 0xb76 <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     db2:	6d 2f       	mov	r22, r29
     db4:	8d e0       	ldi	r24, 0x0D	; 13
     db6:	df de       	rcall	.-578    	; 0xb76 <_Z13enc28j60Writehh>
     db8:	40 e4       	ldi	r20, 0x40	; 64
     dba:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     dbc:	80 e8       	ldi	r24, 0x80	; 128
     dbe:	75 de       	rcall	.-790    	; 0xaaa <_Z15enc28j60WriteOphhh>
     dc0:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     dc2:	91 2f       	mov	r25, r17
     dc4:	02 c0       	rjmp	.+4      	; 0xdca <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	90 e0       	ldi	r25, 0x00	; 0
     dca:	df 91       	pop	r29
     dcc:	cf 91       	pop	r28
     dce:	1f 91       	pop	r17
     dd0:	0f 91       	pop	r16
     dd2:	ff 90       	pop	r15
     dd4:	ef 90       	pop	r14
     dd6:	df 90       	pop	r13
     dd8:	cf 90       	pop	r12
     dda:	bf 90       	pop	r11
     ddc:	af 90       	pop	r10
     dde:	9f 90       	pop	r9
     de0:	08 95       	ret

00000de2 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     de2:	cf 92       	push	r12
     de4:	df 92       	push	r13
     de6:	ef 92       	push	r14
     de8:	ff 92       	push	r15
     dea:	cf 93       	push	r28
     dec:	df 93       	push	r29
     dee:	ec 01       	movw	r28, r24
     df0:	db 01       	movw	r26, r22
     df2:	41 30       	cpi	r20, 0x01	; 1
     df4:	61 f4       	brne	.+24     	; 0xe0e <_Z8checksumPhjh+0x2c>
     df6:	6b 01       	movw	r12, r22
     df8:	88 e0       	ldi	r24, 0x08	; 8
     dfa:	c8 1a       	sub	r12, r24
     dfc:	d1 08       	sbc	r13, r1
     dfe:	e1 2c       	mov	r14, r1
     e00:	f1 2c       	mov	r15, r1
     e02:	81 e1       	ldi	r24, 0x11	; 17
     e04:	c8 0e       	add	r12, r24
     e06:	d1 1c       	adc	r13, r1
     e08:	e1 1c       	adc	r14, r1
     e0a:	f1 1c       	adc	r15, r1
     e0c:	11 c0       	rjmp	.+34     	; 0xe30 <_Z8checksumPhjh+0x4e>
     e0e:	42 30       	cpi	r20, 0x02	; 2
     e10:	61 f4       	brne	.+24     	; 0xe2a <_Z8checksumPhjh+0x48>
     e12:	6b 01       	movw	r12, r22
     e14:	88 e0       	ldi	r24, 0x08	; 8
     e16:	c8 1a       	sub	r12, r24
     e18:	d1 08       	sbc	r13, r1
     e1a:	e1 2c       	mov	r14, r1
     e1c:	f1 2c       	mov	r15, r1
     e1e:	86 e0       	ldi	r24, 0x06	; 6
     e20:	c8 0e       	add	r12, r24
     e22:	d1 1c       	adc	r13, r1
     e24:	e1 1c       	adc	r14, r1
     e26:	f1 1c       	adc	r15, r1
     e28:	03 c0       	rjmp	.+6      	; 0xe30 <_Z8checksumPhjh+0x4e>
     e2a:	c1 2c       	mov	r12, r1
     e2c:	d1 2c       	mov	r13, r1
     e2e:	76 01       	movw	r14, r12
     e30:	a2 30       	cpi	r26, 0x02	; 2
     e32:	b1 05       	cpc	r27, r1
     e34:	f0 f0       	brcs	.+60     	; 0xe72 <_Z8checksumPhjh+0x90>
     e36:	9d 01       	movw	r18, r26
     e38:	fe 01       	movw	r30, r28
     e3a:	40 81       	ld	r20, Z
     e3c:	50 e0       	ldi	r21, 0x00	; 0
     e3e:	60 e0       	ldi	r22, 0x00	; 0
     e40:	70 e0       	ldi	r23, 0x00	; 0
     e42:	76 2f       	mov	r23, r22
     e44:	65 2f       	mov	r22, r21
     e46:	54 2f       	mov	r21, r20
     e48:	44 27       	eor	r20, r20
     e4a:	81 81       	ldd	r24, Z+1	; 0x01
     e4c:	48 2b       	or	r20, r24
     e4e:	c4 0e       	add	r12, r20
     e50:	d5 1e       	adc	r13, r21
     e52:	e6 1e       	adc	r14, r22
     e54:	f7 1e       	adc	r15, r23
     e56:	32 96       	adiw	r30, 0x02	; 2
     e58:	22 50       	subi	r18, 0x02	; 2
     e5a:	31 09       	sbc	r19, r1
     e5c:	22 30       	cpi	r18, 0x02	; 2
     e5e:	31 05       	cpc	r19, r1
     e60:	60 f7       	brcc	.-40     	; 0xe3a <_Z8checksumPhjh+0x58>
     e62:	cd 01       	movw	r24, r26
     e64:	02 97       	sbiw	r24, 0x02	; 2
     e66:	8e 7f       	andi	r24, 0xFE	; 254
     e68:	02 96       	adiw	r24, 0x02	; 2
     e6a:	c8 0f       	add	r28, r24
     e6c:	d9 1f       	adc	r29, r25
     e6e:	a1 70       	andi	r26, 0x01	; 1
     e70:	bb 27       	eor	r27, r27
     e72:	ab 2b       	or	r26, r27
     e74:	61 f0       	breq	.+24     	; 0xe8e <_Z8checksumPhjh+0xac>
     e76:	88 81       	ld	r24, Y
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	a0 e0       	ldi	r26, 0x00	; 0
     e7c:	b0 e0       	ldi	r27, 0x00	; 0
     e7e:	ba 2f       	mov	r27, r26
     e80:	a9 2f       	mov	r26, r25
     e82:	98 2f       	mov	r25, r24
     e84:	88 27       	eor	r24, r24
     e86:	c8 0e       	add	r12, r24
     e88:	d9 1e       	adc	r13, r25
     e8a:	ea 1e       	adc	r14, r26
     e8c:	fb 1e       	adc	r15, r27
     e8e:	a7 01       	movw	r20, r14
     e90:	66 27       	eor	r22, r22
     e92:	77 27       	eor	r23, r23
     e94:	41 15       	cp	r20, r1
     e96:	51 05       	cpc	r21, r1
     e98:	61 05       	cpc	r22, r1
     e9a:	71 05       	cpc	r23, r1
     e9c:	71 f0       	breq	.+28     	; 0xeba <_Z8checksumPhjh+0xd8>
     e9e:	ee 24       	eor	r14, r14
     ea0:	ff 24       	eor	r15, r15
     ea2:	c4 0e       	add	r12, r20
     ea4:	d5 1e       	adc	r13, r21
     ea6:	e6 1e       	adc	r14, r22
     ea8:	f7 1e       	adc	r15, r23
     eaa:	a7 01       	movw	r20, r14
     eac:	66 27       	eor	r22, r22
     eae:	77 27       	eor	r23, r23
     eb0:	41 15       	cp	r20, r1
     eb2:	51 05       	cpc	r21, r1
     eb4:	61 05       	cpc	r22, r1
     eb6:	71 05       	cpc	r23, r1
     eb8:	91 f7       	brne	.-28     	; 0xe9e <_Z8checksumPhjh+0xbc>
     eba:	c6 01       	movw	r24, r12
     ebc:	80 95       	com	r24
     ebe:	90 95       	com	r25
     ec0:	df 91       	pop	r29
     ec2:	cf 91       	pop	r28
     ec4:	ff 90       	pop	r15
     ec6:	ef 90       	pop	r14
     ec8:	df 90       	pop	r13
     eca:	cf 90       	pop	r12
     ecc:	08 95       	ret

00000ece <_Z19init_ip_arp_udp_tcpPhS_h>:
     ece:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     ed2:	a6 2f       	mov	r26, r22
     ed4:	b7 2f       	mov	r27, r23
     ed6:	e3 ec       	ldi	r30, 0xC3	; 195
     ed8:	f1 e0       	ldi	r31, 0x01	; 1
     eda:	47 ec       	ldi	r20, 0xC7	; 199
     edc:	51 e0       	ldi	r21, 0x01	; 1
     ede:	2d 91       	ld	r18, X+
     ee0:	21 93       	st	Z+, r18
     ee2:	e4 17       	cp	r30, r20
     ee4:	f5 07       	cpc	r31, r21
     ee6:	d9 f7       	brne	.-10     	; 0xede <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     ee8:	a8 2f       	mov	r26, r24
     eea:	b9 2f       	mov	r27, r25
     eec:	e7 ec       	ldi	r30, 0xC7	; 199
     eee:	f1 e0       	ldi	r31, 0x01	; 1
     ef0:	2d ec       	ldi	r18, 0xCD	; 205
     ef2:	31 e0       	ldi	r19, 0x01	; 1
     ef4:	8d 91       	ld	r24, X+
     ef6:	81 93       	st	Z+, r24
     ef8:	e2 17       	cp	r30, r18
     efa:	f3 07       	cpc	r31, r19
     efc:	d9 f7       	brne	.-10     	; 0xef4 <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     efe:	08 95       	ret

00000f00 <_Z25eth_type_is_arp_and_my_ipPhj>:
     f00:	69 32       	cpi	r22, 0x29	; 41
     f02:	71 05       	cpc	r23, r1
     f04:	c8 f0       	brcs	.+50     	; 0xf38 <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     f06:	fc 01       	movw	r30, r24
     f08:	24 85       	ldd	r18, Z+12	; 0x0c
     f0a:	28 30       	cpi	r18, 0x08	; 8
     f0c:	b9 f4       	brne	.+46     	; 0xf3c <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     f0e:	25 85       	ldd	r18, Z+13	; 0x0d
     f10:	26 30       	cpi	r18, 0x06	; 6
     f12:	b1 f4       	brne	.+44     	; 0xf40 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     f14:	36 a1       	ldd	r19, Z+38	; 0x26
     f16:	20 91 c3 01 	lds	r18, 0x01C3	; 0x8001c3 <_ZL6ipaddr>
     f1a:	32 13       	cpse	r19, r18
     f1c:	13 c0       	rjmp	.+38     	; 0xf44 <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     f1e:	b7 96       	adiw	r30, 0x27	; 39
     f20:	a4 ec       	ldi	r26, 0xC4	; 196
     f22:	b1 e0       	ldi	r27, 0x01	; 1
     f24:	8a 96       	adiw	r24, 0x2a	; 42
     f26:	31 91       	ld	r19, Z+
     f28:	2d 91       	ld	r18, X+
     f2a:	32 13       	cpse	r19, r18
     f2c:	0d c0       	rjmp	.+26     	; 0xf48 <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     f2e:	e8 17       	cp	r30, r24
     f30:	f9 07       	cpc	r31, r25
     f32:	c9 f7       	brne	.-14     	; 0xf26 <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     f34:	81 e0       	ldi	r24, 0x01	; 1
     f36:	08 95       	ret
     f38:	80 e0       	ldi	r24, 0x00	; 0
     f3a:	08 95       	ret
     f3c:	80 e0       	ldi	r24, 0x00	; 0
     f3e:	08 95       	ret
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	08 95       	ret
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	08 95       	ret
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	08 95       	ret

00000f4c <_Z24eth_type_is_ip_and_my_ipPhj>:
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	fc 01       	movw	r30, r24
     f52:	6a 32       	cpi	r22, 0x2A	; 42
     f54:	71 05       	cpc	r23, r1
     f56:	e0 f0       	brcs	.+56     	; 0xf90 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     f58:	84 85       	ldd	r24, Z+12	; 0x0c
     f5a:	88 30       	cpi	r24, 0x08	; 8
     f5c:	d9 f4       	brne	.+54     	; 0xf94 <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     f5e:	85 85       	ldd	r24, Z+13	; 0x0d
     f60:	81 11       	cpse	r24, r1
     f62:	1a c0       	rjmp	.+52     	; 0xf98 <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     f64:	96 85       	ldd	r25, Z+14	; 0x0e
     f66:	95 34       	cpi	r25, 0x45	; 69
     f68:	c1 f4       	brne	.+48     	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f6a:	26 8d       	ldd	r18, Z+30	; 0x1e
     f6c:	90 91 c3 01 	lds	r25, 0x01C3	; 0x8001c3 <_ZL6ipaddr>
     f70:	29 13       	cpse	r18, r25
     f72:	13 c0       	rjmp	.+38     	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f74:	df 01       	movw	r26, r30
     f76:	5f 96       	adiw	r26, 0x1f	; 31
     f78:	c4 ec       	ldi	r28, 0xC4	; 196
     f7a:	d1 e0       	ldi	r29, 0x01	; 1
     f7c:	b2 96       	adiw	r30, 0x22	; 34
     f7e:	2d 91       	ld	r18, X+
     f80:	99 91       	ld	r25, Y+
     f82:	29 13       	cpse	r18, r25
     f84:	0a c0       	rjmp	.+20     	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f86:	ae 17       	cp	r26, r30
     f88:	bf 07       	cpc	r27, r31
     f8a:	c9 f7       	brne	.-14     	; 0xf7e <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     f8c:	81 e0       	ldi	r24, 0x01	; 1
     f8e:	05 c0       	rjmp	.+10     	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f90:	80 e0       	ldi	r24, 0x00	; 0
     f92:	03 c0       	rjmp	.+6      	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f94:	80 e0       	ldi	r24, 0x00	; 0
     f96:	01 c0       	rjmp	.+2      	; 0xf9a <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	08 95       	ret

00000fa0 <_Z8make_ethPh>:
     fa0:	fc 01       	movw	r30, r24
     fa2:	a7 ec       	ldi	r26, 0xC7	; 199
     fa4:	b1 e0       	ldi	r27, 0x01	; 1
     fa6:	9c 01       	movw	r18, r24
     fa8:	2a 5f       	subi	r18, 0xFA	; 250
     faa:	3f 4f       	sbci	r19, 0xFF	; 255
     fac:	86 81       	ldd	r24, Z+6	; 0x06
     fae:	81 93       	st	Z+, r24
     fb0:	8d 91       	ld	r24, X+
     fb2:	85 83       	std	Z+5, r24	; 0x05
     fb4:	e2 17       	cp	r30, r18
     fb6:	f3 07       	cpc	r31, r19
     fb8:	c9 f7       	brne	.-14     	; 0xfac <_Z8make_ethPh+0xc>
     fba:	08 95       	ret

00000fbc <_Z20fill_ip_hdr_checksumPh>:
     fbc:	cf 93       	push	r28
     fbe:	df 93       	push	r29
     fc0:	ec 01       	movw	r28, r24
     fc2:	18 8e       	std	Y+24, r1	; 0x18
     fc4:	19 8e       	std	Y+25, r1	; 0x19
     fc6:	80 e4       	ldi	r24, 0x40	; 64
     fc8:	8c 8b       	std	Y+20, r24	; 0x14
     fca:	1d 8a       	std	Y+21, r1	; 0x15
     fcc:	8e 8b       	std	Y+22, r24	; 0x16
     fce:	40 e0       	ldi	r20, 0x00	; 0
     fd0:	64 e1       	ldi	r22, 0x14	; 20
     fd2:	70 e0       	ldi	r23, 0x00	; 0
     fd4:	ce 01       	movw	r24, r28
     fd6:	0e 96       	adiw	r24, 0x0e	; 14
     fd8:	04 df       	rcall	.-504    	; 0xde2 <_Z8checksumPhjh>
     fda:	98 8f       	std	Y+24, r25	; 0x18
     fdc:	89 8f       	std	Y+25, r24	; 0x19
     fde:	df 91       	pop	r29
     fe0:	cf 91       	pop	r28
     fe2:	08 95       	ret

00000fe4 <_Z7make_ipPh>:
     fe4:	ac 01       	movw	r20, r24
     fe6:	a3 ec       	ldi	r26, 0xC3	; 195
     fe8:	b1 e0       	ldi	r27, 0x01	; 1
     fea:	fc 01       	movw	r30, r24
     fec:	7a 96       	adiw	r30, 0x1a	; 26
     fee:	27 ec       	ldi	r18, 0xC7	; 199
     ff0:	31 e0       	ldi	r19, 0x01	; 1
     ff2:	90 81       	ld	r25, Z
     ff4:	94 83       	std	Z+4, r25	; 0x04
     ff6:	9d 91       	ld	r25, X+
     ff8:	91 93       	st	Z+, r25
     ffa:	a2 17       	cp	r26, r18
     ffc:	b3 07       	cpc	r27, r19
     ffe:	c9 f7       	brne	.-14     	; 0xff2 <_Z7make_ipPh+0xe>
    1000:	ca 01       	movw	r24, r20
    1002:	dc cf       	rjmp	.-72     	; 0xfbc <_Z20fill_ip_hdr_checksumPh>
    1004:	08 95       	ret

00001006 <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
    1006:	cf 93       	push	r28
    1008:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    100a:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    100c:	c9 df       	rcall	.-110    	; 0xfa0 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    100e:	1c 8a       	std	Y+20, r1	; 0x14
    1010:	82 e0       	ldi	r24, 0x02	; 2
    1012:	8d 8b       	std	Y+21, r24	; 0x15
    1014:	a7 ec       	ldi	r26, 0xC7	; 199
    1016:	b1 e0       	ldi	r27, 0x01	; 1
    1018:	fe 01       	movw	r30, r28
    101a:	76 96       	adiw	r30, 0x16	; 22
    101c:	2d ec       	ldi	r18, 0xCD	; 205
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    101e:	31 e0       	ldi	r19, 0x01	; 1
    1020:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    1022:	82 87       	std	Z+10, r24	; 0x0a
    1024:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    1026:	81 93       	st	Z+, r24
    1028:	a2 17       	cp	r26, r18
    102a:	b3 07       	cpc	r27, r19
    102c:	c9 f7       	brne	.-14     	; 0x1020 <_Z28make_arp_answer_from_requestPh+0x1a>
    102e:	a3 ec       	ldi	r26, 0xC3	; 195
    1030:	b1 e0       	ldi	r27, 0x01	; 1
    1032:	fe 01       	movw	r30, r28
    1034:	7c 96       	adiw	r30, 0x1c	; 28
    1036:	27 ec       	ldi	r18, 0xC7	; 199
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    1038:	31 e0       	ldi	r19, 0x01	; 1
    103a:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    103c:	82 87       	std	Z+10, r24	; 0x0a
    103e:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    1040:	81 93       	st	Z+, r24
    1042:	a2 17       	cp	r26, r18
    1044:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    1046:	c9 f7       	brne	.-14     	; 0x103a <_Z28make_arp_answer_from_requestPh+0x34>
    1048:	be 01       	movw	r22, r28
    104a:	8a e2       	ldi	r24, 0x2A	; 42
    104c:	90 e0       	ldi	r25, 0x00	; 0
}
    104e:	36 de       	rcall	.-916    	; 0xcbc <_Z18enc28j60PacketSendjPh>
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	08 95       	ret

00001056 <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    1056:	0f 93       	push	r16
    1058:	1f 93       	push	r17
    105a:	cf 93       	push	r28
    105c:	df 93       	push	r29
    105e:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    1060:	8b 01       	movw	r16, r22
    1062:	9e df       	rcall	.-196    	; 0xfa0 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    1064:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    1066:	be df       	rcall	.-132    	; 0xfe4 <_Z7make_ipPh>
    1068:	1a a2       	std	Y+34, r1	; 0x22
    106a:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    106c:	88 3f       	cpi	r24, 0xF8	; 248
    106e:	18 f0       	brcs	.+6      	; 0x1076 <_Z28make_echo_reply_from_requestPhj+0x20>
    1070:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    1072:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
    1074:	9d a3       	std	Y+37, r25	; 0x25
    1076:	88 5f       	subi	r24, 0xF8	; 248
    1078:	8c a3       	std	Y+36, r24	; 0x24
}
    107a:	be 01       	movw	r22, r28
    107c:	c8 01       	movw	r24, r16
    107e:	1e de       	rcall	.-964    	; 0xcbc <_Z18enc28j60PacketSendjPh>
    1080:	df 91       	pop	r29
    1082:	cf 91       	pop	r28
    1084:	1f 91       	pop	r17
    1086:	0f 91       	pop	r16
    1088:	08 95       	ret

0000108a <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    108a:	df 92       	push	r13
    108c:	ef 92       	push	r14
    108e:	ff 92       	push	r15
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	cf 93       	push	r28
    1096:	df 93       	push	r29
    1098:	ec 01       	movw	r28, r24
    109a:	d6 2e       	mov	r13, r22
    109c:	e7 2e       	mov	r14, r23
    109e:	04 2f       	mov	r16, r20
    10a0:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    10a2:	f3 2e       	mov	r15, r19
    10a4:	7d df       	rcall	.-262    	; 0xfa0 <_Z8make_ethPh>
    10a6:	0d 3d       	cpi	r16, 0xDD	; 221
    10a8:	08 f0       	brcs	.+2      	; 0x10ac <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    10aa:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    10ac:	18 8a       	std	Y+16, r1	; 0x10
    10ae:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    10b0:	80 0f       	add	r24, r16
    10b2:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    10b4:	ce 01       	movw	r24, r28
    10b6:	96 df       	rcall	.-212    	; 0xfe4 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    10b8:	8a a1       	ldd	r24, Y+34	; 0x22
    10ba:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    10bc:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    10be:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    10c0:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    10c2:	1b a3       	std	Y+35, r17	; 0x23
    10c4:	1e a2       	std	Y+38, r1	; 0x26
    10c6:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    10c8:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    10ca:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
    10cc:	18 a6       	std	Y+40, r1	; 0x28
    10ce:	19 a6       	std	Y+41, r1	; 0x29
    10d0:	00 23       	and	r16, r16
    10d2:	81 f0       	breq	.+32     	; 0x10f4 <_Z27make_udp_reply_from_requestPhPchj+0x6a>
    10d4:	ad 2d       	mov	r26, r13
    10d6:	be 2d       	mov	r27, r14
    10d8:	fe 01       	movw	r30, r28
    10da:	ba 96       	adiw	r30, 0x2a	; 42
    10dc:	2f ef       	ldi	r18, 0xFF	; 255
    10de:	20 0f       	add	r18, r16
    10e0:	30 e0       	ldi	r19, 0x00	; 0
    10e2:	25 5d       	subi	r18, 0xD5	; 213
    10e4:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
    10e6:	2c 0f       	add	r18, r28
    10e8:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    10ea:	9d 91       	ld	r25, X+
    10ec:	91 93       	st	Z+, r25
    10ee:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    10f0:	f3 07       	cpc	r31, r19
    10f2:	d9 f7       	brne	.-10     	; 0x10ea <_Z27make_udp_reply_from_requestPhPchj+0x60>
    10f4:	10 e0       	ldi	r17, 0x00	; 0
    10f6:	b8 01       	movw	r22, r16
    10f8:	60 5f       	subi	r22, 0xF0	; 240
    10fa:	7f 4f       	sbci	r23, 0xFF	; 255
    10fc:	41 e0       	ldi	r20, 0x01	; 1
    10fe:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1100:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    1102:	6f de       	rcall	.-802    	; 0xde2 <_Z8checksumPhjh>
    1104:	98 a7       	std	Y+40, r25	; 0x28
    1106:	89 a7       	std	Y+41, r24	; 0x29
    1108:	be 01       	movw	r22, r28
}
    110a:	c8 01       	movw	r24, r16
    110c:	8a 96       	adiw	r24, 0x2a	; 42
    110e:	d6 dd       	rcall	.-1108   	; 0xcbc <_Z18enc28j60PacketSendjPh>
    1110:	df 91       	pop	r29
    1112:	cf 91       	pop	r28
    1114:	1f 91       	pop	r17
    1116:	0f 91       	pop	r16
    1118:	ff 90       	pop	r15
    111a:	ef 90       	pop	r14
    111c:	df 90       	pop	r13
    111e:	08 95       	ret

00001120 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1120:	87 b3       	in	r24, 0x17	; 23
    1122:	86 60       	ori	r24, 0x06	; 6
    1124:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    1126:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    1128:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    112a:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    112c:	80 e5       	ldi	r24, 0x50	; 80
    112e:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    1130:	70 9a       	sbi	0x0e, 0	; 14
    1132:	08 95       	ret

00001134 <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1134:	00 97       	sbiw	r24, 0x00	; 0
    1136:	41 f0       	breq	.+16     	; 0x1148 <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1138:	ef eb       	ldi	r30, 0xBF	; 191
    113a:	f0 e0       	ldi	r31, 0x00	; 0
    113c:	31 97       	sbiw	r30, 0x01	; 1
    113e:	f1 f7       	brne	.-4      	; 0x113c <_Z8delay_msj+0x8>
    1140:	00 c0       	rjmp	.+0      	; 0x1142 <_Z8delay_msj+0xe>
    1142:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    1144:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1146:	c1 f7       	brne	.-16     	; 0x1138 <_Z8delay_msj+0x4>
    1148:	08 95       	ret

0000114a <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    114a:	e7 ee       	ldi	r30, 0xE7	; 231
    114c:	f3 e0       	ldi	r31, 0x03	; 3
    114e:	84 85       	ldd	r24, Z+12	; 0x0c
    1150:	95 85       	ldd	r25, Z+13	; 0x0d
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	95 87       	std	Z+13, r25	; 0x0d
    1156:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
    1158:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
    115a:	c6 98       	cbi	0x18, 6	; 24
    115c:	08 95       	ret

0000115e <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,20,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    115e:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <chatter_flag>
    1162:	81 11       	cpse	r24, r1
    1164:	03 c0       	rjmp	.+6      	; 0x116c <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	80 93 e2 03 	sts	0x03E2, r24	; 0x8003e2 <chatter_flag>
    116c:	08 95       	ret

0000116e <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
    116e:	cf 93       	push	r28
    1170:	df 93       	push	r29
    1172:	cd b7       	in	r28, 0x3d	; 61
    1174:	de b7       	in	r29, 0x3e	; 62
    1176:	a2 97       	sbiw	r28, 0x22	; 34
    1178:	0f b6       	in	r0, 0x3f	; 63
    117a:	f8 94       	cli
    117c:	de bf       	out	0x3e, r29	; 62
    117e:	0f be       	out	0x3f, r0	; 63
    1180:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1182:	03 ee       	ldi	r16, 0xE3	; 227
    1184:	13 e0       	ldi	r17, 0x03	; 3
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1186:	0f 2e       	mov	r0, r31
    1188:	f7 e2       	ldi	r31, 0x27	; 39
    118a:	4f 2e       	mov	r4, r31
    118c:	f4 e0       	ldi	r31, 0x04	; 4
    118e:	5f 2e       	mov	r5, r31
    1190:	f0 2d       	mov	r31, r0
    1192:	0f 2e       	mov	r0, r31
    1194:	f9 e2       	ldi	r31, 0x29	; 41
    1196:	cf 2e       	mov	r12, r31
    1198:	f4 e0       	ldi	r31, 0x04	; 4
    119a:	df 2e       	mov	r13, r31
    119c:	f0 2d       	mov	r31, r0
    119e:	0f 2e       	mov	r0, r31
    11a0:	fb e2       	ldi	r31, 0x2B	; 43
    11a2:	ef 2e       	mov	r14, r31
    11a4:	f4 e0       	ldi	r31, 0x04	; 4
    11a6:	ff 2e       	mov	r15, r31
    11a8:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
    11aa:	ce 01       	movw	r24, r28
    11ac:	01 96       	adiw	r24, 0x01	; 1
    11ae:	9f 8f       	std	Y+31, r25	; 0x1f
    11b0:	8e 8f       	std	Y+30, r24	; 0x1e
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    11b2:	33 24       	eor	r3, r3
    11b4:	33 94       	inc	r3
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    11b6:	f8 01       	movw	r30, r16
    11b8:	80 81       	ld	r24, Z
    11ba:	91 81       	ldd	r25, Z+1	; 0x01
    11bc:	a2 81       	ldd	r26, Z+2	; 0x02
    11be:	b3 81       	ldd	r27, Z+3	; 0x03
    11c0:	80 93 de 03 	sts	0x03DE, r24	; 0x8003de <_ZZL5proc2PvE4myip>
    11c4:	90 93 df 03 	sts	0x03DF, r25	; 0x8003df <_ZZL5proc2PvE4myip+0x1>
    11c8:	a0 93 e0 03 	sts	0x03E0, r26	; 0x8003e0 <_ZZL5proc2PvE4myip+0x2>
    11cc:	b0 93 e1 03 	sts	0x03E1, r27	; 0x8003e1 <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
    11d0:	8f ef       	ldi	r24, 0xFF	; 255
    11d2:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    11d4:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    11da:	f6 dc       	rcall	.-1556   	; 0xbc8 <_Z12enc28j60InitPh>
    11dc:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    11de:	ef dc       	rcall	.-1570   	; 0xbbe <_Z14enc28j60clkouth>
    11e0:	8a e0       	ldi	r24, 0x0A	; 10
    11e2:	90 e0       	ldi	r25, 0x00	; 0
    11e4:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    11e8:	66 e7       	ldi	r22, 0x76	; 118
    11ea:	74 e0       	ldi	r23, 0x04	; 4
    11ec:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    11ee:	cf dc       	rcall	.-1634   	; 0xb8e <_Z16enc28j60PhyWritehj>
    11f0:	84 e1       	ldi	r24, 0x14	; 20
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    11f8:	40 e5       	ldi	r20, 0x50	; 80
    11fa:	6e ed       	ldi	r22, 0xDE	; 222
    11fc:	73 e0       	ldi	r23, 0x03	; 3
    11fe:	81 e0       	ldi	r24, 0x01	; 1
    1200:	91 e0       	ldi	r25, 0x01	; 1

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
    1202:	65 de       	rcall	.-822    	; 0xece <_Z19init_ip_arp_udp_tcpPhS_h>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1204:	18 a2       	std	Y+32, r1	; 0x20
    1206:	21 2c       	mov	r2, r1
    1208:	0f 2e       	mov	r0, r31
    120a:	fd e2       	ldi	r31, 0x2D	; 45
    120c:	af 2e       	mov	r10, r31
    120e:	f4 e0       	ldi	r31, 0x04	; 4
    1210:	bf 2e       	mov	r11, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    1212:	f0 2d       	mov	r31, r0
    1214:	0f 2e       	mov	r0, r31
    1216:	fd ec       	ldi	r31, 0xCD	; 205
    1218:	6f 2e       	mov	r6, r31
    121a:	f1 e0       	ldi	r31, 0x01	; 1
    121c:	7f 2e       	mov	r7, r31
    121e:	f0 2d       	mov	r31, r0
    1220:	0f 2e       	mov	r0, r31
    1222:	f7 ee       	ldi	r31, 0xE7	; 231
    1224:	8f 2e       	mov	r8, r31
    1226:	f3 e0       	ldi	r31, 0x03	; 3
    1228:	9f 2e       	mov	r9, r31
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    122a:	f0 2d       	mov	r31, r0
    122c:	d8 01       	movw	r26, r16
    122e:	8c 91       	ld	r24, X
    1230:	90 e0       	ldi	r25, 0x00	; 0
    1232:	f2 01       	movw	r30, r4
    1234:	60 81       	ld	r22, Z
    1236:	71 81       	ldd	r23, Z+1	; 0x01
    1238:	11 96       	adiw	r26, 0x01	; 1
    123a:	4c 91       	ld	r20, X
    123c:	50 e0       	ldi	r21, 0x00	; 0
    123e:	33 2d       	mov	r19, r3
    1240:	f6 01       	movw	r30, r12
    1242:	a0 81       	ld	r26, Z
    1244:	b1 81       	ldd	r27, Z+1	; 0x01
    1246:	4a 17       	cp	r20, r26
    1248:	5b 07       	cpc	r21, r27
    124a:	09 f4       	brne	.+2      	; 0x124e <_ZL5proc2Pv+0xe0>
    124c:	32 2d       	mov	r19, r2
    124e:	23 2d       	mov	r18, r3
    1250:	86 17       	cp	r24, r22
    1252:	97 07       	cpc	r25, r23
    1254:	09 f4       	brne	.+2      	; 0x1258 <_ZL5proc2Pv+0xea>
    1256:	22 2d       	mov	r18, r2
    1258:	f3 2f       	mov	r31, r19
    125a:	f2 2b       	or	r31, r18
    125c:	d8 01       	movw	r26, r16
    125e:	12 96       	adiw	r26, 0x02	; 2
    1260:	2c 91       	ld	r18, X
    1262:	30 e0       	ldi	r19, 0x00	; 0
    1264:	e3 2d       	mov	r30, r3
    1266:	d7 01       	movw	r26, r14
    1268:	4d 91       	ld	r20, X+
    126a:	5c 91       	ld	r21, X
    126c:	24 17       	cp	r18, r20
    126e:	35 07       	cpc	r19, r21
    1270:	09 f4       	brne	.+2      	; 0x1274 <_ZL5proc2Pv+0x106>
    1272:	e2 2d       	mov	r30, r2
    1274:	ef 2b       	or	r30, r31
    1276:	71 f4       	brne	.+28     	; 0x1294 <_ZL5proc2Pv+0x126>
    1278:	f8 01       	movw	r30, r16
    127a:	23 81       	ldd	r18, Z+3	; 0x03
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	e3 2d       	mov	r30, r3
    1280:	d5 01       	movw	r26, r10
    1282:	4d 91       	ld	r20, X+
    1284:	5c 91       	ld	r21, X
    1286:	24 17       	cp	r18, r20
    1288:	35 07       	cpc	r19, r21
    128a:	09 f4       	brne	.+2      	; 0x128e <_ZL5proc2Pv+0x120>
    128c:	e2 2d       	mov	r30, r2
    128e:	ee 23       	and	r30, r30
    1290:	09 f4       	brne	.+2      	; 0x1294 <_ZL5proc2Pv+0x126>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    1292:	46 c0       	rjmp	.+140    	; 0x1320 <_ZL5proc2Pv+0x1b2>
    1294:	86 17       	cp	r24, r22
    1296:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    1298:	41 f0       	breq	.+16     	; 0x12aa <_ZL5proc2Pv+0x13c>
    129a:	80 e0       	ldi	r24, 0x00	; 0
    129c:	90 e0       	ldi	r25, 0x00	; 0
    129e:	0e 94 5d 18 	call	0x30ba	; 0x30ba <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    12a2:	f2 01       	movw	r30, r4
    12a4:	80 81       	ld	r24, Z
    12a6:	d8 01       	movw	r26, r16
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    12a8:	8c 93       	st	X, r24
    12aa:	f6 01       	movw	r30, r12
    12ac:	60 81       	ld	r22, Z
    12ae:	71 81       	ldd	r23, Z+1	; 0x01
    12b0:	d8 01       	movw	r26, r16
    12b2:	11 96       	adiw	r26, 0x01	; 1
    12b4:	8c 91       	ld	r24, X
    12b6:	90 e0       	ldi	r25, 0x00	; 0
    12b8:	86 17       	cp	r24, r22
    12ba:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    12bc:	49 f0       	breq	.+18     	; 0x12d0 <_ZL5proc2Pv+0x162>
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	0e 94 5d 18 	call	0x30ba	; 0x30ba <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    12c6:	f6 01       	movw	r30, r12
    12c8:	80 81       	ld	r24, Z
    12ca:	d8 01       	movw	r26, r16
    12cc:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    12ce:	8c 93       	st	X, r24
    12d0:	f7 01       	movw	r30, r14
    12d2:	60 81       	ld	r22, Z
    12d4:	71 81       	ldd	r23, Z+1	; 0x01
    12d6:	d8 01       	movw	r26, r16
    12d8:	12 96       	adiw	r26, 0x02	; 2
    12da:	8c 91       	ld	r24, X
    12dc:	90 e0       	ldi	r25, 0x00	; 0
    12de:	86 17       	cp	r24, r22
    12e0:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    12e2:	49 f0       	breq	.+18     	; 0x12f6 <_ZL5proc2Pv+0x188>
    12e4:	82 e0       	ldi	r24, 0x02	; 2
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	0e 94 5d 18 	call	0x30ba	; 0x30ba <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    12ec:	f7 01       	movw	r30, r14
    12ee:	80 81       	ld	r24, Z
    12f0:	d8 01       	movw	r26, r16
    12f2:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    12f4:	8c 93       	st	X, r24
    12f6:	60 91 2d 04 	lds	r22, 0x042D	; 0x80042d <mem4+0x46>
    12fa:	70 91 2e 04 	lds	r23, 0x042E	; 0x80042e <mem4+0x47>
    12fe:	f8 01       	movw	r30, r16
    1300:	83 81       	ldd	r24, Z+3	; 0x03
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	86 17       	cp	r24, r22
    1306:	97 07       	cpc	r25, r23
    1308:	09 f4       	brne	.+2      	; 0x130c <_ZL5proc2Pv+0x19e>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    130a:	55 cf       	rjmp	.-342    	; 0x11b6 <_ZL5proc2Pv+0x48>
    130c:	83 e0       	ldi	r24, 0x03	; 3
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	0e 94 5d 18 	call	0x30ba	; 0x30ba <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    1314:	80 91 2d 04 	lds	r24, 0x042D	; 0x80042d <mem4+0x46>
    1318:	d8 01       	movw	r26, r16
    131a:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    131c:	8c 93       	st	X, r24
    131e:	49 cf       	rjmp	.-366    	; 0x11b2 <_ZL5proc2Pv+0x44>
    1320:	6d ed       	ldi	r22, 0xDD	; 221
    1322:	71 e0       	ldi	r23, 0x01	; 1
    1324:	80 e0       	ldi	r24, 0x00	; 0
    1326:	92 e0       	ldi	r25, 0x02	; 2
    1328:	f7 dc       	rcall	.-1554   	; 0xd18 <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    132a:	9a a3       	std	Y+34, r25	; 0x22
    132c:	89 a3       	std	Y+33, r24	; 0x21
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    132e:	00 97       	sbiw	r24, 0x00	; 0
    1330:	09 f4       	brne	.+2      	; 0x1334 <_ZL5proc2Pv+0x1c6>
    1332:	70 c0       	rjmp	.+224    	; 0x1414 <_ZL5proc2Pv+0x2a6>
    1334:	bc 01       	movw	r22, r24
    1336:	8d ed       	ldi	r24, 0xDD	; 221
    1338:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
    133a:	e2 dd       	rcall	.-1084   	; 0xf00 <_Z25eth_type_is_arp_and_my_ipPhj>
    133c:	88 23       	and	r24, r24
    133e:	21 f0       	breq	.+8      	; 0x1348 <_ZL5proc2Pv+0x1da>
			 continue;
    1340:	8d ed       	ldi	r24, 0xDD	; 221
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    1342:	91 e0       	ldi	r25, 0x01	; 1
    1344:	60 de       	rcall	.-832    	; 0x1006 <_Z28make_arp_answer_from_requestPh>
    1346:	72 cf       	rjmp	.-284    	; 0x122c <_ZL5proc2Pv+0xbe>
    1348:	69 a1       	ldd	r22, Y+33	; 0x21
    134a:	7a a1       	ldd	r23, Y+34	; 0x22
    134c:	8d ed       	ldi	r24, 0xDD	; 221
    134e:	91 e0       	ldi	r25, 0x01	; 1
    1350:	fd dd       	rcall	.-1030   	; 0xf4c <_Z24eth_type_is_ip_and_my_ipPhj>
    1352:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    1354:	09 f4       	brne	.+2      	; 0x1358 <_ZL5proc2Pv+0x1ea>
    1356:	6a cf       	rjmp	.-300    	; 0x122c <_ZL5proc2Pv+0xbe>
    1358:	80 91 f4 01 	lds	r24, 0x01F4	; 0x8001f4 <_ZZL5proc2PvE3buf+0x17>
    135c:	81 30       	cpi	r24, 0x01	; 1
    135e:	51 f4       	brne	.+20     	; 0x1374 <_ZL5proc2Pv+0x206>
		 {
			make_echo_reply_from_request(buf,plen);
    1360:	80 91 ff 01 	lds	r24, 0x01FF	; 0x8001ff <_ZZL5proc2PvE3buf+0x22>
    1364:	88 30       	cpi	r24, 0x08	; 8
    1366:	31 f4       	brne	.+12     	; 0x1374 <_ZL5proc2Pv+0x206>
    1368:	69 a1       	ldd	r22, Y+33	; 0x21
    136a:	7a a1       	ldd	r23, Y+34	; 0x22
			continue;
    136c:	8d ed       	ldi	r24, 0xDD	; 221
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    136e:	91 e0       	ldi	r25, 0x01	; 1
    1370:	72 de       	rcall	.-796    	; 0x1056 <_Z28make_echo_reply_from_requestPhj>
    1372:	5c cf       	rjmp	.-328    	; 0x122c <_ZL5proc2Pv+0xbe>
    1374:	80 91 07 02 	lds	r24, 0x0207	; 0x800207 <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
    1378:	81 33       	cpi	r24, 0x31	; 49
    137a:	09 f0       	breq	.+2      	; 0x137e <_ZL5proc2Pv+0x210>
    137c:	4b c0       	rjmp	.+150    	; 0x1414 <_ZL5proc2Pv+0x2a6>
    137e:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1380:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1382:	8d e1       	ldi	r24, 0x1D	; 29
			 char loop = buf[UDP_DATA_P + 1];
    1384:	11 92       	st	Z+, r1
    1386:	8a 95       	dec	r24
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    1388:	e9 f7       	brne	.-6      	; 0x1384 <_ZL5proc2Pv+0x216>
    138a:	80 91 08 02 	lds	r24, 0x0208	; 0x800208 <_ZZL5proc2PvE3buf+0x2b>
    138e:	80 53       	subi	r24, 0x30	; 48
    1390:	90 e0       	ldi	r25, 0x00	; 0
    1392:	01 96       	adiw	r24, 0x01	; 1
    1394:	82 30       	cpi	r24, 0x02	; 2
    1396:	91 05       	cpc	r25, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    1398:	0c f0       	brlt	.+2      	; 0x139c <_ZL5proc2Pv+0x22e>
    139a:	87 c0       	rjmp	.+270    	; 0x14aa <_ZL5proc2Pv+0x33c>
    139c:	22 c0       	rjmp	.+68     	; 0x13e2 <_ZL5proc2Pv+0x274>
    139e:	f9 01       	movw	r30, r18
    13a0:	e3 52       	subi	r30, 0x23	; 35
    13a2:	fe 4f       	sbci	r31, 0xFE	; 254
    13a4:	63 a5       	ldd	r22, Z+43	; 0x2b
    13a6:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    13a8:	e2 0f       	add	r30, r18
    13aa:	f3 1f       	adc	r31, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    13ac:	60 83       	st	Z, r22
    13ae:	40 fd       	sbrc	r20, 0
    13b0:	12 c0       	rjmp	.+36     	; 0x13d6 <_ZL5proc2Pv+0x268>
    13b2:	e5 2f       	mov	r30, r21
    13b4:	f0 e0       	ldi	r31, 0x00	; 0
    13b6:	ee 0f       	add	r30, r30
    13b8:	ff 1f       	adc	r31, r31
    13ba:	e5 50       	subi	r30, 0x05	; 5
    13bc:	fc 4f       	sbci	r31, 0xFC	; 252
    13be:	af ef       	ldi	r26, 0xFF	; 255
    13c0:	bf ef       	ldi	r27, 0xFF	; 255
    13c2:	ac 0f       	add	r26, r28
    13c4:	bd 1f       	adc	r27, r29
    13c6:	a2 0f       	add	r26, r18
    13c8:	b3 1f       	adc	r27, r19
    13ca:	2c 91       	ld	r18, X
    13cc:	30 e0       	ldi	r19, 0x00	; 0
					num++;
    13ce:	36 2b       	or	r19, r22
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    13d0:	31 83       	std	Z+1, r19	; 0x01
    13d2:	20 83       	st	Z, r18
    13d4:	5f 5f       	subi	r21, 0xFF	; 255
    13d6:	4f 5f       	subi	r20, 0xFF	; 255
    13d8:	24 2f       	mov	r18, r20
    13da:	30 e0       	ldi	r19, 0x00	; 0
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    13dc:	28 17       	cp	r18, r24
    13de:	39 07       	cpc	r19, r25
    13e0:	f4 f2       	brlt	.-68     	; 0x139e <_ZL5proc2Pv+0x230>
    13e2:	d4 01       	movw	r26, r8
    13e4:	d0 96       	adiw	r26, 0x30	; 48
    13e6:	8d 91       	ld	r24, X+
    13e8:	9c 91       	ld	r25, X
    13ea:	d1 97       	sbiw	r26, 0x31	; 49
    13ec:	51 96       	adiw	r26, 0x11	; 17
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    13ee:	9c 93       	st	X, r25
    13f0:	8e 93       	st	-X, r24
    13f2:	50 97       	sbiw	r26, 0x10	; 16
    13f4:	dd 96       	adiw	r26, 0x3d	; 61
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    13f6:	9c 93       	st	X, r25
    13f8:	8e 93       	st	-X, r24
    13fa:	dc 97       	sbiw	r26, 0x3c	; 60
    13fc:	d9 96       	adiw	r26, 0x39	; 57
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    13fe:	9c 93       	st	X, r25
    1400:	8e 93       	st	-X, r24
    1402:	d8 97       	sbiw	r26, 0x38	; 56
    1404:	d7 96       	adiw	r26, 0x37	; 55
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    1406:	9c 93       	st	X, r25
    1408:	8e 93       	st	-X, r24
    140a:	d6 97       	sbiw	r26, 0x36	; 54
    140c:	df 96       	adiw	r26, 0x3f	; 63
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    140e:	9c 93       	st	X, r25
    1410:	8e 93       	st	-X, r24
    1412:	de 97       	sbiw	r26, 0x3e	; 62
			 if(led_flag)
    1414:	b8 a1       	ldd	r27, Y+32	; 0x20
    1416:	b0 95       	com	r27
			 {
				 PORTB = sbi(PORTB,4);
    1418:	b8 a3       	std	Y+32, r27	; 0x20
    141a:	bb 23       	and	r27, r27
    141c:	29 f0       	breq	.+10     	; 0x1428 <_ZL5proc2Pv+0x2ba>
    141e:	88 b3       	in	r24, 0x18	; 24
    1420:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    1422:	88 bb       	out	0x18, r24	; 24
    1424:	88 bb       	out	0x18, r24	; 24
    1426:	04 c0       	rjmp	.+8      	; 0x1430 <_ZL5proc2Pv+0x2c2>
    1428:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    142a:	8f 7e       	andi	r24, 0xEF	; 239
    142c:	88 bb       	out	0x18, r24	; 24
    142e:	88 bb       	out	0x18, r24	; 24
    1430:	f4 01       	movw	r30, r8
    1432:	82 81       	ldd	r24, Z+2	; 0x02
    1434:	93 81       	ldd	r25, Z+3	; 0x03
    1436:	d3 01       	movw	r26, r6
			 data[1] = mem4[COUNT];
    1438:	11 96       	adiw	r26, 0x01	; 1
    143a:	9c 93       	st	X, r25
    143c:	8e 93       	st	-X, r24
    143e:	86 81       	ldd	r24, Z+6	; 0x06
    1440:	97 81       	ldd	r25, Z+7	; 0x07
    1442:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    1444:	9c 93       	st	X, r25
    1446:	8e 93       	st	-X, r24
    1448:	12 97       	sbiw	r26, 0x02	; 2
    144a:	84 81       	ldd	r24, Z+4	; 0x04
    144c:	95 81       	ldd	r25, Z+5	; 0x05
    144e:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    1450:	9c 93       	st	X, r25
    1452:	8e 93       	st	-X, r24
    1454:	14 97       	sbiw	r26, 0x04	; 4
    1456:	80 89       	ldd	r24, Z+16	; 0x10
    1458:	91 89       	ldd	r25, Z+17	; 0x11
    145a:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    145c:	9c 93       	st	X, r25
    145e:	8e 93       	st	-X, r24
    1460:	16 97       	sbiw	r26, 0x06	; 6
    1462:	82 89       	ldd	r24, Z+18	; 0x12
    1464:	93 89       	ldd	r25, Z+19	; 0x13
    1466:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    1468:	9c 93       	st	X, r25
    146a:	8e 93       	st	-X, r24
    146c:	18 97       	sbiw	r26, 0x08	; 8
    146e:	84 85       	ldd	r24, Z+12	; 0x0c
    1470:	95 85       	ldd	r25, Z+13	; 0x0d
    1472:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    1474:	9c 93       	st	X, r25
    1476:	8e 93       	st	-X, r24
    1478:	1a 97       	sbiw	r26, 0x0a	; 10
    147a:	82 85       	ldd	r24, Z+10	; 0x0a
    147c:	93 85       	ldd	r25, Z+11	; 0x0b
    147e:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    1480:	9c 93       	st	X, r25
    1482:	8e 93       	st	-X, r24
    1484:	1c 97       	sbiw	r26, 0x0c	; 12
    1486:	80 85       	ldd	r24, Z+8	; 0x08
    1488:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    148a:	1f 96       	adiw	r26, 0x0f	; 15
    148c:	9c 93       	st	X, r25
    148e:	8e 93       	st	-X, r24
    1490:	1e 97       	sbiw	r26, 0x0e	; 14
    1492:	2f e0       	ldi	r18, 0x0F	; 15
    1494:	37 e2       	ldi	r19, 0x27	; 39
    1496:	40 e1       	ldi	r20, 0x10	; 16
    1498:	b3 01       	movw	r22, r6
			 vTaskDelay(100);
    149a:	8d ed       	ldi	r24, 0xDD	; 221
    149c:	91 e0       	ldi	r25, 0x01	; 1
    149e:	f5 dd       	rcall	.-1046   	; 0x108a <_Z27make_udp_reply_from_requestPhPchj>
    14a0:	84 e6       	ldi	r24, 0x64	; 100
    14a2:	90 e0       	ldi	r25, 0x00	; 0
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    14a4:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <vTaskDelay>
    14a8:	c1 ce       	rjmp	.-638    	; 0x122c <_ZL5proc2Pv+0xbe>
    14aa:	20 91 09 02 	lds	r18, 0x0209	; 0x800209 <_ZZL5proc2PvE3buf+0x2c>
    14ae:	29 83       	std	Y+1, r18	; 0x01
    14b0:	41 e0       	ldi	r20, 0x01	; 1
    14b2:	50 e0       	ldi	r21, 0x00	; 0
    14b4:	90 cf       	rjmp	.-224    	; 0x13d6 <_ZL5proc2Pv+0x268>

000014b6 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    14b6:	cf 93       	push	r28
    14b8:	df 93       	push	r29
    14ba:	cd b7       	in	r28, 0x3d	; 61
    14bc:	de b7       	in	r29, 0x3e	; 62
    14be:	2f 97       	sbiw	r28, 0x0f	; 15
    14c0:	0f b6       	in	r0, 0x3f	; 63
    14c2:	f8 94       	cli
    14c4:	de bf       	out	0x3e, r29	; 62
    14c6:	0f be       	out	0x3f, r0	; 63
    14c8:	cd bf       	out	0x3d, r28	; 61
    14ca:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    14cc:	fe 01       	movw	r30, r28
    14ce:	31 96       	adiw	r30, 0x01	; 1
    14d0:	8f e0       	ldi	r24, 0x0F	; 15
    14d2:	df 01       	movw	r26, r30
    14d4:	1d 92       	st	X+, r1
    14d6:	8a 95       	dec	r24
    14d8:	e9 f7       	brne	.-6      	; 0x14d4 <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    14da:	07 ee       	ldi	r16, 0xE7	; 231
    14dc:	13 e0       	ldi	r17, 0x03	; 3
    14de:	5e 01       	movw	r10, r28
    14e0:	b0 e1       	ldi	r27, 0x10	; 16
    14e2:	ab 0e       	add	r10, r27
    14e4:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    14e6:	0f 2e       	mov	r0, r31
    14e8:	fa e9       	ldi	r31, 0x9A	; 154
    14ea:	8f 2e       	mov	r8, r31
    14ec:	91 2c       	mov	r9, r1
    14ee:	f0 2d       	mov	r31, r0
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    14f0:	0f 2e       	mov	r0, r31
    14f2:	ff e2       	ldi	r31, 0x2F	; 47
    14f4:	6f 2e       	mov	r6, r31
    14f6:	f4 e0       	ldi	r31, 0x04	; 4
    14f8:	7f 2e       	mov	r7, r31
    14fa:	f0 2d       	mov	r31, r0
					mem4[COUNT] = count_number;
				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    14fc:	0f 2e       	mov	r0, r31
    14fe:	f3 e0       	ldi	r31, 0x03	; 3
    1500:	4f 2e       	mov	r4, r31
    1502:	51 2c       	mov	r5, r1
    1504:	f0 2d       	mov	r31, r0
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1506:	f8 01       	movw	r30, r16
    1508:	80 89       	ldd	r24, Z+16	; 0x10
    150a:	91 89       	ldd	r25, Z+17	; 0x11
    150c:	26 ad       	ldd	r18, Z+62	; 0x3e
    150e:	37 ad       	ldd	r19, Z+63	; 0x3f
    1510:	28 17       	cp	r18, r24
    1512:	39 07       	cpc	r19, r25
    1514:	41 f0       	breq	.+16     	; 0x1526 <_ZL5proc1Pv+0x70>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1516:	95 af       	std	Z+61, r25	; 0x3d
    1518:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    151a:	91 af       	std	Z+57, r25	; 0x39
    151c:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    151e:	97 ab       	std	Z+55, r25	; 0x37
    1520:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    1522:	97 af       	std	Z+63, r25	; 0x3f
    1524:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    1526:	c6 01       	movw	r24, r12
    1528:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    152c:	8f 30       	cpi	r24, 0x0F	; 15
    152e:	58 f3       	brcs	.-42     	; 0x1506 <_ZL5proc1Pv+0x50>
    1530:	ce 01       	movw	r24, r28
    1532:	01 96       	adiw	r24, 0x01	; 1
    1534:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    1536:	c6 01       	movw	r24, r12
    1538:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    153c:	d7 01       	movw	r26, r14
    153e:	8d 93       	st	X+, r24
    1540:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1542:	aa 15       	cp	r26, r10
    1544:	bb 05       	cpc	r27, r11
    1546:	b9 f7       	brne	.-18     	; 0x1536 <_ZL5proc1Pv+0x80>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    1548:	89 81       	ldd	r24, Y+1	; 0x01
    154a:	82 30       	cpi	r24, 0x02	; 2
    154c:	09 f0       	breq	.+2      	; 0x1550 <_ZL5proc1Pv+0x9a>
    154e:	53 c0       	rjmp	.+166    	; 0x15f6 <_ZL5proc1Pv+0x140>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1550:	88 85       	ldd	r24, Y+8	; 0x08
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	98 2f       	mov	r25, r24
    1556:	88 27       	eor	r24, r24
    1558:	29 85       	ldd	r18, Y+9	; 0x09
    155a:	82 2b       	or	r24, r18
    155c:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <count_number+0x1>
    1560:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    1564:	8a 85       	ldd	r24, Y+10	; 0x0a
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	98 2f       	mov	r25, r24
    156a:	88 27       	eor	r24, r24
    156c:	2b 85       	ldd	r18, Y+11	; 0x0b
    156e:	82 2b       	or	r24, r18
    1570:	90 93 36 04 	sts	0x0436, r25	; 0x800436 <current_temp+0x1>
    1574:	80 93 35 04 	sts	0x0435, r24	; 0x800435 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    1578:	2c 85       	ldd	r18, Y+12	; 0x0c
    157a:	30 e0       	ldi	r19, 0x00	; 0
    157c:	32 2f       	mov	r19, r18
    157e:	22 27       	eor	r18, r18
    1580:	4d 85       	ldd	r20, Y+13	; 0x0d
    1582:	24 2b       	or	r18, r20
    1584:	30 93 34 04 	sts	0x0434, r19	; 0x800434 <current_pressure+0x1>
    1588:	20 93 33 04 	sts	0x0433, r18	; 0x800433 <current_pressure>
				mem4[TEMP] = current_temp;
    158c:	f8 01       	movw	r30, r16
    158e:	93 83       	std	Z+3, r25	; 0x03
    1590:	82 83       	std	Z+2, r24	; 0x02
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    1592:	d3 01       	movw	r26, r6
    1594:	8d 91       	ld	r24, X+
    1596:	9c 91       	ld	r25, X
    1598:	89 2b       	or	r24, r25
    159a:	19 f0       	breq	.+6      	; 0x15a2 <_ZL5proc1Pv+0xec>
				{
					Alarm_Start();
    159c:	0e 94 e6 01 	call	0x3cc	; 0x3cc <Alarm_Start>
    15a0:	09 c0       	rjmp	.+18     	; 0x15b4 <_ZL5proc1Pv+0xfe>
				}
				else //PLC
				{
					Alarm_Stop();
    15a2:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <Alarm_Stop>
					mem4[COUNT] = count_number;
    15a6:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <count_number>
    15aa:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <count_number+0x1>
    15ae:	f8 01       	movw	r30, r16
    15b0:	97 83       	std	Z+7, r25	; 0x07
    15b2:	86 83       	std	Z+6, r24	; 0x06
				}
				mem4[PRESSURE] = current_pressure;
    15b4:	80 91 33 04 	lds	r24, 0x0433	; 0x800433 <current_pressure>
    15b8:	90 91 34 04 	lds	r25, 0x0434	; 0x800434 <current_pressure+0x1>
    15bc:	d8 01       	movw	r26, r16
    15be:	15 96       	adiw	r26, 0x05	; 5
    15c0:	9c 93       	st	X, r25
    15c2:	8e 93       	st	-X, r24
    15c4:	14 97       	sbiw	r26, 0x04	; 4
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    15c6:	50 96       	adiw	r26, 0x10	; 16
    15c8:	2d 91       	ld	r18, X+
    15ca:	3c 91       	ld	r19, X
    15cc:	51 97       	sbiw	r26, 0x11	; 17
    15ce:	16 96       	adiw	r26, 0x06	; 6
    15d0:	8d 91       	ld	r24, X+
    15d2:	9c 91       	ld	r25, X
    15d4:	17 97       	sbiw	r26, 0x07	; 7
    15d6:	28 17       	cp	r18, r24
    15d8:	39 07       	cpc	r19, r25
    15da:	09 f0       	breq	.+2      	; 0x15de <_ZL5proc1Pv+0x128>
    15dc:	94 cf       	rjmp	.-216    	; 0x1506 <_ZL5proc1Pv+0x50>
    15de:	52 96       	adiw	r26, 0x12	; 18
    15e0:	8d 91       	ld	r24, X+
    15e2:	9c 91       	ld	r25, X
    15e4:	53 97       	sbiw	r26, 0x13	; 19
    15e6:	89 2b       	or	r24, r25
    15e8:	09 f0       	breq	.+2      	; 0x15ec <_ZL5proc1Pv+0x136>
    15ea:	8d cf       	rjmp	.-230    	; 0x1506 <_ZL5proc1Pv+0x50>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    15ec:	53 96       	adiw	r26, 0x13	; 19
    15ee:	5c 92       	st	X, r5
    15f0:	4e 92       	st	-X, r4
    15f2:	52 97       	sbiw	r26, 0x12	; 18
    15f4:	88 cf       	rjmp	.-240    	; 0x1506 <_ZL5proc1Pv+0x50>
				}
			}
			else
			{
				cbi(PORTB,7);
    15f6:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    15f8:	46 e0       	ldi	r20, 0x06	; 6
    15fa:	61 e0       	ldi	r22, 0x01	; 1
    15fc:	81 e4       	ldi	r24, 0x41	; 65
    15fe:	94 e0       	ldi	r25, 0x04	; 4
    1600:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    1604:	45 e0       	ldi	r20, 0x05	; 5
    1606:	50 e0       	ldi	r21, 0x00	; 0
    1608:	61 e4       	ldi	r22, 0x41	; 65
    160a:	74 e0       	ldi	r23, 0x04	; 4
    160c:	c6 01       	movw	r24, r12
    160e:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    1612:	f4 01       	movw	r30, r8
    1614:	80 81       	ld	r24, Z
    1616:	8f 77       	andi	r24, 0x7F	; 127
    1618:	80 83       	st	Z, r24
				sb->SerialFlush();
    161a:	c6 01       	movw	r24, r12
    161c:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    1620:	d4 01       	movw	r26, r8
    1622:	8c 91       	ld	r24, X
    1624:	80 68       	ori	r24, 0x80	; 128
    1626:	8c 93       	st	X, r24
				sbi(PORTB,7);
    1628:	c7 9a       	sbi	0x18, 7	; 24
    162a:	6d cf       	rjmp	.-294    	; 0x1506 <_ZL5proc1Pv+0x50>

0000162c <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    162c:	cf 93       	push	r28
    162e:	df 93       	push	r29
    1630:	cd b7       	in	r28, 0x3d	; 61
    1632:	de b7       	in	r29, 0x3e	; 62
    1634:	2a 97       	sbiw	r28, 0x0a	; 10
    1636:	0f b6       	in	r0, 0x3f	; 63
    1638:	f8 94       	cli
    163a:	de bf       	out	0x3e, r29	; 62
    163c:	0f be       	out	0x3f, r0	; 63
    163e:	cd bf       	out	0x3d, r28	; 61
    1640:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    1642:	d1 2c       	mov	r13, r1
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1644:	07 ee       	ldi	r16, 0xE7	; 231
    1646:	13 e0       	ldi	r17, 0x03	; 3
			chatter_flag = 2;
    1648:	68 94       	set
    164a:	77 24       	eor	r7, r7
    164c:	71 f8       	bld	r7, 1
    164e:	4e 01       	movw	r8, r28
    1650:	8c e0       	ldi	r24, 0x0C	; 12
    1652:	88 0e       	add	r8, r24
    1654:	91 1c       	adc	r9, r1
    1656:	68 94       	set
    1658:	33 24       	eor	r3, r3
    165a:	34 f8       	bld	r3, 4
    165c:	66 24       	eor	r6, r6
    165e:	63 94       	inc	r6
    1660:	5e 01       	movw	r10, r28
    1662:	e9 e0       	ldi	r30, 0x09	; 9
    1664:	ae 0e       	add	r10, r30
    1666:	b1 1c       	adc	r11, r1
    1668:	0f 2e       	mov	r0, r31
    166a:	f5 e0       	ldi	r31, 0x05	; 5
    166c:	4f 2e       	mov	r4, r31
    166e:	f0 2d       	mov	r31, r0
    1670:	68 94       	set
    1672:	55 24       	eor	r5, r5
    1674:	52 f8       	bld	r5, 2
    1676:	0e c0       	rjmp	.+28     	; 0x1694 <_ZL4procPv+0x68>
    1678:	c6 2c       	mov	r12, r6
    167a:	d6 2c       	mov	r13, r6
    167c:	0b c0       	rjmp	.+22     	; 0x1694 <_ZL4procPv+0x68>
    167e:	c6 2c       	mov	r12, r6
    1680:	d6 2c       	mov	r13, r6
    1682:	08 c0       	rjmp	.+16     	; 0x1694 <_ZL4procPv+0x68>
    1684:	c5 2c       	mov	r12, r5
    1686:	d6 2c       	mov	r13, r6
    1688:	05 c0       	rjmp	.+10     	; 0x1694 <_ZL4procPv+0x68>
    168a:	c4 2c       	mov	r12, r4
    168c:	d6 2c       	mov	r13, r6
    168e:	02 c0       	rjmp	.+4      	; 0x1694 <_ZL4procPv+0x68>
    1690:	c3 2c       	mov	r12, r3
    1692:	d6 2c       	mov	r13, r6
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    1694:	80 b3       	in	r24, 0x10	; 16
    1696:	8e 3f       	cpi	r24, 0xFE	; 254
    1698:	29 f4       	brne	.+10     	; 0x16a4 <_ZL4procPv+0x78>
    169a:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <chatter_flag>
    169e:	81 30       	cpi	r24, 0x01	; 1
    16a0:	09 f4       	brne	.+2      	; 0x16a4 <_ZL4procPv+0x78>
    16a2:	e1 c0       	rjmp	.+450    	; 0x1866 <_ZL4procPv+0x23a>
		{
			mem4[COUNT]++;                // Remove Chattering 
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
    16a4:	80 b3       	in	r24, 0x10	; 16
    16a6:	8f 3f       	cpi	r24, 0xFF	; 255
    16a8:	29 f4       	brne	.+10     	; 0x16b4 <_ZL4procPv+0x88>
    16aa:	80 91 e2 03 	lds	r24, 0x03E2	; 0x8003e2 <chatter_flag>
    16ae:	82 30       	cpi	r24, 0x02	; 2
    16b0:	09 f4       	brne	.+2      	; 0x16b4 <_ZL4procPv+0x88>
    16b2:	e5 c0       	rjmp	.+458    	; 0x187e <_ZL4procPv+0x252>
		{
			vTaskDelay(20);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    16b4:	f8 01       	movw	r30, r16
    16b6:	84 85       	ldd	r24, Z+12	; 0x0c
    16b8:	95 85       	ldd	r25, Z+13	; 0x0d
    16ba:	cc 97       	sbiw	r24, 0x3c	; 60
    16bc:	9c f0       	brlt	.+38     	; 0x16e4 <_ZL4procPv+0xb8>
		{
			mem4[SEC] = 0;
    16be:	15 86       	std	Z+13, r1	; 0x0d
    16c0:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    16c2:	82 85       	ldd	r24, Z+10	; 0x0a
    16c4:	93 85       	ldd	r25, Z+11	; 0x0b
    16c6:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    16c8:	8c 33       	cpi	r24, 0x3C	; 60
    16ca:	91 05       	cpc	r25, r1
    16cc:	1c f4       	brge	.+6      	; 0x16d4 <_ZL4procPv+0xa8>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    16ce:	93 87       	std	Z+11, r25	; 0x0b
    16d0:	82 87       	std	Z+10, r24	; 0x0a
    16d2:	08 c0       	rjmp	.+16     	; 0x16e4 <_ZL4procPv+0xb8>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    16d4:	f8 01       	movw	r30, r16
    16d6:	13 86       	std	Z+11, r1	; 0x0b
    16d8:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    16da:	80 85       	ldd	r24, Z+8	; 0x08
    16dc:	91 85       	ldd	r25, Z+9	; 0x09
    16de:	01 96       	adiw	r24, 0x01	; 1
    16e0:	91 87       	std	Z+9, r25	; 0x09
    16e2:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    16e4:	d1 10       	cpse	r13, r1
    16e6:	2c c0       	rjmp	.+88     	; 0x1740 <_ZL4procPv+0x114>
		{
			if(sb->SerialAvailable() >= 2)
    16e8:	c7 01       	movw	r24, r14
    16ea:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    16ee:	82 30       	cpi	r24, 0x02	; 2
    16f0:	88 f2       	brcs	.-94     	; 0x1694 <_ZL4procPv+0x68>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    16f2:	c7 01       	movw	r24, r14
    16f4:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    16f8:	89 83       	std	Y+1, r24	; 0x01
    16fa:	c7 01       	movw	r24, r14
    16fc:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1700:	8a 83       	std	Y+2, r24	; 0x02
				}
				if(buf1[0] != 0x01)
				{
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    1702:	81 30       	cpi	r24, 0x01	; 1
    1704:	11 f1       	breq	.+68     	; 0x174a <_ZL4procPv+0x11e>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    1706:	84 30       	cpi	r24, 0x04	; 4
    1708:	b9 f1       	breq	.+110    	; 0x1778 <_ZL4procPv+0x14c>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    170a:	85 30       	cpi	r24, 0x05	; 5
    170c:	09 f4       	brne	.+2      	; 0x1710 <_ZL4procPv+0xe4>
    170e:	5b c0       	rjmp	.+182    	; 0x17c6 <_ZL4procPv+0x19a>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1710:	80 31       	cpi	r24, 0x10	; 16
    1712:	09 f4       	brne	.+2      	; 0x1716 <_ZL4procPv+0xea>
    1714:	7e c0       	rjmp	.+252    	; 0x1812 <_ZL4procPv+0x1e6>
				else
				{
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    1716:	46 2d       	mov	r20, r6
    1718:	66 2d       	mov	r22, r6
    171a:	81 e4       	ldi	r24, 0x41	; 65
    171c:	94 e0       	ldi	r25, 0x04	; 4
    171e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    1722:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);                                                                                                                                                                                                                
    1724:	57 98       	cbi	0x0a, 7	; 10
					sb->SerialFlush();
    1726:	c7 01       	movw	r24, r14
    1728:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
					sbi(UCSR0B,RXCIE0);
    172c:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    172e:	45 e0       	ldi	r20, 0x05	; 5
    1730:	50 e0       	ldi	r21, 0x00	; 0
    1732:	61 e4       	ldi	r22, 0x41	; 65
    1734:	74 e0       	ldi	r23, 0x04	; 4
    1736:	c7 01       	movw	r24, r14
    1738:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    173c:	c7 9a       	sbi	0x18, 7	; 24
    173e:	aa cf       	rjmp	.-172    	; 0x1694 <_ZL4procPv+0x68>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1740:	f1 e0       	ldi	r31, 0x01	; 1
    1742:	df 12       	cpse	r13, r31
    1744:	a7 cf       	rjmp	.-178    	; 0x1694 <_ZL4procPv+0x68>
		{
			if(function_code == 0x01)  
    1746:	cf 12       	cpse	r12, r31
    1748:	14 c0       	rjmp	.+40     	; 0x1772 <_ZL4procPv+0x146>
			{
				if(sb->SerialAvailable() >= 6)
    174a:	c7 01       	movw	r24, r14
    174c:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1750:	86 30       	cpi	r24, 0x06	; 6
    1752:	08 f4       	brcc	.+2      	; 0x1756 <_ZL4procPv+0x12a>
    1754:	91 cf       	rjmp	.-222    	; 0x1678 <_ZL4procPv+0x4c>
    1756:	6e 01       	movw	r12, r28
    1758:	83 e0       	ldi	r24, 0x03	; 3
    175a:	c8 0e       	add	r12, r24
    175c:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    175e:	c7 01       	movw	r24, r14
    1760:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1764:	f6 01       	movw	r30, r12
    1766:	81 93       	st	Z+, r24
    1768:	6f 01       	movw	r12, r30
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    176a:	ae 16       	cp	r10, r30
    176c:	bf 06       	cpc	r11, r31
    176e:	b9 f7       	brne	.-18     	; 0x175e <_ZL4procPv+0x132>
    1770:	86 cf       	rjmp	.-244    	; 0x167e <_ZL4procPv+0x52>
						buf1[i] = sb->SerialRead();
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1772:	f4 e0       	ldi	r31, 0x04	; 4
    1774:	cf 12       	cpse	r12, r31
    1776:	24 c0       	rjmp	.+72     	; 0x17c0 <_ZL4procPv+0x194>
			{
				if(sb->SerialAvailable() >= 6)
    1778:	c7 01       	movw	r24, r14
    177a:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    177e:	86 30       	cpi	r24, 0x06	; 6
    1780:	08 f4       	brcc	.+2      	; 0x1784 <_ZL4procPv+0x158>
    1782:	80 cf       	rjmp	.-256    	; 0x1684 <_ZL4procPv+0x58>
    1784:	6e 01       	movw	r12, r28
    1786:	83 e0       	ldi	r24, 0x03	; 3
    1788:	c8 0e       	add	r12, r24
    178a:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    178c:	c7 01       	movw	r24, r14
    178e:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1792:	f6 01       	movw	r30, r12
    1794:	81 93       	st	Z+, r24
    1796:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1798:	ea 15       	cp	r30, r10
    179a:	fb 05       	cpc	r31, r11
    179c:	b9 f7       	brne	.-18     	; 0x178c <_ZL4procPv+0x160>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc04Data(buf1,&func04,mem4);
    179e:	a8 01       	movw	r20, r16
    17a0:	61 e5       	ldi	r22, 0x51	; 81
    17a2:	74 e0       	ldi	r23, 0x04	; 4
    17a4:	ce 01       	movw	r24, r28
    17a6:	01 96       	adiw	r24, 0x01	; 1
    17a8:	0e 94 82 00 	call	0x104	; 0x104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
					sb->SerialWrite((char*)&func04,sizeof(func04));
    17ac:	47 e0       	ldi	r20, 0x07	; 7
    17ae:	50 e0       	ldi	r21, 0x00	; 0
    17b0:	61 e5       	ldi	r22, 0x51	; 81
    17b2:	74 e0       	ldi	r23, 0x04	; 4
    17b4:	c7 01       	movw	r24, r14
    17b6:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    17ba:	c5 2c       	mov	r12, r5
					read_Flag = 0;
    17bc:	d1 2c       	mov	r13, r1
    17be:	6a cf       	rjmp	.-300    	; 0x1694 <_ZL4procPv+0x68>
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    17c0:	f5 e0       	ldi	r31, 0x05	; 5
    17c2:	cf 12       	cpse	r12, r31
    17c4:	23 c0       	rjmp	.+70     	; 0x180c <_ZL4procPv+0x1e0>
			{
				if(sb->SerialAvailable() >= 6)
    17c6:	c7 01       	movw	r24, r14
    17c8:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    17cc:	86 30       	cpi	r24, 0x06	; 6
    17ce:	08 f4       	brcc	.+2      	; 0x17d2 <_ZL4procPv+0x1a6>
    17d0:	5c cf       	rjmp	.-328    	; 0x168a <_ZL4procPv+0x5e>
    17d2:	6e 01       	movw	r12, r28
    17d4:	83 e0       	ldi	r24, 0x03	; 3
    17d6:	c8 0e       	add	r12, r24
    17d8:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    17da:	c7 01       	movw	r24, r14
    17dc:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    17e0:	f6 01       	movw	r30, r12
    17e2:	81 93       	st	Z+, r24
    17e4:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    17e6:	ae 16       	cp	r10, r30
    17e8:	bf 06       	cpc	r11, r31
    17ea:	b9 f7       	brne	.-18     	; 0x17da <_ZL4procPv+0x1ae>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc05Data(buf1,&func05);
    17ec:	68 e5       	ldi	r22, 0x58	; 88
    17ee:	74 e0       	ldi	r23, 0x04	; 4
    17f0:	ce 01       	movw	r24, r28
    17f2:	01 96       	adiw	r24, 0x01	; 1
    17f4:	0e 94 a3 00 	call	0x146	; 0x146 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    17f8:	48 e0       	ldi	r20, 0x08	; 8
    17fa:	50 e0       	ldi	r21, 0x00	; 0
    17fc:	68 e5       	ldi	r22, 0x58	; 88
    17fe:	74 e0       	ldi	r23, 0x04	; 4
    1800:	c7 01       	movw	r24, r14
    1802:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1806:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    1808:	d1 2c       	mov	r13, r1
    180a:	44 cf       	rjmp	.-376    	; 0x1694 <_ZL4procPv+0x68>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    180c:	f0 e1       	ldi	r31, 0x10	; 16
    180e:	cf 12       	cpse	r12, r31
    1810:	41 cf       	rjmp	.-382    	; 0x1694 <_ZL4procPv+0x68>
			{
				if(sb->SerialAvailable() >= 9)
    1812:	c7 01       	movw	r24, r14
    1814:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1818:	89 30       	cpi	r24, 0x09	; 9
    181a:	08 f4       	brcc	.+2      	; 0x181e <_ZL4procPv+0x1f2>
    181c:	39 cf       	rjmp	.-398    	; 0x1690 <_ZL4procPv+0x64>
    181e:	6e 01       	movw	r12, r28
    1820:	83 e0       	ldi	r24, 0x03	; 3
    1822:	c8 0e       	add	r12, r24
    1824:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    1826:	c7 01       	movw	r24, r14
    1828:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    182c:	f6 01       	movw	r30, r12
    182e:	81 93       	st	Z+, r24
    1830:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    1832:	8e 16       	cp	r8, r30
    1834:	9f 06       	cpc	r9, r31
    1836:	b9 f7       	brne	.-18     	; 0x1826 <_ZL4procPv+0x1fa>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1838:	a8 01       	movw	r20, r16
    183a:	66 e4       	ldi	r22, 0x46	; 70
    183c:	74 e0       	ldi	r23, 0x04	; 4
    183e:	ce 01       	movw	r24, r28
    1840:	01 96       	adiw	r24, 0x01	; 1
    1842:	0e 94 bc 00 	call	0x178	; 0x178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1846:	69 e3       	ldi	r22, 0x39	; 57
    1848:	74 e0       	ldi	r23, 0x04	; 4
    184a:	ce 01       	movw	r24, r28
    184c:	01 96       	adiw	r24, 0x01	; 1
    184e:	0e 94 e6 00 	call	0x1cc	; 0x1cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    1852:	48 e0       	ldi	r20, 0x08	; 8
    1854:	50 e0       	ldi	r21, 0x00	; 0
    1856:	69 e3       	ldi	r22, 0x39	; 57
    1858:	74 e0       	ldi	r23, 0x04	; 4
    185a:	c7 01       	movw	r24, r14
    185c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1860:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    1862:	d1 2c       	mov	r13, r1
    1864:	17 cf       	rjmp	.-466    	; 0x1694 <_ZL4procPv+0x68>
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1866:	f8 01       	movw	r30, r16
    1868:	86 81       	ldd	r24, Z+6	; 0x06
    186a:	97 81       	ldd	r25, Z+7	; 0x07
    186c:	01 96       	adiw	r24, 0x01	; 1
    186e:	97 83       	std	Z+7, r25	; 0x07
    1870:	86 83       	std	Z+6, r24	; 0x06
			chatter_flag = 2;
    1872:	70 92 e2 03 	sts	0x03E2, r7	; 0x8003e2 <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    1876:	80 b3       	in	r24, 0x10	; 16
    1878:	8f 3f       	cpi	r24, 0xFF	; 255
    187a:	09 f0       	breq	.+2      	; 0x187e <_ZL4procPv+0x252>
    187c:	1b cf       	rjmp	.-458    	; 0x16b4 <_ZL4procPv+0x88>
		{
			vTaskDelay(20);
    187e:	84 e1       	ldi	r24, 0x14	; 20
    1880:	90 e0       	ldi	r25, 0x00	; 0
    1882:	0e 94 f3 14 	call	0x29e6	; 0x29e6 <vTaskDelay>
			chatter_flag = 0;
    1886:	10 92 e2 03 	sts	0x03E2, r1	; 0x8003e2 <chatter_flag>
    188a:	14 cf       	rjmp	.-472    	; 0x16b4 <_ZL4procPv+0x88>

0000188c <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    188c:	80 91 60 04 	lds	r24, 0x0460	; 0x800460 <DataStruct>
    1890:	90 91 61 04 	lds	r25, 0x0461	; 0x800461 <DataStruct+0x1>
    1894:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    1898:	c5 9a       	sbi	0x18, 5	; 24
    189a:	08 95       	ret

0000189c <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    189c:	80 91 62 04 	lds	r24, 0x0462	; 0x800462 <DataStruct+0x2>
    18a0:	90 91 63 04 	lds	r25, 0x0463	; 0x800463 <DataStruct+0x3>
    18a4:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    18a8:	c6 9a       	sbi	0x18, 6	; 24
    18aa:	08 95       	ret

000018ac <_Z16Count_Sensor_ISR8Dev_typej>:
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,20,Set_Alarm);
    18ac:	4f ea       	ldi	r20, 0xAF	; 175
    18ae:	58 e0       	ldi	r21, 0x08	; 8
    18b0:	64 e1       	ldi	r22, 0x14	; 20
    18b2:	70 e0       	ldi	r23, 0x00	; 0
    18b4:	80 e0       	ldi	r24, 0x00	; 0
    18b6:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <Alarm_Open>
    18ba:	08 95       	ret

000018bc <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    18bc:	cf 93       	push	r28
    18be:	df 93       	push	r29
	dev = new Dev_Manager();
    18c0:	80 e1       	ldi	r24, 0x10	; 16
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	0e 94 9a 02 	call	0x534	; 0x534 <_ZN11Dev_ManagernwEj>
    18c8:	ec 01       	movw	r28, r24
    18ca:	0e 94 67 02 	call	0x4ce	; 0x4ce <_ZN11Dev_ManagerC1Ev>
    18ce:	d0 93 69 04 	sts	0x0469, r29	; 0x800469 <dev+0x1>
    18d2:	c0 93 68 04 	sts	0x0468, r28	; 0x800468 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    18d6:	88 e0       	ldi	r24, 0x08	; 8
    18d8:	90 e0       	ldi	r25, 0x00	; 0
    18da:	3e d8       	rcall	.-3972   	; 0x958 <_ZN10UartDrivernwEj>
    18dc:	ec 01       	movw	r28, r24
    18de:	28 d8       	rcall	.-4016   	; 0x930 <_ZN10UartDriverC1Ev>
    18e0:	40 e0       	ldi	r20, 0x00	; 0
    18e2:	be 01       	movw	r22, r28
    18e4:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    18e8:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    18ec:	0e 94 91 02 	call	0x522	; 0x522 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    18f0:	88 e0       	ldi	r24, 0x08	; 8
    18f2:	90 e0       	ldi	r25, 0x00	; 0
    18f4:	0e 94 09 04 	call	0x812	; 0x812 <_ZN11RS485DrivernwEj>
    18f8:	ec 01       	movw	r28, r24
    18fa:	0e 94 f5 03 	call	0x7ea	; 0x7ea <_ZN11RS485DriverC1Ev>
    18fe:	41 e0       	ldi	r20, 0x01	; 1
    1900:	be 01       	movw	r22, r28
    1902:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1906:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    190a:	0e 94 91 02 	call	0x522	; 0x522 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    190e:	82 e0       	ldi	r24, 0x02	; 2
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <_ZN5TimernwEj>
    1916:	ec 01       	movw	r28, r24
    1918:	0e 94 cb 03 	call	0x796	; 0x796 <_ZN5TimerC1Ev>
    191c:	42 e0       	ldi	r20, 0x02	; 2
    191e:	be 01       	movw	r22, r28
    1920:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1924:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1928:	0e 94 91 02 	call	0x522	; 0x522 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    192c:	82 e0       	ldi	r24, 0x02	; 2
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	0e 94 64 02 	call	0x4c8	; 0x4c8 <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    1934:	2b e0       	ldi	r18, 0x0B	; 11
    1936:	31 e0       	ldi	r19, 0x01	; 1
    1938:	fc 01       	movw	r30, r24
    193a:	31 83       	std	Z+1, r19	; 0x01
    193c:	20 83       	st	Z, r18
    193e:	43 e0       	ldi	r20, 0x03	; 3
    1940:	bc 01       	movw	r22, r24
    1942:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1946:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    194a:	0e 94 91 02 	call	0x522	; 0x522 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Device_Init(UART0);
    194e:	60 e0       	ldi	r22, 0x00	; 0
    1950:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1954:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1958:	0e 94 c5 02 	call	0x58a	; 0x58a <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    195c:	61 e0       	ldi	r22, 0x01	; 1
    195e:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1962:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1966:	0e 94 c5 02 	call	0x58a	; 0x58a <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    196a:	62 e0       	ldi	r22, 0x02	; 2
    196c:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1970:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1974:	0e 94 c5 02 	call	0x58a	; 0x58a <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    1978:	63 e0       	ldi	r22, 0x03	; 3
    197a:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    197e:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1982:	0e 94 c5 02 	call	0x58a	; 0x58a <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    1986:	47 e3       	ldi	r20, 0x37	; 55
    1988:	51 e0       	ldi	r21, 0x01	; 1
    198a:	60 e0       	ldi	r22, 0x00	; 0
    198c:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1990:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1994:	0e 94 b1 02 	call	0x562	; 0x562 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1998:	4d e5       	ldi	r20, 0x5D	; 93
    199a:	51 e0       	ldi	r21, 0x01	; 1
    199c:	61 e0       	ldi	r22, 0x01	; 1
    199e:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    19a2:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    19a6:	0e 94 b1 02 	call	0x562	; 0x562 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    19aa:	df 91       	pop	r29
    19ac:	cf 91       	pop	r28
    19ae:	08 95       	ret

000019b0 <main>:

uint8_t chatter_flag = 0; //채터링 방지 플래그 변수
//uint8_t use_external_count_sensor = 0; // 0 PLC  1 EXTERNAL COUTN SENSOR

int main( void )
{
    19b0:	cf 92       	push	r12
    19b2:	df 92       	push	r13
    19b4:	ef 92       	push	r14
    19b6:	ff 92       	push	r15
    19b8:	0f 93       	push	r16
    19ba:	cf 93       	push	r28
    19bc:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	90 e0       	ldi	r25, 0x00	; 0
    19c2:	0e 94 55 18 	call	0x30aa	; 0x30aa <eeprom_read_byte>
    19c6:	d8 2e       	mov	r13, r24
    19c8:	90 e0       	ldi	r25, 0x00	; 0
    19ca:	90 93 28 04 	sts	0x0428, r25	; 0x800428 <mem4+0x41>
    19ce:	80 93 27 04 	sts	0x0427, r24	; 0x800427 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    19d2:	81 e0       	ldi	r24, 0x01	; 1
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	0e 94 55 18 	call	0x30aa	; 0x30aa <eeprom_read_byte>
    19da:	d8 2f       	mov	r29, r24
    19dc:	90 e0       	ldi	r25, 0x00	; 0
    19de:	90 93 2a 04 	sts	0x042A, r25	; 0x80042a <mem4+0x43>
    19e2:	80 93 29 04 	sts	0x0429, r24	; 0x800429 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    19e6:	82 e0       	ldi	r24, 0x02	; 2
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	0e 94 55 18 	call	0x30aa	; 0x30aa <eeprom_read_byte>
    19ee:	c8 2f       	mov	r28, r24
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	90 93 2c 04 	sts	0x042C, r25	; 0x80042c <mem4+0x45>
    19f6:	80 93 2b 04 	sts	0x042B, r24	; 0x80042b <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    19fa:	83 e0       	ldi	r24, 0x03	; 3
    19fc:	90 e0       	ldi	r25, 0x00	; 0
    19fe:	0e 94 55 18 	call	0x30aa	; 0x30aa <eeprom_read_byte>
    1a02:	28 2f       	mov	r18, r24
    1a04:	30 e0       	ldi	r19, 0x00	; 0
    1a06:	30 93 2e 04 	sts	0x042E, r19	; 0x80042e <mem4+0x47>
    1a0a:	20 93 2d 04 	sts	0x042D, r18	; 0x80042d <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    1a0e:	e3 ee       	ldi	r30, 0xE3	; 227
    1a10:	f3 e0       	ldi	r31, 0x03	; 3
    1a12:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    1a14:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    1a16:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    1a18:	83 83       	std	Z+3, r24	; 0x03

int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1a1a:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1a1c:	4f df       	rcall	.-354    	; 0x18bc <_Z8Init_Devv>
    1a1e:	46 e4       	ldi	r20, 0x46	; 70
    1a20:	5c e0       	ldi	r21, 0x0C	; 12
    1a22:	60 e0       	ldi	r22, 0x00	; 0
    1a24:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1a28:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1a2c:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1a30:	4e e4       	ldi	r20, 0x4E	; 78
    1a32:	5c e0       	ldi	r21, 0x0C	; 12
    1a34:	61 e0       	ldi	r22, 0x01	; 1
    1a36:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1a3a:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1a3e:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    1a42:	45 ea       	ldi	r20, 0xA5	; 165
    1a44:	58 e0       	ldi	r21, 0x08	; 8
    1a46:	62 e0       	ldi	r22, 0x02	; 2
    1a48:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1a4c:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1a50:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    1a54:	46 e5       	ldi	r20, 0x56	; 86
    1a56:	5c e0       	ldi	r21, 0x0C	; 12
    1a58:	63 e0       	ldi	r22, 0x03	; 3
    1a5a:	80 91 68 04 	lds	r24, 0x0468	; 0x800468 <dev>
    1a5e:	90 91 69 04 	lds	r25, 0x0469	; 0x800469 <dev+0x1>
    1a62:	0e 94 d7 02 	call	0x5ae	; 0x5ae <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    1a66:	88 e8       	ldi	r24, 0x88	; 136
    1a68:	90 e0       	ldi	r25, 0x00	; 0
    1a6a:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1a6e:	6c 01       	movw	r12, r24
    1a70:	60 91 68 04 	lds	r22, 0x0468	; 0x800468 <dev>
    1a74:	70 91 69 04 	lds	r23, 0x0469	; 0x800469 <dev+0x1>
    1a78:	40 e0       	ldi	r20, 0x00	; 0
    1a7a:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1a7e:	c1 14       	cp	r12, r1
    1a80:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1a82:	21 f4       	brne	.+8      	; 0x1a8c <main+0xdc>
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	90 e0       	ldi	r25, 0x00	; 0
    1a88:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1a8c:	88 e8       	ldi	r24, 0x88	; 136
    1a8e:	90 e0       	ldi	r25, 0x00	; 0
    1a90:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1a94:	ec 01       	movw	r28, r24
    1a96:	60 91 68 04 	lds	r22, 0x0468	; 0x800468 <dev>
    1a9a:	70 91 69 04 	lds	r23, 0x0469	; 0x800469 <dev+0x1>
    1a9e:	41 e0       	ldi	r20, 0x01	; 1
    1aa0:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    1aa4:	20 97       	sbiw	r28, 0x00	; 0
	{
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1aa6:	21 f4       	brne	.+8      	; 0x1ab0 <main+0x100>
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	90 e0       	ldi	r25, 0x00	; 0
    1aac:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    1ab0:	e0 e6       	ldi	r30, 0x60	; 96
    1ab2:	f4 e0       	ldi	r31, 0x04	; 4
    1ab4:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    1ab6:	c0 82       	st	Z, r12
    1ab8:	d3 83       	std	Z+3, r29	; 0x03
				else if(i == RS485)
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			}
		}
	}
	Alarm_Init(); //알람 초기화
    1aba:	c2 83       	std	Z+2, r28	; 0x02
    1abc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Alarm_Init>
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1ac0:	78 94       	sei
    1ac2:	e1 2c       	mov	r14, r1
    1ac4:	f1 2c       	mov	r15, r1
    1ac6:	02 e0       	ldi	r16, 0x02	; 2
    1ac8:	96 01       	movw	r18, r12
    1aca:	4e e5       	ldi	r20, 0x5E	; 94
    1acc:	51 e0       	ldi	r21, 0x01	; 1
    1ace:	64 e8       	ldi	r22, 0x84	; 132
    1ad0:	71 e0       	ldi	r23, 0x01	; 1
    1ad2:	86 e1       	ldi	r24, 0x16	; 22
    1ad4:	9b e0       	ldi	r25, 0x0B	; 11
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    1ad6:	2b d5       	rcall	.+2646   	; 0x252e <xTaskCreate>
    1ad8:	9e 01       	movw	r18, r28
    1ada:	4e e5       	ldi	r20, 0x5E	; 94
    1adc:	51 e0       	ldi	r21, 0x01	; 1
    1ade:	6a e8       	ldi	r22, 0x8A	; 138
    1ae0:	71 e0       	ldi	r23, 0x01	; 1
    1ae2:	8b e5       	ldi	r24, 0x5B	; 91
    1ae4:	9a e0       	ldi	r25, 0x0A	; 10
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    1ae6:	23 d5       	rcall	.+2630   	; 0x252e <xTaskCreate>
    1ae8:	20 e0       	ldi	r18, 0x00	; 0
    1aea:	30 e0       	ldi	r19, 0x00	; 0
    1aec:	40 ef       	ldi	r20, 0xF0	; 240
    1aee:	50 e0       	ldi	r21, 0x00	; 0
    1af0:	60 e9       	ldi	r22, 0x90	; 144
    1af2:	71 e0       	ldi	r23, 0x01	; 1
    1af4:	87 eb       	ldi	r24, 0xB7	; 183
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    1af6:	98 e0       	ldi	r25, 0x08	; 8
    1af8:	1a d5       	rcall	.+2612   	; 0x252e <xTaskCreate>
	return 0;
}
    1afa:	17 d6       	rcall	.+3118   	; 0x272a <vTaskStartScheduler>
    1afc:	80 e0       	ldi	r24, 0x00	; 0
    1afe:	90 e0       	ldi	r25, 0x00	; 0
    1b00:	df 91       	pop	r29
    1b02:	cf 91       	pop	r28
    1b04:	0f 91       	pop	r16
    1b06:	ff 90       	pop	r15
    1b08:	ef 90       	pop	r14
    1b0a:	df 90       	pop	r13
    1b0c:	cf 90       	pop	r12
    1b0e:	08 95       	ret

00001b10 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1b10:	08 95       	ret

00001b12 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1b12:	cf 93       	push	r28
    1b14:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1b16:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    1b18:	30 d6       	rcall	.+3168   	; 0x277a <vTaskSuspendAll>
    1b1a:	80 91 6a 04 	lds	r24, 0x046A	; 0x80046a <pucAlignedHeap.2069>
    1b1e:	90 91 6b 04 	lds	r25, 0x046B	; 0x80046b <pucAlignedHeap.2069+0x1>
    1b22:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1b24:	31 f4       	brne	.+12     	; 0x1b32 <pvPortMalloc+0x20>
    1b26:	8f e6       	ldi	r24, 0x6F	; 111
    1b28:	94 e0       	ldi	r25, 0x04	; 4
    1b2a:	90 93 6b 04 	sts	0x046B, r25	; 0x80046b <pucAlignedHeap.2069+0x1>
    1b2e:	80 93 6a 04 	sts	0x046A, r24	; 0x80046a <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1b32:	20 91 6c 04 	lds	r18, 0x046C	; 0x80046c <xNextFreeByte>
    1b36:	30 91 6d 04 	lds	r19, 0x046D	; 0x80046d <xNextFreeByte+0x1>
    1b3a:	c9 01       	movw	r24, r18
    1b3c:	8c 0f       	add	r24, r28
    1b3e:	9d 1f       	adc	r25, r29
    1b40:	8b 3f       	cpi	r24, 0xFB	; 251
    1b42:	48 e0       	ldi	r20, 0x08	; 8
    1b44:	94 07       	cpc	r25, r20
    1b46:	70 f4       	brcc	.+28     	; 0x1b64 <pvPortMalloc+0x52>
    1b48:	28 17       	cp	r18, r24
    1b4a:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1b4c:	70 f4       	brcc	.+28     	; 0x1b6a <pvPortMalloc+0x58>
    1b4e:	c0 91 6a 04 	lds	r28, 0x046A	; 0x80046a <pucAlignedHeap.2069>
    1b52:	d0 91 6b 04 	lds	r29, 0x046B	; 0x80046b <pucAlignedHeap.2069+0x1>
    1b56:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    1b58:	d3 1f       	adc	r29, r19
    1b5a:	90 93 6d 04 	sts	0x046D, r25	; 0x80046d <xNextFreeByte+0x1>
    1b5e:	80 93 6c 04 	sts	0x046C, r24	; 0x80046c <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1b62:	05 c0       	rjmp	.+10     	; 0x1b6e <pvPortMalloc+0x5c>
    1b64:	c0 e0       	ldi	r28, 0x00	; 0
    1b66:	d0 e0       	ldi	r29, 0x00	; 0
    1b68:	02 c0       	rjmp	.+4      	; 0x1b6e <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b6a:	c0 e0       	ldi	r28, 0x00	; 0
    1b6c:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1b6e:	c2 d6       	rcall	.+3460   	; 0x28f4 <xTaskResumeAll>
    1b70:	ce 01       	movw	r24, r28
    1b72:	df 91       	pop	r29
    1b74:	cf 91       	pop	r28
    1b76:	08 95       	ret

00001b78 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b78:	08 95       	ret

00001b7a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1b7a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b7c:	03 96       	adiw	r24, 0x03	; 3
    1b7e:	92 83       	std	Z+2, r25	; 0x02
    1b80:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1b82:	2f ef       	ldi	r18, 0xFF	; 255
    1b84:	3f ef       	ldi	r19, 0xFF	; 255
    1b86:	34 83       	std	Z+4, r19	; 0x04
    1b88:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b8a:	96 83       	std	Z+6, r25	; 0x06
    1b8c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1b8e:	90 87       	std	Z+8, r25	; 0x08
    1b90:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1b92:	10 82       	st	Z, r1
    1b94:	08 95       	ret

00001b96 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1b96:	fc 01       	movw	r30, r24
    1b98:	11 86       	std	Z+9, r1	; 0x09
    1b9a:	10 86       	std	Z+8, r1	; 0x08
    1b9c:	08 95       	ret

00001b9e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1b9e:	cf 93       	push	r28
    1ba0:	df 93       	push	r29
    1ba2:	9c 01       	movw	r18, r24
    1ba4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1ba6:	dc 01       	movw	r26, r24
    1ba8:	11 96       	adiw	r26, 0x01	; 1
    1baa:	cd 91       	ld	r28, X+
    1bac:	dc 91       	ld	r29, X
    1bae:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1bb0:	d3 83       	std	Z+3, r29	; 0x03
    1bb2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1bb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb6:	9d 81       	ldd	r25, Y+5	; 0x05
    1bb8:	95 83       	std	Z+5, r25	; 0x05
    1bba:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1bbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1bbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1bc0:	dc 01       	movw	r26, r24
    1bc2:	13 96       	adiw	r26, 0x03	; 3
    1bc4:	7c 93       	st	X, r23
    1bc6:	6e 93       	st	-X, r22
    1bc8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1bca:	7d 83       	std	Y+5, r23	; 0x05
    1bcc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1bce:	31 87       	std	Z+9, r19	; 0x09
    1bd0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1bd2:	f9 01       	movw	r30, r18
    1bd4:	80 81       	ld	r24, Z
    1bd6:	8f 5f       	subi	r24, 0xFF	; 255
    1bd8:	80 83       	st	Z, r24
}
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	08 95       	ret

00001be0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1be0:	cf 93       	push	r28
    1be2:	df 93       	push	r29
    1be4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1be6:	48 81       	ld	r20, Y
    1be8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1bea:	4f 3f       	cpi	r20, 0xFF	; 255
    1bec:	2f ef       	ldi	r18, 0xFF	; 255
    1bee:	52 07       	cpc	r21, r18
    1bf0:	21 f4       	brne	.+8      	; 0x1bfa <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1bf2:	fc 01       	movw	r30, r24
    1bf4:	a7 81       	ldd	r26, Z+7	; 0x07
    1bf6:	b0 85       	ldd	r27, Z+8	; 0x08
    1bf8:	0d c0       	rjmp	.+26     	; 0x1c14 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bfa:	dc 01       	movw	r26, r24
    1bfc:	13 96       	adiw	r26, 0x03	; 3
    1bfe:	01 c0       	rjmp	.+2      	; 0x1c02 <vListInsert+0x22>
    1c00:	df 01       	movw	r26, r30
    1c02:	12 96       	adiw	r26, 0x02	; 2
    1c04:	ed 91       	ld	r30, X+
    1c06:	fc 91       	ld	r31, X
    1c08:	13 97       	sbiw	r26, 0x03	; 3
    1c0a:	20 81       	ld	r18, Z
    1c0c:	31 81       	ldd	r19, Z+1	; 0x01
    1c0e:	42 17       	cp	r20, r18
    1c10:	53 07       	cpc	r21, r19
    1c12:	b0 f7       	brcc	.-20     	; 0x1c00 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c14:	12 96       	adiw	r26, 0x02	; 2
    1c16:	ed 91       	ld	r30, X+
    1c18:	fc 91       	ld	r31, X
    1c1a:	13 97       	sbiw	r26, 0x03	; 3
    1c1c:	fb 83       	std	Y+3, r31	; 0x03
    1c1e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c20:	d5 83       	std	Z+5, r29	; 0x05
    1c22:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c24:	bd 83       	std	Y+5, r27	; 0x05
    1c26:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c28:	13 96       	adiw	r26, 0x03	; 3
    1c2a:	dc 93       	st	X, r29
    1c2c:	ce 93       	st	-X, r28
    1c2e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c30:	99 87       	std	Y+9, r25	; 0x09
    1c32:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c34:	fc 01       	movw	r30, r24
    1c36:	20 81       	ld	r18, Z
    1c38:	2f 5f       	subi	r18, 0xFF	; 255
    1c3a:	20 83       	st	Z, r18
}
    1c3c:	df 91       	pop	r29
    1c3e:	cf 91       	pop	r28
    1c40:	08 95       	ret

00001c42 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1c42:	cf 93       	push	r28
    1c44:	df 93       	push	r29
    1c46:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1c48:	a0 85       	ldd	r26, Z+8	; 0x08
    1c4a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1c4c:	c2 81       	ldd	r28, Z+2	; 0x02
    1c4e:	d3 81       	ldd	r29, Z+3	; 0x03
    1c50:	84 81       	ldd	r24, Z+4	; 0x04
    1c52:	95 81       	ldd	r25, Z+5	; 0x05
    1c54:	9d 83       	std	Y+5, r25	; 0x05
    1c56:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1c58:	c4 81       	ldd	r28, Z+4	; 0x04
    1c5a:	d5 81       	ldd	r29, Z+5	; 0x05
    1c5c:	82 81       	ldd	r24, Z+2	; 0x02
    1c5e:	93 81       	ldd	r25, Z+3	; 0x03
    1c60:	9b 83       	std	Y+3, r25	; 0x03
    1c62:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1c64:	11 96       	adiw	r26, 0x01	; 1
    1c66:	8d 91       	ld	r24, X+
    1c68:	9c 91       	ld	r25, X
    1c6a:	12 97       	sbiw	r26, 0x02	; 2
    1c6c:	e8 17       	cp	r30, r24
    1c6e:	f9 07       	cpc	r31, r25
    1c70:	31 f4       	brne	.+12     	; 0x1c7e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1c72:	84 81       	ldd	r24, Z+4	; 0x04
    1c74:	95 81       	ldd	r25, Z+5	; 0x05
    1c76:	12 96       	adiw	r26, 0x02	; 2
    1c78:	9c 93       	st	X, r25
    1c7a:	8e 93       	st	-X, r24
    1c7c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1c7e:	11 86       	std	Z+9, r1	; 0x09
    1c80:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1c82:	8c 91       	ld	r24, X
    1c84:	81 50       	subi	r24, 0x01	; 1
    1c86:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1c88:	df 91       	pop	r29
    1c8a:	cf 91       	pop	r28
    1c8c:	08 95       	ret

00001c8e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1c8e:	31 e1       	ldi	r19, 0x11	; 17
    1c90:	fc 01       	movw	r30, r24
    1c92:	30 83       	st	Z, r19
    1c94:	31 97       	sbiw	r30, 0x01	; 1
    1c96:	22 e2       	ldi	r18, 0x22	; 34
    1c98:	20 83       	st	Z, r18
    1c9a:	31 97       	sbiw	r30, 0x01	; 1
    1c9c:	a3 e3       	ldi	r26, 0x33	; 51
    1c9e:	a0 83       	st	Z, r26
    1ca0:	31 97       	sbiw	r30, 0x01	; 1
    1ca2:	60 83       	st	Z, r22
    1ca4:	31 97       	sbiw	r30, 0x01	; 1
    1ca6:	70 83       	st	Z, r23
    1ca8:	31 97       	sbiw	r30, 0x01	; 1
    1caa:	10 82       	st	Z, r1
    1cac:	31 97       	sbiw	r30, 0x01	; 1
    1cae:	60 e8       	ldi	r22, 0x80	; 128
    1cb0:	60 83       	st	Z, r22
    1cb2:	31 97       	sbiw	r30, 0x01	; 1
    1cb4:	10 82       	st	Z, r1
    1cb6:	31 97       	sbiw	r30, 0x01	; 1
    1cb8:	62 e0       	ldi	r22, 0x02	; 2
    1cba:	60 83       	st	Z, r22
    1cbc:	31 97       	sbiw	r30, 0x01	; 1
    1cbe:	63 e0       	ldi	r22, 0x03	; 3
    1cc0:	60 83       	st	Z, r22
    1cc2:	31 97       	sbiw	r30, 0x01	; 1
    1cc4:	64 e0       	ldi	r22, 0x04	; 4
    1cc6:	60 83       	st	Z, r22
    1cc8:	31 97       	sbiw	r30, 0x01	; 1
    1cca:	65 e0       	ldi	r22, 0x05	; 5
    1ccc:	60 83       	st	Z, r22
    1cce:	31 97       	sbiw	r30, 0x01	; 1
    1cd0:	66 e0       	ldi	r22, 0x06	; 6
    1cd2:	60 83       	st	Z, r22
    1cd4:	31 97       	sbiw	r30, 0x01	; 1
    1cd6:	67 e0       	ldi	r22, 0x07	; 7
    1cd8:	60 83       	st	Z, r22
    1cda:	31 97       	sbiw	r30, 0x01	; 1
    1cdc:	68 e0       	ldi	r22, 0x08	; 8
    1cde:	60 83       	st	Z, r22
    1ce0:	31 97       	sbiw	r30, 0x01	; 1
    1ce2:	69 e0       	ldi	r22, 0x09	; 9
    1ce4:	60 83       	st	Z, r22
    1ce6:	31 97       	sbiw	r30, 0x01	; 1
    1ce8:	60 e1       	ldi	r22, 0x10	; 16
    1cea:	60 83       	st	Z, r22
    1cec:	31 97       	sbiw	r30, 0x01	; 1
    1cee:	30 83       	st	Z, r19
    1cf0:	31 97       	sbiw	r30, 0x01	; 1
    1cf2:	32 e1       	ldi	r19, 0x12	; 18
    1cf4:	30 83       	st	Z, r19
    1cf6:	31 97       	sbiw	r30, 0x01	; 1
    1cf8:	33 e1       	ldi	r19, 0x13	; 19
    1cfa:	30 83       	st	Z, r19
    1cfc:	31 97       	sbiw	r30, 0x01	; 1
    1cfe:	34 e1       	ldi	r19, 0x14	; 20
    1d00:	30 83       	st	Z, r19
    1d02:	31 97       	sbiw	r30, 0x01	; 1
    1d04:	35 e1       	ldi	r19, 0x15	; 21
    1d06:	30 83       	st	Z, r19
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	36 e1       	ldi	r19, 0x16	; 22
    1d0c:	30 83       	st	Z, r19
    1d0e:	31 97       	sbiw	r30, 0x01	; 1
    1d10:	37 e1       	ldi	r19, 0x17	; 23
    1d12:	30 83       	st	Z, r19
    1d14:	31 97       	sbiw	r30, 0x01	; 1
    1d16:	38 e1       	ldi	r19, 0x18	; 24
    1d18:	30 83       	st	Z, r19
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	39 e1       	ldi	r19, 0x19	; 25
    1d1e:	30 83       	st	Z, r19
    1d20:	31 97       	sbiw	r30, 0x01	; 1
    1d22:	30 e2       	ldi	r19, 0x20	; 32
    1d24:	30 83       	st	Z, r19
    1d26:	31 97       	sbiw	r30, 0x01	; 1
    1d28:	31 e2       	ldi	r19, 0x21	; 33
    1d2a:	30 83       	st	Z, r19
    1d2c:	31 97       	sbiw	r30, 0x01	; 1
    1d2e:	20 83       	st	Z, r18
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	23 e2       	ldi	r18, 0x23	; 35
    1d34:	20 83       	st	Z, r18
    1d36:	31 97       	sbiw	r30, 0x01	; 1
    1d38:	40 83       	st	Z, r20
    1d3a:	31 97       	sbiw	r30, 0x01	; 1
    1d3c:	50 83       	st	Z, r21
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	26 e2       	ldi	r18, 0x26	; 38
    1d42:	20 83       	st	Z, r18
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	27 e2       	ldi	r18, 0x27	; 39
    1d48:	20 83       	st	Z, r18
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	28 e2       	ldi	r18, 0x28	; 40
    1d4e:	20 83       	st	Z, r18
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	29 e2       	ldi	r18, 0x29	; 41
    1d54:	20 83       	st	Z, r18
    1d56:	31 97       	sbiw	r30, 0x01	; 1
    1d58:	20 e3       	ldi	r18, 0x30	; 48
    1d5a:	20 83       	st	Z, r18
    1d5c:	31 97       	sbiw	r30, 0x01	; 1
    1d5e:	21 e3       	ldi	r18, 0x31	; 49
    1d60:	20 83       	st	Z, r18
    1d62:	86 97       	sbiw	r24, 0x26	; 38
    1d64:	08 95       	ret

00001d66 <xPortStartScheduler>:
    1d66:	1b bc       	out	0x2b, r1	; 43
    1d68:	89 ef       	ldi	r24, 0xF9	; 249
    1d6a:	8a bd       	out	0x2a, r24	; 42
    1d6c:	8b e0       	ldi	r24, 0x0B	; 11
    1d6e:	8e bd       	out	0x2e, r24	; 46
    1d70:	87 b7       	in	r24, 0x37	; 55
    1d72:	80 61       	ori	r24, 0x10	; 16
    1d74:	87 bf       	out	0x37, r24	; 55
    1d76:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    1d7a:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    1d7e:	cd 91       	ld	r28, X+
    1d80:	cd bf       	out	0x3d, r28	; 61
    1d82:	dd 91       	ld	r29, X+
    1d84:	de bf       	out	0x3e, r29	; 62
    1d86:	ff 91       	pop	r31
    1d88:	ef 91       	pop	r30
    1d8a:	df 91       	pop	r29
    1d8c:	cf 91       	pop	r28
    1d8e:	bf 91       	pop	r27
    1d90:	af 91       	pop	r26
    1d92:	9f 91       	pop	r25
    1d94:	8f 91       	pop	r24
    1d96:	7f 91       	pop	r23
    1d98:	6f 91       	pop	r22
    1d9a:	5f 91       	pop	r21
    1d9c:	4f 91       	pop	r20
    1d9e:	3f 91       	pop	r19
    1da0:	2f 91       	pop	r18
    1da2:	1f 91       	pop	r17
    1da4:	0f 91       	pop	r16
    1da6:	ff 90       	pop	r15
    1da8:	ef 90       	pop	r14
    1daa:	df 90       	pop	r13
    1dac:	cf 90       	pop	r12
    1dae:	bf 90       	pop	r11
    1db0:	af 90       	pop	r10
    1db2:	9f 90       	pop	r9
    1db4:	8f 90       	pop	r8
    1db6:	7f 90       	pop	r7
    1db8:	6f 90       	pop	r6
    1dba:	5f 90       	pop	r5
    1dbc:	4f 90       	pop	r4
    1dbe:	3f 90       	pop	r3
    1dc0:	2f 90       	pop	r2
    1dc2:	1f 90       	pop	r1
    1dc4:	0f 90       	pop	r0
    1dc6:	0f be       	out	0x3f, r0	; 63
    1dc8:	0f 90       	pop	r0
    1dca:	08 95       	ret
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	08 95       	ret

00001dd0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1dd0:	0f 92       	push	r0
    1dd2:	0f b6       	in	r0, 0x3f	; 63
    1dd4:	f8 94       	cli
    1dd6:	0f 92       	push	r0
    1dd8:	1f 92       	push	r1
    1dda:	11 24       	eor	r1, r1
    1ddc:	2f 92       	push	r2
    1dde:	3f 92       	push	r3
    1de0:	4f 92       	push	r4
    1de2:	5f 92       	push	r5
    1de4:	6f 92       	push	r6
    1de6:	7f 92       	push	r7
    1de8:	8f 92       	push	r8
    1dea:	9f 92       	push	r9
    1dec:	af 92       	push	r10
    1dee:	bf 92       	push	r11
    1df0:	cf 92       	push	r12
    1df2:	df 92       	push	r13
    1df4:	ef 92       	push	r14
    1df6:	ff 92       	push	r15
    1df8:	0f 93       	push	r16
    1dfa:	1f 93       	push	r17
    1dfc:	2f 93       	push	r18
    1dfe:	3f 93       	push	r19
    1e00:	4f 93       	push	r20
    1e02:	5f 93       	push	r21
    1e04:	6f 93       	push	r22
    1e06:	7f 93       	push	r23
    1e08:	8f 93       	push	r24
    1e0a:	9f 93       	push	r25
    1e0c:	af 93       	push	r26
    1e0e:	bf 93       	push	r27
    1e10:	cf 93       	push	r28
    1e12:	df 93       	push	r29
    1e14:	ef 93       	push	r30
    1e16:	ff 93       	push	r31
    1e18:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    1e1c:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    1e20:	0d b6       	in	r0, 0x3d	; 61
    1e22:	0d 92       	st	X+, r0
    1e24:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1e26:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    1e28:	25 d6       	rcall	.+3146   	; 0x2a74 <vTaskSwitchContext>
    1e2a:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    1e2e:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    1e32:	cd 91       	ld	r28, X+
    1e34:	cd bf       	out	0x3d, r28	; 61
    1e36:	dd 91       	ld	r29, X+
    1e38:	de bf       	out	0x3e, r29	; 62
    1e3a:	ff 91       	pop	r31
    1e3c:	ef 91       	pop	r30
    1e3e:	df 91       	pop	r29
    1e40:	cf 91       	pop	r28
    1e42:	bf 91       	pop	r27
    1e44:	af 91       	pop	r26
    1e46:	9f 91       	pop	r25
    1e48:	8f 91       	pop	r24
    1e4a:	7f 91       	pop	r23
    1e4c:	6f 91       	pop	r22
    1e4e:	5f 91       	pop	r21
    1e50:	4f 91       	pop	r20
    1e52:	3f 91       	pop	r19
    1e54:	2f 91       	pop	r18
    1e56:	1f 91       	pop	r17
    1e58:	0f 91       	pop	r16
    1e5a:	ff 90       	pop	r15
    1e5c:	ef 90       	pop	r14
    1e5e:	df 90       	pop	r13
    1e60:	cf 90       	pop	r12
    1e62:	bf 90       	pop	r11
    1e64:	af 90       	pop	r10
    1e66:	9f 90       	pop	r9
    1e68:	8f 90       	pop	r8
    1e6a:	7f 90       	pop	r7
    1e6c:	6f 90       	pop	r6
    1e6e:	5f 90       	pop	r5
    1e70:	4f 90       	pop	r4
    1e72:	3f 90       	pop	r3
    1e74:	2f 90       	pop	r2
    1e76:	1f 90       	pop	r1
    1e78:	0f 90       	pop	r0
    1e7a:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1e7c:	0f 90       	pop	r0
    1e7e:	08 95       	ret

00001e80 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e80:	0f 92       	push	r0
    1e82:	0f b6       	in	r0, 0x3f	; 63
    1e84:	f8 94       	cli
    1e86:	0f 92       	push	r0
    1e88:	1f 92       	push	r1
    1e8a:	11 24       	eor	r1, r1
    1e8c:	2f 92       	push	r2
    1e8e:	3f 92       	push	r3
    1e90:	4f 92       	push	r4
    1e92:	5f 92       	push	r5
    1e94:	6f 92       	push	r6
    1e96:	7f 92       	push	r7
    1e98:	8f 92       	push	r8
    1e9a:	9f 92       	push	r9
    1e9c:	af 92       	push	r10
    1e9e:	bf 92       	push	r11
    1ea0:	cf 92       	push	r12
    1ea2:	df 92       	push	r13
    1ea4:	ef 92       	push	r14
    1ea6:	ff 92       	push	r15
    1ea8:	0f 93       	push	r16
    1eaa:	1f 93       	push	r17
    1eac:	2f 93       	push	r18
    1eae:	3f 93       	push	r19
    1eb0:	4f 93       	push	r20
    1eb2:	5f 93       	push	r21
    1eb4:	6f 93       	push	r22
    1eb6:	7f 93       	push	r23
    1eb8:	8f 93       	push	r24
    1eba:	9f 93       	push	r25
    1ebc:	af 93       	push	r26
    1ebe:	bf 93       	push	r27
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	ef 93       	push	r30
    1ec6:	ff 93       	push	r31
    1ec8:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    1ecc:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    1ed0:	0d b6       	in	r0, 0x3d	; 61
    1ed2:	0d 92       	st	X+, r0
    1ed4:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    1ed6:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    1ed8:	56 d4       	rcall	.+2220   	; 0x2786 <xTaskIncrementTick>
    1eda:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    1edc:	cb d5       	rcall	.+2966   	; 0x2a74 <vTaskSwitchContext>
    1ede:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    1ee2:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    1ee6:	cd 91       	ld	r28, X+
    1ee8:	cd bf       	out	0x3d, r28	; 61
    1eea:	dd 91       	ld	r29, X+
    1eec:	de bf       	out	0x3e, r29	; 62
    1eee:	ff 91       	pop	r31
    1ef0:	ef 91       	pop	r30
    1ef2:	df 91       	pop	r29
    1ef4:	cf 91       	pop	r28
    1ef6:	bf 91       	pop	r27
    1ef8:	af 91       	pop	r26
    1efa:	9f 91       	pop	r25
    1efc:	8f 91       	pop	r24
    1efe:	7f 91       	pop	r23
    1f00:	6f 91       	pop	r22
    1f02:	5f 91       	pop	r21
    1f04:	4f 91       	pop	r20
    1f06:	3f 91       	pop	r19
    1f08:	2f 91       	pop	r18
    1f0a:	1f 91       	pop	r17
    1f0c:	0f 91       	pop	r16
    1f0e:	ff 90       	pop	r15
    1f10:	ef 90       	pop	r14
    1f12:	df 90       	pop	r13
    1f14:	cf 90       	pop	r12
    1f16:	bf 90       	pop	r11
    1f18:	af 90       	pop	r10
    1f1a:	9f 90       	pop	r9
    1f1c:	8f 90       	pop	r8
    1f1e:	7f 90       	pop	r7
    1f20:	6f 90       	pop	r6
    1f22:	5f 90       	pop	r5
    1f24:	4f 90       	pop	r4
    1f26:	3f 90       	pop	r3
    1f28:	2f 90       	pop	r2
    1f2a:	1f 90       	pop	r1
    1f2c:	0f 90       	pop	r0
    1f2e:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1f30:	0f 90       	pop	r0
    1f32:	08 95       	ret

00001f34 <__vector_12>:
    1f34:	a5 df       	rcall	.-182    	; 0x1e80 <vPortYieldFromTick>
    1f36:	18 95       	reti

00001f38 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1f38:	0f 93       	push	r16
    1f3a:	1f 93       	push	r17
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	ec 01       	movw	r28, r24
    1f42:	04 2f       	mov	r16, r20
    1f44:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1f46:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1f48:	41 11       	cpse	r20, r1
    1f4a:	0b c0       	rjmp	.+22     	; 0x1f62 <prvCopyDataToQueue+0x2a>
    1f4c:	88 81       	ld	r24, Y
    1f4e:	99 81       	ldd	r25, Y+1	; 0x01
    1f50:	89 2b       	or	r24, r25
    1f52:	09 f0       	breq	.+2      	; 0x1f56 <prvCopyDataToQueue+0x1e>
    1f54:	41 c0       	rjmp	.+130    	; 0x1fd8 <prvCopyDataToQueue+0xa0>
    1f56:	8a 81       	ldd	r24, Y+2	; 0x02
    1f58:	9b 81       	ldd	r25, Y+3	; 0x03
    1f5a:	0b d7       	rcall	.+3606   	; 0x2d72 <xTaskPriorityDisinherit>
    1f5c:	1b 82       	std	Y+3, r1	; 0x03
    1f5e:	1a 82       	std	Y+2, r1	; 0x02
    1f60:	42 c0       	rjmp	.+132    	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1f62:	01 11       	cpse	r16, r1
    1f64:	17 c0       	rjmp	.+46     	; 0x1f94 <prvCopyDataToQueue+0x5c>
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	8c 81       	ldd	r24, Y+4	; 0x04
    1f6a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f6c:	0e 94 4c 18 	call	0x3098	; 0x3098 <memcpy>
    1f70:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1f72:	8c 81       	ldd	r24, Y+4	; 0x04
    1f74:	9d 81       	ldd	r25, Y+5	; 0x05
    1f76:	82 0f       	add	r24, r18
    1f78:	91 1d       	adc	r25, r1
    1f7a:	9d 83       	std	Y+5, r25	; 0x05
    1f7c:	8c 83       	std	Y+4, r24	; 0x04
    1f7e:	2a 81       	ldd	r18, Y+2	; 0x02
    1f80:	3b 81       	ldd	r19, Y+3	; 0x03
    1f82:	82 17       	cp	r24, r18
    1f84:	93 07       	cpc	r25, r19
    1f86:	50 f1       	brcs	.+84     	; 0x1fdc <prvCopyDataToQueue+0xa4>
    1f88:	88 81       	ld	r24, Y
    1f8a:	99 81       	ldd	r25, Y+1	; 0x01
    1f8c:	9d 83       	std	Y+5, r25	; 0x05
    1f8e:	8c 83       	std	Y+4, r24	; 0x04
    1f90:	80 e0       	ldi	r24, 0x00	; 0
    1f92:	29 c0       	rjmp	.+82     	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1f94:	50 e0       	ldi	r21, 0x00	; 0
    1f96:	8e 81       	ldd	r24, Y+6	; 0x06
    1f98:	9f 81       	ldd	r25, Y+7	; 0x07
    1f9a:	0e 94 4c 18 	call	0x3098	; 0x3098 <memcpy>
    1f9e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1fa0:	90 e0       	ldi	r25, 0x00	; 0
    1fa2:	91 95       	neg	r25
    1fa4:	81 95       	neg	r24
    1fa6:	91 09       	sbc	r25, r1
    1fa8:	2e 81       	ldd	r18, Y+6	; 0x06
    1faa:	3f 81       	ldd	r19, Y+7	; 0x07
    1fac:	28 0f       	add	r18, r24
    1fae:	39 1f       	adc	r19, r25
    1fb0:	3f 83       	std	Y+7, r19	; 0x07
    1fb2:	2e 83       	std	Y+6, r18	; 0x06
    1fb4:	48 81       	ld	r20, Y
    1fb6:	59 81       	ldd	r21, Y+1	; 0x01
    1fb8:	24 17       	cp	r18, r20
    1fba:	35 07       	cpc	r19, r21
    1fbc:	30 f4       	brcc	.+12     	; 0x1fca <prvCopyDataToQueue+0x92>
    1fbe:	2a 81       	ldd	r18, Y+2	; 0x02
    1fc0:	3b 81       	ldd	r19, Y+3	; 0x03
    1fc2:	82 0f       	add	r24, r18
    1fc4:	93 1f       	adc	r25, r19
    1fc6:	9f 83       	std	Y+7, r25	; 0x07
    1fc8:	8e 83       	std	Y+6, r24	; 0x06
    1fca:	02 30       	cpi	r16, 0x02	; 2
    1fcc:	49 f4       	brne	.+18     	; 0x1fe0 <prvCopyDataToQueue+0xa8>
    1fce:	11 23       	and	r17, r17
    1fd0:	49 f0       	breq	.+18     	; 0x1fe4 <prvCopyDataToQueue+0xac>
    1fd2:	11 50       	subi	r17, 0x01	; 1
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	07 c0       	rjmp	.+14     	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1fd8:	80 e0       	ldi	r24, 0x00	; 0
    1fda:	05 c0       	rjmp	.+10     	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1fdc:	80 e0       	ldi	r24, 0x00	; 0
    1fde:	03 c0       	rjmp	.+6      	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1fe0:	80 e0       	ldi	r24, 0x00	; 0
    1fe2:	01 c0       	rjmp	.+2      	; 0x1fe6 <prvCopyDataToQueue+0xae>
    1fe4:	80 e0       	ldi	r24, 0x00	; 0
    1fe6:	1f 5f       	subi	r17, 0xFF	; 255
    1fe8:	1a 8f       	std	Y+26, r17	; 0x1a
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	1f 91       	pop	r17
    1ff0:	0f 91       	pop	r16
    1ff2:	08 95       	ret

00001ff4 <prvCopyDataFromQueue>:
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	44 8d       	ldd	r20, Z+28	; 0x1c
    1ff8:	44 23       	and	r20, r20
    1ffa:	a9 f0       	breq	.+42     	; 0x2026 <prvCopyDataFromQueue+0x32>
    1ffc:	50 e0       	ldi	r21, 0x00	; 0
    1ffe:	26 81       	ldd	r18, Z+6	; 0x06
    2000:	37 81       	ldd	r19, Z+7	; 0x07
    2002:	24 0f       	add	r18, r20
    2004:	35 1f       	adc	r19, r21
    2006:	37 83       	std	Z+7, r19	; 0x07
    2008:	26 83       	std	Z+6, r18	; 0x06
    200a:	82 81       	ldd	r24, Z+2	; 0x02
    200c:	93 81       	ldd	r25, Z+3	; 0x03
    200e:	28 17       	cp	r18, r24
    2010:	39 07       	cpc	r19, r25
    2012:	20 f0       	brcs	.+8      	; 0x201c <prvCopyDataFromQueue+0x28>
    2014:	80 81       	ld	r24, Z
    2016:	91 81       	ldd	r25, Z+1	; 0x01
    2018:	97 83       	std	Z+7, r25	; 0x07
    201a:	86 83       	std	Z+6, r24	; 0x06
    201c:	cb 01       	movw	r24, r22
    201e:	66 81       	ldd	r22, Z+6	; 0x06
    2020:	77 81       	ldd	r23, Z+7	; 0x07
    2022:	0c 94 4c 18 	jmp	0x3098	; 0x3098 <memcpy>
    2026:	08 95       	ret

00002028 <prvUnlockQueue>:
    2028:	ef 92       	push	r14
    202a:	ff 92       	push	r15
    202c:	0f 93       	push	r16
    202e:	1f 93       	push	r17
    2030:	cf 93       	push	r28
    2032:	8c 01       	movw	r16, r24
    2034:	0f b6       	in	r0, 0x3f	; 63
    2036:	f8 94       	cli
    2038:	0f 92       	push	r0
    203a:	fc 01       	movw	r30, r24
    203c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    203e:	1c 16       	cp	r1, r28
    2040:	9c f4       	brge	.+38     	; 0x2068 <prvUnlockQueue+0x40>
    2042:	81 89       	ldd	r24, Z+17	; 0x11
    2044:	81 11       	cpse	r24, r1
    2046:	06 c0       	rjmp	.+12     	; 0x2054 <prvUnlockQueue+0x2c>
    2048:	0f c0       	rjmp	.+30     	; 0x2068 <prvUnlockQueue+0x40>
    204a:	f8 01       	movw	r30, r16
    204c:	81 89       	ldd	r24, Z+17	; 0x11
    204e:	81 11       	cpse	r24, r1
    2050:	05 c0       	rjmp	.+10     	; 0x205c <prvUnlockQueue+0x34>
    2052:	0a c0       	rjmp	.+20     	; 0x2068 <prvUnlockQueue+0x40>
    2054:	78 01       	movw	r14, r16
    2056:	f1 e1       	ldi	r31, 0x11	; 17
    2058:	ef 0e       	add	r14, r31
    205a:	f1 1c       	adc	r15, r1
    205c:	c7 01       	movw	r24, r14
    205e:	9a d5       	rcall	.+2868   	; 0x2b94 <xTaskRemoveFromEventList>
    2060:	81 11       	cpse	r24, r1
    2062:	21 d6       	rcall	.+3138   	; 0x2ca6 <vTaskMissedYield>
    2064:	c1 50       	subi	r28, 0x01	; 1
    2066:	89 f7       	brne	.-30     	; 0x204a <prvUnlockQueue+0x22>
    2068:	8f ef       	ldi	r24, 0xFF	; 255
    206a:	f8 01       	movw	r30, r16
    206c:	86 8f       	std	Z+30, r24	; 0x1e
    206e:	0f 90       	pop	r0
    2070:	0f be       	out	0x3f, r0	; 63
    2072:	0f b6       	in	r0, 0x3f	; 63
    2074:	f8 94       	cli
    2076:	0f 92       	push	r0
    2078:	c5 8d       	ldd	r28, Z+29	; 0x1d
    207a:	1c 16       	cp	r1, r28
    207c:	9c f4       	brge	.+38     	; 0x20a4 <prvUnlockQueue+0x7c>
    207e:	80 85       	ldd	r24, Z+8	; 0x08
    2080:	81 11       	cpse	r24, r1
    2082:	06 c0       	rjmp	.+12     	; 0x2090 <prvUnlockQueue+0x68>
    2084:	0f c0       	rjmp	.+30     	; 0x20a4 <prvUnlockQueue+0x7c>
    2086:	f8 01       	movw	r30, r16
    2088:	80 85       	ldd	r24, Z+8	; 0x08
    208a:	81 11       	cpse	r24, r1
    208c:	05 c0       	rjmp	.+10     	; 0x2098 <prvUnlockQueue+0x70>
    208e:	0a c0       	rjmp	.+20     	; 0x20a4 <prvUnlockQueue+0x7c>
    2090:	78 01       	movw	r14, r16
    2092:	f8 e0       	ldi	r31, 0x08	; 8
    2094:	ef 0e       	add	r14, r31
    2096:	f1 1c       	adc	r15, r1
    2098:	c7 01       	movw	r24, r14
    209a:	7c d5       	rcall	.+2808   	; 0x2b94 <xTaskRemoveFromEventList>
    209c:	81 11       	cpse	r24, r1
    209e:	03 d6       	rcall	.+3078   	; 0x2ca6 <vTaskMissedYield>
    20a0:	c1 50       	subi	r28, 0x01	; 1
    20a2:	89 f7       	brne	.-30     	; 0x2086 <prvUnlockQueue+0x5e>
    20a4:	8f ef       	ldi	r24, 0xFF	; 255
    20a6:	f8 01       	movw	r30, r16
    20a8:	85 8f       	std	Z+29, r24	; 0x1d
    20aa:	0f 90       	pop	r0
    20ac:	0f be       	out	0x3f, r0	; 63
    20ae:	cf 91       	pop	r28
    20b0:	1f 91       	pop	r17
    20b2:	0f 91       	pop	r16
    20b4:	ff 90       	pop	r15
    20b6:	ef 90       	pop	r14
    20b8:	08 95       	ret

000020ba <xQueueGenericReset>:
    20ba:	cf 93       	push	r28
    20bc:	df 93       	push	r29
    20be:	ec 01       	movw	r28, r24
    20c0:	0f b6       	in	r0, 0x3f	; 63
    20c2:	f8 94       	cli
    20c4:	0f 92       	push	r0
    20c6:	48 81       	ld	r20, Y
    20c8:	59 81       	ldd	r21, Y+1	; 0x01
    20ca:	2c 8d       	ldd	r18, Y+28	; 0x1c
    20cc:	30 e0       	ldi	r19, 0x00	; 0
    20ce:	7b 8d       	ldd	r23, Y+27	; 0x1b
    20d0:	72 9f       	mul	r23, r18
    20d2:	c0 01       	movw	r24, r0
    20d4:	73 9f       	mul	r23, r19
    20d6:	90 0d       	add	r25, r0
    20d8:	11 24       	eor	r1, r1
    20da:	fa 01       	movw	r30, r20
    20dc:	e8 0f       	add	r30, r24
    20de:	f9 1f       	adc	r31, r25
    20e0:	fb 83       	std	Y+3, r31	; 0x03
    20e2:	ea 83       	std	Y+2, r30	; 0x02
    20e4:	1a 8e       	std	Y+26, r1	; 0x1a
    20e6:	5d 83       	std	Y+5, r21	; 0x05
    20e8:	4c 83       	std	Y+4, r20	; 0x04
    20ea:	82 1b       	sub	r24, r18
    20ec:	93 0b       	sbc	r25, r19
    20ee:	84 0f       	add	r24, r20
    20f0:	95 1f       	adc	r25, r21
    20f2:	9f 83       	std	Y+7, r25	; 0x07
    20f4:	8e 83       	std	Y+6, r24	; 0x06
    20f6:	8f ef       	ldi	r24, 0xFF	; 255
    20f8:	8d 8f       	std	Y+29, r24	; 0x1d
    20fa:	8e 8f       	std	Y+30, r24	; 0x1e
    20fc:	61 11       	cpse	r22, r1
    20fe:	0a c0       	rjmp	.+20     	; 0x2114 <xQueueGenericReset+0x5a>
    2100:	88 85       	ldd	r24, Y+8	; 0x08
    2102:	88 23       	and	r24, r24
    2104:	69 f0       	breq	.+26     	; 0x2120 <xQueueGenericReset+0x66>
    2106:	ce 01       	movw	r24, r28
    2108:	08 96       	adiw	r24, 0x08	; 8
    210a:	44 d5       	rcall	.+2696   	; 0x2b94 <xTaskRemoveFromEventList>
    210c:	88 23       	and	r24, r24
    210e:	41 f0       	breq	.+16     	; 0x2120 <xQueueGenericReset+0x66>
    2110:	5f de       	rcall	.-834    	; 0x1dd0 <vPortYield>
    2112:	06 c0       	rjmp	.+12     	; 0x2120 <xQueueGenericReset+0x66>
    2114:	ce 01       	movw	r24, r28
    2116:	08 96       	adiw	r24, 0x08	; 8
    2118:	30 dd       	rcall	.-1440   	; 0x1b7a <vListInitialise>
    211a:	ce 01       	movw	r24, r28
    211c:	41 96       	adiw	r24, 0x11	; 17
    211e:	2d dd       	rcall	.-1446   	; 0x1b7a <vListInitialise>
    2120:	0f 90       	pop	r0
    2122:	0f be       	out	0x3f, r0	; 63
    2124:	81 e0       	ldi	r24, 0x01	; 1
    2126:	df 91       	pop	r29
    2128:	cf 91       	pop	r28
    212a:	08 95       	ret

0000212c <xQueueGenericCreate>:
    212c:	0f 93       	push	r16
    212e:	1f 93       	push	r17
    2130:	cf 93       	push	r28
    2132:	df 93       	push	r29
    2134:	08 2f       	mov	r16, r24
    2136:	16 2f       	mov	r17, r22
    2138:	66 23       	and	r22, r22
    213a:	b1 f0       	breq	.+44     	; 0x2168 <xQueueGenericCreate+0x3c>
    213c:	86 9f       	mul	r24, r22
    213e:	c0 01       	movw	r24, r0
    2140:	11 24       	eor	r1, r1
    2142:	4f 96       	adiw	r24, 0x1f	; 31
    2144:	e6 dc       	rcall	.-1588   	; 0x1b12 <pvPortMalloc>
    2146:	ec 01       	movw	r28, r24
    2148:	00 97       	sbiw	r24, 0x00	; 0
    214a:	39 f4       	brne	.+14     	; 0x215a <xQueueGenericCreate+0x2e>
    214c:	13 c0       	rjmp	.+38     	; 0x2174 <xQueueGenericCreate+0x48>
    214e:	0b 8f       	std	Y+27, r16	; 0x1b
    2150:	1c 8f       	std	Y+28, r17	; 0x1c
    2152:	61 e0       	ldi	r22, 0x01	; 1
    2154:	ce 01       	movw	r24, r28
    2156:	b1 df       	rcall	.-158    	; 0x20ba <xQueueGenericReset>
    2158:	0d c0       	rjmp	.+26     	; 0x2174 <xQueueGenericCreate+0x48>
    215a:	4f 96       	adiw	r24, 0x1f	; 31
    215c:	99 83       	std	Y+1, r25	; 0x01
    215e:	88 83       	st	Y, r24
    2160:	f6 cf       	rjmp	.-20     	; 0x214e <xQueueGenericCreate+0x22>
    2162:	d9 83       	std	Y+1, r29	; 0x01
    2164:	c8 83       	st	Y, r28
    2166:	f3 cf       	rjmp	.-26     	; 0x214e <xQueueGenericCreate+0x22>
    2168:	8f e1       	ldi	r24, 0x1F	; 31
    216a:	90 e0       	ldi	r25, 0x00	; 0
    216c:	d2 dc       	rcall	.-1628   	; 0x1b12 <pvPortMalloc>
    216e:	ec 01       	movw	r28, r24
    2170:	89 2b       	or	r24, r25
    2172:	b9 f7       	brne	.-18     	; 0x2162 <xQueueGenericCreate+0x36>
    2174:	ce 01       	movw	r24, r28
    2176:	df 91       	pop	r29
    2178:	cf 91       	pop	r28
    217a:	1f 91       	pop	r17
    217c:	0f 91       	pop	r16
    217e:	08 95       	ret

00002180 <xQueueGenericSend>:
    2180:	9f 92       	push	r9
    2182:	af 92       	push	r10
    2184:	bf 92       	push	r11
    2186:	cf 92       	push	r12
    2188:	df 92       	push	r13
    218a:	ef 92       	push	r14
    218c:	ff 92       	push	r15
    218e:	0f 93       	push	r16
    2190:	1f 93       	push	r17
    2192:	cf 93       	push	r28
    2194:	df 93       	push	r29
    2196:	00 d0       	rcall	.+0      	; 0x2198 <xQueueGenericSend+0x18>
    2198:	00 d0       	rcall	.+0      	; 0x219a <xQueueGenericSend+0x1a>
    219a:	1f 92       	push	r1
    219c:	cd b7       	in	r28, 0x3d	; 61
    219e:	de b7       	in	r29, 0x3e	; 62
    21a0:	8c 01       	movw	r16, r24
    21a2:	6b 01       	movw	r12, r22
    21a4:	5d 83       	std	Y+5, r21	; 0x05
    21a6:	4c 83       	std	Y+4, r20	; 0x04
    21a8:	a2 2e       	mov	r10, r18
    21aa:	b1 2c       	mov	r11, r1
    21ac:	99 24       	eor	r9, r9
    21ae:	93 94       	inc	r9
    21b0:	7c 01       	movw	r14, r24
    21b2:	88 e0       	ldi	r24, 0x08	; 8
    21b4:	e8 0e       	add	r14, r24
    21b6:	f1 1c       	adc	r15, r1
    21b8:	0f b6       	in	r0, 0x3f	; 63
    21ba:	f8 94       	cli
    21bc:	0f 92       	push	r0
    21be:	f8 01       	movw	r30, r16
    21c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    21c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    21c4:	98 17       	cp	r25, r24
    21c6:	18 f0       	brcs	.+6      	; 0x21ce <xQueueGenericSend+0x4e>
    21c8:	f2 e0       	ldi	r31, 0x02	; 2
    21ca:	af 12       	cpse	r10, r31
    21cc:	15 c0       	rjmp	.+42     	; 0x21f8 <xQueueGenericSend+0x78>
    21ce:	4a 2d       	mov	r20, r10
    21d0:	b6 01       	movw	r22, r12
    21d2:	c8 01       	movw	r24, r16
    21d4:	b1 de       	rcall	.-670    	; 0x1f38 <prvCopyDataToQueue>
    21d6:	f8 01       	movw	r30, r16
    21d8:	91 89       	ldd	r25, Z+17	; 0x11
    21da:	99 23       	and	r25, r25
    21dc:	39 f0       	breq	.+14     	; 0x21ec <xQueueGenericSend+0x6c>
    21de:	c8 01       	movw	r24, r16
    21e0:	41 96       	adiw	r24, 0x11	; 17
    21e2:	d8 d4       	rcall	.+2480   	; 0x2b94 <xTaskRemoveFromEventList>
    21e4:	88 23       	and	r24, r24
    21e6:	21 f0       	breq	.+8      	; 0x21f0 <xQueueGenericSend+0x70>
    21e8:	f3 dd       	rcall	.-1050   	; 0x1dd0 <vPortYield>
    21ea:	02 c0       	rjmp	.+4      	; 0x21f0 <xQueueGenericSend+0x70>
    21ec:	81 11       	cpse	r24, r1
    21ee:	f0 dd       	rcall	.-1056   	; 0x1dd0 <vPortYield>
    21f0:	0f 90       	pop	r0
    21f2:	0f be       	out	0x3f, r0	; 63
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	45 c0       	rjmp	.+138    	; 0x2282 <xQueueGenericSend+0x102>
    21f8:	8c 81       	ldd	r24, Y+4	; 0x04
    21fa:	9d 81       	ldd	r25, Y+5	; 0x05
    21fc:	89 2b       	or	r24, r25
    21fe:	21 f4       	brne	.+8      	; 0x2208 <xQueueGenericSend+0x88>
    2200:	0f 90       	pop	r0
    2202:	0f be       	out	0x3f, r0	; 63
    2204:	80 e0       	ldi	r24, 0x00	; 0
    2206:	3d c0       	rjmp	.+122    	; 0x2282 <xQueueGenericSend+0x102>
    2208:	b1 10       	cpse	r11, r1
    220a:	04 c0       	rjmp	.+8      	; 0x2214 <xQueueGenericSend+0x94>
    220c:	ce 01       	movw	r24, r28
    220e:	01 96       	adiw	r24, 0x01	; 1
    2210:	07 d5       	rcall	.+2574   	; 0x2c20 <vTaskSetTimeOutState>
    2212:	b9 2c       	mov	r11, r9
    2214:	0f 90       	pop	r0
    2216:	0f be       	out	0x3f, r0	; 63
    2218:	b0 d2       	rcall	.+1376   	; 0x277a <vTaskSuspendAll>
    221a:	0f b6       	in	r0, 0x3f	; 63
    221c:	f8 94       	cli
    221e:	0f 92       	push	r0
    2220:	f8 01       	movw	r30, r16
    2222:	85 8d       	ldd	r24, Z+29	; 0x1d
    2224:	8f 3f       	cpi	r24, 0xFF	; 255
    2226:	09 f4       	brne	.+2      	; 0x222a <xQueueGenericSend+0xaa>
    2228:	15 8e       	std	Z+29, r1	; 0x1d
    222a:	f8 01       	movw	r30, r16
    222c:	86 8d       	ldd	r24, Z+30	; 0x1e
    222e:	8f 3f       	cpi	r24, 0xFF	; 255
    2230:	09 f4       	brne	.+2      	; 0x2234 <xQueueGenericSend+0xb4>
    2232:	16 8e       	std	Z+30, r1	; 0x1e
    2234:	0f 90       	pop	r0
    2236:	0f be       	out	0x3f, r0	; 63
    2238:	be 01       	movw	r22, r28
    223a:	6c 5f       	subi	r22, 0xFC	; 252
    223c:	7f 4f       	sbci	r23, 0xFF	; 255
    223e:	ce 01       	movw	r24, r28
    2240:	01 96       	adiw	r24, 0x01	; 1
    2242:	f9 d4       	rcall	.+2546   	; 0x2c36 <xTaskCheckForTimeOut>
    2244:	81 11       	cpse	r24, r1
    2246:	19 c0       	rjmp	.+50     	; 0x227a <xQueueGenericSend+0xfa>
    2248:	0f b6       	in	r0, 0x3f	; 63
    224a:	f8 94       	cli
    224c:	0f 92       	push	r0
    224e:	f8 01       	movw	r30, r16
    2250:	92 8d       	ldd	r25, Z+26	; 0x1a
    2252:	0f 90       	pop	r0
    2254:	0f be       	out	0x3f, r0	; 63
    2256:	83 8d       	ldd	r24, Z+27	; 0x1b
    2258:	98 13       	cpse	r25, r24
    225a:	0b c0       	rjmp	.+22     	; 0x2272 <xQueueGenericSend+0xf2>
    225c:	6c 81       	ldd	r22, Y+4	; 0x04
    225e:	7d 81       	ldd	r23, Y+5	; 0x05
    2260:	c7 01       	movw	r24, r14
    2262:	88 d4       	rcall	.+2320   	; 0x2b74 <vTaskPlaceOnEventList>
    2264:	c8 01       	movw	r24, r16
    2266:	e0 de       	rcall	.-576    	; 0x2028 <prvUnlockQueue>
    2268:	45 d3       	rcall	.+1674   	; 0x28f4 <xTaskResumeAll>
    226a:	81 11       	cpse	r24, r1
    226c:	a5 cf       	rjmp	.-182    	; 0x21b8 <xQueueGenericSend+0x38>
    226e:	b0 dd       	rcall	.-1184   	; 0x1dd0 <vPortYield>
    2270:	a3 cf       	rjmp	.-186    	; 0x21b8 <xQueueGenericSend+0x38>
    2272:	c8 01       	movw	r24, r16
    2274:	d9 de       	rcall	.-590    	; 0x2028 <prvUnlockQueue>
    2276:	3e d3       	rcall	.+1660   	; 0x28f4 <xTaskResumeAll>
    2278:	9f cf       	rjmp	.-194    	; 0x21b8 <xQueueGenericSend+0x38>
    227a:	c8 01       	movw	r24, r16
    227c:	d5 de       	rcall	.-598    	; 0x2028 <prvUnlockQueue>
    227e:	3a d3       	rcall	.+1652   	; 0x28f4 <xTaskResumeAll>
    2280:	80 e0       	ldi	r24, 0x00	; 0
    2282:	0f 90       	pop	r0
    2284:	0f 90       	pop	r0
    2286:	0f 90       	pop	r0
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	df 91       	pop	r29
    228e:	cf 91       	pop	r28
    2290:	1f 91       	pop	r17
    2292:	0f 91       	pop	r16
    2294:	ff 90       	pop	r15
    2296:	ef 90       	pop	r14
    2298:	df 90       	pop	r13
    229a:	cf 90       	pop	r12
    229c:	bf 90       	pop	r11
    229e:	af 90       	pop	r10
    22a0:	9f 90       	pop	r9
    22a2:	08 95       	ret

000022a4 <xQueueCreateMutex>:
    22a4:	cf 93       	push	r28
    22a6:	df 93       	push	r29
    22a8:	48 2f       	mov	r20, r24
    22aa:	60 e0       	ldi	r22, 0x00	; 0
    22ac:	81 e0       	ldi	r24, 0x01	; 1
    22ae:	3e df       	rcall	.-388    	; 0x212c <xQueueGenericCreate>
    22b0:	ec 01       	movw	r28, r24
    22b2:	00 97       	sbiw	r24, 0x00	; 0
    22b4:	59 f0       	breq	.+22     	; 0x22cc <xQueueCreateMutex+0x28>
    22b6:	1b 82       	std	Y+3, r1	; 0x03
    22b8:	1a 82       	std	Y+2, r1	; 0x02
    22ba:	19 82       	std	Y+1, r1	; 0x01
    22bc:	18 82       	st	Y, r1
    22be:	1e 82       	std	Y+6, r1	; 0x06
    22c0:	20 e0       	ldi	r18, 0x00	; 0
    22c2:	40 e0       	ldi	r20, 0x00	; 0
    22c4:	50 e0       	ldi	r21, 0x00	; 0
    22c6:	60 e0       	ldi	r22, 0x00	; 0
    22c8:	70 e0       	ldi	r23, 0x00	; 0
    22ca:	5a df       	rcall	.-332    	; 0x2180 <xQueueGenericSend>
    22cc:	ce 01       	movw	r24, r28
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	08 95       	ret

000022d4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    22d4:	8f 92       	push	r8
    22d6:	9f 92       	push	r9
    22d8:	af 92       	push	r10
    22da:	bf 92       	push	r11
    22dc:	cf 92       	push	r12
    22de:	df 92       	push	r13
    22e0:	ef 92       	push	r14
    22e2:	ff 92       	push	r15
    22e4:	0f 93       	push	r16
    22e6:	1f 93       	push	r17
    22e8:	cf 93       	push	r28
    22ea:	df 93       	push	r29
    22ec:	00 d0       	rcall	.+0      	; 0x22ee <xQueueGenericReceive+0x1a>
    22ee:	00 d0       	rcall	.+0      	; 0x22f0 <xQueueGenericReceive+0x1c>
    22f0:	1f 92       	push	r1
    22f2:	cd b7       	in	r28, 0x3d	; 61
    22f4:	de b7       	in	r29, 0x3e	; 62
    22f6:	8c 01       	movw	r16, r24
    22f8:	5b 01       	movw	r10, r22
    22fa:	5d 83       	std	Y+5, r21	; 0x05
    22fc:	4c 83       	std	Y+4, r20	; 0x04
    22fe:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2300:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2302:	99 24       	eor	r9, r9
    2304:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2306:	6c 01       	movw	r12, r24
    2308:	81 e1       	ldi	r24, 0x11	; 17
    230a:	c8 0e       	add	r12, r24
    230c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    230e:	0f b6       	in	r0, 0x3f	; 63
    2310:	f8 94       	cli
    2312:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2314:	f8 01       	movw	r30, r16
    2316:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2318:	ff 20       	and	r15, r15
    231a:	61 f1       	breq	.+88     	; 0x2374 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    231c:	c6 80       	ldd	r12, Z+6	; 0x06
    231e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2320:	b5 01       	movw	r22, r10
    2322:	c8 01       	movw	r24, r16
    2324:	67 de       	rcall	.-818    	; 0x1ff4 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2326:	81 10       	cpse	r8, r1
    2328:	16 c0       	rjmp	.+44     	; 0x2356 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    232a:	fa 94       	dec	r15
    232c:	f8 01       	movw	r30, r16
    232e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2330:	80 81       	ld	r24, Z
    2332:	91 81       	ldd	r25, Z+1	; 0x01
    2334:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2336:	21 f4       	brne	.+8      	; 0x2340 <xQueueGenericReceive+0x6c>
    2338:	5c d5       	rcall	.+2744   	; 0x2df2 <pvTaskIncrementMutexHeldCount>
    233a:	f8 01       	movw	r30, r16
    233c:	93 83       	std	Z+3, r25	; 0x03
    233e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2340:	f8 01       	movw	r30, r16
    2342:	80 85       	ldd	r24, Z+8	; 0x08
    2344:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2346:	91 f0       	breq	.+36     	; 0x236c <xQueueGenericReceive+0x98>
    2348:	c8 01       	movw	r24, r16
    234a:	08 96       	adiw	r24, 0x08	; 8
    234c:	23 d4       	rcall	.+2118   	; 0x2b94 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    234e:	88 23       	and	r24, r24
    2350:	69 f0       	breq	.+26     	; 0x236c <xQueueGenericReceive+0x98>
    2352:	3e dd       	rcall	.-1412   	; 0x1dd0 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2354:	0b c0       	rjmp	.+22     	; 0x236c <xQueueGenericReceive+0x98>
    2356:	f8 01       	movw	r30, r16
    2358:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    235a:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    235c:	81 89       	ldd	r24, Z+17	; 0x11
    235e:	88 23       	and	r24, r24
    2360:	29 f0       	breq	.+10     	; 0x236c <xQueueGenericReceive+0x98>
    2362:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2364:	41 96       	adiw	r24, 0x11	; 17
    2366:	16 d4       	rcall	.+2092   	; 0x2b94 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2368:	81 11       	cpse	r24, r1
    236a:	32 dd       	rcall	.-1436   	; 0x1dd0 <vPortYield>
				return pdPASS;
    236c:	0f 90       	pop	r0
    236e:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	58 c0       	rjmp	.+176    	; 0x2424 <xQueueGenericReceive+0x150>
    2374:	8c 81       	ldd	r24, Y+4	; 0x04
    2376:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2378:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    237a:	21 f4       	brne	.+8      	; 0x2384 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    237c:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    237e:	0f be       	out	0x3f, r0	; 63
    2380:	80 e0       	ldi	r24, 0x00	; 0
    2382:	50 c0       	rjmp	.+160    	; 0x2424 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    2384:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2386:	04 c0       	rjmp	.+8      	; 0x2390 <xQueueGenericReceive+0xbc>
    2388:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    238a:	01 96       	adiw	r24, 0x01	; 1
    238c:	49 d4       	rcall	.+2194   	; 0x2c20 <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    238e:	e9 2c       	mov	r14, r9
    2390:	0f 90       	pop	r0
    2392:	0f be       	out	0x3f, r0	; 63
    2394:	f2 d1       	rcall	.+996    	; 0x277a <vTaskSuspendAll>
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	0f 92       	push	r0
    239c:	f8 01       	movw	r30, r16
    239e:	85 8d       	ldd	r24, Z+29	; 0x1d
    23a0:	8f 3f       	cpi	r24, 0xFF	; 255
    23a2:	09 f4       	brne	.+2      	; 0x23a6 <xQueueGenericReceive+0xd2>
    23a4:	15 8e       	std	Z+29, r1	; 0x1d
    23a6:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23aa:	8f 3f       	cpi	r24, 0xFF	; 255
    23ac:	09 f4       	brne	.+2      	; 0x23b0 <xQueueGenericReceive+0xdc>
    23ae:	16 8e       	std	Z+30, r1	; 0x1e
    23b0:	0f 90       	pop	r0
    23b2:	0f be       	out	0x3f, r0	; 63
    23b4:	be 01       	movw	r22, r28
    23b6:	6c 5f       	subi	r22, 0xFC	; 252
    23b8:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    23ba:	ce 01       	movw	r24, r28
    23bc:	01 96       	adiw	r24, 0x01	; 1
    23be:	3b d4       	rcall	.+2166   	; 0x2c36 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    23c0:	81 11       	cpse	r24, r1
    23c2:	24 c0       	rjmp	.+72     	; 0x240c <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    23c4:	0f b6       	in	r0, 0x3f	; 63
    23c6:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23c8:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    23ca:	f8 01       	movw	r30, r16
    23cc:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ce:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    23d0:	0f be       	out	0x3f, r0	; 63
    23d2:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    23d4:	17 c0       	rjmp	.+46     	; 0x2404 <xQueueGenericReceive+0x130>
    23d6:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    23d8:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23da:	89 2b       	or	r24, r25
    23dc:	41 f4       	brne	.+16     	; 0x23ee <xQueueGenericReceive+0x11a>
    23de:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    23e0:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    23e2:	0f 92       	push	r0
    23e4:	82 81       	ldd	r24, Z+2	; 0x02
    23e6:	93 81       	ldd	r25, Z+3	; 0x03
    23e8:	62 d4       	rcall	.+2244   	; 0x2cae <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    23ea:	0f 90       	pop	r0
    23ec:	0f be       	out	0x3f, r0	; 63
    23ee:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    23f0:	7d 81       	ldd	r23, Y+5	; 0x05
    23f2:	c6 01       	movw	r24, r12
    23f4:	bf d3       	rcall	.+1918   	; 0x2b74 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    23f6:	c8 01       	movw	r24, r16
    23f8:	17 de       	rcall	.-978    	; 0x2028 <prvUnlockQueue>
    23fa:	7c d2       	rcall	.+1272   	; 0x28f4 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    23fc:	81 11       	cpse	r24, r1
    23fe:	87 cf       	rjmp	.-242    	; 0x230e <xQueueGenericReceive+0x3a>
    2400:	e7 dc       	rcall	.-1586   	; 0x1dd0 <vPortYield>
			( void ) xTaskResumeAll();
    2402:	85 cf       	rjmp	.-246    	; 0x230e <xQueueGenericReceive+0x3a>
    2404:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2406:	10 de       	rcall	.-992    	; 0x2028 <prvUnlockQueue>
    2408:	75 d2       	rcall	.+1258   	; 0x28f4 <xTaskResumeAll>
    240a:	81 cf       	rjmp	.-254    	; 0x230e <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    240c:	c8 01       	movw	r24, r16
    240e:	0c de       	rcall	.-1000   	; 0x2028 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2410:	71 d2       	rcall	.+1250   	; 0x28f4 <xTaskResumeAll>
    2412:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2414:	f8 94       	cli
    2416:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    2418:	f8 01       	movw	r30, r16
    241a:	82 8d       	ldd	r24, Z+26	; 0x1a
    241c:	0f 90       	pop	r0
    241e:	0f be       	out	0x3f, r0	; 63
    2420:	81 11       	cpse	r24, r1
    2422:	75 cf       	rjmp	.-278    	; 0x230e <xQueueGenericReceive+0x3a>
    2424:	0f 90       	pop	r0
    2426:	0f 90       	pop	r0
    2428:	0f 90       	pop	r0
    242a:	0f 90       	pop	r0
    242c:	0f 90       	pop	r0
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	1f 91       	pop	r17
    2434:	0f 91       	pop	r16
    2436:	ff 90       	pop	r15
    2438:	ef 90       	pop	r14
    243a:	df 90       	pop	r13
    243c:	cf 90       	pop	r12
    243e:	bf 90       	pop	r11
    2440:	af 90       	pop	r10
    2442:	9f 90       	pop	r9
    2444:	8f 90       	pop	r8
    2446:	08 95       	ret

00002448 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    2448:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    244c:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    2450:	80 81       	ld	r24, Z
    2452:	81 11       	cpse	r24, r1
    2454:	07 c0       	rjmp	.+14     	; 0x2464 <prvResetNextTaskUnblockTime+0x1c>
    2456:	8f ef       	ldi	r24, 0xFF	; 255
    2458:	9f ef       	ldi	r25, 0xFF	; 255
    245a:	90 93 6e 0d 	sts	0x0D6E, r25	; 0x800d6e <xNextTaskUnblockTime+0x1>
    245e:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <xNextTaskUnblockTime>
    2462:	08 95       	ret
    2464:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    2468:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    246c:	05 80       	ldd	r0, Z+5	; 0x05
    246e:	f6 81       	ldd	r31, Z+6	; 0x06
    2470:	e0 2d       	mov	r30, r0
    2472:	06 80       	ldd	r0, Z+6	; 0x06
    2474:	f7 81       	ldd	r31, Z+7	; 0x07
    2476:	e0 2d       	mov	r30, r0
    2478:	82 81       	ldd	r24, Z+2	; 0x02
    247a:	93 81       	ldd	r25, Z+3	; 0x03
    247c:	90 93 6e 0d 	sts	0x0D6E, r25	; 0x800d6e <xNextTaskUnblockTime+0x1>
    2480:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <xNextTaskUnblockTime>
    2484:	08 95       	ret

00002486 <prvAddCurrentTaskToDelayedList>:
    2486:	ff 92       	push	r15
    2488:	0f 93       	push	r16
    248a:	1f 93       	push	r17
    248c:	cf 93       	push	r28
    248e:	df 93       	push	r29
    2490:	ec 01       	movw	r28, r24
    2492:	f6 2e       	mov	r15, r22
    2494:	00 91 75 0d 	lds	r16, 0x0D75	; 0x800d75 <xTickCount>
    2498:	10 91 76 0d 	lds	r17, 0x0D76	; 0x800d76 <xTickCount+0x1>
    249c:	80 91 ce 0d 	lds	r24, 0x0DCE	; 0x800dce <pxCurrentTCB>
    24a0:	90 91 cf 0d 	lds	r25, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    24a4:	02 96       	adiw	r24, 0x02	; 2
    24a6:	cd db       	rcall	.-2150   	; 0x1c42 <uxListRemove>
    24a8:	cf 3f       	cpi	r28, 0xFF	; 255
    24aa:	8f ef       	ldi	r24, 0xFF	; 255
    24ac:	d8 07       	cpc	r29, r24
    24ae:	61 f4       	brne	.+24     	; 0x24c8 <prvAddCurrentTaskToDelayedList+0x42>
    24b0:	ff 20       	and	r15, r15
    24b2:	51 f0       	breq	.+20     	; 0x24c8 <prvAddCurrentTaskToDelayedList+0x42>
    24b4:	60 91 ce 0d 	lds	r22, 0x0DCE	; 0x800dce <pxCurrentTCB>
    24b8:	70 91 cf 0d 	lds	r23, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    24bc:	6e 5f       	subi	r22, 0xFE	; 254
    24be:	7f 4f       	sbci	r23, 0xFF	; 255
    24c0:	88 e7       	ldi	r24, 0x78	; 120
    24c2:	9d e0       	ldi	r25, 0x0D	; 13
    24c4:	6c db       	rcall	.-2344   	; 0x1b9e <vListInsertEnd>
    24c6:	2d c0       	rjmp	.+90     	; 0x2522 <prvAddCurrentTaskToDelayedList+0x9c>
    24c8:	c0 0f       	add	r28, r16
    24ca:	d1 1f       	adc	r29, r17
    24cc:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    24d0:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    24d4:	d3 83       	std	Z+3, r29	; 0x03
    24d6:	c2 83       	std	Z+2, r28	; 0x02
    24d8:	c0 17       	cp	r28, r16
    24da:	d1 07       	cpc	r29, r17
    24dc:	60 f4       	brcc	.+24     	; 0x24f6 <prvAddCurrentTaskToDelayedList+0x70>
    24de:	60 91 ce 0d 	lds	r22, 0x0DCE	; 0x800dce <pxCurrentTCB>
    24e2:	70 91 cf 0d 	lds	r23, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    24e6:	80 91 94 0d 	lds	r24, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    24ea:	90 91 95 0d 	lds	r25, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    24ee:	6e 5f       	subi	r22, 0xFE	; 254
    24f0:	7f 4f       	sbci	r23, 0xFF	; 255
    24f2:	76 db       	rcall	.-2324   	; 0x1be0 <vListInsert>
    24f4:	16 c0       	rjmp	.+44     	; 0x2522 <prvAddCurrentTaskToDelayedList+0x9c>
    24f6:	60 91 ce 0d 	lds	r22, 0x0DCE	; 0x800dce <pxCurrentTCB>
    24fa:	70 91 cf 0d 	lds	r23, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    24fe:	80 91 96 0d 	lds	r24, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    2502:	90 91 97 0d 	lds	r25, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    2506:	6e 5f       	subi	r22, 0xFE	; 254
    2508:	7f 4f       	sbci	r23, 0xFF	; 255
    250a:	6a db       	rcall	.-2348   	; 0x1be0 <vListInsert>
    250c:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <xNextTaskUnblockTime>
    2510:	90 91 6e 0d 	lds	r25, 0x0D6E	; 0x800d6e <xNextTaskUnblockTime+0x1>
    2514:	c8 17       	cp	r28, r24
    2516:	d9 07       	cpc	r29, r25
    2518:	20 f4       	brcc	.+8      	; 0x2522 <prvAddCurrentTaskToDelayedList+0x9c>
    251a:	d0 93 6e 0d 	sts	0x0D6E, r29	; 0x800d6e <xNextTaskUnblockTime+0x1>
    251e:	c0 93 6d 0d 	sts	0x0D6D, r28	; 0x800d6d <xNextTaskUnblockTime>
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	ff 90       	pop	r15
    252c:	08 95       	ret

0000252e <xTaskCreate>:
    252e:	4f 92       	push	r4
    2530:	5f 92       	push	r5
    2532:	6f 92       	push	r6
    2534:	7f 92       	push	r7
    2536:	8f 92       	push	r8
    2538:	9f 92       	push	r9
    253a:	af 92       	push	r10
    253c:	bf 92       	push	r11
    253e:	cf 92       	push	r12
    2540:	df 92       	push	r13
    2542:	ef 92       	push	r14
    2544:	ff 92       	push	r15
    2546:	0f 93       	push	r16
    2548:	cf 93       	push	r28
    254a:	df 93       	push	r29
    254c:	4c 01       	movw	r8, r24
    254e:	6b 01       	movw	r12, r22
    2550:	5a 01       	movw	r10, r20
    2552:	29 01       	movw	r4, r18
    2554:	ca 01       	movw	r24, r20
    2556:	dd da       	rcall	.-2630   	; 0x1b12 <pvPortMalloc>
    2558:	3c 01       	movw	r6, r24
    255a:	89 2b       	or	r24, r25
    255c:	09 f4       	brne	.+2      	; 0x2560 <xTaskCreate+0x32>
    255e:	d4 c0       	rjmp	.+424    	; 0x2708 <xTaskCreate+0x1da>
    2560:	88 e2       	ldi	r24, 0x28	; 40
    2562:	90 e0       	ldi	r25, 0x00	; 0
    2564:	d6 da       	rcall	.-2644   	; 0x1b12 <pvPortMalloc>
    2566:	ec 01       	movw	r28, r24
    2568:	89 2b       	or	r24, r25
    256a:	71 f0       	breq	.+28     	; 0x2588 <xTaskCreate+0x5a>
    256c:	78 8e       	std	Y+24, r7	; 0x18
    256e:	6f 8a       	std	Y+23, r6	; 0x17
    2570:	81 e0       	ldi	r24, 0x01	; 1
    2572:	a8 1a       	sub	r10, r24
    2574:	b1 08       	sbc	r11, r1
    2576:	6a 0c       	add	r6, r10
    2578:	7b 1c       	adc	r7, r11
    257a:	d6 01       	movw	r26, r12
    257c:	8c 91       	ld	r24, X
    257e:	89 8f       	std	Y+25, r24	; 0x19
    2580:	8c 91       	ld	r24, X
    2582:	81 11       	cpse	r24, r1
    2584:	04 c0       	rjmp	.+8      	; 0x258e <xTaskCreate+0x60>
    2586:	17 c0       	rjmp	.+46     	; 0x25b6 <xTaskCreate+0x88>
    2588:	c3 01       	movw	r24, r6
    258a:	f6 da       	rcall	.-2580   	; 0x1b78 <vPortFree>
    258c:	bd c0       	rjmp	.+378    	; 0x2708 <xTaskCreate+0x1da>
    258e:	ae 01       	movw	r20, r28
    2590:	46 5e       	subi	r20, 0xE6	; 230
    2592:	5f 4f       	sbci	r21, 0xFF	; 255
    2594:	f6 01       	movw	r30, r12
    2596:	31 96       	adiw	r30, 0x01	; 1
    2598:	b8 e0       	ldi	r27, 0x08	; 8
    259a:	cb 0e       	add	r12, r27
    259c:	d1 1c       	adc	r13, r1
    259e:	cf 01       	movw	r24, r30
    25a0:	21 91       	ld	r18, Z+
    25a2:	da 01       	movw	r26, r20
    25a4:	2d 93       	st	X+, r18
    25a6:	ad 01       	movw	r20, r26
    25a8:	dc 01       	movw	r26, r24
    25aa:	8c 91       	ld	r24, X
    25ac:	88 23       	and	r24, r24
    25ae:	19 f0       	breq	.+6      	; 0x25b6 <xTaskCreate+0x88>
    25b0:	ec 15       	cp	r30, r12
    25b2:	fd 05       	cpc	r31, r13
    25b4:	a1 f7       	brne	.-24     	; 0x259e <xTaskCreate+0x70>
    25b6:	18 a2       	std	Y+32, r1	; 0x20
    25b8:	04 30       	cpi	r16, 0x04	; 4
    25ba:	08 f0       	brcs	.+2      	; 0x25be <xTaskCreate+0x90>
    25bc:	03 e0       	ldi	r16, 0x03	; 3
    25be:	0e 8b       	std	Y+22, r16	; 0x16
    25c0:	09 a3       	std	Y+33, r16	; 0x21
    25c2:	1a a2       	std	Y+34, r1	; 0x22
    25c4:	6e 01       	movw	r12, r28
    25c6:	b2 e0       	ldi	r27, 0x02	; 2
    25c8:	cb 0e       	add	r12, r27
    25ca:	d1 1c       	adc	r13, r1
    25cc:	c6 01       	movw	r24, r12
    25ce:	e3 da       	rcall	.-2618   	; 0x1b96 <vListInitialiseItem>
    25d0:	ce 01       	movw	r24, r28
    25d2:	0c 96       	adiw	r24, 0x0c	; 12
    25d4:	e0 da       	rcall	.-2624   	; 0x1b96 <vListInitialiseItem>
    25d6:	d9 87       	std	Y+9, r29	; 0x09
    25d8:	c8 87       	std	Y+8, r28	; 0x08
    25da:	84 e0       	ldi	r24, 0x04	; 4
    25dc:	90 e0       	ldi	r25, 0x00	; 0
    25de:	80 1b       	sub	r24, r16
    25e0:	91 09       	sbc	r25, r1
    25e2:	9d 87       	std	Y+13, r25	; 0x0d
    25e4:	8c 87       	std	Y+12, r24	; 0x0c
    25e6:	db 8b       	std	Y+19, r29	; 0x13
    25e8:	ca 8b       	std	Y+18, r28	; 0x12
    25ea:	1b a2       	std	Y+35, r1	; 0x23
    25ec:	1c a2       	std	Y+36, r1	; 0x24
    25ee:	1d a2       	std	Y+37, r1	; 0x25
    25f0:	1e a2       	std	Y+38, r1	; 0x26
    25f2:	1f a2       	std	Y+39, r1	; 0x27
    25f4:	a2 01       	movw	r20, r4
    25f6:	b4 01       	movw	r22, r8
    25f8:	c3 01       	movw	r24, r6
    25fa:	49 db       	rcall	.-2414   	; 0x1c8e <pxPortInitialiseStack>
    25fc:	99 83       	std	Y+1, r25	; 0x01
    25fe:	88 83       	st	Y, r24
    2600:	e1 14       	cp	r14, r1
    2602:	f1 04       	cpc	r15, r1
    2604:	19 f0       	breq	.+6      	; 0x260c <xTaskCreate+0xde>
    2606:	f7 01       	movw	r30, r14
    2608:	d1 83       	std	Z+1, r29	; 0x01
    260a:	c0 83       	st	Z, r28
    260c:	0f b6       	in	r0, 0x3f	; 63
    260e:	f8 94       	cli
    2610:	0f 92       	push	r0
    2612:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <uxCurrentNumberOfTasks>
    2616:	8f 5f       	subi	r24, 0xFF	; 255
    2618:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <uxCurrentNumberOfTasks>
    261c:	80 91 ce 0d 	lds	r24, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2620:	90 91 cf 0d 	lds	r25, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2624:	89 2b       	or	r24, r25
    2626:	89 f5       	brne	.+98     	; 0x268a <xTaskCreate+0x15c>
    2628:	d0 93 cf 0d 	sts	0x0DCF, r29	; 0x800dcf <pxCurrentTCB+0x1>
    262c:	c0 93 ce 0d 	sts	0x0DCE, r28	; 0x800dce <pxCurrentTCB>
    2630:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <uxCurrentNumberOfTasks>
    2634:	81 30       	cpi	r24, 0x01	; 1
    2636:	09 f0       	breq	.+2      	; 0x263a <xTaskCreate+0x10c>
    2638:	38 c0       	rjmp	.+112    	; 0x26aa <xTaskCreate+0x17c>
    263a:	8a ea       	ldi	r24, 0xAA	; 170
    263c:	9d e0       	ldi	r25, 0x0D	; 13
    263e:	9d da       	rcall	.-2758   	; 0x1b7a <vListInitialise>
    2640:	83 eb       	ldi	r24, 0xB3	; 179
    2642:	9d e0       	ldi	r25, 0x0D	; 13
    2644:	9a da       	rcall	.-2764   	; 0x1b7a <vListInitialise>
    2646:	8c eb       	ldi	r24, 0xBC	; 188
    2648:	9d e0       	ldi	r25, 0x0D	; 13
    264a:	97 da       	rcall	.-2770   	; 0x1b7a <vListInitialise>
    264c:	85 ec       	ldi	r24, 0xC5	; 197
    264e:	9d e0       	ldi	r25, 0x0D	; 13
    2650:	94 da       	rcall	.-2776   	; 0x1b7a <vListInitialise>
    2652:	81 ea       	ldi	r24, 0xA1	; 161
    2654:	9d e0       	ldi	r25, 0x0D	; 13
    2656:	91 da       	rcall	.-2782   	; 0x1b7a <vListInitialise>
    2658:	88 e9       	ldi	r24, 0x98	; 152
    265a:	9d e0       	ldi	r25, 0x0D	; 13
    265c:	8e da       	rcall	.-2788   	; 0x1b7a <vListInitialise>
    265e:	8b e8       	ldi	r24, 0x8B	; 139
    2660:	9d e0       	ldi	r25, 0x0D	; 13
    2662:	8b da       	rcall	.-2794   	; 0x1b7a <vListInitialise>
    2664:	82 e8       	ldi	r24, 0x82	; 130
    2666:	9d e0       	ldi	r25, 0x0D	; 13
    2668:	88 da       	rcall	.-2800   	; 0x1b7a <vListInitialise>
    266a:	88 e7       	ldi	r24, 0x78	; 120
    266c:	9d e0       	ldi	r25, 0x0D	; 13
    266e:	85 da       	rcall	.-2806   	; 0x1b7a <vListInitialise>
    2670:	81 ea       	ldi	r24, 0xA1	; 161
    2672:	9d e0       	ldi	r25, 0x0D	; 13
    2674:	90 93 97 0d 	sts	0x0D97, r25	; 0x800d97 <pxDelayedTaskList+0x1>
    2678:	80 93 96 0d 	sts	0x0D96, r24	; 0x800d96 <pxDelayedTaskList>
    267c:	88 e9       	ldi	r24, 0x98	; 152
    267e:	9d e0       	ldi	r25, 0x0D	; 13
    2680:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    2684:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
    2688:	10 c0       	rjmp	.+32     	; 0x26aa <xTaskCreate+0x17c>
    268a:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <xSchedulerRunning>
    268e:	81 11       	cpse	r24, r1
    2690:	0c c0       	rjmp	.+24     	; 0x26aa <xTaskCreate+0x17c>
    2692:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2696:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    269a:	96 89       	ldd	r25, Z+22	; 0x16
    269c:	8e 89       	ldd	r24, Y+22	; 0x16
    269e:	89 17       	cp	r24, r25
    26a0:	20 f0       	brcs	.+8      	; 0x26aa <xTaskCreate+0x17c>
    26a2:	d0 93 cf 0d 	sts	0x0DCF, r29	; 0x800dcf <pxCurrentTCB+0x1>
    26a6:	c0 93 ce 0d 	sts	0x0DCE, r28	; 0x800dce <pxCurrentTCB>
    26aa:	80 91 6f 0d 	lds	r24, 0x0D6F	; 0x800d6f <uxTaskNumber>
    26ae:	8f 5f       	subi	r24, 0xFF	; 255
    26b0:	80 93 6f 0d 	sts	0x0D6F, r24	; 0x800d6f <uxTaskNumber>
    26b4:	8e 89       	ldd	r24, Y+22	; 0x16
    26b6:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    26ba:	98 17       	cp	r25, r24
    26bc:	10 f4       	brcc	.+4      	; 0x26c2 <xTaskCreate+0x194>
    26be:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	9c 01       	movw	r18, r24
    26c6:	22 0f       	add	r18, r18
    26c8:	33 1f       	adc	r19, r19
    26ca:	22 0f       	add	r18, r18
    26cc:	33 1f       	adc	r19, r19
    26ce:	22 0f       	add	r18, r18
    26d0:	33 1f       	adc	r19, r19
    26d2:	82 0f       	add	r24, r18
    26d4:	93 1f       	adc	r25, r19
    26d6:	b6 01       	movw	r22, r12
    26d8:	86 55       	subi	r24, 0x56	; 86
    26da:	92 4f       	sbci	r25, 0xF2	; 242
    26dc:	60 da       	rcall	.-2880   	; 0x1b9e <vListInsertEnd>
    26de:	0f 90       	pop	r0
    26e0:	0f be       	out	0x3f, r0	; 63
    26e2:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <xSchedulerRunning>
    26e6:	88 23       	and	r24, r24
    26e8:	59 f0       	breq	.+22     	; 0x2700 <xTaskCreate+0x1d2>
    26ea:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    26ee:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    26f2:	96 89       	ldd	r25, Z+22	; 0x16
    26f4:	8e 89       	ldd	r24, Y+22	; 0x16
    26f6:	98 17       	cp	r25, r24
    26f8:	28 f4       	brcc	.+10     	; 0x2704 <xTaskCreate+0x1d6>
    26fa:	6a db       	rcall	.-2348   	; 0x1dd0 <vPortYield>
    26fc:	81 e0       	ldi	r24, 0x01	; 1
    26fe:	05 c0       	rjmp	.+10     	; 0x270a <xTaskCreate+0x1dc>
    2700:	81 e0       	ldi	r24, 0x01	; 1
    2702:	03 c0       	rjmp	.+6      	; 0x270a <xTaskCreate+0x1dc>
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	01 c0       	rjmp	.+2      	; 0x270a <xTaskCreate+0x1dc>
    2708:	8f ef       	ldi	r24, 0xFF	; 255
    270a:	df 91       	pop	r29
    270c:	cf 91       	pop	r28
    270e:	0f 91       	pop	r16
    2710:	ff 90       	pop	r15
    2712:	ef 90       	pop	r14
    2714:	df 90       	pop	r13
    2716:	cf 90       	pop	r12
    2718:	bf 90       	pop	r11
    271a:	af 90       	pop	r10
    271c:	9f 90       	pop	r9
    271e:	8f 90       	pop	r8
    2720:	7f 90       	pop	r7
    2722:	6f 90       	pop	r6
    2724:	5f 90       	pop	r5
    2726:	4f 90       	pop	r4
    2728:	08 95       	ret

0000272a <vTaskStartScheduler>:
    272a:	ef 92       	push	r14
    272c:	ff 92       	push	r15
    272e:	0f 93       	push	r16
    2730:	0f 2e       	mov	r0, r31
    2732:	fb e6       	ldi	r31, 0x6B	; 107
    2734:	ef 2e       	mov	r14, r31
    2736:	fd e0       	ldi	r31, 0x0D	; 13
    2738:	ff 2e       	mov	r15, r31
    273a:	f0 2d       	mov	r31, r0
    273c:	00 e0       	ldi	r16, 0x00	; 0
    273e:	20 e0       	ldi	r18, 0x00	; 0
    2740:	30 e0       	ldi	r19, 0x00	; 0
    2742:	45 e5       	ldi	r20, 0x55	; 85
    2744:	50 e0       	ldi	r21, 0x00	; 0
    2746:	66 e9       	ldi	r22, 0x96	; 150
    2748:	71 e0       	ldi	r23, 0x01	; 1
    274a:	83 e0       	ldi	r24, 0x03	; 3
    274c:	95 e1       	ldi	r25, 0x15	; 21
    274e:	ef de       	rcall	.-546    	; 0x252e <xTaskCreate>
    2750:	81 30       	cpi	r24, 0x01	; 1
    2752:	79 f4       	brne	.+30     	; 0x2772 <vTaskStartScheduler+0x48>
    2754:	f8 94       	cli
    2756:	8f ef       	ldi	r24, 0xFF	; 255
    2758:	9f ef       	ldi	r25, 0xFF	; 255
    275a:	90 93 6e 0d 	sts	0x0D6E, r25	; 0x800d6e <xNextTaskUnblockTime+0x1>
    275e:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <xNextTaskUnblockTime>
    2762:	81 e0       	ldi	r24, 0x01	; 1
    2764:	80 93 73 0d 	sts	0x0D73, r24	; 0x800d73 <xSchedulerRunning>
    2768:	10 92 76 0d 	sts	0x0D76, r1	; 0x800d76 <xTickCount+0x1>
    276c:	10 92 75 0d 	sts	0x0D75, r1	; 0x800d75 <xTickCount>
    2770:	fa da       	rcall	.-2572   	; 0x1d66 <xPortStartScheduler>
    2772:	0f 91       	pop	r16
    2774:	ff 90       	pop	r15
    2776:	ef 90       	pop	r14
    2778:	08 95       	ret

0000277a <vTaskSuspendAll>:
    277a:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    277e:	8f 5f       	subi	r24, 0xFF	; 255
    2780:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxSchedulerSuspended>
    2784:	08 95       	ret

00002786 <xTaskIncrementTick>:
    2786:	cf 92       	push	r12
    2788:	df 92       	push	r13
    278a:	ef 92       	push	r14
    278c:	ff 92       	push	r15
    278e:	0f 93       	push	r16
    2790:	1f 93       	push	r17
    2792:	cf 93       	push	r28
    2794:	df 93       	push	r29
    2796:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    279a:	81 11       	cpse	r24, r1
    279c:	95 c0       	rjmp	.+298    	; 0x28c8 <xTaskIncrementTick+0x142>
    279e:	e0 90 75 0d 	lds	r14, 0x0D75	; 0x800d75 <xTickCount>
    27a2:	f0 90 76 0d 	lds	r15, 0x0D76	; 0x800d76 <xTickCount+0x1>
    27a6:	8f ef       	ldi	r24, 0xFF	; 255
    27a8:	e8 1a       	sub	r14, r24
    27aa:	f8 0a       	sbc	r15, r24
    27ac:	f0 92 76 0d 	sts	0x0D76, r15	; 0x800d76 <xTickCount+0x1>
    27b0:	e0 92 75 0d 	sts	0x0D75, r14	; 0x800d75 <xTickCount>
    27b4:	e1 14       	cp	r14, r1
    27b6:	f1 04       	cpc	r15, r1
    27b8:	b1 f4       	brne	.+44     	; 0x27e6 <xTaskIncrementTick+0x60>
    27ba:	80 91 96 0d 	lds	r24, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    27be:	90 91 97 0d 	lds	r25, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    27c2:	20 91 94 0d 	lds	r18, 0x0D94	; 0x800d94 <pxOverflowDelayedTaskList>
    27c6:	30 91 95 0d 	lds	r19, 0x0D95	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    27ca:	30 93 97 0d 	sts	0x0D97, r19	; 0x800d97 <pxDelayedTaskList+0x1>
    27ce:	20 93 96 0d 	sts	0x0D96, r18	; 0x800d96 <pxDelayedTaskList>
    27d2:	90 93 95 0d 	sts	0x0D95, r25	; 0x800d95 <pxOverflowDelayedTaskList+0x1>
    27d6:	80 93 94 0d 	sts	0x0D94, r24	; 0x800d94 <pxOverflowDelayedTaskList>
    27da:	80 91 70 0d 	lds	r24, 0x0D70	; 0x800d70 <xNumOfOverflows>
    27de:	8f 5f       	subi	r24, 0xFF	; 255
    27e0:	80 93 70 0d 	sts	0x0D70, r24	; 0x800d70 <xNumOfOverflows>
    27e4:	31 de       	rcall	.-926    	; 0x2448 <prvResetNextTaskUnblockTime>
    27e6:	80 91 6d 0d 	lds	r24, 0x0D6D	; 0x800d6d <xNextTaskUnblockTime>
    27ea:	90 91 6e 0d 	lds	r25, 0x0D6E	; 0x800d6e <xNextTaskUnblockTime+0x1>
    27ee:	e8 16       	cp	r14, r24
    27f0:	f9 06       	cpc	r15, r25
    27f2:	10 f4       	brcc	.+4      	; 0x27f8 <xTaskIncrementTick+0x72>
    27f4:	d1 2c       	mov	r13, r1
    27f6:	50 c0       	rjmp	.+160    	; 0x2898 <xTaskIncrementTick+0x112>
    27f8:	d1 2c       	mov	r13, r1
    27fa:	cc 24       	eor	r12, r12
    27fc:	c3 94       	inc	r12
    27fe:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    2802:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    2806:	80 81       	ld	r24, Z
    2808:	81 11       	cpse	r24, r1
    280a:	07 c0       	rjmp	.+14     	; 0x281a <xTaskIncrementTick+0x94>
    280c:	8f ef       	ldi	r24, 0xFF	; 255
    280e:	9f ef       	ldi	r25, 0xFF	; 255
    2810:	90 93 6e 0d 	sts	0x0D6E, r25	; 0x800d6e <xNextTaskUnblockTime+0x1>
    2814:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <xNextTaskUnblockTime>
    2818:	3f c0       	rjmp	.+126    	; 0x2898 <xTaskIncrementTick+0x112>
    281a:	e0 91 96 0d 	lds	r30, 0x0D96	; 0x800d96 <pxDelayedTaskList>
    281e:	f0 91 97 0d 	lds	r31, 0x0D97	; 0x800d97 <pxDelayedTaskList+0x1>
    2822:	05 80       	ldd	r0, Z+5	; 0x05
    2824:	f6 81       	ldd	r31, Z+6	; 0x06
    2826:	e0 2d       	mov	r30, r0
    2828:	c6 81       	ldd	r28, Z+6	; 0x06
    282a:	d7 81       	ldd	r29, Z+7	; 0x07
    282c:	8a 81       	ldd	r24, Y+2	; 0x02
    282e:	9b 81       	ldd	r25, Y+3	; 0x03
    2830:	e8 16       	cp	r14, r24
    2832:	f9 06       	cpc	r15, r25
    2834:	28 f4       	brcc	.+10     	; 0x2840 <xTaskIncrementTick+0xba>
    2836:	90 93 6e 0d 	sts	0x0D6E, r25	; 0x800d6e <xNextTaskUnblockTime+0x1>
    283a:	80 93 6d 0d 	sts	0x0D6D, r24	; 0x800d6d <xNextTaskUnblockTime>
    283e:	2c c0       	rjmp	.+88     	; 0x2898 <xTaskIncrementTick+0x112>
    2840:	8e 01       	movw	r16, r28
    2842:	0e 5f       	subi	r16, 0xFE	; 254
    2844:	1f 4f       	sbci	r17, 0xFF	; 255
    2846:	c8 01       	movw	r24, r16
    2848:	fc d9       	rcall	.-3080   	; 0x1c42 <uxListRemove>
    284a:	8c 89       	ldd	r24, Y+20	; 0x14
    284c:	9d 89       	ldd	r25, Y+21	; 0x15
    284e:	89 2b       	or	r24, r25
    2850:	19 f0       	breq	.+6      	; 0x2858 <xTaskIncrementTick+0xd2>
    2852:	ce 01       	movw	r24, r28
    2854:	0c 96       	adiw	r24, 0x0c	; 12
    2856:	f5 d9       	rcall	.-3094   	; 0x1c42 <uxListRemove>
    2858:	8e 89       	ldd	r24, Y+22	; 0x16
    285a:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    285e:	98 17       	cp	r25, r24
    2860:	10 f4       	brcc	.+4      	; 0x2866 <xTaskIncrementTick+0xe0>
    2862:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    2866:	90 e0       	ldi	r25, 0x00	; 0
    2868:	9c 01       	movw	r18, r24
    286a:	22 0f       	add	r18, r18
    286c:	33 1f       	adc	r19, r19
    286e:	22 0f       	add	r18, r18
    2870:	33 1f       	adc	r19, r19
    2872:	22 0f       	add	r18, r18
    2874:	33 1f       	adc	r19, r19
    2876:	82 0f       	add	r24, r18
    2878:	93 1f       	adc	r25, r19
    287a:	b8 01       	movw	r22, r16
    287c:	86 55       	subi	r24, 0x56	; 86
    287e:	92 4f       	sbci	r25, 0xF2	; 242
    2880:	8e d9       	rcall	.-3300   	; 0x1b9e <vListInsertEnd>
    2882:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2886:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    288a:	9e 89       	ldd	r25, Y+22	; 0x16
    288c:	86 89       	ldd	r24, Z+22	; 0x16
    288e:	98 17       	cp	r25, r24
    2890:	08 f4       	brcc	.+2      	; 0x2894 <xTaskIncrementTick+0x10e>
    2892:	b5 cf       	rjmp	.-150    	; 0x27fe <xTaskIncrementTick+0x78>
    2894:	dc 2c       	mov	r13, r12
    2896:	b3 cf       	rjmp	.-154    	; 0x27fe <xTaskIncrementTick+0x78>
    2898:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    289c:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    28a0:	86 89       	ldd	r24, Z+22	; 0x16
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	fc 01       	movw	r30, r24
    28a6:	ee 0f       	add	r30, r30
    28a8:	ff 1f       	adc	r31, r31
    28aa:	ee 0f       	add	r30, r30
    28ac:	ff 1f       	adc	r31, r31
    28ae:	ee 0f       	add	r30, r30
    28b0:	ff 1f       	adc	r31, r31
    28b2:	8e 0f       	add	r24, r30
    28b4:	9f 1f       	adc	r25, r31
    28b6:	fc 01       	movw	r30, r24
    28b8:	e6 55       	subi	r30, 0x56	; 86
    28ba:	f2 4f       	sbci	r31, 0xF2	; 242
    28bc:	80 81       	ld	r24, Z
    28be:	82 30       	cpi	r24, 0x02	; 2
    28c0:	48 f0       	brcs	.+18     	; 0x28d4 <xTaskIncrementTick+0x14e>
    28c2:	dd 24       	eor	r13, r13
    28c4:	d3 94       	inc	r13
    28c6:	06 c0       	rjmp	.+12     	; 0x28d4 <xTaskIncrementTick+0x14e>
    28c8:	80 91 72 0d 	lds	r24, 0x0D72	; 0x800d72 <uxPendedTicks>
    28cc:	8f 5f       	subi	r24, 0xFF	; 255
    28ce:	80 93 72 0d 	sts	0x0D72, r24	; 0x800d72 <uxPendedTicks>
    28d2:	d1 2c       	mov	r13, r1
    28d4:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <xYieldPending>
    28d8:	88 23       	and	r24, r24
    28da:	11 f0       	breq	.+4      	; 0x28e0 <xTaskIncrementTick+0x15a>
    28dc:	dd 24       	eor	r13, r13
    28de:	d3 94       	inc	r13
    28e0:	8d 2d       	mov	r24, r13
    28e2:	df 91       	pop	r29
    28e4:	cf 91       	pop	r28
    28e6:	1f 91       	pop	r17
    28e8:	0f 91       	pop	r16
    28ea:	ff 90       	pop	r15
    28ec:	ef 90       	pop	r14
    28ee:	df 90       	pop	r13
    28f0:	cf 90       	pop	r12
    28f2:	08 95       	ret

000028f4 <xTaskResumeAll>:
    28f4:	df 92       	push	r13
    28f6:	ef 92       	push	r14
    28f8:	ff 92       	push	r15
    28fa:	0f 93       	push	r16
    28fc:	1f 93       	push	r17
    28fe:	cf 93       	push	r28
    2900:	df 93       	push	r29
    2902:	0f b6       	in	r0, 0x3f	; 63
    2904:	f8 94       	cli
    2906:	0f 92       	push	r0
    2908:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    290c:	81 50       	subi	r24, 0x01	; 1
    290e:	80 93 6a 0d 	sts	0x0D6A, r24	; 0x800d6a <uxSchedulerSuspended>
    2912:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    2916:	81 11       	cpse	r24, r1
    2918:	59 c0       	rjmp	.+178    	; 0x29cc <xTaskResumeAll+0xd8>
    291a:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <uxCurrentNumberOfTasks>
    291e:	81 11       	cpse	r24, r1
    2920:	30 c0       	rjmp	.+96     	; 0x2982 <xTaskResumeAll+0x8e>
    2922:	57 c0       	rjmp	.+174    	; 0x29d2 <xTaskResumeAll+0xde>
    2924:	d7 01       	movw	r26, r14
    2926:	15 96       	adiw	r26, 0x05	; 5
    2928:	ed 91       	ld	r30, X+
    292a:	fc 91       	ld	r31, X
    292c:	16 97       	sbiw	r26, 0x06	; 6
    292e:	c6 81       	ldd	r28, Z+6	; 0x06
    2930:	d7 81       	ldd	r29, Z+7	; 0x07
    2932:	ce 01       	movw	r24, r28
    2934:	0c 96       	adiw	r24, 0x0c	; 12
    2936:	85 d9       	rcall	.-3318   	; 0x1c42 <uxListRemove>
    2938:	8e 01       	movw	r16, r28
    293a:	0e 5f       	subi	r16, 0xFE	; 254
    293c:	1f 4f       	sbci	r17, 0xFF	; 255
    293e:	c8 01       	movw	r24, r16
    2940:	80 d9       	rcall	.-3328   	; 0x1c42 <uxListRemove>
    2942:	8e 89       	ldd	r24, Y+22	; 0x16
    2944:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    2948:	98 17       	cp	r25, r24
    294a:	10 f4       	brcc	.+4      	; 0x2950 <xTaskResumeAll+0x5c>
    294c:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    2950:	90 e0       	ldi	r25, 0x00	; 0
    2952:	9c 01       	movw	r18, r24
    2954:	22 0f       	add	r18, r18
    2956:	33 1f       	adc	r19, r19
    2958:	22 0f       	add	r18, r18
    295a:	33 1f       	adc	r19, r19
    295c:	22 0f       	add	r18, r18
    295e:	33 1f       	adc	r19, r19
    2960:	82 0f       	add	r24, r18
    2962:	93 1f       	adc	r25, r19
    2964:	b8 01       	movw	r22, r16
    2966:	86 55       	subi	r24, 0x56	; 86
    2968:	92 4f       	sbci	r25, 0xF2	; 242
    296a:	19 d9       	rcall	.-3534   	; 0x1b9e <vListInsertEnd>
    296c:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2970:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2974:	9e 89       	ldd	r25, Y+22	; 0x16
    2976:	86 89       	ldd	r24, Z+22	; 0x16
    2978:	98 17       	cp	r25, r24
    297a:	68 f0       	brcs	.+26     	; 0x2996 <xTaskResumeAll+0xa2>
    297c:	d0 92 71 0d 	sts	0x0D71, r13	; 0x800d71 <xYieldPending>
    2980:	0a c0       	rjmp	.+20     	; 0x2996 <xTaskResumeAll+0xa2>
    2982:	c0 e0       	ldi	r28, 0x00	; 0
    2984:	d0 e0       	ldi	r29, 0x00	; 0
    2986:	0f 2e       	mov	r0, r31
    2988:	fb e8       	ldi	r31, 0x8B	; 139
    298a:	ef 2e       	mov	r14, r31
    298c:	fd e0       	ldi	r31, 0x0D	; 13
    298e:	ff 2e       	mov	r15, r31
    2990:	f0 2d       	mov	r31, r0
    2992:	dd 24       	eor	r13, r13
    2994:	d3 94       	inc	r13
    2996:	f7 01       	movw	r30, r14
    2998:	80 81       	ld	r24, Z
    299a:	81 11       	cpse	r24, r1
    299c:	c3 cf       	rjmp	.-122    	; 0x2924 <xTaskResumeAll+0x30>
    299e:	cd 2b       	or	r28, r29
    29a0:	09 f0       	breq	.+2      	; 0x29a4 <xTaskResumeAll+0xb0>
    29a2:	52 dd       	rcall	.-1372   	; 0x2448 <prvResetNextTaskUnblockTime>
    29a4:	c0 91 72 0d 	lds	r28, 0x0D72	; 0x800d72 <uxPendedTicks>
    29a8:	cc 23       	and	r28, r28
    29aa:	49 f0       	breq	.+18     	; 0x29be <xTaskResumeAll+0xca>
    29ac:	d1 e0       	ldi	r29, 0x01	; 1
    29ae:	eb de       	rcall	.-554    	; 0x2786 <xTaskIncrementTick>
    29b0:	81 11       	cpse	r24, r1
    29b2:	d0 93 71 0d 	sts	0x0D71, r29	; 0x800d71 <xYieldPending>
    29b6:	c1 50       	subi	r28, 0x01	; 1
    29b8:	d1 f7       	brne	.-12     	; 0x29ae <xTaskResumeAll+0xba>
    29ba:	10 92 72 0d 	sts	0x0D72, r1	; 0x800d72 <uxPendedTicks>
    29be:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <xYieldPending>
    29c2:	88 23       	and	r24, r24
    29c4:	29 f0       	breq	.+10     	; 0x29d0 <xTaskResumeAll+0xdc>
    29c6:	04 da       	rcall	.-3064   	; 0x1dd0 <vPortYield>
    29c8:	81 e0       	ldi	r24, 0x01	; 1
    29ca:	03 c0       	rjmp	.+6      	; 0x29d2 <xTaskResumeAll+0xde>
    29cc:	80 e0       	ldi	r24, 0x00	; 0
    29ce:	01 c0       	rjmp	.+2      	; 0x29d2 <xTaskResumeAll+0xde>
    29d0:	80 e0       	ldi	r24, 0x00	; 0
    29d2:	0f 90       	pop	r0
    29d4:	0f be       	out	0x3f, r0	; 63
    29d6:	df 91       	pop	r29
    29d8:	cf 91       	pop	r28
    29da:	1f 91       	pop	r17
    29dc:	0f 91       	pop	r16
    29de:	ff 90       	pop	r15
    29e0:	ef 90       	pop	r14
    29e2:	df 90       	pop	r13
    29e4:	08 95       	ret

000029e6 <vTaskDelay>:
    29e6:	cf 93       	push	r28
    29e8:	df 93       	push	r29
    29ea:	ec 01       	movw	r28, r24
    29ec:	89 2b       	or	r24, r25
    29ee:	39 f0       	breq	.+14     	; 0x29fe <vTaskDelay+0x18>
    29f0:	c4 de       	rcall	.-632    	; 0x277a <vTaskSuspendAll>
    29f2:	60 e0       	ldi	r22, 0x00	; 0
    29f4:	ce 01       	movw	r24, r28
    29f6:	47 dd       	rcall	.-1394   	; 0x2486 <prvAddCurrentTaskToDelayedList>
    29f8:	7d df       	rcall	.-262    	; 0x28f4 <xTaskResumeAll>
    29fa:	81 11       	cpse	r24, r1
    29fc:	01 c0       	rjmp	.+2      	; 0x2a00 <vTaskDelay+0x1a>
    29fe:	e8 d9       	rcall	.-3120   	; 0x1dd0 <vPortYield>
    2a00:	df 91       	pop	r29
    2a02:	cf 91       	pop	r28
    2a04:	08 95       	ret

00002a06 <prvIdleTask>:
    2a06:	02 e8       	ldi	r16, 0x82	; 130
    2a08:	1d e0       	ldi	r17, 0x0D	; 13
    2a0a:	0f 2e       	mov	r0, r31
    2a0c:	fa ea       	ldi	r31, 0xAA	; 170
    2a0e:	ef 2e       	mov	r14, r31
    2a10:	fd e0       	ldi	r31, 0x0D	; 13
    2a12:	ff 2e       	mov	r15, r31
    2a14:	f0 2d       	mov	r31, r0
    2a16:	24 c0       	rjmp	.+72     	; 0x2a60 <prvIdleTask+0x5a>
    2a18:	b0 de       	rcall	.-672    	; 0x277a <vTaskSuspendAll>
    2a1a:	d8 01       	movw	r26, r16
    2a1c:	cc 91       	ld	r28, X
    2a1e:	6a df       	rcall	.-300    	; 0x28f4 <xTaskResumeAll>
    2a20:	cc 23       	and	r28, r28
    2a22:	f1 f0       	breq	.+60     	; 0x2a60 <prvIdleTask+0x5a>
    2a24:	0f b6       	in	r0, 0x3f	; 63
    2a26:	f8 94       	cli
    2a28:	0f 92       	push	r0
    2a2a:	d8 01       	movw	r26, r16
    2a2c:	15 96       	adiw	r26, 0x05	; 5
    2a2e:	ed 91       	ld	r30, X+
    2a30:	fc 91       	ld	r31, X
    2a32:	16 97       	sbiw	r26, 0x06	; 6
    2a34:	c6 81       	ldd	r28, Z+6	; 0x06
    2a36:	d7 81       	ldd	r29, Z+7	; 0x07
    2a38:	ce 01       	movw	r24, r28
    2a3a:	02 96       	adiw	r24, 0x02	; 2
    2a3c:	02 d9       	rcall	.-3580   	; 0x1c42 <uxListRemove>
    2a3e:	80 91 77 0d 	lds	r24, 0x0D77	; 0x800d77 <uxCurrentNumberOfTasks>
    2a42:	81 50       	subi	r24, 0x01	; 1
    2a44:	80 93 77 0d 	sts	0x0D77, r24	; 0x800d77 <uxCurrentNumberOfTasks>
    2a48:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
    2a4c:	81 50       	subi	r24, 0x01	; 1
    2a4e:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
    2a52:	0f 90       	pop	r0
    2a54:	0f be       	out	0x3f, r0	; 63
    2a56:	8f 89       	ldd	r24, Y+23	; 0x17
    2a58:	98 8d       	ldd	r25, Y+24	; 0x18
    2a5a:	8e d8       	rcall	.-3812   	; 0x1b78 <vPortFree>
    2a5c:	ce 01       	movw	r24, r28
    2a5e:	8c d8       	rcall	.-3816   	; 0x1b78 <vPortFree>
    2a60:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <uxDeletedTasksWaitingCleanUp>
    2a64:	81 11       	cpse	r24, r1
    2a66:	d8 cf       	rjmp	.-80     	; 0x2a18 <prvIdleTask+0x12>
    2a68:	f7 01       	movw	r30, r14
    2a6a:	80 81       	ld	r24, Z
    2a6c:	82 30       	cpi	r24, 0x02	; 2
    2a6e:	c0 f3       	brcs	.-16     	; 0x2a60 <prvIdleTask+0x5a>
    2a70:	af d9       	rcall	.-3234   	; 0x1dd0 <vPortYield>
    2a72:	f6 cf       	rjmp	.-20     	; 0x2a60 <prvIdleTask+0x5a>

00002a74 <vTaskSwitchContext>:
    2a74:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    2a78:	88 23       	and	r24, r24
    2a7a:	21 f0       	breq	.+8      	; 0x2a84 <vTaskSwitchContext+0x10>
    2a7c:	81 e0       	ldi	r24, 0x01	; 1
    2a7e:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <xYieldPending>
    2a82:	08 95       	ret
    2a84:	10 92 71 0d 	sts	0x0D71, r1	; 0x800d71 <xYieldPending>
    2a88:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2a8c:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2a90:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2a94:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2a98:	2d 91       	ld	r18, X+
    2a9a:	3c 91       	ld	r19, X
    2a9c:	87 89       	ldd	r24, Z+23	; 0x17
    2a9e:	90 8d       	ldd	r25, Z+24	; 0x18
    2aa0:	82 17       	cp	r24, r18
    2aa2:	93 07       	cpc	r25, r19
    2aa4:	58 f0       	brcs	.+22     	; 0x2abc <vTaskSwitchContext+0x48>
    2aa6:	60 91 ce 0d 	lds	r22, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2aaa:	70 91 cf 0d 	lds	r23, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2aae:	80 91 ce 0d 	lds	r24, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2ab2:	90 91 cf 0d 	lds	r25, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2ab6:	67 5e       	subi	r22, 0xE7	; 231
    2ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    2aba:	2a d8       	rcall	.-4012   	; 0x1b10 <vApplicationStackOverflowHook>
    2abc:	20 91 74 0d 	lds	r18, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    2ac0:	82 2f       	mov	r24, r18
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	fc 01       	movw	r30, r24
    2ac6:	ee 0f       	add	r30, r30
    2ac8:	ff 1f       	adc	r31, r31
    2aca:	ee 0f       	add	r30, r30
    2acc:	ff 1f       	adc	r31, r31
    2ace:	ee 0f       	add	r30, r30
    2ad0:	ff 1f       	adc	r31, r31
    2ad2:	e8 0f       	add	r30, r24
    2ad4:	f9 1f       	adc	r31, r25
    2ad6:	e6 55       	subi	r30, 0x56	; 86
    2ad8:	f2 4f       	sbci	r31, 0xF2	; 242
    2ada:	30 81       	ld	r19, Z
    2adc:	31 11       	cpse	r19, r1
    2ade:	11 c0       	rjmp	.+34     	; 0x2b02 <vTaskSwitchContext+0x8e>
    2ae0:	21 50       	subi	r18, 0x01	; 1
    2ae2:	82 2f       	mov	r24, r18
    2ae4:	90 e0       	ldi	r25, 0x00	; 0
    2ae6:	fc 01       	movw	r30, r24
    2ae8:	ee 0f       	add	r30, r30
    2aea:	ff 1f       	adc	r31, r31
    2aec:	ee 0f       	add	r30, r30
    2aee:	ff 1f       	adc	r31, r31
    2af0:	ee 0f       	add	r30, r30
    2af2:	ff 1f       	adc	r31, r31
    2af4:	e8 0f       	add	r30, r24
    2af6:	f9 1f       	adc	r31, r25
    2af8:	e6 55       	subi	r30, 0x56	; 86
    2afa:	f2 4f       	sbci	r31, 0xF2	; 242
    2afc:	30 81       	ld	r19, Z
    2afe:	33 23       	and	r19, r19
    2b00:	79 f3       	breq	.-34     	; 0x2ae0 <vTaskSwitchContext+0x6c>
    2b02:	ac 01       	movw	r20, r24
    2b04:	44 0f       	add	r20, r20
    2b06:	55 1f       	adc	r21, r21
    2b08:	44 0f       	add	r20, r20
    2b0a:	55 1f       	adc	r21, r21
    2b0c:	44 0f       	add	r20, r20
    2b0e:	55 1f       	adc	r21, r21
    2b10:	48 0f       	add	r20, r24
    2b12:	59 1f       	adc	r21, r25
    2b14:	da 01       	movw	r26, r20
    2b16:	a6 55       	subi	r26, 0x56	; 86
    2b18:	b2 4f       	sbci	r27, 0xF2	; 242
    2b1a:	11 96       	adiw	r26, 0x01	; 1
    2b1c:	ed 91       	ld	r30, X+
    2b1e:	fc 91       	ld	r31, X
    2b20:	12 97       	sbiw	r26, 0x02	; 2
    2b22:	02 80       	ldd	r0, Z+2	; 0x02
    2b24:	f3 81       	ldd	r31, Z+3	; 0x03
    2b26:	e0 2d       	mov	r30, r0
    2b28:	12 96       	adiw	r26, 0x02	; 2
    2b2a:	fc 93       	st	X, r31
    2b2c:	ee 93       	st	-X, r30
    2b2e:	11 97       	sbiw	r26, 0x01	; 1
    2b30:	43 55       	subi	r20, 0x53	; 83
    2b32:	52 4f       	sbci	r21, 0xF2	; 242
    2b34:	e4 17       	cp	r30, r20
    2b36:	f5 07       	cpc	r31, r21
    2b38:	29 f4       	brne	.+10     	; 0x2b44 <vTaskSwitchContext+0xd0>
    2b3a:	42 81       	ldd	r20, Z+2	; 0x02
    2b3c:	53 81       	ldd	r21, Z+3	; 0x03
    2b3e:	fd 01       	movw	r30, r26
    2b40:	52 83       	std	Z+2, r21	; 0x02
    2b42:	41 83       	std	Z+1, r20	; 0x01
    2b44:	fc 01       	movw	r30, r24
    2b46:	ee 0f       	add	r30, r30
    2b48:	ff 1f       	adc	r31, r31
    2b4a:	ee 0f       	add	r30, r30
    2b4c:	ff 1f       	adc	r31, r31
    2b4e:	ee 0f       	add	r30, r30
    2b50:	ff 1f       	adc	r31, r31
    2b52:	8e 0f       	add	r24, r30
    2b54:	9f 1f       	adc	r25, r31
    2b56:	fc 01       	movw	r30, r24
    2b58:	e6 55       	subi	r30, 0x56	; 86
    2b5a:	f2 4f       	sbci	r31, 0xF2	; 242
    2b5c:	01 80       	ldd	r0, Z+1	; 0x01
    2b5e:	f2 81       	ldd	r31, Z+2	; 0x02
    2b60:	e0 2d       	mov	r30, r0
    2b62:	86 81       	ldd	r24, Z+6	; 0x06
    2b64:	97 81       	ldd	r25, Z+7	; 0x07
    2b66:	90 93 cf 0d 	sts	0x0DCF, r25	; 0x800dcf <pxCurrentTCB+0x1>
    2b6a:	80 93 ce 0d 	sts	0x0DCE, r24	; 0x800dce <pxCurrentTCB>
    2b6e:	20 93 74 0d 	sts	0x0D74, r18	; 0x800d74 <uxTopReadyPriority>
    2b72:	08 95       	ret

00002b74 <vTaskPlaceOnEventList>:
    2b74:	cf 93       	push	r28
    2b76:	df 93       	push	r29
    2b78:	eb 01       	movw	r28, r22
    2b7a:	60 91 ce 0d 	lds	r22, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2b7e:	70 91 cf 0d 	lds	r23, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2b82:	64 5f       	subi	r22, 0xF4	; 244
    2b84:	7f 4f       	sbci	r23, 0xFF	; 255
    2b86:	2c d8       	rcall	.-4008   	; 0x1be0 <vListInsert>
    2b88:	61 e0       	ldi	r22, 0x01	; 1
    2b8a:	ce 01       	movw	r24, r28
    2b8c:	7c dc       	rcall	.-1800   	; 0x2486 <prvAddCurrentTaskToDelayedList>
    2b8e:	df 91       	pop	r29
    2b90:	cf 91       	pop	r28
    2b92:	08 95       	ret

00002b94 <xTaskRemoveFromEventList>:
    2b94:	0f 93       	push	r16
    2b96:	1f 93       	push	r17
    2b98:	cf 93       	push	r28
    2b9a:	df 93       	push	r29
    2b9c:	dc 01       	movw	r26, r24
    2b9e:	15 96       	adiw	r26, 0x05	; 5
    2ba0:	ed 91       	ld	r30, X+
    2ba2:	fc 91       	ld	r31, X
    2ba4:	16 97       	sbiw	r26, 0x06	; 6
    2ba6:	c6 81       	ldd	r28, Z+6	; 0x06
    2ba8:	d7 81       	ldd	r29, Z+7	; 0x07
    2baa:	8e 01       	movw	r16, r28
    2bac:	04 5f       	subi	r16, 0xF4	; 244
    2bae:	1f 4f       	sbci	r17, 0xFF	; 255
    2bb0:	c8 01       	movw	r24, r16
    2bb2:	47 d8       	rcall	.-3954   	; 0x1c42 <uxListRemove>
    2bb4:	80 91 6a 0d 	lds	r24, 0x0D6A	; 0x800d6a <uxSchedulerSuspended>
    2bb8:	81 11       	cpse	r24, r1
    2bba:	1b c0       	rjmp	.+54     	; 0x2bf2 <xTaskRemoveFromEventList+0x5e>
    2bbc:	0a 50       	subi	r16, 0x0A	; 10
    2bbe:	11 09       	sbc	r17, r1
    2bc0:	c8 01       	movw	r24, r16
    2bc2:	3f d8       	rcall	.-3970   	; 0x1c42 <uxListRemove>
    2bc4:	8e 89       	ldd	r24, Y+22	; 0x16
    2bc6:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    2bca:	98 17       	cp	r25, r24
    2bcc:	10 f4       	brcc	.+4      	; 0x2bd2 <xTaskRemoveFromEventList+0x3e>
    2bce:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	9c 01       	movw	r18, r24
    2bd6:	22 0f       	add	r18, r18
    2bd8:	33 1f       	adc	r19, r19
    2bda:	22 0f       	add	r18, r18
    2bdc:	33 1f       	adc	r19, r19
    2bde:	22 0f       	add	r18, r18
    2be0:	33 1f       	adc	r19, r19
    2be2:	82 0f       	add	r24, r18
    2be4:	93 1f       	adc	r25, r19
    2be6:	b8 01       	movw	r22, r16
    2be8:	86 55       	subi	r24, 0x56	; 86
    2bea:	92 4f       	sbci	r25, 0xF2	; 242
    2bec:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <vListInsertEnd>
    2bf0:	05 c0       	rjmp	.+10     	; 0x2bfc <xTaskRemoveFromEventList+0x68>
    2bf2:	b8 01       	movw	r22, r16
    2bf4:	8b e8       	ldi	r24, 0x8B	; 139
    2bf6:	9d e0       	ldi	r25, 0x0D	; 13
    2bf8:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <vListInsertEnd>
    2bfc:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2c00:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2c04:	9e 89       	ldd	r25, Y+22	; 0x16
    2c06:	86 89       	ldd	r24, Z+22	; 0x16
    2c08:	89 17       	cp	r24, r25
    2c0a:	20 f4       	brcc	.+8      	; 0x2c14 <xTaskRemoveFromEventList+0x80>
    2c0c:	81 e0       	ldi	r24, 0x01	; 1
    2c0e:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <xYieldPending>
    2c12:	01 c0       	rjmp	.+2      	; 0x2c16 <xTaskRemoveFromEventList+0x82>
    2c14:	80 e0       	ldi	r24, 0x00	; 0
    2c16:	df 91       	pop	r29
    2c18:	cf 91       	pop	r28
    2c1a:	1f 91       	pop	r17
    2c1c:	0f 91       	pop	r16
    2c1e:	08 95       	ret

00002c20 <vTaskSetTimeOutState>:
    2c20:	20 91 70 0d 	lds	r18, 0x0D70	; 0x800d70 <xNumOfOverflows>
    2c24:	fc 01       	movw	r30, r24
    2c26:	20 83       	st	Z, r18
    2c28:	20 91 75 0d 	lds	r18, 0x0D75	; 0x800d75 <xTickCount>
    2c2c:	30 91 76 0d 	lds	r19, 0x0D76	; 0x800d76 <xTickCount+0x1>
    2c30:	32 83       	std	Z+2, r19	; 0x02
    2c32:	21 83       	std	Z+1, r18	; 0x01
    2c34:	08 95       	ret

00002c36 <xTaskCheckForTimeOut>:
    2c36:	0f b6       	in	r0, 0x3f	; 63
    2c38:	f8 94       	cli
    2c3a:	0f 92       	push	r0
    2c3c:	40 91 75 0d 	lds	r20, 0x0D75	; 0x800d75 <xTickCount>
    2c40:	50 91 76 0d 	lds	r21, 0x0D76	; 0x800d76 <xTickCount+0x1>
    2c44:	db 01       	movw	r26, r22
    2c46:	2d 91       	ld	r18, X+
    2c48:	3c 91       	ld	r19, X
    2c4a:	2f 3f       	cpi	r18, 0xFF	; 255
    2c4c:	bf ef       	ldi	r27, 0xFF	; 255
    2c4e:	3b 07       	cpc	r19, r27
    2c50:	11 f1       	breq	.+68     	; 0x2c96 <xTaskCheckForTimeOut+0x60>
    2c52:	e0 91 70 0d 	lds	r30, 0x0D70	; 0x800d70 <xNumOfOverflows>
    2c56:	dc 01       	movw	r26, r24
    2c58:	fc 91       	ld	r31, X
    2c5a:	fe 17       	cp	r31, r30
    2c5c:	39 f0       	breq	.+14     	; 0x2c6c <xTaskCheckForTimeOut+0x36>
    2c5e:	11 96       	adiw	r26, 0x01	; 1
    2c60:	ed 91       	ld	r30, X+
    2c62:	fc 91       	ld	r31, X
    2c64:	12 97       	sbiw	r26, 0x02	; 2
    2c66:	4e 17       	cp	r20, r30
    2c68:	5f 07       	cpc	r21, r31
    2c6a:	b8 f4       	brcc	.+46     	; 0x2c9a <xTaskCheckForTimeOut+0x64>
    2c6c:	dc 01       	movw	r26, r24
    2c6e:	11 96       	adiw	r26, 0x01	; 1
    2c70:	ed 91       	ld	r30, X+
    2c72:	fc 91       	ld	r31, X
    2c74:	12 97       	sbiw	r26, 0x02	; 2
    2c76:	da 01       	movw	r26, r20
    2c78:	ae 1b       	sub	r26, r30
    2c7a:	bf 0b       	sbc	r27, r31
    2c7c:	a2 17       	cp	r26, r18
    2c7e:	b3 07       	cpc	r27, r19
    2c80:	70 f4       	brcc	.+28     	; 0x2c9e <xTaskCheckForTimeOut+0x68>
    2c82:	db 01       	movw	r26, r22
    2c84:	e4 1b       	sub	r30, r20
    2c86:	f5 0b       	sbc	r31, r21
    2c88:	2e 0f       	add	r18, r30
    2c8a:	3f 1f       	adc	r19, r31
    2c8c:	2d 93       	st	X+, r18
    2c8e:	3c 93       	st	X, r19
    2c90:	c7 df       	rcall	.-114    	; 0x2c20 <vTaskSetTimeOutState>
    2c92:	80 e0       	ldi	r24, 0x00	; 0
    2c94:	05 c0       	rjmp	.+10     	; 0x2ca0 <xTaskCheckForTimeOut+0x6a>
    2c96:	80 e0       	ldi	r24, 0x00	; 0
    2c98:	03 c0       	rjmp	.+6      	; 0x2ca0 <xTaskCheckForTimeOut+0x6a>
    2c9a:	81 e0       	ldi	r24, 0x01	; 1
    2c9c:	01 c0       	rjmp	.+2      	; 0x2ca0 <xTaskCheckForTimeOut+0x6a>
    2c9e:	81 e0       	ldi	r24, 0x01	; 1
    2ca0:	0f 90       	pop	r0
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	08 95       	ret

00002ca6 <vTaskMissedYield>:
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <xYieldPending>
    2cac:	08 95       	ret

00002cae <vTaskPriorityInherit>:
    2cae:	0f 93       	push	r16
    2cb0:	1f 93       	push	r17
    2cb2:	cf 93       	push	r28
    2cb4:	df 93       	push	r29
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	89 2b       	or	r24, r25
    2cba:	09 f4       	brne	.+2      	; 0x2cbe <vTaskPriorityInherit+0x10>
    2cbc:	55 c0       	rjmp	.+170    	; 0x2d68 <vTaskPriorityInherit+0xba>
    2cbe:	26 89       	ldd	r18, Z+22	; 0x16
    2cc0:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2cc4:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2cc8:	56 96       	adiw	r26, 0x16	; 22
    2cca:	8c 91       	ld	r24, X
    2ccc:	28 17       	cp	r18, r24
    2cce:	08 f0       	brcs	.+2      	; 0x2cd2 <vTaskPriorityInherit+0x24>
    2cd0:	4b c0       	rjmp	.+150    	; 0x2d68 <vTaskPriorityInherit+0xba>
    2cd2:	84 85       	ldd	r24, Z+12	; 0x0c
    2cd4:	95 85       	ldd	r25, Z+13	; 0x0d
    2cd6:	99 23       	and	r25, r25
    2cd8:	64 f0       	brlt	.+24     	; 0x2cf2 <vTaskPriorityInherit+0x44>
    2cda:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2cde:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2ce2:	56 96       	adiw	r26, 0x16	; 22
    2ce4:	3c 91       	ld	r19, X
    2ce6:	84 e0       	ldi	r24, 0x04	; 4
    2ce8:	90 e0       	ldi	r25, 0x00	; 0
    2cea:	83 1b       	sub	r24, r19
    2cec:	91 09       	sbc	r25, r1
    2cee:	95 87       	std	Z+13, r25	; 0x0d
    2cf0:	84 87       	std	Z+12, r24	; 0x0c
    2cf2:	30 e0       	ldi	r19, 0x00	; 0
    2cf4:	c9 01       	movw	r24, r18
    2cf6:	88 0f       	add	r24, r24
    2cf8:	99 1f       	adc	r25, r25
    2cfa:	88 0f       	add	r24, r24
    2cfc:	99 1f       	adc	r25, r25
    2cfe:	88 0f       	add	r24, r24
    2d00:	99 1f       	adc	r25, r25
    2d02:	28 0f       	add	r18, r24
    2d04:	39 1f       	adc	r19, r25
    2d06:	26 55       	subi	r18, 0x56	; 86
    2d08:	32 4f       	sbci	r19, 0xF2	; 242
    2d0a:	82 85       	ldd	r24, Z+10	; 0x0a
    2d0c:	93 85       	ldd	r25, Z+11	; 0x0b
    2d0e:	82 17       	cp	r24, r18
    2d10:	93 07       	cpc	r25, r19
    2d12:	19 f5       	brne	.+70     	; 0x2d5a <vTaskPriorityInherit+0xac>
    2d14:	8f 01       	movw	r16, r30
    2d16:	ef 01       	movw	r28, r30
    2d18:	22 96       	adiw	r28, 0x02	; 2
    2d1a:	ce 01       	movw	r24, r28
    2d1c:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <uxListRemove>
    2d20:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2d24:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2d28:	86 89       	ldd	r24, Z+22	; 0x16
    2d2a:	f8 01       	movw	r30, r16
    2d2c:	86 8b       	std	Z+22, r24	; 0x16
    2d2e:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    2d32:	98 17       	cp	r25, r24
    2d34:	10 f4       	brcc	.+4      	; 0x2d3a <vTaskPriorityInherit+0x8c>
    2d36:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    2d3a:	90 e0       	ldi	r25, 0x00	; 0
    2d3c:	9c 01       	movw	r18, r24
    2d3e:	22 0f       	add	r18, r18
    2d40:	33 1f       	adc	r19, r19
    2d42:	22 0f       	add	r18, r18
    2d44:	33 1f       	adc	r19, r19
    2d46:	22 0f       	add	r18, r18
    2d48:	33 1f       	adc	r19, r19
    2d4a:	82 0f       	add	r24, r18
    2d4c:	93 1f       	adc	r25, r19
    2d4e:	be 01       	movw	r22, r28
    2d50:	86 55       	subi	r24, 0x56	; 86
    2d52:	92 4f       	sbci	r25, 0xF2	; 242
    2d54:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <vListInsertEnd>
    2d58:	07 c0       	rjmp	.+14     	; 0x2d68 <vTaskPriorityInherit+0xba>
    2d5a:	a0 91 ce 0d 	lds	r26, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2d5e:	b0 91 cf 0d 	lds	r27, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2d62:	56 96       	adiw	r26, 0x16	; 22
    2d64:	8c 91       	ld	r24, X
    2d66:	86 8b       	std	Z+22, r24	; 0x16
    2d68:	df 91       	pop	r29
    2d6a:	cf 91       	pop	r28
    2d6c:	1f 91       	pop	r17
    2d6e:	0f 91       	pop	r16
    2d70:	08 95       	ret

00002d72 <xTaskPriorityDisinherit>:
    2d72:	0f 93       	push	r16
    2d74:	1f 93       	push	r17
    2d76:	cf 93       	push	r28
    2d78:	df 93       	push	r29
    2d7a:	fc 01       	movw	r30, r24
    2d7c:	89 2b       	or	r24, r25
    2d7e:	79 f1       	breq	.+94     	; 0x2dde <xTaskPriorityDisinherit+0x6c>
    2d80:	82 a1       	ldd	r24, Z+34	; 0x22
    2d82:	81 50       	subi	r24, 0x01	; 1
    2d84:	82 a3       	std	Z+34, r24	; 0x22
    2d86:	26 89       	ldd	r18, Z+22	; 0x16
    2d88:	91 a1       	ldd	r25, Z+33	; 0x21
    2d8a:	29 17       	cp	r18, r25
    2d8c:	51 f1       	breq	.+84     	; 0x2de2 <xTaskPriorityDisinherit+0x70>
    2d8e:	81 11       	cpse	r24, r1
    2d90:	2a c0       	rjmp	.+84     	; 0x2de6 <xTaskPriorityDisinherit+0x74>
    2d92:	ef 01       	movw	r28, r30
    2d94:	8f 01       	movw	r16, r30
    2d96:	0e 5f       	subi	r16, 0xFE	; 254
    2d98:	1f 4f       	sbci	r17, 0xFF	; 255
    2d9a:	c8 01       	movw	r24, r16
    2d9c:	0e 94 21 0e 	call	0x1c42	; 0x1c42 <uxListRemove>
    2da0:	89 a1       	ldd	r24, Y+33	; 0x21
    2da2:	8e 8b       	std	Y+22, r24	; 0x16
    2da4:	24 e0       	ldi	r18, 0x04	; 4
    2da6:	30 e0       	ldi	r19, 0x00	; 0
    2da8:	28 1b       	sub	r18, r24
    2daa:	31 09       	sbc	r19, r1
    2dac:	3d 87       	std	Y+13, r19	; 0x0d
    2dae:	2c 87       	std	Y+12, r18	; 0x0c
    2db0:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <uxTopReadyPriority>
    2db4:	98 17       	cp	r25, r24
    2db6:	10 f4       	brcc	.+4      	; 0x2dbc <xTaskPriorityDisinherit+0x4a>
    2db8:	80 93 74 0d 	sts	0x0D74, r24	; 0x800d74 <uxTopReadyPriority>
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	9c 01       	movw	r18, r24
    2dc0:	22 0f       	add	r18, r18
    2dc2:	33 1f       	adc	r19, r19
    2dc4:	22 0f       	add	r18, r18
    2dc6:	33 1f       	adc	r19, r19
    2dc8:	22 0f       	add	r18, r18
    2dca:	33 1f       	adc	r19, r19
    2dcc:	82 0f       	add	r24, r18
    2dce:	93 1f       	adc	r25, r19
    2dd0:	b8 01       	movw	r22, r16
    2dd2:	86 55       	subi	r24, 0x56	; 86
    2dd4:	92 4f       	sbci	r25, 0xF2	; 242
    2dd6:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <vListInsertEnd>
    2dda:	81 e0       	ldi	r24, 0x01	; 1
    2ddc:	05 c0       	rjmp	.+10     	; 0x2de8 <xTaskPriorityDisinherit+0x76>
    2dde:	80 e0       	ldi	r24, 0x00	; 0
    2de0:	03 c0       	rjmp	.+6      	; 0x2de8 <xTaskPriorityDisinherit+0x76>
    2de2:	80 e0       	ldi	r24, 0x00	; 0
    2de4:	01 c0       	rjmp	.+2      	; 0x2de8 <xTaskPriorityDisinherit+0x76>
    2de6:	80 e0       	ldi	r24, 0x00	; 0
    2de8:	df 91       	pop	r29
    2dea:	cf 91       	pop	r28
    2dec:	1f 91       	pop	r17
    2dee:	0f 91       	pop	r16
    2df0:	08 95       	ret

00002df2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2df2:	80 91 ce 0d 	lds	r24, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2df6:	90 91 cf 0d 	lds	r25, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2dfa:	89 2b       	or	r24, r25
    2dfc:	39 f0       	breq	.+14     	; 0x2e0c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2dfe:	e0 91 ce 0d 	lds	r30, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2e02:	f0 91 cf 0d 	lds	r31, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
    2e06:	82 a1       	ldd	r24, Z+34	; 0x22
    2e08:	8f 5f       	subi	r24, 0xFF	; 255
    2e0a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2e0c:	80 91 ce 0d 	lds	r24, 0x0DCE	; 0x800dce <pxCurrentTCB>
    2e10:	90 91 cf 0d 	lds	r25, 0x0DCF	; 0x800dcf <pxCurrentTCB+0x1>
	}
    2e14:	08 95       	ret

00002e16 <__subsf3>:
    2e16:	50 58       	subi	r21, 0x80	; 128

00002e18 <__addsf3>:
    2e18:	bb 27       	eor	r27, r27
    2e1a:	aa 27       	eor	r26, r26
    2e1c:	0e d0       	rcall	.+28     	; 0x2e3a <__addsf3x>
    2e1e:	e0 c0       	rjmp	.+448    	; 0x2fe0 <__fp_round>
    2e20:	d1 d0       	rcall	.+418    	; 0x2fc4 <__fp_pscA>
    2e22:	30 f0       	brcs	.+12     	; 0x2e30 <__addsf3+0x18>
    2e24:	d6 d0       	rcall	.+428    	; 0x2fd2 <__fp_pscB>
    2e26:	20 f0       	brcs	.+8      	; 0x2e30 <__addsf3+0x18>
    2e28:	31 f4       	brne	.+12     	; 0x2e36 <__addsf3+0x1e>
    2e2a:	9f 3f       	cpi	r25, 0xFF	; 255
    2e2c:	11 f4       	brne	.+4      	; 0x2e32 <__addsf3+0x1a>
    2e2e:	1e f4       	brtc	.+6      	; 0x2e36 <__addsf3+0x1e>
    2e30:	c6 c0       	rjmp	.+396    	; 0x2fbe <__fp_nan>
    2e32:	0e f4       	brtc	.+2      	; 0x2e36 <__addsf3+0x1e>
    2e34:	e0 95       	com	r30
    2e36:	e7 fb       	bst	r30, 7
    2e38:	bc c0       	rjmp	.+376    	; 0x2fb2 <__fp_inf>

00002e3a <__addsf3x>:
    2e3a:	e9 2f       	mov	r30, r25
    2e3c:	e2 d0       	rcall	.+452    	; 0x3002 <__fp_split3>
    2e3e:	80 f3       	brcs	.-32     	; 0x2e20 <__addsf3+0x8>
    2e40:	ba 17       	cp	r27, r26
    2e42:	62 07       	cpc	r22, r18
    2e44:	73 07       	cpc	r23, r19
    2e46:	84 07       	cpc	r24, r20
    2e48:	95 07       	cpc	r25, r21
    2e4a:	18 f0       	brcs	.+6      	; 0x2e52 <__addsf3x+0x18>
    2e4c:	71 f4       	brne	.+28     	; 0x2e6a <__addsf3x+0x30>
    2e4e:	9e f5       	brtc	.+102    	; 0x2eb6 <__addsf3x+0x7c>
    2e50:	fa c0       	rjmp	.+500    	; 0x3046 <__fp_zero>
    2e52:	0e f4       	brtc	.+2      	; 0x2e56 <__addsf3x+0x1c>
    2e54:	e0 95       	com	r30
    2e56:	0b 2e       	mov	r0, r27
    2e58:	ba 2f       	mov	r27, r26
    2e5a:	a0 2d       	mov	r26, r0
    2e5c:	0b 01       	movw	r0, r22
    2e5e:	b9 01       	movw	r22, r18
    2e60:	90 01       	movw	r18, r0
    2e62:	0c 01       	movw	r0, r24
    2e64:	ca 01       	movw	r24, r20
    2e66:	a0 01       	movw	r20, r0
    2e68:	11 24       	eor	r1, r1
    2e6a:	ff 27       	eor	r31, r31
    2e6c:	59 1b       	sub	r21, r25
    2e6e:	99 f0       	breq	.+38     	; 0x2e96 <__addsf3x+0x5c>
    2e70:	59 3f       	cpi	r21, 0xF9	; 249
    2e72:	50 f4       	brcc	.+20     	; 0x2e88 <__addsf3x+0x4e>
    2e74:	50 3e       	cpi	r21, 0xE0	; 224
    2e76:	68 f1       	brcs	.+90     	; 0x2ed2 <__addsf3x+0x98>
    2e78:	1a 16       	cp	r1, r26
    2e7a:	f0 40       	sbci	r31, 0x00	; 0
    2e7c:	a2 2f       	mov	r26, r18
    2e7e:	23 2f       	mov	r18, r19
    2e80:	34 2f       	mov	r19, r20
    2e82:	44 27       	eor	r20, r20
    2e84:	58 5f       	subi	r21, 0xF8	; 248
    2e86:	f3 cf       	rjmp	.-26     	; 0x2e6e <__addsf3x+0x34>
    2e88:	46 95       	lsr	r20
    2e8a:	37 95       	ror	r19
    2e8c:	27 95       	ror	r18
    2e8e:	a7 95       	ror	r26
    2e90:	f0 40       	sbci	r31, 0x00	; 0
    2e92:	53 95       	inc	r21
    2e94:	c9 f7       	brne	.-14     	; 0x2e88 <__addsf3x+0x4e>
    2e96:	7e f4       	brtc	.+30     	; 0x2eb6 <__addsf3x+0x7c>
    2e98:	1f 16       	cp	r1, r31
    2e9a:	ba 0b       	sbc	r27, r26
    2e9c:	62 0b       	sbc	r22, r18
    2e9e:	73 0b       	sbc	r23, r19
    2ea0:	84 0b       	sbc	r24, r20
    2ea2:	ba f0       	brmi	.+46     	; 0x2ed2 <__addsf3x+0x98>
    2ea4:	91 50       	subi	r25, 0x01	; 1
    2ea6:	a1 f0       	breq	.+40     	; 0x2ed0 <__addsf3x+0x96>
    2ea8:	ff 0f       	add	r31, r31
    2eaa:	bb 1f       	adc	r27, r27
    2eac:	66 1f       	adc	r22, r22
    2eae:	77 1f       	adc	r23, r23
    2eb0:	88 1f       	adc	r24, r24
    2eb2:	c2 f7       	brpl	.-16     	; 0x2ea4 <__addsf3x+0x6a>
    2eb4:	0e c0       	rjmp	.+28     	; 0x2ed2 <__addsf3x+0x98>
    2eb6:	ba 0f       	add	r27, r26
    2eb8:	62 1f       	adc	r22, r18
    2eba:	73 1f       	adc	r23, r19
    2ebc:	84 1f       	adc	r24, r20
    2ebe:	48 f4       	brcc	.+18     	; 0x2ed2 <__addsf3x+0x98>
    2ec0:	87 95       	ror	r24
    2ec2:	77 95       	ror	r23
    2ec4:	67 95       	ror	r22
    2ec6:	b7 95       	ror	r27
    2ec8:	f7 95       	ror	r31
    2eca:	9e 3f       	cpi	r25, 0xFE	; 254
    2ecc:	08 f0       	brcs	.+2      	; 0x2ed0 <__addsf3x+0x96>
    2ece:	b3 cf       	rjmp	.-154    	; 0x2e36 <__addsf3+0x1e>
    2ed0:	93 95       	inc	r25
    2ed2:	88 0f       	add	r24, r24
    2ed4:	08 f0       	brcs	.+2      	; 0x2ed8 <__addsf3x+0x9e>
    2ed6:	99 27       	eor	r25, r25
    2ed8:	ee 0f       	add	r30, r30
    2eda:	97 95       	ror	r25
    2edc:	87 95       	ror	r24
    2ede:	08 95       	ret

00002ee0 <__fixunssfsi>:
    2ee0:	98 d0       	rcall	.+304    	; 0x3012 <__fp_splitA>
    2ee2:	88 f0       	brcs	.+34     	; 0x2f06 <__fixunssfsi+0x26>
    2ee4:	9f 57       	subi	r25, 0x7F	; 127
    2ee6:	90 f0       	brcs	.+36     	; 0x2f0c <__fixunssfsi+0x2c>
    2ee8:	b9 2f       	mov	r27, r25
    2eea:	99 27       	eor	r25, r25
    2eec:	b7 51       	subi	r27, 0x17	; 23
    2eee:	a0 f0       	brcs	.+40     	; 0x2f18 <__fixunssfsi+0x38>
    2ef0:	d1 f0       	breq	.+52     	; 0x2f26 <__fixunssfsi+0x46>
    2ef2:	66 0f       	add	r22, r22
    2ef4:	77 1f       	adc	r23, r23
    2ef6:	88 1f       	adc	r24, r24
    2ef8:	99 1f       	adc	r25, r25
    2efa:	1a f0       	brmi	.+6      	; 0x2f02 <__fixunssfsi+0x22>
    2efc:	ba 95       	dec	r27
    2efe:	c9 f7       	brne	.-14     	; 0x2ef2 <__fixunssfsi+0x12>
    2f00:	12 c0       	rjmp	.+36     	; 0x2f26 <__fixunssfsi+0x46>
    2f02:	b1 30       	cpi	r27, 0x01	; 1
    2f04:	81 f0       	breq	.+32     	; 0x2f26 <__fixunssfsi+0x46>
    2f06:	9f d0       	rcall	.+318    	; 0x3046 <__fp_zero>
    2f08:	b1 e0       	ldi	r27, 0x01	; 1
    2f0a:	08 95       	ret
    2f0c:	9c c0       	rjmp	.+312    	; 0x3046 <__fp_zero>
    2f0e:	67 2f       	mov	r22, r23
    2f10:	78 2f       	mov	r23, r24
    2f12:	88 27       	eor	r24, r24
    2f14:	b8 5f       	subi	r27, 0xF8	; 248
    2f16:	39 f0       	breq	.+14     	; 0x2f26 <__fixunssfsi+0x46>
    2f18:	b9 3f       	cpi	r27, 0xF9	; 249
    2f1a:	cc f3       	brlt	.-14     	; 0x2f0e <__fixunssfsi+0x2e>
    2f1c:	86 95       	lsr	r24
    2f1e:	77 95       	ror	r23
    2f20:	67 95       	ror	r22
    2f22:	b3 95       	inc	r27
    2f24:	d9 f7       	brne	.-10     	; 0x2f1c <__fixunssfsi+0x3c>
    2f26:	3e f4       	brtc	.+14     	; 0x2f36 <__fixunssfsi+0x56>
    2f28:	90 95       	com	r25
    2f2a:	80 95       	com	r24
    2f2c:	70 95       	com	r23
    2f2e:	61 95       	neg	r22
    2f30:	7f 4f       	sbci	r23, 0xFF	; 255
    2f32:	8f 4f       	sbci	r24, 0xFF	; 255
    2f34:	9f 4f       	sbci	r25, 0xFF	; 255
    2f36:	08 95       	ret

00002f38 <__floatunsisf>:
    2f38:	e8 94       	clt
    2f3a:	09 c0       	rjmp	.+18     	; 0x2f4e <__floatsisf+0x12>

00002f3c <__floatsisf>:
    2f3c:	97 fb       	bst	r25, 7
    2f3e:	3e f4       	brtc	.+14     	; 0x2f4e <__floatsisf+0x12>
    2f40:	90 95       	com	r25
    2f42:	80 95       	com	r24
    2f44:	70 95       	com	r23
    2f46:	61 95       	neg	r22
    2f48:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4a:	8f 4f       	sbci	r24, 0xFF	; 255
    2f4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f4e:	99 23       	and	r25, r25
    2f50:	a9 f0       	breq	.+42     	; 0x2f7c <__floatsisf+0x40>
    2f52:	f9 2f       	mov	r31, r25
    2f54:	96 e9       	ldi	r25, 0x96	; 150
    2f56:	bb 27       	eor	r27, r27
    2f58:	93 95       	inc	r25
    2f5a:	f6 95       	lsr	r31
    2f5c:	87 95       	ror	r24
    2f5e:	77 95       	ror	r23
    2f60:	67 95       	ror	r22
    2f62:	b7 95       	ror	r27
    2f64:	f1 11       	cpse	r31, r1
    2f66:	f8 cf       	rjmp	.-16     	; 0x2f58 <__floatsisf+0x1c>
    2f68:	fa f4       	brpl	.+62     	; 0x2fa8 <__floatsisf+0x6c>
    2f6a:	bb 0f       	add	r27, r27
    2f6c:	11 f4       	brne	.+4      	; 0x2f72 <__floatsisf+0x36>
    2f6e:	60 ff       	sbrs	r22, 0
    2f70:	1b c0       	rjmp	.+54     	; 0x2fa8 <__floatsisf+0x6c>
    2f72:	6f 5f       	subi	r22, 0xFF	; 255
    2f74:	7f 4f       	sbci	r23, 0xFF	; 255
    2f76:	8f 4f       	sbci	r24, 0xFF	; 255
    2f78:	9f 4f       	sbci	r25, 0xFF	; 255
    2f7a:	16 c0       	rjmp	.+44     	; 0x2fa8 <__floatsisf+0x6c>
    2f7c:	88 23       	and	r24, r24
    2f7e:	11 f0       	breq	.+4      	; 0x2f84 <__floatsisf+0x48>
    2f80:	96 e9       	ldi	r25, 0x96	; 150
    2f82:	11 c0       	rjmp	.+34     	; 0x2fa6 <__floatsisf+0x6a>
    2f84:	77 23       	and	r23, r23
    2f86:	21 f0       	breq	.+8      	; 0x2f90 <__floatsisf+0x54>
    2f88:	9e e8       	ldi	r25, 0x8E	; 142
    2f8a:	87 2f       	mov	r24, r23
    2f8c:	76 2f       	mov	r23, r22
    2f8e:	05 c0       	rjmp	.+10     	; 0x2f9a <__floatsisf+0x5e>
    2f90:	66 23       	and	r22, r22
    2f92:	71 f0       	breq	.+28     	; 0x2fb0 <__floatsisf+0x74>
    2f94:	96 e8       	ldi	r25, 0x86	; 134
    2f96:	86 2f       	mov	r24, r22
    2f98:	70 e0       	ldi	r23, 0x00	; 0
    2f9a:	60 e0       	ldi	r22, 0x00	; 0
    2f9c:	2a f0       	brmi	.+10     	; 0x2fa8 <__floatsisf+0x6c>
    2f9e:	9a 95       	dec	r25
    2fa0:	66 0f       	add	r22, r22
    2fa2:	77 1f       	adc	r23, r23
    2fa4:	88 1f       	adc	r24, r24
    2fa6:	da f7       	brpl	.-10     	; 0x2f9e <__floatsisf+0x62>
    2fa8:	88 0f       	add	r24, r24
    2faa:	96 95       	lsr	r25
    2fac:	87 95       	ror	r24
    2fae:	97 f9       	bld	r25, 7
    2fb0:	08 95       	ret

00002fb2 <__fp_inf>:
    2fb2:	97 f9       	bld	r25, 7
    2fb4:	9f 67       	ori	r25, 0x7F	; 127
    2fb6:	80 e8       	ldi	r24, 0x80	; 128
    2fb8:	70 e0       	ldi	r23, 0x00	; 0
    2fba:	60 e0       	ldi	r22, 0x00	; 0
    2fbc:	08 95       	ret

00002fbe <__fp_nan>:
    2fbe:	9f ef       	ldi	r25, 0xFF	; 255
    2fc0:	80 ec       	ldi	r24, 0xC0	; 192
    2fc2:	08 95       	ret

00002fc4 <__fp_pscA>:
    2fc4:	00 24       	eor	r0, r0
    2fc6:	0a 94       	dec	r0
    2fc8:	16 16       	cp	r1, r22
    2fca:	17 06       	cpc	r1, r23
    2fcc:	18 06       	cpc	r1, r24
    2fce:	09 06       	cpc	r0, r25
    2fd0:	08 95       	ret

00002fd2 <__fp_pscB>:
    2fd2:	00 24       	eor	r0, r0
    2fd4:	0a 94       	dec	r0
    2fd6:	12 16       	cp	r1, r18
    2fd8:	13 06       	cpc	r1, r19
    2fda:	14 06       	cpc	r1, r20
    2fdc:	05 06       	cpc	r0, r21
    2fde:	08 95       	ret

00002fe0 <__fp_round>:
    2fe0:	09 2e       	mov	r0, r25
    2fe2:	03 94       	inc	r0
    2fe4:	00 0c       	add	r0, r0
    2fe6:	11 f4       	brne	.+4      	; 0x2fec <__fp_round+0xc>
    2fe8:	88 23       	and	r24, r24
    2fea:	52 f0       	brmi	.+20     	; 0x3000 <__fp_round+0x20>
    2fec:	bb 0f       	add	r27, r27
    2fee:	40 f4       	brcc	.+16     	; 0x3000 <__fp_round+0x20>
    2ff0:	bf 2b       	or	r27, r31
    2ff2:	11 f4       	brne	.+4      	; 0x2ff8 <__fp_round+0x18>
    2ff4:	60 ff       	sbrs	r22, 0
    2ff6:	04 c0       	rjmp	.+8      	; 0x3000 <__fp_round+0x20>
    2ff8:	6f 5f       	subi	r22, 0xFF	; 255
    2ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    2ffc:	8f 4f       	sbci	r24, 0xFF	; 255
    2ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    3000:	08 95       	ret

00003002 <__fp_split3>:
    3002:	57 fd       	sbrc	r21, 7
    3004:	90 58       	subi	r25, 0x80	; 128
    3006:	44 0f       	add	r20, r20
    3008:	55 1f       	adc	r21, r21
    300a:	59 f0       	breq	.+22     	; 0x3022 <__fp_splitA+0x10>
    300c:	5f 3f       	cpi	r21, 0xFF	; 255
    300e:	71 f0       	breq	.+28     	; 0x302c <__fp_splitA+0x1a>
    3010:	47 95       	ror	r20

00003012 <__fp_splitA>:
    3012:	88 0f       	add	r24, r24
    3014:	97 fb       	bst	r25, 7
    3016:	99 1f       	adc	r25, r25
    3018:	61 f0       	breq	.+24     	; 0x3032 <__fp_splitA+0x20>
    301a:	9f 3f       	cpi	r25, 0xFF	; 255
    301c:	79 f0       	breq	.+30     	; 0x303c <__fp_splitA+0x2a>
    301e:	87 95       	ror	r24
    3020:	08 95       	ret
    3022:	12 16       	cp	r1, r18
    3024:	13 06       	cpc	r1, r19
    3026:	14 06       	cpc	r1, r20
    3028:	55 1f       	adc	r21, r21
    302a:	f2 cf       	rjmp	.-28     	; 0x3010 <__fp_split3+0xe>
    302c:	46 95       	lsr	r20
    302e:	f1 df       	rcall	.-30     	; 0x3012 <__fp_splitA>
    3030:	08 c0       	rjmp	.+16     	; 0x3042 <__fp_splitA+0x30>
    3032:	16 16       	cp	r1, r22
    3034:	17 06       	cpc	r1, r23
    3036:	18 06       	cpc	r1, r24
    3038:	99 1f       	adc	r25, r25
    303a:	f1 cf       	rjmp	.-30     	; 0x301e <__fp_splitA+0xc>
    303c:	86 95       	lsr	r24
    303e:	71 05       	cpc	r23, r1
    3040:	61 05       	cpc	r22, r1
    3042:	08 94       	sec
    3044:	08 95       	ret

00003046 <__fp_zero>:
    3046:	e8 94       	clt

00003048 <__fp_szero>:
    3048:	bb 27       	eor	r27, r27
    304a:	66 27       	eor	r22, r22
    304c:	77 27       	eor	r23, r23
    304e:	cb 01       	movw	r24, r22
    3050:	97 f9       	bld	r25, 7
    3052:	08 95       	ret

00003054 <__udivmodsi4>:
    3054:	a1 e2       	ldi	r26, 0x21	; 33
    3056:	1a 2e       	mov	r1, r26
    3058:	aa 1b       	sub	r26, r26
    305a:	bb 1b       	sub	r27, r27
    305c:	fd 01       	movw	r30, r26
    305e:	0d c0       	rjmp	.+26     	; 0x307a <__udivmodsi4_ep>

00003060 <__udivmodsi4_loop>:
    3060:	aa 1f       	adc	r26, r26
    3062:	bb 1f       	adc	r27, r27
    3064:	ee 1f       	adc	r30, r30
    3066:	ff 1f       	adc	r31, r31
    3068:	a2 17       	cp	r26, r18
    306a:	b3 07       	cpc	r27, r19
    306c:	e4 07       	cpc	r30, r20
    306e:	f5 07       	cpc	r31, r21
    3070:	20 f0       	brcs	.+8      	; 0x307a <__udivmodsi4_ep>
    3072:	a2 1b       	sub	r26, r18
    3074:	b3 0b       	sbc	r27, r19
    3076:	e4 0b       	sbc	r30, r20
    3078:	f5 0b       	sbc	r31, r21

0000307a <__udivmodsi4_ep>:
    307a:	66 1f       	adc	r22, r22
    307c:	77 1f       	adc	r23, r23
    307e:	88 1f       	adc	r24, r24
    3080:	99 1f       	adc	r25, r25
    3082:	1a 94       	dec	r1
    3084:	69 f7       	brne	.-38     	; 0x3060 <__udivmodsi4_loop>
    3086:	60 95       	com	r22
    3088:	70 95       	com	r23
    308a:	80 95       	com	r24
    308c:	90 95       	com	r25
    308e:	9b 01       	movw	r18, r22
    3090:	ac 01       	movw	r20, r24
    3092:	bd 01       	movw	r22, r26
    3094:	cf 01       	movw	r24, r30
    3096:	08 95       	ret

00003098 <memcpy>:
    3098:	fb 01       	movw	r30, r22
    309a:	dc 01       	movw	r26, r24
    309c:	02 c0       	rjmp	.+4      	; 0x30a2 <memcpy+0xa>
    309e:	01 90       	ld	r0, Z+
    30a0:	0d 92       	st	X+, r0
    30a2:	41 50       	subi	r20, 0x01	; 1
    30a4:	50 40       	sbci	r21, 0x00	; 0
    30a6:	d8 f7       	brcc	.-10     	; 0x309e <memcpy+0x6>
    30a8:	08 95       	ret

000030aa <eeprom_read_byte>:
    30aa:	e1 99       	sbic	0x1c, 1	; 28
    30ac:	fe cf       	rjmp	.-4      	; 0x30aa <eeprom_read_byte>
    30ae:	9f bb       	out	0x1f, r25	; 31
    30b0:	8e bb       	out	0x1e, r24	; 30
    30b2:	e0 9a       	sbi	0x1c, 0	; 28
    30b4:	99 27       	eor	r25, r25
    30b6:	8d b3       	in	r24, 0x1d	; 29
    30b8:	08 95       	ret

000030ba <eeprom_update_byte>:
    30ba:	26 2f       	mov	r18, r22

000030bc <eeprom_update_r18>:
    30bc:	e1 99       	sbic	0x1c, 1	; 28
    30be:	fe cf       	rjmp	.-4      	; 0x30bc <eeprom_update_r18>
    30c0:	9f bb       	out	0x1f, r25	; 31
    30c2:	8e bb       	out	0x1e, r24	; 30
    30c4:	e0 9a       	sbi	0x1c, 0	; 28
    30c6:	01 97       	sbiw	r24, 0x01	; 1
    30c8:	0d b2       	in	r0, 0x1d	; 29
    30ca:	02 16       	cp	r0, r18
    30cc:	31 f0       	breq	.+12     	; 0x30da <eeprom_update_r18+0x1e>
    30ce:	2d bb       	out	0x1d, r18	; 29
    30d0:	0f b6       	in	r0, 0x3f	; 63
    30d2:	f8 94       	cli
    30d4:	e2 9a       	sbi	0x1c, 2	; 28
    30d6:	e1 9a       	sbi	0x1c, 1	; 28
    30d8:	0f be       	out	0x3f, r0	; 63
    30da:	08 95       	ret

000030dc <_exit>:
    30dc:	f8 94       	cli

000030de <__stop_program>:
    30de:	ff cf       	rjmp	.-2      	; 0x30de <__stop_program>
