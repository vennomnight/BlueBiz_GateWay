
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ac  00800100  0000314e  000031e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000314e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c34  008001ac  008001ac  0000328e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000328e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000032c0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000940  00000000  00000000  00003300  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b9c0  00000000  00000000  00003c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003235  00000000  00000000  0000f600  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000052ed  00000000  00000000  00012835  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000189c  00000000  00000000  00017b24  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000033af  00000000  00000000  000193c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007f68  00000000  00000000  0001c76f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000930  00000000  00000000  000246d7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	8a c3       	rjmp	.+1812   	; 0x71a <__vector_1>
       6:	00 00       	nop
       8:	60 c0       	rjmp	.+192    	; 0xca <__bad_interrupt>
       a:	00 00       	nop
       c:	5e c0       	rjmp	.+188    	; 0xca <__bad_interrupt>
       e:	00 00       	nop
      10:	5c c0       	rjmp	.+184    	; 0xca <__bad_interrupt>
      12:	00 00       	nop
      14:	5a c0       	rjmp	.+180    	; 0xca <__bad_interrupt>
      16:	00 00       	nop
      18:	58 c0       	rjmp	.+176    	; 0xca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	56 c0       	rjmp	.+172    	; 0xca <__bad_interrupt>
      1e:	00 00       	nop
      20:	54 c0       	rjmp	.+168    	; 0xca <__bad_interrupt>
      22:	00 00       	nop
      24:	4d c4       	rjmp	.+2202   	; 0x8c0 <__vector_9>
      26:	00 00       	nop
      28:	50 c0       	rjmp	.+160    	; 0xca <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4e c0       	rjmp	.+156    	; 0xca <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 d1 0f 	jmp	0x1fa2	; 0x1fa2 <__vector_12>
      34:	4a c0       	rjmp	.+148    	; 0xca <__bad_interrupt>
      36:	00 00       	nop
      38:	48 c0       	rjmp	.+144    	; 0xca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	e1 c1       	rjmp	.+962    	; 0x400 <__vector_15>
      3e:	00 00       	nop
      40:	44 c0       	rjmp	.+136    	; 0xca <__bad_interrupt>
      42:	00 00       	nop
      44:	42 c0       	rjmp	.+132    	; 0xca <__bad_interrupt>
      46:	00 00       	nop
      48:	d7 c2       	rjmp	.+1454   	; 0x5f8 <__vector_18>
      4a:	00 00       	nop
      4c:	3e c0       	rjmp	.+124    	; 0xca <__bad_interrupt>
      4e:	00 00       	nop
      50:	3c c0       	rjmp	.+120    	; 0xca <__bad_interrupt>
      52:	00 00       	nop
      54:	3a c0       	rjmp	.+116    	; 0xca <__bad_interrupt>
      56:	00 00       	nop
      58:	38 c0       	rjmp	.+112    	; 0xca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	36 c0       	rjmp	.+108    	; 0xca <__bad_interrupt>
      5e:	00 00       	nop
      60:	34 c0       	rjmp	.+104    	; 0xca <__bad_interrupt>
      62:	00 00       	nop
      64:	32 c0       	rjmp	.+100    	; 0xca <__bad_interrupt>
      66:	00 00       	nop
      68:	30 c0       	rjmp	.+96     	; 0xca <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2e c0       	rjmp	.+92     	; 0xca <__bad_interrupt>
      6e:	00 00       	nop
      70:	24 c3       	rjmp	.+1608   	; 0x6ba <__vector_28>
      72:	00 00       	nop
      74:	2a c0       	rjmp	.+84     	; 0xca <__bad_interrupt>
      76:	00 00       	nop
      78:	ef c2       	rjmp	.+1502   	; 0x658 <__vector_30>
      7a:	00 00       	nop
      7c:	26 c0       	rjmp	.+76     	; 0xca <__bad_interrupt>
      7e:	00 00       	nop
      80:	24 c0       	rjmp	.+72     	; 0xca <__bad_interrupt>
      82:	00 00       	nop
      84:	22 c0       	rjmp	.+68     	; 0xca <__bad_interrupt>
      86:	00 00       	nop
      88:	20 c0       	rjmp	.+64     	; 0xca <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ee e4       	ldi	r30, 0x4E	; 78
      a0:	f1 e3       	ldi	r31, 0x31	; 49
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 3a       	cpi	r26, 0xAC	; 172
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2d e0       	ldi	r18, 0x0D	; 13
      b4:	ac ea       	ldi	r26, 0xAC	; 172
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a0 3e       	cpi	r26, 0xE0	; 224
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 0f 0d 	call	0x1a1e	; 0x1a1e <main>
      c6:	0c 94 a5 18 	jmp	0x314a	; 0x314a <_exit>

000000ca <__bad_interrupt>:
      ca:	9a cf       	rjmp	.-204    	; 0x0 <__vectors>

000000cc <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      cc:	fc 01       	movw	r30, r24
      ce:	68 0f       	add	r22, r24
      d0:	79 1f       	adc	r23, r25
      d2:	8f ef       	ldi	r24, 0xFF	; 255
      d4:	9f ef       	ldi	r25, 0xFF	; 255
      d6:	e6 17       	cp	r30, r22
      d8:	f7 07       	cpc	r31, r23
      da:	99 f0       	breq	.+38     	; 0x102 <_Z5CRC16Phi+0x36>
      dc:	21 91       	ld	r18, Z+
      de:	82 27       	eor	r24, r18
      e0:	28 e0       	ldi	r18, 0x08	; 8
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	ac 01       	movw	r20, r24
      e6:	41 70       	andi	r20, 0x01	; 1
      e8:	55 27       	eor	r21, r21
      ea:	96 95       	lsr	r25
      ec:	87 95       	ror	r24
      ee:	45 2b       	or	r20, r21
      f0:	21 f0       	breq	.+8      	; 0xfa <_Z5CRC16Phi+0x2e>
      f2:	41 e0       	ldi	r20, 0x01	; 1
      f4:	84 27       	eor	r24, r20
      f6:	40 ea       	ldi	r20, 0xA0	; 160
      f8:	94 27       	eor	r25, r20
      fa:	21 50       	subi	r18, 0x01	; 1
      fc:	31 09       	sbc	r19, r1
      fe:	91 f7       	brne	.-28     	; 0xe4 <_Z5CRC16Phi+0x18>
     100:	ea cf       	rjmp	.-44     	; 0xd6 <_Z5CRC16Phi+0xa>
     102:	08 95       	ret

00000104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	dc 01       	movw	r26, r24
     10a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     10c:	8c 91       	ld	r24, X
     10e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     110:	11 96       	adiw	r26, 0x01	; 1
     112:	8c 91       	ld	r24, X
     114:	11 97       	sbiw	r26, 0x01	; 1
     116:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     118:	13 96       	adiw	r26, 0x03	; 3
     11a:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     11c:	92 e0       	ldi	r25, 0x02	; 2
     11e:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     120:	e8 2f       	mov	r30, r24
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	ee 0f       	add	r30, r30
     126:	ff 1f       	adc	r31, r31
     128:	e4 0f       	add	r30, r20
     12a:	f5 1f       	adc	r31, r21
     12c:	81 81       	ldd	r24, Z+1	; 0x01
     12e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     130:	80 81       	ld	r24, Z
     132:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     134:	65 e0       	ldi	r22, 0x05	; 5
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	ce 01       	movw	r24, r28
     13a:	c8 df       	rcall	.-112    	; 0xcc <_Z5CRC16Phi>
	function04->CRC = crc16;
     13c:	9e 83       	std	Y+6, r25	; 0x06
     13e:	8d 83       	std	Y+5, r24	; 0x05
}
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	08 95       	ret

00000146 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     146:	cf 93       	push	r28
     148:	df 93       	push	r29
     14a:	fc 01       	movw	r30, r24
     14c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     14e:	80 81       	ld	r24, Z
     150:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     156:	82 81       	ldd	r24, Z+2	; 0x02
     158:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     15a:	83 81       	ldd	r24, Z+3	; 0x03
     15c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     15e:	84 81       	ldd	r24, Z+4	; 0x04
     160:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     162:	85 81       	ldd	r24, Z+5	; 0x05
     164:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     166:	66 e0       	ldi	r22, 0x06	; 6
     168:	70 e0       	ldi	r23, 0x00	; 0
     16a:	ce 01       	movw	r24, r28
     16c:	af df       	rcall	.-162    	; 0xcc <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     16e:	9f 83       	std	Y+7, r25	; 0x07
     170:	8e 83       	std	Y+6, r24	; 0x06
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	fc 01       	movw	r30, r24
     17e:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     180:	80 81       	ld	r24, Z
     182:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     184:	81 81       	ldd	r24, Z+1	; 0x01
     186:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     18c:	83 81       	ldd	r24, Z+3	; 0x03
     18e:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     190:	94 81       	ldd	r25, Z+4	; 0x04
     192:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     194:	95 81       	ldd	r25, Z+5	; 0x05
     196:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     198:	96 81       	ldd	r25, Z+6	; 0x06
     19a:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     19c:	27 81       	ldd	r18, Z+7	; 0x07
     19e:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1a0:	90 85       	ldd	r25, Z+8	; 0x08
     1a2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1a4:	e8 2f       	mov	r30, r24
     1a6:	f0 e0       	ldi	r31, 0x00	; 0
     1a8:	ee 0f       	add	r30, r30
     1aa:	ff 1f       	adc	r31, r31
     1ac:	e4 0f       	add	r30, r20
     1ae:	f5 1f       	adc	r31, r21
     1b0:	89 2f       	mov	r24, r25
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	92 2b       	or	r25, r18
     1b6:	91 83       	std	Z+1, r25	; 0x01
     1b8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1ba:	69 e0       	ldi	r22, 0x09	; 9
     1bc:	70 e0       	ldi	r23, 0x00	; 0
     1be:	ce 01       	movw	r24, r28
     1c0:	85 df       	rcall	.-246    	; 0xcc <_Z5CRC16Phi>
	function10->CRC = crc16;
     1c2:	9a 87       	std	Y+10, r25	; 0x0a
     1c4:	89 87       	std	Y+9, r24	; 0x09
}
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	08 95       	ret

000001cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	fc 01       	movw	r30, r24
     1d2:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1d4:	80 81       	ld	r24, Z
     1d6:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1d8:	81 81       	ldd	r24, Z+1	; 0x01
     1da:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1dc:	82 81       	ldd	r24, Z+2	; 0x02
     1de:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1e0:	83 81       	ldd	r24, Z+3	; 0x03
     1e2:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     1e8:	85 81       	ldd	r24, Z+5	; 0x05
     1ea:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     1ec:	66 e0       	ldi	r22, 0x06	; 6
     1ee:	70 e0       	ldi	r23, 0x00	; 0
     1f0:	ce 01       	movw	r24, r28
     1f2:	6c df       	rcall	.-296    	; 0xcc <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     1f4:	9f 83       	std	Y+7, r25	; 0x07
     1f6:	8e 83       	std	Y+6, r24	; 0x06
}
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	08 95       	ret

000001fe <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     204:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     206:	81 e8       	ldi	r24, 0x81	; 129
     208:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     20a:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     20c:	63 e0       	ldi	r22, 0x03	; 3
     20e:	70 e0       	ldi	r23, 0x00	; 0
     210:	ce 01       	movw	r24, r28
     212:	5c df       	rcall	.-328    	; 0xcc <_Z5CRC16Phi>
	Exception->CRC = crc16;
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	08 95       	ret

0000021e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     21e:	1f 93       	push	r17
     220:	cf 93       	push	r28
     222:	df 93       	push	r29
     224:	ec 01       	movw	r28, r24
     226:	cb 01       	movw	r24, r22
     228:	14 2f       	mov	r17, r20
     22a:	fe 01       	movw	r30, r28
     22c:	ea 57       	subi	r30, 0x7A	; 122
     22e:	ff 4f       	sbci	r31, 0xFF	; 255
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	64 2f       	mov	r22, r20
     236:	ca d1       	rcall	.+916    	; 0x5cc <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     238:	88 23       	and	r24, r24
     23a:	71 f0       	breq	.+28     	; 0x258 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     23c:	fe 01       	movw	r30, r28
     23e:	eb 57       	subi	r30, 0x7B	; 123
     240:	ff 4f       	sbci	r31, 0xFF	; 255
     242:	10 83       	st	Z, r17
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	10 82       	st	Z, r1
     248:	34 97       	sbiw	r30, 0x04	; 4
     24a:	11 82       	std	Z+1, r1	; 0x01
     24c:	10 82       	st	Z, r1
     24e:	ce 57       	subi	r28, 0x7E	; 126
     250:	df 4f       	sbci	r29, 0xFF	; 255
     252:	19 82       	std	Y+1, r1	; 0x01
     254:	18 82       	st	Y, r1
     256:	04 c0       	rjmp	.+8      	; 0x260 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     258:	ca 57       	subi	r28, 0x7A	; 122
     25a:	df 4f       	sbci	r29, 0xFF	; 255
     25c:	19 82       	std	Y+1, r1	; 0x01
     25e:	18 82       	st	Y, r1
     260:	df 91       	pop	r29
     262:	cf 91       	pop	r28
     264:	1f 91       	pop	r17
     266:	08 95       	ret

00000268 <_ZN12SerialBuffernwEj>:
     268:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
     26c:	08 95       	ret

0000026e <_ZN12SerialBuffer11SerialstoreEc>:
     26e:	fc 01       	movw	r30, r24
     270:	e0 58       	subi	r30, 0x80	; 128
     272:	ff 4f       	sbci	r31, 0xFF	; 255
     274:	20 81       	ld	r18, Z
     276:	2f 5f       	subi	r18, 0xFF	; 255
     278:	2f 77       	andi	r18, 0x7F	; 127
     27a:	19 f4       	brne	.+6      	; 0x282 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     27c:	11 82       	std	Z+1, r1	; 0x01
     27e:	10 82       	st	Z, r1
     280:	21 e0       	ldi	r18, 0x01	; 1
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	fc 01       	movw	r30, r24
     286:	ee 57       	subi	r30, 0x7E	; 126
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	40 81       	ld	r20, Z
     28c:	51 81       	ldd	r21, Z+1	; 0x01
     28e:	24 17       	cp	r18, r20
     290:	35 07       	cpc	r19, r21
     292:	89 f0       	breq	.+34     	; 0x2b6 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     294:	dc 01       	movw	r26, r24
     296:	a0 58       	subi	r26, 0x80	; 128
     298:	bf 4f       	sbci	r27, 0xFF	; 255
     29a:	ed 91       	ld	r30, X+
     29c:	fc 91       	ld	r31, X
     29e:	11 97       	sbiw	r26, 0x01	; 1
     2a0:	e8 0f       	add	r30, r24
     2a2:	f9 1f       	adc	r31, r25
     2a4:	61 83       	std	Z+1, r22	; 0x01
     2a6:	2d 93       	st	X+, r18
     2a8:	3c 93       	st	X, r19
     2aa:	fc 01       	movw	r30, r24
     2ac:	ec 57       	subi	r30, 0x7C	; 124
     2ae:	ff 4f       	sbci	r31, 0xFF	; 255
     2b0:	80 81       	ld	r24, Z
     2b2:	8f 5f       	subi	r24, 0xFF	; 255
     2b4:	80 83       	st	Z, r24
     2b6:	08 95       	ret

000002b8 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	1f 93       	push	r17
     2c8:	cf 93       	push	r28
     2ca:	8c 01       	movw	r16, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	7a 01       	movw	r14, r20
     2d0:	dc 01       	movw	r26, r24
     2d2:	ab 57       	subi	r26, 0x7B	; 123
     2d4:	bf 4f       	sbci	r27, 0xFF	; 255
     2d6:	fc 01       	movw	r30, r24
     2d8:	ea 57       	subi	r30, 0x7A	; 122
     2da:	ff 4f       	sbci	r31, 0xFF	; 255
     2dc:	6c 91       	ld	r22, X
     2de:	80 81       	ld	r24, Z
     2e0:	91 81       	ldd	r25, Z+1	; 0x01
     2e2:	81 d1       	rcall	.+770    	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2e4:	89 2b       	or	r24, r25
     2e6:	d1 f0       	breq	.+52     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2e8:	1e 14       	cp	r1, r14
     2ea:	1f 04       	cpc	r1, r15
     2ec:	bc f4       	brge	.+46     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2ee:	c0 e0       	ldi	r28, 0x00	; 0
     2f0:	58 01       	movw	r10, r16
     2f2:	85 e8       	ldi	r24, 0x85	; 133
     2f4:	a8 0e       	add	r10, r24
     2f6:	b1 1c       	adc	r11, r1
     2f8:	0a 57       	subi	r16, 0x7A	; 122
     2fa:	1f 4f       	sbci	r17, 0xFF	; 255
     2fc:	f6 01       	movw	r30, r12
     2fe:	ec 0f       	add	r30, r28
     300:	f1 1d       	adc	r31, r1
     302:	40 81       	ld	r20, Z
     304:	f5 01       	movw	r30, r10
     306:	60 81       	ld	r22, Z
     308:	f8 01       	movw	r30, r16
     30a:	80 81       	ld	r24, Z
     30c:	91 81       	ldd	r25, Z+1	; 0x01
     30e:	17 d1       	rcall	.+558    	; 0x53e <_ZN11Dev_Manager5WriteE8Dev_typec>
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	2c 2f       	mov	r18, r28
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	2e 15       	cp	r18, r14
     318:	3f 05       	cpc	r19, r15
     31a:	84 f3       	brlt	.-32     	; 0x2fc <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	bf 90       	pop	r11
     32c:	af 90       	pop	r10
     32e:	08 95       	ret

00000330 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     330:	fc 01       	movw	r30, r24
     332:	ee 57       	subi	r30, 0x7E	; 126
     334:	ff 4f       	sbci	r31, 0xFF	; 255
     336:	20 81       	ld	r18, Z
     338:	31 81       	ldd	r19, Z+1	; 0x01
     33a:	32 97       	sbiw	r30, 0x02	; 2
     33c:	40 81       	ld	r20, Z
     33e:	51 81       	ldd	r21, Z+1	; 0x01
     340:	42 17       	cp	r20, r18
     342:	53 07       	cpc	r21, r19
     344:	e9 f0       	breq	.+58     	; 0x380 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	3f 4f       	sbci	r19, 0xFF	; 255
     34a:	fc 01       	movw	r30, r24
     34c:	e2 0f       	add	r30, r18
     34e:	f3 1f       	adc	r31, r19
     350:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     352:	2f 77       	andi	r18, 0x7F	; 127
     354:	33 27       	eor	r19, r19
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	31 83       	std	Z+1, r19	; 0x01
     35e:	20 83       	st	Z, r18
		if (ib.tail == num)
     360:	32 96       	adiw	r30, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	26 17       	cp	r18, r22
     368:	37 07       	cpc	r19, r23
     36a:	61 f4       	brne	.+24     	; 0x384 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     36c:	32 97       	sbiw	r30, 0x02	; 2
     36e:	11 82       	std	Z+1, r1	; 0x01
     370:	10 82       	st	Z, r1
			ib.head = 0;
     372:	32 97       	sbiw	r30, 0x02	; 2
     374:	11 82       	std	Z+1, r1	; 0x01
     376:	10 82       	st	Z, r1
			num = 0;
     378:	34 96       	adiw	r30, 0x04	; 4
     37a:	10 82       	st	Z, r1
		}
		return data;
     37c:	84 2f       	mov	r24, r20
     37e:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     384:	84 2f       	mov	r24, r20
	}
}
     386:	08 95       	ret

00000388 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     388:	dc 01       	movw	r26, r24
     38a:	a0 58       	subi	r26, 0x80	; 128
     38c:	bf 4f       	sbci	r27, 0xFF	; 255
     38e:	fc 01       	movw	r30, r24
     390:	ee 57       	subi	r30, 0x7E	; 126
     392:	ff 4f       	sbci	r31, 0xFF	; 255
     394:	8c 91       	ld	r24, X
     396:	90 81       	ld	r25, Z
     398:	89 1b       	sub	r24, r25
}
     39a:	8f 77       	andi	r24, 0x7F	; 127
     39c:	08 95       	ret

0000039e <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     39e:	fc 01       	movw	r30, r24
     3a0:	ee 57       	subi	r30, 0x7E	; 126
     3a2:	ff 4f       	sbci	r31, 0xFF	; 255
     3a4:	11 82       	std	Z+1, r1	; 0x01
     3a6:	10 82       	st	Z, r1
	ib.head = 0;
     3a8:	32 97       	sbiw	r30, 0x02	; 2
     3aa:	11 82       	std	Z+1, r1	; 0x01
     3ac:	10 82       	st	Z, r1
	num = 0;
     3ae:	34 96       	adiw	r30, 0x04	; 4
     3b0:	10 82       	st	Z, r1
     3b2:	08 95       	ret

000003b4 <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
     3b4:	8c e0       	ldi	r24, 0x0C	; 12
     3b6:	83 bf       	out	0x33, r24	; 51
     3b8:	8c e7       	ldi	r24, 0x7C	; 124
     3ba:	81 bf       	out	0x31, r24	; 49
     3bc:	87 b7       	in	r24, 0x37	; 55
     3be:	82 60       	ori	r24, 0x02	; 2
     3c0:	87 bf       	out	0x37, r24	; 55
     3c2:	08 95       	ret

000003c4 <Alarm_Stop>:
     3c4:	87 b7       	in	r24, 0x37	; 55
     3c6:	8d 7f       	andi	r24, 0xFD	; 253
     3c8:	87 bf       	out	0x37, r24	; 55
     3ca:	08 95       	ret

000003cc <Alarm_Start>:
     3cc:	87 b7       	in	r24, 0x37	; 55
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	87 bf       	out	0x37, r24	; 55
     3d2:	08 95       	ret

000003d4 <Alarm_Open>:
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	fc 01       	movw	r30, r24
     3d8:	ee 0f       	add	r30, r30
     3da:	ff 1f       	adc	r31, r31
     3dc:	df 01       	movw	r26, r30
     3de:	a8 0f       	add	r26, r24
     3e0:	b9 1f       	adc	r27, r25
     3e2:	aa 0f       	add	r26, r26
     3e4:	bb 1f       	adc	r27, r27
     3e6:	a4 55       	subi	r26, 0x54	; 84
     3e8:	be 4f       	sbci	r27, 0xFE	; 254
     3ea:	11 96       	adiw	r26, 0x01	; 1
     3ec:	7c 93       	st	X, r23
     3ee:	6e 93       	st	-X, r22
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	1c 92       	st	X, r1
     3f4:	1e 92       	st	-X, r1
     3f6:	12 97       	sbiw	r26, 0x02	; 2
     3f8:	fd 01       	movw	r30, r26
     3fa:	55 83       	std	Z+5, r21	; 0x05
     3fc:	44 83       	std	Z+4, r20	; 0x04
     3fe:	08 95       	ret

00000400 <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
     400:	1f 92       	push	r1
     402:	0f 92       	push	r0
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	0f 92       	push	r0
     408:	11 24       	eor	r1, r1
     40a:	0b b6       	in	r0, 0x3b	; 59
     40c:	0f 92       	push	r0
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	1f 93       	push	r17
     416:	2f 93       	push	r18
     418:	3f 93       	push	r19
     41a:	4f 93       	push	r20
     41c:	5f 93       	push	r21
     41e:	6f 93       	push	r22
     420:	7f 93       	push	r23
     422:	8f 93       	push	r24
     424:	9f 93       	push	r25
     426:	af 93       	push	r26
     428:	bf 93       	push	r27
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	ef 93       	push	r30
     430:	ff 93       	push	r31
     432:	cc ea       	ldi	r28, 0xAC	; 172
     434:	d1 e0       	ldi	r29, 0x01	; 1
     436:	0f 2e       	mov	r0, r31
     438:	fa ec       	ldi	r31, 0xCA	; 202
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 e0       	ldi	r31, 0x01	; 1
     43e:	ff 2e       	mov	r15, r31
     440:	f0 2d       	mov	r31, r0
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
     442:	ec 81       	ldd	r30, Y+4	; 0x04
     444:	fd 81       	ldd	r31, Y+5	; 0x05
     446:	30 97       	sbiw	r30, 0x00	; 0
     448:	79 f0       	breq	.+30     	; 0x468 <__vector_15+0x68>
		{
			AlarmTable[i].Time++;
     44a:	8a 81       	ldd	r24, Y+2	; 0x02
     44c:	9b 81       	ldd	r25, Y+3	; 0x03
     44e:	01 96       	adiw	r24, 0x01	; 1
     450:	9b 83       	std	Y+3, r25	; 0x03
     452:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
     454:	28 81       	ld	r18, Y
     456:	39 81       	ldd	r19, Y+1	; 0x01
     458:	82 17       	cp	r24, r18
     45a:	93 07       	cpc	r25, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <__vector_15+0x68>
			{
				AlarmTable[i].Time = 0;
     45e:	1b 82       	std	Y+3, r1	; 0x03
     460:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
     462:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
     464:	1d 82       	std	Y+5, r1	; 0x05
     466:	1c 82       	std	Y+4, r1	; 0x04
     468:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
     46a:	ce 15       	cp	r28, r14
     46c:	df 05       	cpc	r29, r15
     46e:	49 f7       	brne	.-46     	; 0x442 <__vector_15+0x42>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
     470:	ff 91       	pop	r31
     472:	ef 91       	pop	r30
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	bf 91       	pop	r27
     47a:	af 91       	pop	r26
     47c:	9f 91       	pop	r25
     47e:	8f 91       	pop	r24
     480:	7f 91       	pop	r23
     482:	6f 91       	pop	r22
     484:	5f 91       	pop	r21
     486:	4f 91       	pop	r20
     488:	3f 91       	pop	r19
     48a:	2f 91       	pop	r18
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	ff 90       	pop	r15
     492:	ef 90       	pop	r14
     494:	0f 90       	pop	r0
     496:	0b be       	out	0x3b, r0	; 59
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0
     49e:	1f 90       	pop	r1
     4a0:	18 95       	reti

000004a2 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	08 95       	ret

000004a6 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
	virtual void Device_Writes(const char* data){}
     4a6:	08 95       	ret

000004a8 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
     4a8:	08 95       	ret

000004aa <_ZN20DeviceDriveInterFace11Stop_DeviceEv>:
	virtual void Stop_Device(void){}
     4aa:	08 95       	ret

000004ac <_ZN20DeviceDriveInterFace12Start_DeviceEv>:
	virtual void Start_Device(void){}
     4ac:	08 95       	ret

000004ae <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
     4ae:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
     4b0:	8f ef       	ldi	r24, 0xFF	; 255
     4b2:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
     4b4:	ea e6       	ldi	r30, 0x6A	; 106
     4b6:	f0 e0       	ldi	r31, 0x00	; 0
     4b8:	80 81       	ld	r24, Z
     4ba:	82 60       	ori	r24, 0x02	; 2
     4bc:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
     4be:	80 81       	ld	r24, Z
     4c0:	8e 7f       	andi	r24, 0xFE	; 254
     4c2:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
     4c4:	89 b7       	in	r24, 0x39	; 57
     4c6:	81 60       	ori	r24, 0x01	; 1
     4c8:	89 bf       	out	0x39, r24	; 57
     4ca:	08 95       	ret

000004cc <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
     4cc:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
}
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     4d2:	28 e0       	ldi	r18, 0x08	; 8
     4d4:	dc 01       	movw	r26, r24
     4d6:	e2 2f       	mov	r30, r18
     4d8:	1d 92       	st	X+, r1
     4da:	ea 95       	dec	r30
     4dc:	e9 f7       	brne	.-6      	; 0x4d8 <_ZN11Dev_ManagerC1Ev+0x6>
     4de:	fc 01       	movw	r30, r24
     4e0:	38 96       	adiw	r30, 0x08	; 8
     4e2:	df 01       	movw	r26, r30
     4e4:	1d 92       	st	X+, r1
     4e6:	2a 95       	dec	r18
     4e8:	e9 f7       	brne	.-6      	; 0x4e4 <_ZN11Dev_ManagerC1Ev+0x12>
     4ea:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     4ee:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <_ZN11Dev_Manager4instE>
     4f2:	08 95       	ret

000004f4 <_ZN11Dev_Manager11getInstanceEv>:
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <_ZN11Dev_Manager4instE>
     4fc:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     500:	89 2b       	or	r24, r25
     502:	51 f4       	brne	.+20     	; 0x518 <_ZN11Dev_Manager11getInstanceEv+0x24>
     504:	80 e1       	ldi	r24, 0x10	; 16
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <pvPortMalloc>
     50c:	ec 01       	movw	r28, r24
     50e:	e1 df       	rcall	.-62     	; 0x4d2 <_ZN11Dev_ManagerC1Ev>
     510:	d0 93 cb 01 	sts	0x01CB, r29	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     514:	c0 93 ca 01 	sts	0x01CA, r28	; 0x8001ca <_ZN11Dev_Manager4instE>
     518:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <_ZN11Dev_Manager4instE>
     51c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	08 95       	ret

00000526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     526:	50 e0       	ldi	r21, 0x00	; 0
     528:	44 0f       	add	r20, r20
     52a:	55 1f       	adc	r21, r21
     52c:	84 0f       	add	r24, r20
     52e:	95 1f       	adc	r25, r21
     530:	fc 01       	movw	r30, r24
     532:	71 83       	std	Z+1, r23	; 0x01
     534:	60 83       	st	Z, r22
     536:	08 95       	ret

00000538 <_ZN11Dev_ManagernwEj>:
     538:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
     53c:	08 95       	ret

0000053e <_ZN11Dev_Manager5WriteE8Dev_typec>:
     53e:	26 2f       	mov	r18, r22
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	22 0f       	add	r18, r18
     544:	33 1f       	adc	r19, r19
     546:	82 0f       	add	r24, r18
     548:	93 1f       	adc	r25, r19
     54a:	dc 01       	movw	r26, r24
     54c:	8d 91       	ld	r24, X+
     54e:	9c 91       	ld	r25, X
     550:	00 97       	sbiw	r24, 0x00	; 0
     552:	41 f0       	breq	.+16     	; 0x564 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     554:	64 2f       	mov	r22, r20
     556:	dc 01       	movw	r26, r24
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	06 80       	ldd	r0, Z+6	; 0x06
     55e:	f7 81       	ldd	r31, Z+7	; 0x07
     560:	e0 2d       	mov	r30, r0
     562:	09 95       	icall
     564:	08 95       	ret

00000566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     566:	26 2f       	mov	r18, r22
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	22 0f       	add	r18, r18
     56c:	33 1f       	adc	r19, r19
     56e:	82 0f       	add	r24, r18
     570:	93 1f       	adc	r25, r19
     572:	dc 01       	movw	r26, r24
     574:	8d 91       	ld	r24, X+
     576:	9c 91       	ld	r25, X
     578:	00 97       	sbiw	r24, 0x00	; 0
     57a:	41 f0       	breq	.+16     	; 0x58c <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     57c:	ba 01       	movw	r22, r20
     57e:	dc 01       	movw	r26, r24
     580:	ed 91       	ld	r30, X+
     582:	fc 91       	ld	r31, X
     584:	04 80       	ldd	r0, Z+4	; 0x04
     586:	f5 81       	ldd	r31, Z+5	; 0x05
     588:	e0 2d       	mov	r30, r0
     58a:	09 95       	icall
     58c:	08 95       	ret

0000058e <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     58e:	70 e0       	ldi	r23, 0x00	; 0
     590:	66 0f       	add	r22, r22
     592:	77 1f       	adc	r23, r23
     594:	86 0f       	add	r24, r22
     596:	97 1f       	adc	r25, r23
     598:	dc 01       	movw	r26, r24
     59a:	8d 91       	ld	r24, X+
     59c:	9c 91       	ld	r25, X
     59e:	00 97       	sbiw	r24, 0x00	; 0
     5a0:	39 f0       	breq	.+14     	; 0x5b0 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     5a2:	dc 01       	movw	r26, r24
     5a4:	ed 91       	ld	r30, X+
     5a6:	fc 91       	ld	r31, X
     5a8:	01 90       	ld	r0, Z+
     5aa:	f0 81       	ld	r31, Z
     5ac:	e0 2d       	mov	r30, r0
     5ae:	09 95       	icall
     5b0:	08 95       	ret

000005b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     5b2:	e6 2f       	mov	r30, r22
     5b4:	f0 e0       	ldi	r31, 0x00	; 0
     5b6:	ee 0f       	add	r30, r30
     5b8:	ff 1f       	adc	r31, r31
     5ba:	e8 0f       	add	r30, r24
     5bc:	f9 1f       	adc	r31, r25
     5be:	80 81       	ld	r24, Z
     5c0:	91 81       	ldd	r25, Z+1	; 0x01
     5c2:	89 2b       	or	r24, r25
     5c4:	11 f0       	breq	.+4      	; 0x5ca <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     5c6:	51 87       	std	Z+9, r21	; 0x09
     5c8:	40 87       	std	Z+8, r20	; 0x08
     5ca:	08 95       	ret

000005cc <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     5cc:	70 e0       	ldi	r23, 0x00	; 0
     5ce:	66 0f       	add	r22, r22
     5d0:	77 1f       	adc	r23, r23
     5d2:	fc 01       	movw	r30, r24
     5d4:	e6 0f       	add	r30, r22
     5d6:	f7 1f       	adc	r31, r23
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	20 81       	ld	r18, Z
     5dc:	31 81       	ldd	r19, Z+1	; 0x01
     5de:	23 2b       	or	r18, r19
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	08 95       	ret

000005e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* const Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     5e6:	70 e0       	ldi	r23, 0x00	; 0
     5e8:	66 0f       	add	r22, r22
     5ea:	77 1f       	adc	r23, r23
     5ec:	86 0f       	add	r24, r22
     5ee:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     5f0:	fc 01       	movw	r30, r24
     5f2:	80 81       	ld	r24, Z
     5f4:	91 81       	ldd	r25, Z+1	; 0x01
     5f6:	08 95       	ret

000005f8 <__vector_18>:
ISR(USART0_RX_vect)
{
     5f8:	1f 92       	push	r1
     5fa:	0f 92       	push	r0
     5fc:	0f b6       	in	r0, 0x3f	; 63
     5fe:	0f 92       	push	r0
     600:	11 24       	eor	r1, r1
     602:	0b b6       	in	r0, 0x3b	; 59
     604:	0f 92       	push	r0
     606:	2f 93       	push	r18
     608:	3f 93       	push	r19
     60a:	4f 93       	push	r20
     60c:	5f 93       	push	r21
     60e:	6f 93       	push	r22
     610:	7f 93       	push	r23
     612:	8f 93       	push	r24
     614:	9f 93       	push	r25
     616:	af 93       	push	r26
     618:	bf 93       	push	r27
     61a:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     61c:	ff 93       	push	r31
     61e:	6a df       	rcall	.-300    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     620:	6c b1       	in	r22, 0x0c	; 12
     622:	70 e0       	ldi	r23, 0x00	; 0
     624:	dc 01       	movw	r26, r24
     626:	18 96       	adiw	r26, 0x08	; 8
     628:	ed 91       	ld	r30, X+
     62a:	fc 91       	ld	r31, X
     62c:	19 97       	sbiw	r26, 0x09	; 9
     62e:	80 e0       	ldi	r24, 0x00	; 0
}
     630:	09 95       	icall
     632:	ff 91       	pop	r31
     634:	ef 91       	pop	r30
     636:	bf 91       	pop	r27
     638:	af 91       	pop	r26
     63a:	9f 91       	pop	r25
     63c:	8f 91       	pop	r24
     63e:	7f 91       	pop	r23
     640:	6f 91       	pop	r22
     642:	5f 91       	pop	r21
     644:	4f 91       	pop	r20
     646:	3f 91       	pop	r19
     648:	2f 91       	pop	r18
     64a:	0f 90       	pop	r0
     64c:	0b be       	out	0x3b, r0	; 59
     64e:	0f 90       	pop	r0
     650:	0f be       	out	0x3f, r0	; 63
     652:	0f 90       	pop	r0
     654:	1f 90       	pop	r1
     656:	18 95       	reti

00000658 <__vector_30>:
ISR(USART1_RX_vect)
{
     658:	1f 92       	push	r1
     65a:	0f 92       	push	r0
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	0f 92       	push	r0
     660:	11 24       	eor	r1, r1
     662:	0b b6       	in	r0, 0x3b	; 59
     664:	0f 92       	push	r0
     666:	2f 93       	push	r18
     668:	3f 93       	push	r19
     66a:	4f 93       	push	r20
     66c:	5f 93       	push	r21
     66e:	6f 93       	push	r22
     670:	7f 93       	push	r23
     672:	8f 93       	push	r24
     674:	9f 93       	push	r25
     676:	af 93       	push	r26
     678:	bf 93       	push	r27
     67a:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     67c:	ff 93       	push	r31
     67e:	3a df       	rcall	.-396    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     680:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     684:	70 e0       	ldi	r23, 0x00	; 0
     686:	dc 01       	movw	r26, r24
     688:	1a 96       	adiw	r26, 0x0a	; 10
     68a:	ed 91       	ld	r30, X+
     68c:	fc 91       	ld	r31, X
     68e:	1b 97       	sbiw	r26, 0x0b	; 11
     690:	81 e0       	ldi	r24, 0x01	; 1
}
     692:	09 95       	icall
     694:	ff 91       	pop	r31
     696:	ef 91       	pop	r30
     698:	bf 91       	pop	r27
     69a:	af 91       	pop	r26
     69c:	9f 91       	pop	r25
     69e:	8f 91       	pop	r24
     6a0:	7f 91       	pop	r23
     6a2:	6f 91       	pop	r22
     6a4:	5f 91       	pop	r21
     6a6:	4f 91       	pop	r20
     6a8:	3f 91       	pop	r19
     6aa:	2f 91       	pop	r18
     6ac:	0f 90       	pop	r0
     6ae:	0b be       	out	0x3b, r0	; 59
     6b0:	0f 90       	pop	r0
     6b2:	0f be       	out	0x3f, r0	; 63
     6b4:	0f 90       	pop	r0
     6b6:	1f 90       	pop	r1
     6b8:	18 95       	reti

000006ba <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     6ba:	1f 92       	push	r1
     6bc:	0f 92       	push	r0
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	0f 92       	push	r0
     6c2:	11 24       	eor	r1, r1
     6c4:	0b b6       	in	r0, 0x3b	; 59
     6c6:	0f 92       	push	r0
     6c8:	2f 93       	push	r18
     6ca:	3f 93       	push	r19
     6cc:	4f 93       	push	r20
     6ce:	5f 93       	push	r21
     6d0:	6f 93       	push	r22
     6d2:	7f 93       	push	r23
     6d4:	8f 93       	push	r24
     6d6:	9f 93       	push	r25
     6d8:	af 93       	push	r26
     6da:	bf 93       	push	r27
     6dc:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
     6de:	ff 93       	push	r31
     6e0:	09 df       	rcall	.-494    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     6e2:	dc 01       	movw	r26, r24
     6e4:	1c 96       	adiw	r26, 0x0c	; 12
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	1d 97       	sbiw	r26, 0x0d	; 13
     6ec:	60 e0       	ldi	r22, 0x00	; 0
     6ee:	70 e0       	ldi	r23, 0x00	; 0
     6f0:	82 e0       	ldi	r24, 0x02	; 2
}
     6f2:	09 95       	icall
     6f4:	ff 91       	pop	r31
     6f6:	ef 91       	pop	r30
     6f8:	bf 91       	pop	r27
     6fa:	af 91       	pop	r26
     6fc:	9f 91       	pop	r25
     6fe:	8f 91       	pop	r24
     700:	7f 91       	pop	r23
     702:	6f 91       	pop	r22
     704:	5f 91       	pop	r21
     706:	4f 91       	pop	r20
     708:	3f 91       	pop	r19
     70a:	2f 91       	pop	r18
     70c:	0f 90       	pop	r0
     70e:	0b be       	out	0x3b, r0	; 59
     710:	0f 90       	pop	r0
     712:	0f be       	out	0x3f, r0	; 63
     714:	0f 90       	pop	r0
     716:	1f 90       	pop	r1
     718:	18 95       	reti

0000071a <__vector_1>:
ISR(INT0_vect)
{
     71a:	1f 92       	push	r1
     71c:	0f 92       	push	r0
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	0f 92       	push	r0
     722:	11 24       	eor	r1, r1
     724:	0b b6       	in	r0, 0x3b	; 59
     726:	0f 92       	push	r0
     728:	2f 93       	push	r18
     72a:	3f 93       	push	r19
     72c:	4f 93       	push	r20
     72e:	5f 93       	push	r21
     730:	6f 93       	push	r22
     732:	7f 93       	push	r23
     734:	8f 93       	push	r24
     736:	9f 93       	push	r25
     738:	af 93       	push	r26
     73a:	bf 93       	push	r27
     73c:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
     73e:	ff 93       	push	r31
     740:	d9 de       	rcall	.-590    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     742:	dc 01       	movw	r26, r24
     744:	1e 96       	adiw	r26, 0x0e	; 14
     746:	ed 91       	ld	r30, X+
     748:	fc 91       	ld	r31, X
     74a:	1f 97       	sbiw	r26, 0x0f	; 15
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	83 e0       	ldi	r24, 0x03	; 3
     752:	09 95       	icall
     754:	ff 91       	pop	r31
     756:	ef 91       	pop	r30
     758:	bf 91       	pop	r27
     75a:	af 91       	pop	r26
     75c:	9f 91       	pop	r25
     75e:	8f 91       	pop	r24
     760:	7f 91       	pop	r23
     762:	6f 91       	pop	r22
     764:	5f 91       	pop	r21
     766:	4f 91       	pop	r20
     768:	3f 91       	pop	r19
     76a:	2f 91       	pop	r18
     76c:	0f 90       	pop	r0
     76e:	0b be       	out	0x3b, r0	; 59
     770:	0f 90       	pop	r0
     772:	0f be       	out	0x3f, r0	; 63
     774:	0f 90       	pop	r0
     776:	1f 90       	pop	r1
     778:	18 95       	reti

0000077a <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
     77a:	80 e4       	ldi	r24, 0x40	; 64
     77c:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
     780:	84 e0       	ldi	r24, 0x04	; 4
     782:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
     786:	88 e0       	ldi	r24, 0x08	; 8
     788:	9d e3       	ldi	r25, 0x3D	; 61
     78a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     78e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
     792:	82 e0       	ldi	r24, 0x02	; 2
     794:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     798:	08 95       	ret

0000079a <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
     79a:	2b e1       	ldi	r18, 0x1B	; 27
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	fc 01       	movw	r30, r24
     7a0:	31 83       	std	Z+1, r19	; 0x01
     7a2:	20 83       	st	Z, r18
     7a4:	08 95       	ret

000007a6 <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
     7a6:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
}
     7aa:	08 95       	ret

000007ac <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
     7b0:	ec 01       	movw	r28, r24
     7b2:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     7b6:	88 e9       	ldi	r24, 0x98	; 152
     7b8:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     7bc:	86 e0       	ldi	r24, 0x06	; 6
     7be:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     7c2:	be 01       	movw	r22, r28
     7c4:	6e 5f       	subi	r22, 0xFE	; 254
     7c6:	7f 4f       	sbci	r23, 0xFF	; 255
     7c8:	ce 01       	movw	r24, r28
     7ca:	19 d1       	rcall	.+562    	; 0x9fe <_ZN4Ubbr10Ubbr_ValueERKj>
     7cc:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     7d0:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     7d4:	81 e0       	ldi	r24, 0x01	; 1
     7d6:	0e 94 89 11 	call	0x2312	; 0x2312 <xQueueCreateMutex>
     7da:	9f 83       	std	Y+7, r25	; 0x07
     7dc:	8e 83       	std	Y+6, r24	; 0x06
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	0e 94 89 11 	call	0x2312	; 0x2312 <xQueueCreateMutex>
     7e4:	9d 83       	std	Y+5, r25	; 0x05
     7e6:	8c 83       	std	Y+4, r24	; 0x04
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <_ZN11RS485DriverC1Ev>:
     7ee:	2b e2       	ldi	r18, 0x2B	; 43
     7f0:	31 e0       	ldi	r19, 0x01	; 1
     7f2:	fc 01       	movw	r30, r24
     7f4:	31 83       	std	Z+1, r19	; 0x01
     7f6:	20 83       	st	Z, r18
     7f8:	20 e8       	ldi	r18, 0x80	; 128
     7fa:	35 e2       	ldi	r19, 0x25	; 37
     7fc:	33 83       	std	Z+3, r19	; 0x03
     7fe:	22 83       	std	Z+2, r18	; 0x02
     800:	20 91 cc 01 	lds	r18, 0x01CC	; 0x8001cc <_ZN11RS485Driver4instE>
     804:	30 91 cd 01 	lds	r19, 0x01CD	; 0x8001cd <_ZN11RS485Driver4instE+0x1>
     808:	23 2b       	or	r18, r19
     80a:	21 f4       	brne	.+8      	; 0x814 <_ZN11RS485DriverC1Ev+0x26>
     80c:	90 93 cd 01 	sts	0x01CD, r25	; 0x8001cd <_ZN11RS485Driver4instE+0x1>
     810:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <_ZN11RS485Driver4instE>
     814:	08 95       	ret

00000816 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     816:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
}
     81a:	08 95       	ret

0000081c <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
     824:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	44 e6       	ldi	r20, 0x64	; 100
     82a:	50 e0       	ldi	r21, 0x00	; 0
     82c:	60 e0       	ldi	r22, 0x00	; 0
     82e:	70 e0       	ldi	r23, 0x00	; 0
     830:	8c 81       	ldd	r24, Y+4	; 0x04
     832:	9d 81       	ldd	r25, Y+5	; 0x05
     834:	0e 94 a1 11 	call	0x2342	; 0x2342 <xQueueGenericReceive>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	81 f4       	brne	.+32     	; 0x85c <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     83c:	eb e9       	ldi	r30, 0x9B	; 155
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	80 81       	ld	r24, Z
     842:	85 ff       	sbrs	r24, 5
     844:	fd cf       	rjmp	.-6      	; 0x840 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     846:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     84a:	20 e0       	ldi	r18, 0x00	; 0
     84c:	40 e0       	ldi	r20, 0x00	; 0
     84e:	50 e0       	ldi	r21, 0x00	; 0
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	8c 81       	ldd	r24, Y+4	; 0x04
     856:	9d 81       	ldd	r25, Y+5	; 0x05
     858:	0e 94 f7 10 	call	0x21ee	; 0x21ee <xQueueGenericSend>
	}
}
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	08 95       	ret

00000864 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     864:	db cf       	rjmp	.-74     	; 0x81c <_ZN11RS485Driver12UART_PutcharEc>
     866:	08 95       	ret

00000868 <_ZN11RS485Driver14UART_PutStringEPKc>:
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	8c 01       	movw	r16, r24
     872:	eb 01       	movw	r28, r22
     874:	20 e0       	ldi	r18, 0x00	; 0
     876:	44 e6       	ldi	r20, 0x64	; 100
     878:	50 e0       	ldi	r21, 0x00	; 0
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	fc 01       	movw	r30, r24
     880:	86 81       	ldd	r24, Z+6	; 0x06
     882:	97 81       	ldd	r25, Z+7	; 0x07
     884:	0e 94 a1 11 	call	0x2342	; 0x2342 <xQueueGenericReceive>
     888:	81 30       	cpi	r24, 0x01	; 1
     88a:	99 f4       	brne	.+38     	; 0x8b2 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     88c:	68 81       	ld	r22, Y
     88e:	66 23       	and	r22, r22
     890:	31 f0       	breq	.+12     	; 0x89e <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     892:	21 96       	adiw	r28, 0x01	; 1
     894:	c8 01       	movw	r24, r16
     896:	c2 df       	rcall	.-124    	; 0x81c <_ZN11RS485Driver12UART_PutcharEc>
     898:	69 91       	ld	r22, Y+
     89a:	61 11       	cpse	r22, r1
     89c:	fb cf       	rjmp	.-10     	; 0x894 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     89e:	20 e0       	ldi	r18, 0x00	; 0
     8a0:	40 e0       	ldi	r20, 0x00	; 0
     8a2:	50 e0       	ldi	r21, 0x00	; 0
     8a4:	60 e0       	ldi	r22, 0x00	; 0
     8a6:	70 e0       	ldi	r23, 0x00	; 0
     8a8:	f8 01       	movw	r30, r16
     8aa:	86 81       	ldd	r24, Z+6	; 0x06
     8ac:	97 81       	ldd	r25, Z+7	; 0x07
     8ae:	0e 94 f7 10 	call	0x21ee	; 0x21ee <xQueueGenericSend>
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	1f 91       	pop	r17
     8b8:	0f 91       	pop	r16
     8ba:	08 95       	ret

000008bc <_ZN11RS485Driver13Device_WritesEPKc>:
     8bc:	d5 cf       	rjmp	.-86     	; 0x868 <_ZN11RS485Driver14UART_PutStringEPKc>
     8be:	08 95       	ret

000008c0 <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
     8c0:	1f 92       	push	r1
     8c2:	0f 92       	push	r0
     8c4:	0f b6       	in	r0, 0x3f	; 63
     8c6:	0f 92       	push	r0
     8c8:	11 24       	eor	r1, r1
     8ca:	0b b6       	in	r0, 0x3b	; 59
     8cc:	0f 92       	push	r0
     8ce:	8f 93       	push	r24
     8d0:	9f 93       	push	r25
     8d2:	ef 93       	push	r30
     8d4:	ff 93       	push	r31
	mem4[3]++;
     8d6:	e7 ef       	ldi	r30, 0xF7	; 247
     8d8:	f3 e0       	ldi	r31, 0x03	; 3
     8da:	86 81       	ldd	r24, Z+6	; 0x06
     8dc:	97 81       	ldd	r25, Z+7	; 0x07
     8de:	01 96       	adiw	r24, 0x01	; 1
     8e0:	97 83       	std	Z+7, r25	; 0x07
     8e2:	86 83       	std	Z+6, r24	; 0x06
}
     8e4:	ff 91       	pop	r31
     8e6:	ef 91       	pop	r30
     8e8:	9f 91       	pop	r25
     8ea:	8f 91       	pop	r24
     8ec:	0f 90       	pop	r0
     8ee:	0b be       	out	0x3b, r0	; 59
     8f0:	0f 90       	pop	r0
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	0f 90       	pop	r0
     8f6:	1f 90       	pop	r1
     8f8:	18 95       	reti

000008fa <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	ec 01       	movw	r28, r24
     900:	88 e9       	ldi	r24, 0x98	; 152
     902:	8a b9       	out	0x0a, r24	; 10
     904:	86 e0       	ldi	r24, 0x06	; 6
     906:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     90a:	be 01       	movw	r22, r28
     90c:	6e 5f       	subi	r22, 0xFE	; 254
     90e:	7f 4f       	sbci	r23, 0xFF	; 255
     910:	ce 01       	movw	r24, r28
     912:	75 d0       	rcall	.+234    	; 0x9fe <_ZN4Ubbr10Ubbr_ValueERKj>
     914:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     918:	99 b9       	out	0x09, r25	; 9
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	0e 94 89 11 	call	0x2312	; 0x2312 <xQueueCreateMutex>
     920:	9f 83       	std	Y+7, r25	; 0x07
     922:	8e 83       	std	Y+6, r24	; 0x06
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	0e 94 89 11 	call	0x2312	; 0x2312 <xQueueCreateMutex>
     92a:	9d 83       	std	Y+5, r25	; 0x05
     92c:	8c 83       	std	Y+4, r24	; 0x04
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	08 95       	ret

00000934 <_ZN10UartDriverC1Ev>:
     934:	2b e3       	ldi	r18, 0x3B	; 59
     936:	31 e0       	ldi	r19, 0x01	; 1
     938:	fc 01       	movw	r30, r24
     93a:	31 83       	std	Z+1, r19	; 0x01
     93c:	20 83       	st	Z, r18
     93e:	20 ec       	ldi	r18, 0xC0	; 192
     940:	32 e1       	ldi	r19, 0x12	; 18
     942:	33 83       	std	Z+3, r19	; 0x03
     944:	22 83       	std	Z+2, r18	; 0x02
     946:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <_ZN10UartDriver4instE>
     94a:	30 91 cf 01 	lds	r19, 0x01CF	; 0x8001cf <_ZN10UartDriver4instE+0x1>
     94e:	23 2b       	or	r18, r19
     950:	21 f4       	brne	.+8      	; 0x95a <_ZN10UartDriverC1Ev+0x26>
     952:	90 93 cf 01 	sts	0x01CF, r25	; 0x8001cf <_ZN10UartDriver4instE+0x1>
     956:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <_ZN10UartDriver4instE>
     95a:	08 95       	ret

0000095c <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     95c:	0c 94 c0 0d 	jmp	0x1b80	; 0x1b80 <pvPortMalloc>
}
     960:	08 95       	ret

00000962 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	ec 01       	movw	r28, r24
     96a:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     96c:	20 e0       	ldi	r18, 0x00	; 0
     96e:	44 e6       	ldi	r20, 0x64	; 100
     970:	50 e0       	ldi	r21, 0x00	; 0
     972:	60 e0       	ldi	r22, 0x00	; 0
     974:	70 e0       	ldi	r23, 0x00	; 0
     976:	8c 81       	ldd	r24, Y+4	; 0x04
     978:	9d 81       	ldd	r25, Y+5	; 0x05
     97a:	0e 94 a1 11 	call	0x2342	; 0x2342 <xQueueGenericReceive>
     97e:	81 30       	cpi	r24, 0x01	; 1
     980:	61 f4       	brne	.+24     	; 0x99a <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     982:	5d 9b       	sbis	0x0b, 5	; 11
     984:	fe cf       	rjmp	.-4      	; 0x982 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     986:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     988:	20 e0       	ldi	r18, 0x00	; 0
     98a:	40 e0       	ldi	r20, 0x00	; 0
     98c:	50 e0       	ldi	r21, 0x00	; 0
     98e:	60 e0       	ldi	r22, 0x00	; 0
     990:	70 e0       	ldi	r23, 0x00	; 0
     992:	8c 81       	ldd	r24, Y+4	; 0x04
     994:	9d 81       	ldd	r25, Y+5	; 0x05
     996:	0e 94 f7 10 	call	0x21ee	; 0x21ee <xQueueGenericSend>
	}
}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	08 95       	ret

000009a2 <_ZN10UartDriver12Device_WriteEc>:
     9a2:	df cf       	rjmp	.-66     	; 0x962 <_ZN10UartDriver12UART_PutcharEc>
     9a4:	08 95       	ret

000009a6 <_ZN10UartDriver14UART_PutStringEPKc>:
     9a6:	0f 93       	push	r16
     9a8:	1f 93       	push	r17
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	8c 01       	movw	r16, r24
     9b0:	eb 01       	movw	r28, r22
     9b2:	20 e0       	ldi	r18, 0x00	; 0
     9b4:	44 e6       	ldi	r20, 0x64	; 100
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	fc 01       	movw	r30, r24
     9be:	86 81       	ldd	r24, Z+6	; 0x06
     9c0:	97 81       	ldd	r25, Z+7	; 0x07
     9c2:	0e 94 a1 11 	call	0x2342	; 0x2342 <xQueueGenericReceive>
     9c6:	81 30       	cpi	r24, 0x01	; 1
     9c8:	99 f4       	brne	.+38     	; 0x9f0 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     9ca:	68 81       	ld	r22, Y
     9cc:	66 23       	and	r22, r22
     9ce:	31 f0       	breq	.+12     	; 0x9dc <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     9d0:	21 96       	adiw	r28, 0x01	; 1
     9d2:	c8 01       	movw	r24, r16
     9d4:	c6 df       	rcall	.-116    	; 0x962 <_ZN10UartDriver12UART_PutcharEc>
     9d6:	69 91       	ld	r22, Y+
     9d8:	61 11       	cpse	r22, r1
     9da:	fb cf       	rjmp	.-10     	; 0x9d2 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     9dc:	20 e0       	ldi	r18, 0x00	; 0
     9de:	40 e0       	ldi	r20, 0x00	; 0
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	60 e0       	ldi	r22, 0x00	; 0
     9e4:	70 e0       	ldi	r23, 0x00	; 0
     9e6:	f8 01       	movw	r30, r16
     9e8:	86 81       	ldd	r24, Z+6	; 0x06
     9ea:	97 81       	ldd	r25, Z+7	; 0x07
     9ec:	0e 94 f7 10 	call	0x21ee	; 0x21ee <xQueueGenericSend>
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	08 95       	ret

000009fa <_ZN10UartDriver13Device_WritesEPKc>:
     9fa:	d5 cf       	rjmp	.-86     	; 0x9a6 <_ZN10UartDriver14UART_PutStringEPKc>
     9fc:	08 95       	ret

000009fe <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     9fe:	cf 92       	push	r12
     a00:	df 92       	push	r13
     a02:	ef 92       	push	r14
     a04:	ff 92       	push	r15
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
     a0a:	fb 01       	movw	r30, r22
     a0c:	20 81       	ld	r18, Z
     a0e:	31 81       	ldd	r19, Z+1	; 0x01
     a10:	c9 01       	movw	r24, r18
     a12:	a0 e0       	ldi	r26, 0x00	; 0
     a14:	b0 e0       	ldi	r27, 0x00	; 0
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	aa 1f       	adc	r26, r26
     a1c:	bb 1f       	adc	r27, r27
     a1e:	88 0f       	add	r24, r24
     a20:	99 1f       	adc	r25, r25
     a22:	aa 1f       	adc	r26, r26
     a24:	bb 1f       	adc	r27, r27
     a26:	9c 01       	movw	r18, r24
     a28:	ad 01       	movw	r20, r26
     a2a:	22 0f       	add	r18, r18
     a2c:	33 1f       	adc	r19, r19
     a2e:	44 1f       	adc	r20, r20
     a30:	55 1f       	adc	r21, r21
     a32:	22 0f       	add	r18, r18
     a34:	33 1f       	adc	r19, r19
     a36:	44 1f       	adc	r20, r20
     a38:	55 1f       	adc	r21, r21
     a3a:	60 e0       	ldi	r22, 0x00	; 0
     a3c:	74 e2       	ldi	r23, 0x24	; 36
     a3e:	84 ef       	ldi	r24, 0xF4	; 244
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	0e 94 61 18 	call	0x30c2	; 0x30c2 <__udivmodsi4>
     a46:	ca 01       	movw	r24, r20
     a48:	b9 01       	movw	r22, r18
     a4a:	61 50       	subi	r22, 0x01	; 1
     a4c:	71 09       	sbc	r23, r1
     a4e:	81 09       	sbc	r24, r1
     a50:	91 09       	sbc	r25, r1
     a52:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <__floatunsisf>
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	40 e0       	ldi	r20, 0x00	; 0
     a5c:	5f e3       	ldi	r21, 0x3F	; 63
     a5e:	0e 94 43 17 	call	0x2e86	; 0x2e86 <__addsf3>
     a62:	6b 01       	movw	r12, r22
     a64:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     a66:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <__fixunssfsi>
     a6a:	d6 2f       	mov	r29, r22
     a6c:	f0 e0       	ldi	r31, 0x00	; 0
     a6e:	cf 2f       	mov	r28, r31
     a70:	c7 01       	movw	r24, r14
     a72:	b6 01       	movw	r22, r12
     a74:	0e 94 a7 17 	call	0x2f4e	; 0x2f4e <__fixunssfsi>
}
     a78:	ce 01       	movw	r24, r28
     a7a:	86 2b       	or	r24, r22
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	ff 90       	pop	r15
     a82:	ef 90       	pop	r14
     a84:	df 90       	pop	r13
     a86:	cf 90       	pop	r12
     a88:	08 95       	ret

00000a8a <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     a8a:	c0 98       	cbi	0x18, 0	; 24
     a8c:	96 2f       	mov	r25, r22
     a8e:	6f 71       	andi	r22, 0x1F	; 31
     a90:	86 2b       	or	r24, r22
     a92:	8f b9       	out	0x0f, r24	; 15
     a94:	77 9b       	sbis	0x0e, 7	; 14
     a96:	fe cf       	rjmp	.-4      	; 0xa94 <_Z14enc28j60ReadOphh+0xa>
     a98:	1f b8       	out	0x0f, r1	; 15
     a9a:	77 9b       	sbis	0x0e, 7	; 14
     a9c:	fe cf       	rjmp	.-4      	; 0xa9a <_Z14enc28j60ReadOphh+0x10>
     a9e:	99 23       	and	r25, r25
     aa0:	1c f4       	brge	.+6      	; 0xaa8 <_Z14enc28j60ReadOphh+0x1e>
     aa2:	1f b8       	out	0x0f, r1	; 15
     aa4:	77 9b       	sbis	0x0e, 7	; 14
     aa6:	fe cf       	rjmp	.-4      	; 0xaa4 <_Z14enc28j60ReadOphh+0x1a>
     aa8:	c0 9a       	sbi	0x18, 0	; 24
     aaa:	8f b1       	in	r24, 0x0f	; 15
     aac:	08 95       	ret

00000aae <_Z15enc28j60WriteOphhh>:
     aae:	c0 98       	cbi	0x18, 0	; 24
     ab0:	6f 71       	andi	r22, 0x1F	; 31
     ab2:	86 2b       	or	r24, r22
     ab4:	8f b9       	out	0x0f, r24	; 15
     ab6:	77 9b       	sbis	0x0e, 7	; 14
     ab8:	fe cf       	rjmp	.-4      	; 0xab6 <_Z15enc28j60WriteOphhh+0x8>
     aba:	4f b9       	out	0x0f, r20	; 15
     abc:	77 9b       	sbis	0x0e, 7	; 14
     abe:	fe cf       	rjmp	.-4      	; 0xabc <_Z15enc28j60WriteOphhh+0xe>
     ac0:	c0 9a       	sbi	0x18, 0	; 24
     ac2:	08 95       	ret

00000ac4 <_Z18enc28j60ReadBufferjPh>:
     ac4:	fb 01       	movw	r30, r22
     ac6:	c0 98       	cbi	0x18, 0	; 24
     ac8:	2a e3       	ldi	r18, 0x3A	; 58
     aca:	2f b9       	out	0x0f, r18	; 15
     acc:	77 9b       	sbis	0x0e, 7	; 14
     ace:	fe cf       	rjmp	.-4      	; 0xacc <_Z18enc28j60ReadBufferjPh+0x8>
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	61 f0       	breq	.+24     	; 0xaec <_Z18enc28j60ReadBufferjPh+0x28>
     ad4:	df 01       	movw	r26, r30
     ad6:	a8 0f       	add	r26, r24
     ad8:	b9 1f       	adc	r27, r25
     ada:	1f b8       	out	0x0f, r1	; 15
     adc:	77 9b       	sbis	0x0e, 7	; 14
     ade:	fe cf       	rjmp	.-4      	; 0xadc <_Z18enc28j60ReadBufferjPh+0x18>
     ae0:	9f b1       	in	r25, 0x0f	; 15
     ae2:	91 93       	st	Z+, r25
     ae4:	ae 17       	cp	r26, r30
     ae6:	bf 07       	cpc	r27, r31
     ae8:	c1 f7       	brne	.-16     	; 0xada <_Z18enc28j60ReadBufferjPh+0x16>
     aea:	01 c0       	rjmp	.+2      	; 0xaee <_Z18enc28j60ReadBufferjPh+0x2a>
     aec:	df 01       	movw	r26, r30
     aee:	1c 92       	st	X, r1
     af0:	c0 9a       	sbi	0x18, 0	; 24
     af2:	08 95       	ret

00000af4 <_Z19enc28j60WriteBufferjPh>:
     af4:	fb 01       	movw	r30, r22
     af6:	c0 98       	cbi	0x18, 0	; 24
     af8:	2a e7       	ldi	r18, 0x7A	; 122
     afa:	2f b9       	out	0x0f, r18	; 15
     afc:	77 9b       	sbis	0x0e, 7	; 14
     afe:	fe cf       	rjmp	.-4      	; 0xafc <_Z19enc28j60WriteBufferjPh+0x8>
     b00:	00 97       	sbiw	r24, 0x00	; 0
     b02:	61 f0       	breq	.+24     	; 0xb1c <_Z19enc28j60WriteBufferjPh+0x28>
     b04:	9f 01       	movw	r18, r30
     b06:	28 0f       	add	r18, r24
     b08:	39 1f       	adc	r19, r25
     b0a:	03 c0       	rjmp	.+6      	; 0xb12 <_Z19enc28j60WriteBufferjPh+0x1e>
     b0c:	2e 17       	cp	r18, r30
     b0e:	3f 07       	cpc	r19, r31
     b10:	29 f0       	breq	.+10     	; 0xb1c <_Z19enc28j60WriteBufferjPh+0x28>
     b12:	91 91       	ld	r25, Z+
     b14:	9f b9       	out	0x0f, r25	; 15
     b16:	77 9b       	sbis	0x0e, 7	; 14
     b18:	fe cf       	rjmp	.-4      	; 0xb16 <_Z19enc28j60WriteBufferjPh+0x22>
     b1a:	f8 cf       	rjmp	.-16     	; 0xb0c <_Z19enc28j60WriteBufferjPh+0x18>
     b1c:	c0 9a       	sbi	0x18, 0	; 24
     b1e:	08 95       	ret

00000b20 <_Z15enc28j60SetBankh>:
     b20:	1f 93       	push	r17
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
     b26:	18 2f       	mov	r17, r24
     b28:	10 76       	andi	r17, 0x60	; 96
     b2a:	c1 2f       	mov	r28, r17
     b2c:	d0 e0       	ldi	r29, 0x00	; 0
     b2e:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <_ZL12Enc28j60Bank>
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	c8 17       	cp	r28, r24
     b36:	d9 07       	cpc	r29, r25
     b38:	a1 f0       	breq	.+40     	; 0xb62 <_Z15enc28j60SetBankh+0x42>
     b3a:	43 e0       	ldi	r20, 0x03	; 3
     b3c:	6f e1       	ldi	r22, 0x1F	; 31
     b3e:	80 ea       	ldi	r24, 0xA0	; 160
     b40:	b6 df       	rcall	.-148    	; 0xaae <_Z15enc28j60WriteOphhh>
     b42:	ae 01       	movw	r20, r28
     b44:	55 95       	asr	r21
     b46:	47 95       	ror	r20
     b48:	55 95       	asr	r21
     b4a:	47 95       	ror	r20
     b4c:	55 95       	asr	r21
     b4e:	47 95       	ror	r20
     b50:	55 95       	asr	r21
     b52:	47 95       	ror	r20
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	6f e1       	ldi	r22, 0x1F	; 31
     b5a:	80 e8       	ldi	r24, 0x80	; 128
     b5c:	a8 df       	rcall	.-176    	; 0xaae <_Z15enc28j60WriteOphhh>
     b5e:	10 93 d2 01 	sts	0x01D2, r17	; 0x8001d2 <_ZL12Enc28j60Bank>
     b62:	df 91       	pop	r29
     b64:	cf 91       	pop	r28
     b66:	1f 91       	pop	r17
     b68:	08 95       	ret

00000b6a <_Z12enc28j60Readh>:
     b6a:	cf 93       	push	r28
     b6c:	c8 2f       	mov	r28, r24
     b6e:	d8 df       	rcall	.-80     	; 0xb20 <_Z15enc28j60SetBankh>
     b70:	6c 2f       	mov	r22, r28
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	8a df       	rcall	.-236    	; 0xa8a <_Z14enc28j60ReadOphh>
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <_Z13enc28j60Writehh>:
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	c8 2f       	mov	r28, r24
     b80:	d6 2f       	mov	r29, r22
     b82:	ce df       	rcall	.-100    	; 0xb20 <_Z15enc28j60SetBankh>
     b84:	4d 2f       	mov	r20, r29
     b86:	6c 2f       	mov	r22, r28
     b88:	80 e4       	ldi	r24, 0x40	; 64
     b8a:	91 df       	rcall	.-222    	; 0xaae <_Z15enc28j60WriteOphhh>
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
     b90:	08 95       	ret

00000b92 <_Z16enc28j60PhyWritehj>:
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	d6 2f       	mov	r29, r22
     b98:	c7 2f       	mov	r28, r23
     b9a:	68 2f       	mov	r22, r24
     b9c:	84 ed       	ldi	r24, 0xD4	; 212
     b9e:	ed df       	rcall	.-38     	; 0xb7a <_Z13enc28j60Writehh>
     ba0:	6d 2f       	mov	r22, r29
     ba2:	86 ed       	ldi	r24, 0xD6	; 214
     ba4:	ea df       	rcall	.-44     	; 0xb7a <_Z13enc28j60Writehh>
     ba6:	6c 2f       	mov	r22, r28
     ba8:	87 ed       	ldi	r24, 0xD7	; 215
     baa:	e7 df       	rcall	.-50     	; 0xb7a <_Z13enc28j60Writehh>
     bac:	8a ee       	ldi	r24, 0xEA	; 234
     bae:	dd df       	rcall	.-70     	; 0xb6a <_Z12enc28j60Readh>
     bb0:	80 ff       	sbrs	r24, 0
     bb2:	04 c0       	rjmp	.+8      	; 0xbbc <_Z16enc28j60PhyWritehj+0x2a>
     bb4:	85 e0       	ldi	r24, 0x05	; 5
     bb6:	8a 95       	dec	r24
     bb8:	f1 f7       	brne	.-4      	; 0xbb6 <_Z16enc28j60PhyWritehj+0x24>
     bba:	f8 cf       	rjmp	.-16     	; 0xbac <_Z16enc28j60PhyWritehj+0x1a>
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	08 95       	ret

00000bc2 <_Z14enc28j60clkouth>:
     bc2:	68 2f       	mov	r22, r24
     bc4:	67 70       	andi	r22, 0x07	; 7
     bc6:	85 e7       	ldi	r24, 0x75	; 117
     bc8:	d8 cf       	rjmp	.-80     	; 0xb7a <_Z13enc28j60Writehh>
     bca:	08 95       	ret

00000bcc <_Z12enc28j60InitPh>:
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	ec 01       	movw	r28, r24
     bd2:	b8 9a       	sbi	0x17, 0	; 23
     bd4:	c0 9a       	sbi	0x18, 0	; 24
     bd6:	a6 d2       	rcall	.+1356   	; 0x1124 <_Z8spi_initv>
     bd8:	4f ef       	ldi	r20, 0xFF	; 255
     bda:	60 e0       	ldi	r22, 0x00	; 0
     bdc:	8f ef       	ldi	r24, 0xFF	; 255
     bde:	67 df       	rcall	.-306    	; 0xaae <_Z15enc28j60WriteOphhh>
     be0:	82 e3       	ldi	r24, 0x32	; 50
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	a9 d2       	rcall	.+1362   	; 0x1138 <_Z8delay_msj>
     be6:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
     bea:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <_ZL13NextPacketPtr>
     bee:	60 e0       	ldi	r22, 0x00	; 0
     bf0:	88 e0       	ldi	r24, 0x08	; 8
     bf2:	c3 df       	rcall	.-122    	; 0xb7a <_Z13enc28j60Writehh>
     bf4:	60 e0       	ldi	r22, 0x00	; 0
     bf6:	89 e0       	ldi	r24, 0x09	; 9
     bf8:	c0 df       	rcall	.-128    	; 0xb7a <_Z13enc28j60Writehh>
     bfa:	60 e0       	ldi	r22, 0x00	; 0
     bfc:	8c e0       	ldi	r24, 0x0C	; 12
     bfe:	bd df       	rcall	.-134    	; 0xb7a <_Z13enc28j60Writehh>
     c00:	60 e0       	ldi	r22, 0x00	; 0
     c02:	8d e0       	ldi	r24, 0x0D	; 13
     c04:	ba df       	rcall	.-140    	; 0xb7a <_Z13enc28j60Writehh>
     c06:	6e ef       	ldi	r22, 0xFE	; 254
     c08:	8a e0       	ldi	r24, 0x0A	; 10
     c0a:	b7 df       	rcall	.-146    	; 0xb7a <_Z13enc28j60Writehh>
     c0c:	69 e1       	ldi	r22, 0x19	; 25
     c0e:	8b e0       	ldi	r24, 0x0B	; 11
     c10:	b4 df       	rcall	.-152    	; 0xb7a <_Z13enc28j60Writehh>
     c12:	6f ef       	ldi	r22, 0xFF	; 255
     c14:	84 e0       	ldi	r24, 0x04	; 4
     c16:	b1 df       	rcall	.-158    	; 0xb7a <_Z13enc28j60Writehh>
     c18:	69 e1       	ldi	r22, 0x19	; 25
     c1a:	85 e0       	ldi	r24, 0x05	; 5
     c1c:	ae df       	rcall	.-164    	; 0xb7a <_Z13enc28j60Writehh>
     c1e:	6f ef       	ldi	r22, 0xFF	; 255
     c20:	86 e0       	ldi	r24, 0x06	; 6
     c22:	ab df       	rcall	.-170    	; 0xb7a <_Z13enc28j60Writehh>
     c24:	6f e1       	ldi	r22, 0x1F	; 31
     c26:	87 e0       	ldi	r24, 0x07	; 7
     c28:	a8 df       	rcall	.-176    	; 0xb7a <_Z13enc28j60Writehh>
     c2a:	60 eb       	ldi	r22, 0xB0	; 176
     c2c:	88 e3       	ldi	r24, 0x38	; 56
     c2e:	a5 df       	rcall	.-182    	; 0xb7a <_Z13enc28j60Writehh>
     c30:	6f e3       	ldi	r22, 0x3F	; 63
     c32:	88 e2       	ldi	r24, 0x28	; 40
     c34:	a2 df       	rcall	.-188    	; 0xb7a <_Z13enc28j60Writehh>
     c36:	60 e3       	ldi	r22, 0x30	; 48
     c38:	89 e2       	ldi	r24, 0x29	; 41
     c3a:	9f df       	rcall	.-194    	; 0xb7a <_Z13enc28j60Writehh>
     c3c:	69 ef       	ldi	r22, 0xF9	; 249
     c3e:	80 e3       	ldi	r24, 0x30	; 48
     c40:	9c df       	rcall	.-200    	; 0xb7a <_Z13enc28j60Writehh>
     c42:	67 ef       	ldi	r22, 0xF7	; 247
     c44:	81 e3       	ldi	r24, 0x31	; 49
     c46:	99 df       	rcall	.-206    	; 0xb7a <_Z13enc28j60Writehh>
     c48:	6d e0       	ldi	r22, 0x0D	; 13
     c4a:	80 ec       	ldi	r24, 0xC0	; 192
     c4c:	96 df       	rcall	.-212    	; 0xb7a <_Z13enc28j60Writehh>
     c4e:	60 e0       	ldi	r22, 0x00	; 0
     c50:	81 ec       	ldi	r24, 0xC1	; 193
     c52:	93 df       	rcall	.-218    	; 0xb7a <_Z13enc28j60Writehh>
     c54:	42 e3       	ldi	r20, 0x32	; 50
     c56:	62 ec       	ldi	r22, 0xC2	; 194
     c58:	80 e8       	ldi	r24, 0x80	; 128
     c5a:	29 df       	rcall	.-430    	; 0xaae <_Z15enc28j60WriteOphhh>
     c5c:	62 e1       	ldi	r22, 0x12	; 18
     c5e:	86 ec       	ldi	r24, 0xC6	; 198
     c60:	8c df       	rcall	.-232    	; 0xb7a <_Z13enc28j60Writehh>
     c62:	6c e0       	ldi	r22, 0x0C	; 12
     c64:	87 ec       	ldi	r24, 0xC7	; 199
     c66:	89 df       	rcall	.-238    	; 0xb7a <_Z13enc28j60Writehh>
     c68:	62 e1       	ldi	r22, 0x12	; 18
     c6a:	84 ec       	ldi	r24, 0xC4	; 196
     c6c:	86 df       	rcall	.-244    	; 0xb7a <_Z13enc28j60Writehh>
     c6e:	6c ed       	ldi	r22, 0xDC	; 220
     c70:	8a ec       	ldi	r24, 0xCA	; 202
     c72:	83 df       	rcall	.-250    	; 0xb7a <_Z13enc28j60Writehh>
     c74:	65 e0       	ldi	r22, 0x05	; 5
     c76:	8b ec       	ldi	r24, 0xCB	; 203
     c78:	80 df       	rcall	.-256    	; 0xb7a <_Z13enc28j60Writehh>
     c7a:	68 81       	ld	r22, Y
     c7c:	84 ee       	ldi	r24, 0xE4	; 228
     c7e:	7d df       	rcall	.-262    	; 0xb7a <_Z13enc28j60Writehh>
     c80:	69 81       	ldd	r22, Y+1	; 0x01
     c82:	85 ee       	ldi	r24, 0xE5	; 229
     c84:	7a df       	rcall	.-268    	; 0xb7a <_Z13enc28j60Writehh>
     c86:	6a 81       	ldd	r22, Y+2	; 0x02
     c88:	82 ee       	ldi	r24, 0xE2	; 226
     c8a:	77 df       	rcall	.-274    	; 0xb7a <_Z13enc28j60Writehh>
     c8c:	6b 81       	ldd	r22, Y+3	; 0x03
     c8e:	83 ee       	ldi	r24, 0xE3	; 227
     c90:	74 df       	rcall	.-280    	; 0xb7a <_Z13enc28j60Writehh>
     c92:	6c 81       	ldd	r22, Y+4	; 0x04
     c94:	80 ee       	ldi	r24, 0xE0	; 224
     c96:	71 df       	rcall	.-286    	; 0xb7a <_Z13enc28j60Writehh>
     c98:	6d 81       	ldd	r22, Y+5	; 0x05
     c9a:	81 ee       	ldi	r24, 0xE1	; 225
     c9c:	6e df       	rcall	.-292    	; 0xb7a <_Z13enc28j60Writehh>
     c9e:	60 e0       	ldi	r22, 0x00	; 0
     ca0:	71 e0       	ldi	r23, 0x01	; 1
     ca2:	80 e1       	ldi	r24, 0x10	; 16
     ca4:	76 df       	rcall	.-276    	; 0xb92 <_Z16enc28j60PhyWritehj>
     ca6:	8f e1       	ldi	r24, 0x1F	; 31
     ca8:	3b df       	rcall	.-394    	; 0xb20 <_Z15enc28j60SetBankh>
     caa:	40 ec       	ldi	r20, 0xC0	; 192
     cac:	6b e1       	ldi	r22, 0x1B	; 27
     cae:	80 e8       	ldi	r24, 0x80	; 128
     cb0:	fe de       	rcall	.-516    	; 0xaae <_Z15enc28j60WriteOphhh>
     cb2:	44 e0       	ldi	r20, 0x04	; 4
     cb4:	6f e1       	ldi	r22, 0x1F	; 31
     cb6:	80 e8       	ldi	r24, 0x80	; 128
     cb8:	fa de       	rcall	.-524    	; 0xaae <_Z15enc28j60WriteOphhh>
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

00000cc0 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     cc0:	0f 93       	push	r16
     cc2:	1f 93       	push	r17
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
     cc8:	ec 01       	movw	r28, r24
     cca:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     ccc:	6f ef       	ldi	r22, 0xFF	; 255
     cce:	82 e0       	ldi	r24, 0x02	; 2
     cd0:	54 df       	rcall	.-344    	; 0xb7a <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     cd2:	69 e1       	ldi	r22, 0x19	; 25
     cd4:	83 e0       	ldi	r24, 0x03	; 3
     cd6:	51 df       	rcall	.-350    	; 0xb7a <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     cd8:	6c 2f       	mov	r22, r28
     cda:	61 50       	subi	r22, 0x01	; 1
     cdc:	86 e0       	ldi	r24, 0x06	; 6
     cde:	4d df       	rcall	.-358    	; 0xb7a <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     ce0:	ce 01       	movw	r24, r28
     ce2:	81 50       	subi	r24, 0x01	; 1
     ce4:	96 4e       	sbci	r25, 0xE6	; 230
     ce6:	69 2f       	mov	r22, r25
     ce8:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     cea:	47 df       	rcall	.-370    	; 0xb7a <_Z13enc28j60Writehh>
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	60 e0       	ldi	r22, 0x00	; 0
     cf0:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     cf2:	dd de       	rcall	.-582    	; 0xaae <_Z15enc28j60WriteOphhh>
     cf4:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     cf6:	ce 01       	movw	r24, r28
     cf8:	fd de       	rcall	.-518    	; 0xaf4 <_Z19enc28j60WriteBufferjPh>
     cfa:	48 e0       	ldi	r20, 0x08	; 8
     cfc:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     cfe:	80 e8       	ldi	r24, 0x80	; 128
     d00:	d6 de       	rcall	.-596    	; 0xaae <_Z15enc28j60WriteOphhh>
     d02:	8c e1       	ldi	r24, 0x1C	; 28
     d04:	32 df       	rcall	.-412    	; 0xb6a <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     d06:	81 ff       	sbrs	r24, 1
     d08:	04 c0       	rjmp	.+8      	; 0xd12 <_Z18enc28j60PacketSendjPh+0x52>
     d0a:	48 e0       	ldi	r20, 0x08	; 8
     d0c:	6f e1       	ldi	r22, 0x1F	; 31
     d0e:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     d10:	ce de       	rcall	.-612    	; 0xaae <_Z15enc28j60WriteOphhh>
     d12:	df 91       	pop	r29
     d14:	cf 91       	pop	r28
     d16:	1f 91       	pop	r17
     d18:	0f 91       	pop	r16
     d1a:	08 95       	ret

00000d1c <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     d1c:	9f 92       	push	r9
     d1e:	af 92       	push	r10
     d20:	bf 92       	push	r11
     d22:	cf 92       	push	r12
     d24:	df 92       	push	r13
     d26:	ef 92       	push	r14
     d28:	ff 92       	push	r15
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	cf 93       	push	r28
     d30:	df 93       	push	r29
     d32:	5c 01       	movw	r10, r24
     d34:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     d36:	89 e3       	ldi	r24, 0x39	; 57
     d38:	18 df       	rcall	.-464    	; 0xb6a <_Z12enc28j60Readh>
     d3a:	88 23       	and	r24, r24
     d3c:	09 f4       	brne	.+2      	; 0xd40 <_Z21enc28j60PacketReceivejPh+0x24>
     d3e:	45 c0       	rjmp	.+138    	; 0xdca <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     d40:	60 91 d0 01 	lds	r22, 0x01D0	; 0x8001d0 <_ZL13NextPacketPtr>
     d44:	c0 91 d1 01 	lds	r28, 0x01D1	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
     d48:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     d4a:	17 df       	rcall	.-466    	; 0xb7a <_Z13enc28j60Writehh>
     d4c:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	14 df       	rcall	.-472    	; 0xb7a <_Z13enc28j60Writehh>
     d52:	60 e0       	ldi	r22, 0x00	; 0
     d54:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d56:	99 de       	rcall	.-718    	; 0xa8a <_Z14enc28j60ReadOphh>
     d58:	c8 2f       	mov	r28, r24
     d5a:	60 e0       	ldi	r22, 0x00	; 0
     d5c:	8a e3       	ldi	r24, 0x3A	; 58
     d5e:	95 de       	rcall	.-726    	; 0xa8a <_Z14enc28j60ReadOphh>
     d60:	d0 e0       	ldi	r29, 0x00	; 0
     d62:	d8 2b       	or	r29, r24
     d64:	d0 93 d1 01 	sts	0x01D1, r29	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d68:	c0 93 d0 01 	sts	0x01D0, r28	; 0x8001d0 <_ZL13NextPacketPtr>
     d6c:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d6e:	8a e3       	ldi	r24, 0x3A	; 58
     d70:	8c de       	rcall	.-744    	; 0xa8a <_Z14enc28j60ReadOphh>
     d72:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d74:	60 e0       	ldi	r22, 0x00	; 0
     d76:	8a e3       	ldi	r24, 0x3A	; 58
     d78:	88 de       	rcall	.-752    	; 0xa8a <_Z14enc28j60ReadOphh>
     d7a:	98 2e       	mov	r9, r24
     d7c:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     d7e:	8a e3       	ldi	r24, 0x3A	; 58
     d80:	84 de       	rcall	.-760    	; 0xa8a <_Z14enc28j60ReadOphh>
     d82:	c8 2e       	mov	r12, r24
     d84:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     d86:	8a e3       	ldi	r24, 0x3A	; 58
     d88:	80 de       	rcall	.-768    	; 0xa8a <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     d8a:	c7 fe       	sbrs	r12, 7
     d8c:	0f c0       	rjmp	.+30     	; 0xdac <_Z21enc28j60PacketReceivejPh+0x90>
     d8e:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d90:	a8 1a       	sub	r10, r24
     d92:	b1 08       	sbc	r11, r1
     d94:	10 e0       	ldi	r17, 0x00	; 0
     d96:	19 29       	or	r17, r9
     d98:	04 50       	subi	r16, 0x04	; 4
     d9a:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     d9c:	a0 16       	cp	r10, r16
     d9e:	b1 06       	cpc	r11, r17
     da0:	08 f4       	brcc	.+2      	; 0xda4 <_Z21enc28j60PacketReceivejPh+0x88>
     da2:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     da4:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     da6:	c8 01       	movw	r24, r16
     da8:	8d de       	rcall	.-742    	; 0xac4 <_Z18enc28j60ReadBufferjPh>
     daa:	02 c0       	rjmp	.+4      	; 0xdb0 <_Z21enc28j60PacketReceivejPh+0x94>
     dac:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     dae:	10 e0       	ldi	r17, 0x00	; 0
     db0:	6c 2f       	mov	r22, r28
     db2:	8c e0       	ldi	r24, 0x0C	; 12
     db4:	e2 de       	rcall	.-572    	; 0xb7a <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     db6:	6d 2f       	mov	r22, r29
     db8:	8d e0       	ldi	r24, 0x0D	; 13
     dba:	df de       	rcall	.-578    	; 0xb7a <_Z13enc28j60Writehh>
     dbc:	40 e4       	ldi	r20, 0x40	; 64
     dbe:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     dc0:	80 e8       	ldi	r24, 0x80	; 128
     dc2:	75 de       	rcall	.-790    	; 0xaae <_Z15enc28j60WriteOphhh>
     dc4:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     dc6:	91 2f       	mov	r25, r17
     dc8:	02 c0       	rjmp	.+4      	; 0xdce <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	1f 91       	pop	r17
     dd4:	0f 91       	pop	r16
     dd6:	ff 90       	pop	r15
     dd8:	ef 90       	pop	r14
     dda:	df 90       	pop	r13
     ddc:	cf 90       	pop	r12
     dde:	bf 90       	pop	r11
     de0:	af 90       	pop	r10
     de2:	9f 90       	pop	r9
     de4:	08 95       	ret

00000de6 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     de6:	cf 92       	push	r12
     de8:	df 92       	push	r13
     dea:	ef 92       	push	r14
     dec:	ff 92       	push	r15
     dee:	cf 93       	push	r28
     df0:	df 93       	push	r29
     df2:	ec 01       	movw	r28, r24
     df4:	db 01       	movw	r26, r22
     df6:	41 30       	cpi	r20, 0x01	; 1
     df8:	61 f4       	brne	.+24     	; 0xe12 <_Z8checksumPhjh+0x2c>
     dfa:	6b 01       	movw	r12, r22
     dfc:	88 e0       	ldi	r24, 0x08	; 8
     dfe:	c8 1a       	sub	r12, r24
     e00:	d1 08       	sbc	r13, r1
     e02:	e1 2c       	mov	r14, r1
     e04:	f1 2c       	mov	r15, r1
     e06:	81 e1       	ldi	r24, 0x11	; 17
     e08:	c8 0e       	add	r12, r24
     e0a:	d1 1c       	adc	r13, r1
     e0c:	e1 1c       	adc	r14, r1
     e0e:	f1 1c       	adc	r15, r1
     e10:	11 c0       	rjmp	.+34     	; 0xe34 <_Z8checksumPhjh+0x4e>
     e12:	42 30       	cpi	r20, 0x02	; 2
     e14:	61 f4       	brne	.+24     	; 0xe2e <_Z8checksumPhjh+0x48>
     e16:	6b 01       	movw	r12, r22
     e18:	88 e0       	ldi	r24, 0x08	; 8
     e1a:	c8 1a       	sub	r12, r24
     e1c:	d1 08       	sbc	r13, r1
     e1e:	e1 2c       	mov	r14, r1
     e20:	f1 2c       	mov	r15, r1
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	c8 0e       	add	r12, r24
     e26:	d1 1c       	adc	r13, r1
     e28:	e1 1c       	adc	r14, r1
     e2a:	f1 1c       	adc	r15, r1
     e2c:	03 c0       	rjmp	.+6      	; 0xe34 <_Z8checksumPhjh+0x4e>
     e2e:	c1 2c       	mov	r12, r1
     e30:	d1 2c       	mov	r13, r1
     e32:	76 01       	movw	r14, r12
     e34:	a2 30       	cpi	r26, 0x02	; 2
     e36:	b1 05       	cpc	r27, r1
     e38:	f0 f0       	brcs	.+60     	; 0xe76 <_Z8checksumPhjh+0x90>
     e3a:	9d 01       	movw	r18, r26
     e3c:	fe 01       	movw	r30, r28
     e3e:	40 81       	ld	r20, Z
     e40:	50 e0       	ldi	r21, 0x00	; 0
     e42:	60 e0       	ldi	r22, 0x00	; 0
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	76 2f       	mov	r23, r22
     e48:	65 2f       	mov	r22, r21
     e4a:	54 2f       	mov	r21, r20
     e4c:	44 27       	eor	r20, r20
     e4e:	81 81       	ldd	r24, Z+1	; 0x01
     e50:	48 2b       	or	r20, r24
     e52:	c4 0e       	add	r12, r20
     e54:	d5 1e       	adc	r13, r21
     e56:	e6 1e       	adc	r14, r22
     e58:	f7 1e       	adc	r15, r23
     e5a:	32 96       	adiw	r30, 0x02	; 2
     e5c:	22 50       	subi	r18, 0x02	; 2
     e5e:	31 09       	sbc	r19, r1
     e60:	22 30       	cpi	r18, 0x02	; 2
     e62:	31 05       	cpc	r19, r1
     e64:	60 f7       	brcc	.-40     	; 0xe3e <_Z8checksumPhjh+0x58>
     e66:	cd 01       	movw	r24, r26
     e68:	02 97       	sbiw	r24, 0x02	; 2
     e6a:	8e 7f       	andi	r24, 0xFE	; 254
     e6c:	02 96       	adiw	r24, 0x02	; 2
     e6e:	c8 0f       	add	r28, r24
     e70:	d9 1f       	adc	r29, r25
     e72:	a1 70       	andi	r26, 0x01	; 1
     e74:	bb 27       	eor	r27, r27
     e76:	ab 2b       	or	r26, r27
     e78:	61 f0       	breq	.+24     	; 0xe92 <_Z8checksumPhjh+0xac>
     e7a:	88 81       	ld	r24, Y
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	a0 e0       	ldi	r26, 0x00	; 0
     e80:	b0 e0       	ldi	r27, 0x00	; 0
     e82:	ba 2f       	mov	r27, r26
     e84:	a9 2f       	mov	r26, r25
     e86:	98 2f       	mov	r25, r24
     e88:	88 27       	eor	r24, r24
     e8a:	c8 0e       	add	r12, r24
     e8c:	d9 1e       	adc	r13, r25
     e8e:	ea 1e       	adc	r14, r26
     e90:	fb 1e       	adc	r15, r27
     e92:	a7 01       	movw	r20, r14
     e94:	66 27       	eor	r22, r22
     e96:	77 27       	eor	r23, r23
     e98:	41 15       	cp	r20, r1
     e9a:	51 05       	cpc	r21, r1
     e9c:	61 05       	cpc	r22, r1
     e9e:	71 05       	cpc	r23, r1
     ea0:	71 f0       	breq	.+28     	; 0xebe <_Z8checksumPhjh+0xd8>
     ea2:	ee 24       	eor	r14, r14
     ea4:	ff 24       	eor	r15, r15
     ea6:	c4 0e       	add	r12, r20
     ea8:	d5 1e       	adc	r13, r21
     eaa:	e6 1e       	adc	r14, r22
     eac:	f7 1e       	adc	r15, r23
     eae:	a7 01       	movw	r20, r14
     eb0:	66 27       	eor	r22, r22
     eb2:	77 27       	eor	r23, r23
     eb4:	41 15       	cp	r20, r1
     eb6:	51 05       	cpc	r21, r1
     eb8:	61 05       	cpc	r22, r1
     eba:	71 05       	cpc	r23, r1
     ebc:	91 f7       	brne	.-28     	; 0xea2 <_Z8checksumPhjh+0xbc>
     ebe:	c6 01       	movw	r24, r12
     ec0:	80 95       	com	r24
     ec2:	90 95       	com	r25
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	08 95       	ret

00000ed2 <_Z19init_ip_arp_udp_tcpPhS_h>:
     ed2:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     ed6:	a6 2f       	mov	r26, r22
     ed8:	b7 2f       	mov	r27, r23
     eda:	e3 ed       	ldi	r30, 0xD3	; 211
     edc:	f1 e0       	ldi	r31, 0x01	; 1
     ede:	47 ed       	ldi	r20, 0xD7	; 215
     ee0:	51 e0       	ldi	r21, 0x01	; 1
     ee2:	2d 91       	ld	r18, X+
     ee4:	21 93       	st	Z+, r18
     ee6:	e4 17       	cp	r30, r20
     ee8:	f5 07       	cpc	r31, r21
     eea:	d9 f7       	brne	.-10     	; 0xee2 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     eec:	a8 2f       	mov	r26, r24
     eee:	b9 2f       	mov	r27, r25
     ef0:	e7 ed       	ldi	r30, 0xD7	; 215
     ef2:	f1 e0       	ldi	r31, 0x01	; 1
     ef4:	2d ed       	ldi	r18, 0xDD	; 221
     ef6:	31 e0       	ldi	r19, 0x01	; 1
     ef8:	8d 91       	ld	r24, X+
     efa:	81 93       	st	Z+, r24
     efc:	e2 17       	cp	r30, r18
     efe:	f3 07       	cpc	r31, r19
     f00:	d9 f7       	brne	.-10     	; 0xef8 <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     f02:	08 95       	ret

00000f04 <_Z25eth_type_is_arp_and_my_ipPhj>:
     f04:	69 32       	cpi	r22, 0x29	; 41
     f06:	71 05       	cpc	r23, r1
     f08:	c8 f0       	brcs	.+50     	; 0xf3c <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     f0a:	fc 01       	movw	r30, r24
     f0c:	24 85       	ldd	r18, Z+12	; 0x0c
     f0e:	28 30       	cpi	r18, 0x08	; 8
     f10:	b9 f4       	brne	.+46     	; 0xf40 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     f12:	25 85       	ldd	r18, Z+13	; 0x0d
     f14:	26 30       	cpi	r18, 0x06	; 6
     f16:	b1 f4       	brne	.+44     	; 0xf44 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     f18:	36 a1       	ldd	r19, Z+38	; 0x26
     f1a:	20 91 d3 01 	lds	r18, 0x01D3	; 0x8001d3 <_ZL6ipaddr>
     f1e:	32 13       	cpse	r19, r18
     f20:	13 c0       	rjmp	.+38     	; 0xf48 <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     f22:	b7 96       	adiw	r30, 0x27	; 39
     f24:	a4 ed       	ldi	r26, 0xD4	; 212
     f26:	b1 e0       	ldi	r27, 0x01	; 1
     f28:	8a 96       	adiw	r24, 0x2a	; 42
     f2a:	31 91       	ld	r19, Z+
     f2c:	2d 91       	ld	r18, X+
     f2e:	32 13       	cpse	r19, r18
     f30:	0d c0       	rjmp	.+26     	; 0xf4c <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     f32:	e8 17       	cp	r30, r24
     f34:	f9 07       	cpc	r31, r25
     f36:	c9 f7       	brne	.-14     	; 0xf2a <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	08 95       	ret
     f3c:	80 e0       	ldi	r24, 0x00	; 0
     f3e:	08 95       	ret
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	08 95       	ret
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	08 95       	ret
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	08 95       	ret
     f4c:	80 e0       	ldi	r24, 0x00	; 0
     f4e:	08 95       	ret

00000f50 <_Z24eth_type_is_ip_and_my_ipPhj>:
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
     f54:	fc 01       	movw	r30, r24
     f56:	6a 32       	cpi	r22, 0x2A	; 42
     f58:	71 05       	cpc	r23, r1
     f5a:	e0 f0       	brcs	.+56     	; 0xf94 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     f5c:	84 85       	ldd	r24, Z+12	; 0x0c
     f5e:	88 30       	cpi	r24, 0x08	; 8
     f60:	d9 f4       	brne	.+54     	; 0xf98 <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     f62:	85 85       	ldd	r24, Z+13	; 0x0d
     f64:	81 11       	cpse	r24, r1
     f66:	1a c0       	rjmp	.+52     	; 0xf9c <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     f68:	96 85       	ldd	r25, Z+14	; 0x0e
     f6a:	95 34       	cpi	r25, 0x45	; 69
     f6c:	c1 f4       	brne	.+48     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f6e:	26 8d       	ldd	r18, Z+30	; 0x1e
     f70:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <_ZL6ipaddr>
     f74:	29 13       	cpse	r18, r25
     f76:	13 c0       	rjmp	.+38     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f78:	df 01       	movw	r26, r30
     f7a:	5f 96       	adiw	r26, 0x1f	; 31
     f7c:	c4 ed       	ldi	r28, 0xD4	; 212
     f7e:	d1 e0       	ldi	r29, 0x01	; 1
     f80:	b2 96       	adiw	r30, 0x22	; 34
     f82:	2d 91       	ld	r18, X+
     f84:	99 91       	ld	r25, Y+
     f86:	29 13       	cpse	r18, r25
     f88:	0a c0       	rjmp	.+20     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f8a:	ae 17       	cp	r26, r30
     f8c:	bf 07       	cpc	r27, r31
     f8e:	c9 f7       	brne	.-14     	; 0xf82 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	05 c0       	rjmp	.+10     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f94:	80 e0       	ldi	r24, 0x00	; 0
     f96:	03 c0       	rjmp	.+6      	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	01 c0       	rjmp	.+2      	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret

00000fa4 <_Z8make_ethPh>:
     fa4:	fc 01       	movw	r30, r24
     fa6:	a7 ed       	ldi	r26, 0xD7	; 215
     fa8:	b1 e0       	ldi	r27, 0x01	; 1
     faa:	9c 01       	movw	r18, r24
     fac:	2a 5f       	subi	r18, 0xFA	; 250
     fae:	3f 4f       	sbci	r19, 0xFF	; 255
     fb0:	86 81       	ldd	r24, Z+6	; 0x06
     fb2:	81 93       	st	Z+, r24
     fb4:	8d 91       	ld	r24, X+
     fb6:	85 83       	std	Z+5, r24	; 0x05
     fb8:	e2 17       	cp	r30, r18
     fba:	f3 07       	cpc	r31, r19
     fbc:	c9 f7       	brne	.-14     	; 0xfb0 <_Z8make_ethPh+0xc>
     fbe:	08 95       	ret

00000fc0 <_Z20fill_ip_hdr_checksumPh>:
     fc0:	cf 93       	push	r28
     fc2:	df 93       	push	r29
     fc4:	ec 01       	movw	r28, r24
     fc6:	18 8e       	std	Y+24, r1	; 0x18
     fc8:	19 8e       	std	Y+25, r1	; 0x19
     fca:	80 e4       	ldi	r24, 0x40	; 64
     fcc:	8c 8b       	std	Y+20, r24	; 0x14
     fce:	1d 8a       	std	Y+21, r1	; 0x15
     fd0:	8e 8b       	std	Y+22, r24	; 0x16
     fd2:	40 e0       	ldi	r20, 0x00	; 0
     fd4:	64 e1       	ldi	r22, 0x14	; 20
     fd6:	70 e0       	ldi	r23, 0x00	; 0
     fd8:	ce 01       	movw	r24, r28
     fda:	0e 96       	adiw	r24, 0x0e	; 14
     fdc:	04 df       	rcall	.-504    	; 0xde6 <_Z8checksumPhjh>
     fde:	98 8f       	std	Y+24, r25	; 0x18
     fe0:	89 8f       	std	Y+25, r24	; 0x19
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	08 95       	ret

00000fe8 <_Z7make_ipPh>:
     fe8:	ac 01       	movw	r20, r24
     fea:	a3 ed       	ldi	r26, 0xD3	; 211
     fec:	b1 e0       	ldi	r27, 0x01	; 1
     fee:	fc 01       	movw	r30, r24
     ff0:	7a 96       	adiw	r30, 0x1a	; 26
     ff2:	27 ed       	ldi	r18, 0xD7	; 215
     ff4:	31 e0       	ldi	r19, 0x01	; 1
     ff6:	90 81       	ld	r25, Z
     ff8:	94 83       	std	Z+4, r25	; 0x04
     ffa:	9d 91       	ld	r25, X+
     ffc:	91 93       	st	Z+, r25
     ffe:	a2 17       	cp	r26, r18
    1000:	b3 07       	cpc	r27, r19
    1002:	c9 f7       	brne	.-14     	; 0xff6 <_Z7make_ipPh+0xe>
    1004:	ca 01       	movw	r24, r20
    1006:	dc cf       	rjmp	.-72     	; 0xfc0 <_Z20fill_ip_hdr_checksumPh>
    1008:	08 95       	ret

0000100a <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    100e:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    1010:	c9 df       	rcall	.-110    	; 0xfa4 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    1012:	1c 8a       	std	Y+20, r1	; 0x14
    1014:	82 e0       	ldi	r24, 0x02	; 2
    1016:	8d 8b       	std	Y+21, r24	; 0x15
    1018:	a7 ed       	ldi	r26, 0xD7	; 215
    101a:	b1 e0       	ldi	r27, 0x01	; 1
    101c:	fe 01       	movw	r30, r28
    101e:	76 96       	adiw	r30, 0x16	; 22
    1020:	2d ed       	ldi	r18, 0xDD	; 221
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    1022:	31 e0       	ldi	r19, 0x01	; 1
    1024:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    1026:	82 87       	std	Z+10, r24	; 0x0a
    1028:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    102a:	81 93       	st	Z+, r24
    102c:	a2 17       	cp	r26, r18
    102e:	b3 07       	cpc	r27, r19
    1030:	c9 f7       	brne	.-14     	; 0x1024 <_Z28make_arp_answer_from_requestPh+0x1a>
    1032:	a3 ed       	ldi	r26, 0xD3	; 211
    1034:	b1 e0       	ldi	r27, 0x01	; 1
    1036:	fe 01       	movw	r30, r28
    1038:	7c 96       	adiw	r30, 0x1c	; 28
    103a:	27 ed       	ldi	r18, 0xD7	; 215
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    103c:	31 e0       	ldi	r19, 0x01	; 1
    103e:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    1040:	82 87       	std	Z+10, r24	; 0x0a
    1042:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    1044:	81 93       	st	Z+, r24
    1046:	a2 17       	cp	r26, r18
    1048:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    104a:	c9 f7       	brne	.-14     	; 0x103e <_Z28make_arp_answer_from_requestPh+0x34>
    104c:	be 01       	movw	r22, r28
    104e:	8a e2       	ldi	r24, 0x2A	; 42
    1050:	90 e0       	ldi	r25, 0x00	; 0
}
    1052:	36 de       	rcall	.-916    	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	08 95       	ret

0000105a <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    1064:	8b 01       	movw	r16, r22
    1066:	9e df       	rcall	.-196    	; 0xfa4 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    1068:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    106a:	be df       	rcall	.-132    	; 0xfe8 <_Z7make_ipPh>
    106c:	1a a2       	std	Y+34, r1	; 0x22
    106e:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    1070:	88 3f       	cpi	r24, 0xF8	; 248
    1072:	18 f0       	brcs	.+6      	; 0x107a <_Z28make_echo_reply_from_requestPhj+0x20>
    1074:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    1076:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
    1078:	9d a3       	std	Y+37, r25	; 0x25
    107a:	88 5f       	subi	r24, 0xF8	; 248
    107c:	8c a3       	std	Y+36, r24	; 0x24
}
    107e:	be 01       	movw	r22, r28
    1080:	c8 01       	movw	r24, r16
    1082:	1e de       	rcall	.-964    	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1084:	df 91       	pop	r29
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	08 95       	ret

0000108e <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    108e:	df 92       	push	r13
    1090:	ef 92       	push	r14
    1092:	ff 92       	push	r15
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	ec 01       	movw	r28, r24
    109e:	d6 2e       	mov	r13, r22
    10a0:	e7 2e       	mov	r14, r23
    10a2:	04 2f       	mov	r16, r20
    10a4:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    10a6:	f3 2e       	mov	r15, r19
    10a8:	7d df       	rcall	.-262    	; 0xfa4 <_Z8make_ethPh>
    10aa:	0d 3d       	cpi	r16, 0xDD	; 221
    10ac:	08 f0       	brcs	.+2      	; 0x10b0 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    10ae:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    10b0:	18 8a       	std	Y+16, r1	; 0x10
    10b2:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    10b4:	80 0f       	add	r24, r16
    10b6:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    10b8:	ce 01       	movw	r24, r28
    10ba:	96 df       	rcall	.-212    	; 0xfe8 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    10bc:	8a a1       	ldd	r24, Y+34	; 0x22
    10be:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    10c0:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    10c2:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    10c4:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    10c6:	1b a3       	std	Y+35, r17	; 0x23
    10c8:	1e a2       	std	Y+38, r1	; 0x26
    10ca:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    10cc:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    10ce:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
    10d0:	18 a6       	std	Y+40, r1	; 0x28
    10d2:	19 a6       	std	Y+41, r1	; 0x29
    10d4:	00 23       	and	r16, r16
    10d6:	81 f0       	breq	.+32     	; 0x10f8 <_Z27make_udp_reply_from_requestPhPchj+0x6a>
    10d8:	ad 2d       	mov	r26, r13
    10da:	be 2d       	mov	r27, r14
    10dc:	fe 01       	movw	r30, r28
    10de:	ba 96       	adiw	r30, 0x2a	; 42
    10e0:	2f ef       	ldi	r18, 0xFF	; 255
    10e2:	20 0f       	add	r18, r16
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	25 5d       	subi	r18, 0xD5	; 213
    10e8:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
    10ea:	2c 0f       	add	r18, r28
    10ec:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    10ee:	9d 91       	ld	r25, X+
    10f0:	91 93       	st	Z+, r25
    10f2:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    10f4:	f3 07       	cpc	r31, r19
    10f6:	d9 f7       	brne	.-10     	; 0x10ee <_Z27make_udp_reply_from_requestPhPchj+0x60>
    10f8:	10 e0       	ldi	r17, 0x00	; 0
    10fa:	b8 01       	movw	r22, r16
    10fc:	60 5f       	subi	r22, 0xF0	; 240
    10fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1104:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    1106:	6f de       	rcall	.-802    	; 0xde6 <_Z8checksumPhjh>
    1108:	98 a7       	std	Y+40, r25	; 0x28
    110a:	89 a7       	std	Y+41, r24	; 0x29
    110c:	be 01       	movw	r22, r28
}
    110e:	c8 01       	movw	r24, r16
    1110:	8a 96       	adiw	r24, 0x2a	; 42
    1112:	d6 dd       	rcall	.-1108   	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	1f 91       	pop	r17
    111a:	0f 91       	pop	r16
    111c:	ff 90       	pop	r15
    111e:	ef 90       	pop	r14
    1120:	df 90       	pop	r13
    1122:	08 95       	ret

00001124 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1124:	87 b3       	in	r24, 0x17	; 23
    1126:	86 60       	ori	r24, 0x06	; 6
    1128:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    112a:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    112c:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    112e:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    1130:	80 e5       	ldi	r24, 0x50	; 80
    1132:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    1134:	70 9a       	sbi	0x0e, 0	; 14
    1136:	08 95       	ret

00001138 <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1138:	00 97       	sbiw	r24, 0x00	; 0
    113a:	41 f0       	breq	.+16     	; 0x114c <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    113c:	ef eb       	ldi	r30, 0xBF	; 191
    113e:	f0 e0       	ldi	r31, 0x00	; 0
    1140:	31 97       	sbiw	r30, 0x01	; 1
    1142:	f1 f7       	brne	.-4      	; 0x1140 <_Z8delay_msj+0x8>
    1144:	00 c0       	rjmp	.+0      	; 0x1146 <_Z8delay_msj+0xe>
    1146:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    1148:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    114a:	c1 f7       	brne	.-16     	; 0x113c <_Z8delay_msj+0x4>
    114c:	08 95       	ret

0000114e <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    114e:	e7 ef       	ldi	r30, 0xF7	; 247
    1150:	f3 e0       	ldi	r31, 0x03	; 3
    1152:	84 85       	ldd	r24, Z+12	; 0x0c
    1154:	95 85       	ldd	r25, Z+13	; 0x0d
    1156:	01 96       	adiw	r24, 0x01	; 1
    1158:	95 87       	std	Z+13, r25	; 0x0d
    115a:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
    115c:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
    115e:	c6 98       	cbi	0x18, 6	; 24
    1160:	08 95       	ret

00001162 <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,20,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    1162:	80 91 f2 03 	lds	r24, 0x03F2	; 0x8003f2 <chatter_flag>
    1166:	81 11       	cpse	r24, r1
    1168:	03 c0       	rjmp	.+6      	; 0x1170 <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <chatter_flag>
    1170:	08 95       	ret

00001172 <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
    1172:	cf 93       	push	r28
    1174:	df 93       	push	r29
    1176:	cd b7       	in	r28, 0x3d	; 61
    1178:	de b7       	in	r29, 0x3e	; 62
    117a:	a2 97       	sbiw	r28, 0x22	; 34
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	de bf       	out	0x3e, r29	; 62
    1182:	0f be       	out	0x3f, r0	; 63
    1184:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1186:	03 ef       	ldi	r16, 0xF3	; 243
    1188:	13 e0       	ldi	r17, 0x03	; 3
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    118a:	0f 2e       	mov	r0, r31
    118c:	f7 e3       	ldi	r31, 0x37	; 55
    118e:	4f 2e       	mov	r4, r31
    1190:	f4 e0       	ldi	r31, 0x04	; 4
    1192:	5f 2e       	mov	r5, r31
    1194:	f0 2d       	mov	r31, r0
    1196:	0f 2e       	mov	r0, r31
    1198:	f9 e3       	ldi	r31, 0x39	; 57
    119a:	cf 2e       	mov	r12, r31
    119c:	f4 e0       	ldi	r31, 0x04	; 4
    119e:	df 2e       	mov	r13, r31
    11a0:	f0 2d       	mov	r31, r0
    11a2:	0f 2e       	mov	r0, r31
    11a4:	fb e3       	ldi	r31, 0x3B	; 59
    11a6:	ef 2e       	mov	r14, r31
    11a8:	f4 e0       	ldi	r31, 0x04	; 4
    11aa:	ff 2e       	mov	r15, r31
    11ac:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
    11ae:	ce 01       	movw	r24, r28
    11b0:	01 96       	adiw	r24, 0x01	; 1
    11b2:	9f 8f       	std	Y+31, r25	; 0x1f
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    11b6:	33 24       	eor	r3, r3
    11b8:	33 94       	inc	r3
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    11ba:	f8 01       	movw	r30, r16
    11bc:	80 81       	ld	r24, Z
    11be:	91 81       	ldd	r25, Z+1	; 0x01
    11c0:	a2 81       	ldd	r26, Z+2	; 0x02
    11c2:	b3 81       	ldd	r27, Z+3	; 0x03
    11c4:	80 93 ee 03 	sts	0x03EE, r24	; 0x8003ee <_ZZL5proc2PvE4myip>
    11c8:	90 93 ef 03 	sts	0x03EF, r25	; 0x8003ef <_ZZL5proc2PvE4myip+0x1>
    11cc:	a0 93 f0 03 	sts	0x03F0, r26	; 0x8003f0 <_ZZL5proc2PvE4myip+0x2>
    11d0:	b0 93 f1 03 	sts	0x03F1, r27	; 0x8003f1 <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
    11d4:	8f ef       	ldi	r24, 0xFF	; 255
    11d6:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    11d8:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    11de:	f6 dc       	rcall	.-1556   	; 0xbcc <_Z12enc28j60InitPh>
    11e0:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    11e2:	ef dc       	rcall	.-1570   	; 0xbc2 <_Z14enc28j60clkouth>
    11e4:	8a e0       	ldi	r24, 0x0A	; 10
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    11ec:	66 e7       	ldi	r22, 0x76	; 118
    11ee:	74 e0       	ldi	r23, 0x04	; 4
    11f0:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    11f2:	cf dc       	rcall	.-1634   	; 0xb92 <_Z16enc28j60PhyWritehj>
    11f4:	84 e1       	ldi	r24, 0x14	; 20
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    11fc:	40 e5       	ldi	r20, 0x50	; 80
    11fe:	6e ee       	ldi	r22, 0xEE	; 238
    1200:	73 e0       	ldi	r23, 0x03	; 3
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	91 e0       	ldi	r25, 0x01	; 1

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
    1206:	65 de       	rcall	.-822    	; 0xed2 <_Z19init_ip_arp_udp_tcpPhS_h>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1208:	18 a2       	std	Y+32, r1	; 0x20
    120a:	21 2c       	mov	r2, r1
    120c:	0f 2e       	mov	r0, r31
    120e:	fd e3       	ldi	r31, 0x3D	; 61
    1210:	af 2e       	mov	r10, r31
    1212:	f4 e0       	ldi	r31, 0x04	; 4
    1214:	bf 2e       	mov	r11, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    1216:	f0 2d       	mov	r31, r0
    1218:	0f 2e       	mov	r0, r31
    121a:	fd ed       	ldi	r31, 0xDD	; 221
    121c:	6f 2e       	mov	r6, r31
    121e:	f1 e0       	ldi	r31, 0x01	; 1
    1220:	7f 2e       	mov	r7, r31
    1222:	f0 2d       	mov	r31, r0
    1224:	0f 2e       	mov	r0, r31
    1226:	f7 ef       	ldi	r31, 0xF7	; 247
    1228:	8f 2e       	mov	r8, r31
    122a:	f3 e0       	ldi	r31, 0x03	; 3
    122c:	9f 2e       	mov	r9, r31
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    122e:	f0 2d       	mov	r31, r0
    1230:	d8 01       	movw	r26, r16
    1232:	8c 91       	ld	r24, X
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	f2 01       	movw	r30, r4
    1238:	60 81       	ld	r22, Z
    123a:	71 81       	ldd	r23, Z+1	; 0x01
    123c:	11 96       	adiw	r26, 0x01	; 1
    123e:	4c 91       	ld	r20, X
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	33 2d       	mov	r19, r3
    1244:	f6 01       	movw	r30, r12
    1246:	a0 81       	ld	r26, Z
    1248:	b1 81       	ldd	r27, Z+1	; 0x01
    124a:	4a 17       	cp	r20, r26
    124c:	5b 07       	cpc	r21, r27
    124e:	09 f4       	brne	.+2      	; 0x1252 <_ZL5proc2Pv+0xe0>
    1250:	32 2d       	mov	r19, r2
    1252:	23 2d       	mov	r18, r3
    1254:	86 17       	cp	r24, r22
    1256:	97 07       	cpc	r25, r23
    1258:	09 f4       	brne	.+2      	; 0x125c <_ZL5proc2Pv+0xea>
    125a:	22 2d       	mov	r18, r2
    125c:	f3 2f       	mov	r31, r19
    125e:	f2 2b       	or	r31, r18
    1260:	d8 01       	movw	r26, r16
    1262:	12 96       	adiw	r26, 0x02	; 2
    1264:	2c 91       	ld	r18, X
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	e3 2d       	mov	r30, r3
    126a:	d7 01       	movw	r26, r14
    126c:	4d 91       	ld	r20, X+
    126e:	5c 91       	ld	r21, X
    1270:	24 17       	cp	r18, r20
    1272:	35 07       	cpc	r19, r21
    1274:	09 f4       	brne	.+2      	; 0x1278 <_ZL5proc2Pv+0x106>
    1276:	e2 2d       	mov	r30, r2
    1278:	ef 2b       	or	r30, r31
    127a:	71 f4       	brne	.+28     	; 0x1298 <_ZL5proc2Pv+0x126>
    127c:	f8 01       	movw	r30, r16
    127e:	23 81       	ldd	r18, Z+3	; 0x03
    1280:	30 e0       	ldi	r19, 0x00	; 0
    1282:	e3 2d       	mov	r30, r3
    1284:	d5 01       	movw	r26, r10
    1286:	4d 91       	ld	r20, X+
    1288:	5c 91       	ld	r21, X
    128a:	24 17       	cp	r18, r20
    128c:	35 07       	cpc	r19, r21
    128e:	09 f4       	brne	.+2      	; 0x1292 <_ZL5proc2Pv+0x120>
    1290:	e2 2d       	mov	r30, r2
    1292:	ee 23       	and	r30, r30
    1294:	09 f4       	brne	.+2      	; 0x1298 <_ZL5proc2Pv+0x126>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    1296:	46 c0       	rjmp	.+140    	; 0x1324 <_ZL5proc2Pv+0x1b2>
    1298:	86 17       	cp	r24, r22
    129a:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    129c:	41 f0       	breq	.+16     	; 0x12ae <_ZL5proc2Pv+0x13c>
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	0e 94 94 18 	call	0x3128	; 0x3128 <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    12a6:	f2 01       	movw	r30, r4
    12a8:	80 81       	ld	r24, Z
    12aa:	d8 01       	movw	r26, r16
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    12ac:	8c 93       	st	X, r24
    12ae:	f6 01       	movw	r30, r12
    12b0:	60 81       	ld	r22, Z
    12b2:	71 81       	ldd	r23, Z+1	; 0x01
    12b4:	d8 01       	movw	r26, r16
    12b6:	11 96       	adiw	r26, 0x01	; 1
    12b8:	8c 91       	ld	r24, X
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	86 17       	cp	r24, r22
    12be:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    12c0:	49 f0       	breq	.+18     	; 0x12d4 <_ZL5proc2Pv+0x162>
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	0e 94 94 18 	call	0x3128	; 0x3128 <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    12ca:	f6 01       	movw	r30, r12
    12cc:	80 81       	ld	r24, Z
    12ce:	d8 01       	movw	r26, r16
    12d0:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    12d2:	8c 93       	st	X, r24
    12d4:	f7 01       	movw	r30, r14
    12d6:	60 81       	ld	r22, Z
    12d8:	71 81       	ldd	r23, Z+1	; 0x01
    12da:	d8 01       	movw	r26, r16
    12dc:	12 96       	adiw	r26, 0x02	; 2
    12de:	8c 91       	ld	r24, X
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	86 17       	cp	r24, r22
    12e4:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    12e6:	49 f0       	breq	.+18     	; 0x12fa <_ZL5proc2Pv+0x188>
    12e8:	82 e0       	ldi	r24, 0x02	; 2
    12ea:	90 e0       	ldi	r25, 0x00	; 0
    12ec:	0e 94 94 18 	call	0x3128	; 0x3128 <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    12f0:	f7 01       	movw	r30, r14
    12f2:	80 81       	ld	r24, Z
    12f4:	d8 01       	movw	r26, r16
    12f6:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    12f8:	8c 93       	st	X, r24
    12fa:	60 91 3d 04 	lds	r22, 0x043D	; 0x80043d <mem4+0x46>
    12fe:	70 91 3e 04 	lds	r23, 0x043E	; 0x80043e <mem4+0x47>
    1302:	f8 01       	movw	r30, r16
    1304:	83 81       	ldd	r24, Z+3	; 0x03
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	86 17       	cp	r24, r22
    130a:	97 07       	cpc	r25, r23
    130c:	09 f4       	brne	.+2      	; 0x1310 <_ZL5proc2Pv+0x19e>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    130e:	55 cf       	rjmp	.-342    	; 0x11ba <_ZL5proc2Pv+0x48>
    1310:	83 e0       	ldi	r24, 0x03	; 3
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	0e 94 94 18 	call	0x3128	; 0x3128 <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    1318:	80 91 3d 04 	lds	r24, 0x043D	; 0x80043d <mem4+0x46>
    131c:	d8 01       	movw	r26, r16
    131e:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    1320:	8c 93       	st	X, r24
    1322:	49 cf       	rjmp	.-366    	; 0x11b6 <_ZL5proc2Pv+0x44>
    1324:	6d ee       	ldi	r22, 0xED	; 237
    1326:	71 e0       	ldi	r23, 0x01	; 1
    1328:	80 e0       	ldi	r24, 0x00	; 0
    132a:	92 e0       	ldi	r25, 0x02	; 2
    132c:	f7 dc       	rcall	.-1554   	; 0xd1c <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    132e:	9a a3       	std	Y+34, r25	; 0x22
    1330:	89 a3       	std	Y+33, r24	; 0x21
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    1332:	00 97       	sbiw	r24, 0x00	; 0
    1334:	09 f4       	brne	.+2      	; 0x1338 <_ZL5proc2Pv+0x1c6>
    1336:	70 c0       	rjmp	.+224    	; 0x1418 <_ZL5proc2Pv+0x2a6>
    1338:	bc 01       	movw	r22, r24
    133a:	8d ee       	ldi	r24, 0xED	; 237
    133c:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
    133e:	e2 dd       	rcall	.-1084   	; 0xf04 <_Z25eth_type_is_arp_and_my_ipPhj>
    1340:	88 23       	and	r24, r24
    1342:	21 f0       	breq	.+8      	; 0x134c <_ZL5proc2Pv+0x1da>
			 continue;
    1344:	8d ee       	ldi	r24, 0xED	; 237
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    1346:	91 e0       	ldi	r25, 0x01	; 1
    1348:	60 de       	rcall	.-832    	; 0x100a <_Z28make_arp_answer_from_requestPh>
    134a:	72 cf       	rjmp	.-284    	; 0x1230 <_ZL5proc2Pv+0xbe>
    134c:	69 a1       	ldd	r22, Y+33	; 0x21
    134e:	7a a1       	ldd	r23, Y+34	; 0x22
    1350:	8d ee       	ldi	r24, 0xED	; 237
    1352:	91 e0       	ldi	r25, 0x01	; 1
    1354:	fd dd       	rcall	.-1030   	; 0xf50 <_Z24eth_type_is_ip_and_my_ipPhj>
    1356:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    1358:	09 f4       	brne	.+2      	; 0x135c <_ZL5proc2Pv+0x1ea>
    135a:	6a cf       	rjmp	.-300    	; 0x1230 <_ZL5proc2Pv+0xbe>
    135c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <_ZZL5proc2PvE3buf+0x17>
    1360:	81 30       	cpi	r24, 0x01	; 1
    1362:	51 f4       	brne	.+20     	; 0x1378 <_ZL5proc2Pv+0x206>
		 {
			make_echo_reply_from_request(buf,plen);
    1364:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <_ZZL5proc2PvE3buf+0x22>
    1368:	88 30       	cpi	r24, 0x08	; 8
    136a:	31 f4       	brne	.+12     	; 0x1378 <_ZL5proc2Pv+0x206>
    136c:	69 a1       	ldd	r22, Y+33	; 0x21
    136e:	7a a1       	ldd	r23, Y+34	; 0x22
			continue;
    1370:	8d ee       	ldi	r24, 0xED	; 237
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    1372:	91 e0       	ldi	r25, 0x01	; 1
    1374:	72 de       	rcall	.-796    	; 0x105a <_Z28make_echo_reply_from_requestPhj>
    1376:	5c cf       	rjmp	.-328    	; 0x1230 <_ZL5proc2Pv+0xbe>
    1378:	80 91 17 02 	lds	r24, 0x0217	; 0x800217 <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
    137c:	81 33       	cpi	r24, 0x31	; 49
    137e:	09 f0       	breq	.+2      	; 0x1382 <_ZL5proc2Pv+0x210>
    1380:	4b c0       	rjmp	.+150    	; 0x1418 <_ZL5proc2Pv+0x2a6>
    1382:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1384:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1386:	8d e1       	ldi	r24, 0x1D	; 29
			 char loop = buf[UDP_DATA_P + 1];
    1388:	11 92       	st	Z+, r1
    138a:	8a 95       	dec	r24
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    138c:	e9 f7       	brne	.-6      	; 0x1388 <_ZL5proc2Pv+0x216>
    138e:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <_ZZL5proc2PvE3buf+0x2b>
    1392:	80 53       	subi	r24, 0x30	; 48
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	01 96       	adiw	r24, 0x01	; 1
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	91 05       	cpc	r25, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    139c:	0c f0       	brlt	.+2      	; 0x13a0 <_ZL5proc2Pv+0x22e>
    139e:	87 c0       	rjmp	.+270    	; 0x14ae <_ZL5proc2Pv+0x33c>
    13a0:	22 c0       	rjmp	.+68     	; 0x13e6 <_ZL5proc2Pv+0x274>
    13a2:	f9 01       	movw	r30, r18
    13a4:	e3 51       	subi	r30, 0x13	; 19
    13a6:	fe 4f       	sbci	r31, 0xFE	; 254
    13a8:	63 a5       	ldd	r22, Z+43	; 0x2b
    13aa:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    13ac:	e2 0f       	add	r30, r18
    13ae:	f3 1f       	adc	r31, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    13b0:	60 83       	st	Z, r22
    13b2:	40 fd       	sbrc	r20, 0
    13b4:	12 c0       	rjmp	.+36     	; 0x13da <_ZL5proc2Pv+0x268>
    13b6:	e5 2f       	mov	r30, r21
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	ee 0f       	add	r30, r30
    13bc:	ff 1f       	adc	r31, r31
    13be:	e5 5f       	subi	r30, 0xF5	; 245
    13c0:	fb 4f       	sbci	r31, 0xFB	; 251
    13c2:	af ef       	ldi	r26, 0xFF	; 255
    13c4:	bf ef       	ldi	r27, 0xFF	; 255
    13c6:	ac 0f       	add	r26, r28
    13c8:	bd 1f       	adc	r27, r29
    13ca:	a2 0f       	add	r26, r18
    13cc:	b3 1f       	adc	r27, r19
    13ce:	2c 91       	ld	r18, X
    13d0:	30 e0       	ldi	r19, 0x00	; 0
					num++;
    13d2:	36 2b       	or	r19, r22
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    13d4:	31 83       	std	Z+1, r19	; 0x01
    13d6:	20 83       	st	Z, r18
    13d8:	5f 5f       	subi	r21, 0xFF	; 255
    13da:	4f 5f       	subi	r20, 0xFF	; 255
    13dc:	24 2f       	mov	r18, r20
    13de:	30 e0       	ldi	r19, 0x00	; 0
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    13e0:	28 17       	cp	r18, r24
    13e2:	39 07       	cpc	r19, r25
    13e4:	f4 f2       	brlt	.-68     	; 0x13a2 <_ZL5proc2Pv+0x230>
    13e6:	d4 01       	movw	r26, r8
    13e8:	d0 96       	adiw	r26, 0x30	; 48
    13ea:	8d 91       	ld	r24, X+
    13ec:	9c 91       	ld	r25, X
    13ee:	d1 97       	sbiw	r26, 0x31	; 49
    13f0:	51 96       	adiw	r26, 0x11	; 17
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    13f2:	9c 93       	st	X, r25
    13f4:	8e 93       	st	-X, r24
    13f6:	50 97       	sbiw	r26, 0x10	; 16
    13f8:	dd 96       	adiw	r26, 0x3d	; 61
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    13fa:	9c 93       	st	X, r25
    13fc:	8e 93       	st	-X, r24
    13fe:	dc 97       	sbiw	r26, 0x3c	; 60
    1400:	d9 96       	adiw	r26, 0x39	; 57
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1402:	9c 93       	st	X, r25
    1404:	8e 93       	st	-X, r24
    1406:	d8 97       	sbiw	r26, 0x38	; 56
    1408:	d7 96       	adiw	r26, 0x37	; 55
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    140a:	9c 93       	st	X, r25
    140c:	8e 93       	st	-X, r24
    140e:	d6 97       	sbiw	r26, 0x36	; 54
    1410:	df 96       	adiw	r26, 0x3f	; 63
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    1412:	9c 93       	st	X, r25
    1414:	8e 93       	st	-X, r24
    1416:	de 97       	sbiw	r26, 0x3e	; 62
			 if(led_flag)
    1418:	b8 a1       	ldd	r27, Y+32	; 0x20
    141a:	b0 95       	com	r27
			 {
				 PORTB = sbi(PORTB,4);
    141c:	b8 a3       	std	Y+32, r27	; 0x20
    141e:	bb 23       	and	r27, r27
    1420:	29 f0       	breq	.+10     	; 0x142c <_ZL5proc2Pv+0x2ba>
    1422:	88 b3       	in	r24, 0x18	; 24
    1424:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    1426:	88 bb       	out	0x18, r24	; 24
    1428:	88 bb       	out	0x18, r24	; 24
    142a:	04 c0       	rjmp	.+8      	; 0x1434 <_ZL5proc2Pv+0x2c2>
    142c:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    142e:	8f 7e       	andi	r24, 0xEF	; 239
    1430:	88 bb       	out	0x18, r24	; 24
    1432:	88 bb       	out	0x18, r24	; 24
    1434:	f4 01       	movw	r30, r8
    1436:	82 81       	ldd	r24, Z+2	; 0x02
    1438:	93 81       	ldd	r25, Z+3	; 0x03
    143a:	d3 01       	movw	r26, r6
			 data[1] = mem4[COUNT];
    143c:	11 96       	adiw	r26, 0x01	; 1
    143e:	9c 93       	st	X, r25
    1440:	8e 93       	st	-X, r24
    1442:	86 81       	ldd	r24, Z+6	; 0x06
    1444:	97 81       	ldd	r25, Z+7	; 0x07
    1446:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    1448:	9c 93       	st	X, r25
    144a:	8e 93       	st	-X, r24
    144c:	12 97       	sbiw	r26, 0x02	; 2
    144e:	84 81       	ldd	r24, Z+4	; 0x04
    1450:	95 81       	ldd	r25, Z+5	; 0x05
    1452:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    1454:	9c 93       	st	X, r25
    1456:	8e 93       	st	-X, r24
    1458:	14 97       	sbiw	r26, 0x04	; 4
    145a:	80 89       	ldd	r24, Z+16	; 0x10
    145c:	91 89       	ldd	r25, Z+17	; 0x11
    145e:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    1460:	9c 93       	st	X, r25
    1462:	8e 93       	st	-X, r24
    1464:	16 97       	sbiw	r26, 0x06	; 6
    1466:	82 89       	ldd	r24, Z+18	; 0x12
    1468:	93 89       	ldd	r25, Z+19	; 0x13
    146a:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    146c:	9c 93       	st	X, r25
    146e:	8e 93       	st	-X, r24
    1470:	18 97       	sbiw	r26, 0x08	; 8
    1472:	84 85       	ldd	r24, Z+12	; 0x0c
    1474:	95 85       	ldd	r25, Z+13	; 0x0d
    1476:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    1478:	9c 93       	st	X, r25
    147a:	8e 93       	st	-X, r24
    147c:	1a 97       	sbiw	r26, 0x0a	; 10
    147e:	82 85       	ldd	r24, Z+10	; 0x0a
    1480:	93 85       	ldd	r25, Z+11	; 0x0b
    1482:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    1484:	9c 93       	st	X, r25
    1486:	8e 93       	st	-X, r24
    1488:	1c 97       	sbiw	r26, 0x0c	; 12
    148a:	80 85       	ldd	r24, Z+8	; 0x08
    148c:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    148e:	1f 96       	adiw	r26, 0x0f	; 15
    1490:	9c 93       	st	X, r25
    1492:	8e 93       	st	-X, r24
    1494:	1e 97       	sbiw	r26, 0x0e	; 14
    1496:	2f e0       	ldi	r18, 0x0F	; 15
    1498:	37 e2       	ldi	r19, 0x27	; 39
    149a:	40 e1       	ldi	r20, 0x10	; 16
    149c:	b3 01       	movw	r22, r6
			 vTaskDelay(100);
    149e:	8d ee       	ldi	r24, 0xED	; 237
    14a0:	91 e0       	ldi	r25, 0x01	; 1
    14a2:	f5 dd       	rcall	.-1046   	; 0x108e <_Z27make_udp_reply_from_requestPhPchj>
    14a4:	84 e6       	ldi	r24, 0x64	; 100
    14a6:	90 e0       	ldi	r25, 0x00	; 0
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    14a8:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <vTaskDelay>
    14ac:	c1 ce       	rjmp	.-638    	; 0x1230 <_ZL5proc2Pv+0xbe>
    14ae:	20 91 19 02 	lds	r18, 0x0219	; 0x800219 <_ZZL5proc2PvE3buf+0x2c>
    14b2:	29 83       	std	Y+1, r18	; 0x01
    14b4:	41 e0       	ldi	r20, 0x01	; 1
    14b6:	50 e0       	ldi	r21, 0x00	; 0
    14b8:	90 cf       	rjmp	.-224    	; 0x13da <_ZL5proc2Pv+0x268>

000014ba <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	cd b7       	in	r28, 0x3d	; 61
    14c0:	de b7       	in	r29, 0x3e	; 62
    14c2:	2f 97       	sbiw	r28, 0x0f	; 15
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	de bf       	out	0x3e, r29	; 62
    14ca:	0f be       	out	0x3f, r0	; 63
    14cc:	cd bf       	out	0x3d, r28	; 61
    14ce:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    14d0:	fe 01       	movw	r30, r28
    14d2:	31 96       	adiw	r30, 0x01	; 1
    14d4:	8f e0       	ldi	r24, 0x0F	; 15
    14d6:	df 01       	movw	r26, r30
    14d8:	1d 92       	st	X+, r1
    14da:	8a 95       	dec	r24
    14dc:	e9 f7       	brne	.-6      	; 0x14d8 <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    14de:	07 ef       	ldi	r16, 0xF7	; 247
    14e0:	13 e0       	ldi	r17, 0x03	; 3
    14e2:	5e 01       	movw	r10, r28
    14e4:	b0 e1       	ldi	r27, 0x10	; 16
    14e6:	ab 0e       	add	r10, r27
    14e8:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    14ea:	0f 2e       	mov	r0, r31
    14ec:	fa e9       	ldi	r31, 0x9A	; 154
    14ee:	8f 2e       	mov	r8, r31
    14f0:	91 2c       	mov	r9, r1
    14f2:	f0 2d       	mov	r31, r0
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    14f4:	0f 2e       	mov	r0, r31
    14f6:	ff e3       	ldi	r31, 0x3F	; 63
    14f8:	6f 2e       	mov	r6, r31
    14fa:	f4 e0       	ldi	r31, 0x04	; 4
    14fc:	7f 2e       	mov	r7, r31
    14fe:	f0 2d       	mov	r31, r0
					mem4[COUNT] = count_number;
				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1500:	0f 2e       	mov	r0, r31
    1502:	f3 e0       	ldi	r31, 0x03	; 3
    1504:	4f 2e       	mov	r4, r31
    1506:	51 2c       	mov	r5, r1
    1508:	f0 2d       	mov	r31, r0
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    150a:	f8 01       	movw	r30, r16
    150c:	80 89       	ldd	r24, Z+16	; 0x10
    150e:	91 89       	ldd	r25, Z+17	; 0x11
    1510:	26 ad       	ldd	r18, Z+62	; 0x3e
    1512:	37 ad       	ldd	r19, Z+63	; 0x3f
    1514:	28 17       	cp	r18, r24
    1516:	39 07       	cpc	r19, r25
    1518:	41 f0       	breq	.+16     	; 0x152a <_ZL5proc1Pv+0x70>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    151a:	95 af       	std	Z+61, r25	; 0x3d
    151c:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    151e:	91 af       	std	Z+57, r25	; 0x39
    1520:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1522:	97 ab       	std	Z+55, r25	; 0x37
    1524:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    1526:	97 af       	std	Z+63, r25	; 0x3f
    1528:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    152a:	c6 01       	movw	r24, r12
    152c:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1530:	8f 30       	cpi	r24, 0x0F	; 15
    1532:	58 f3       	brcs	.-42     	; 0x150a <_ZL5proc1Pv+0x50>
    1534:	ce 01       	movw	r24, r28
    1536:	01 96       	adiw	r24, 0x01	; 1
    1538:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    153a:	c6 01       	movw	r24, r12
    153c:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1540:	d7 01       	movw	r26, r14
    1542:	8d 93       	st	X+, r24
    1544:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1546:	aa 15       	cp	r26, r10
    1548:	bb 05       	cpc	r27, r11
    154a:	b9 f7       	brne	.-18     	; 0x153a <_ZL5proc1Pv+0x80>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	82 30       	cpi	r24, 0x02	; 2
    1550:	09 f0       	breq	.+2      	; 0x1554 <_ZL5proc1Pv+0x9a>
    1552:	53 c0       	rjmp	.+166    	; 0x15fa <_ZL5proc1Pv+0x140>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1554:	88 85       	ldd	r24, Y+8	; 0x08
    1556:	90 e0       	ldi	r25, 0x00	; 0
    1558:	98 2f       	mov	r25, r24
    155a:	88 27       	eor	r24, r24
    155c:	29 85       	ldd	r18, Y+9	; 0x09
    155e:	82 2b       	or	r24, r18
    1560:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <count_number+0x1>
    1564:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    1568:	8a 85       	ldd	r24, Y+10	; 0x0a
    156a:	90 e0       	ldi	r25, 0x00	; 0
    156c:	98 2f       	mov	r25, r24
    156e:	88 27       	eor	r24, r24
    1570:	2b 85       	ldd	r18, Y+11	; 0x0b
    1572:	82 2b       	or	r24, r18
    1574:	90 93 46 04 	sts	0x0446, r25	; 0x800446 <current_temp+0x1>
    1578:	80 93 45 04 	sts	0x0445, r24	; 0x800445 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    157c:	2c 85       	ldd	r18, Y+12	; 0x0c
    157e:	30 e0       	ldi	r19, 0x00	; 0
    1580:	32 2f       	mov	r19, r18
    1582:	22 27       	eor	r18, r18
    1584:	4d 85       	ldd	r20, Y+13	; 0x0d
    1586:	24 2b       	or	r18, r20
    1588:	30 93 44 04 	sts	0x0444, r19	; 0x800444 <current_pressure+0x1>
    158c:	20 93 43 04 	sts	0x0443, r18	; 0x800443 <current_pressure>
				mem4[TEMP] = current_temp;
    1590:	f8 01       	movw	r30, r16
    1592:	93 83       	std	Z+3, r25	; 0x03
    1594:	82 83       	std	Z+2, r24	; 0x02
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    1596:	d3 01       	movw	r26, r6
    1598:	8d 91       	ld	r24, X+
    159a:	9c 91       	ld	r25, X
    159c:	89 2b       	or	r24, r25
    159e:	19 f0       	breq	.+6      	; 0x15a6 <_ZL5proc1Pv+0xec>
				{
					Alarm_Start();
    15a0:	0e 94 e6 01 	call	0x3cc	; 0x3cc <Alarm_Start>
    15a4:	09 c0       	rjmp	.+18     	; 0x15b8 <_ZL5proc1Pv+0xfe>
				}
				else //PLC
				{
					Alarm_Stop();
    15a6:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <Alarm_Stop>
					mem4[COUNT] = count_number;
    15aa:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <count_number>
    15ae:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <count_number+0x1>
    15b2:	f8 01       	movw	r30, r16
    15b4:	97 83       	std	Z+7, r25	; 0x07
    15b6:	86 83       	std	Z+6, r24	; 0x06
				}
				mem4[PRESSURE] = current_pressure;
    15b8:	80 91 43 04 	lds	r24, 0x0443	; 0x800443 <current_pressure>
    15bc:	90 91 44 04 	lds	r25, 0x0444	; 0x800444 <current_pressure+0x1>
    15c0:	d8 01       	movw	r26, r16
    15c2:	15 96       	adiw	r26, 0x05	; 5
    15c4:	9c 93       	st	X, r25
    15c6:	8e 93       	st	-X, r24
    15c8:	14 97       	sbiw	r26, 0x04	; 4
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    15ca:	50 96       	adiw	r26, 0x10	; 16
    15cc:	2d 91       	ld	r18, X+
    15ce:	3c 91       	ld	r19, X
    15d0:	51 97       	sbiw	r26, 0x11	; 17
    15d2:	16 96       	adiw	r26, 0x06	; 6
    15d4:	8d 91       	ld	r24, X+
    15d6:	9c 91       	ld	r25, X
    15d8:	17 97       	sbiw	r26, 0x07	; 7
    15da:	28 17       	cp	r18, r24
    15dc:	39 07       	cpc	r19, r25
    15de:	09 f0       	breq	.+2      	; 0x15e2 <_ZL5proc1Pv+0x128>
    15e0:	94 cf       	rjmp	.-216    	; 0x150a <_ZL5proc1Pv+0x50>
    15e2:	52 96       	adiw	r26, 0x12	; 18
    15e4:	8d 91       	ld	r24, X+
    15e6:	9c 91       	ld	r25, X
    15e8:	53 97       	sbiw	r26, 0x13	; 19
    15ea:	89 2b       	or	r24, r25
    15ec:	09 f0       	breq	.+2      	; 0x15f0 <_ZL5proc1Pv+0x136>
    15ee:	8d cf       	rjmp	.-230    	; 0x150a <_ZL5proc1Pv+0x50>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    15f0:	53 96       	adiw	r26, 0x13	; 19
    15f2:	5c 92       	st	X, r5
    15f4:	4e 92       	st	-X, r4
    15f6:	52 97       	sbiw	r26, 0x12	; 18
    15f8:	88 cf       	rjmp	.-240    	; 0x150a <_ZL5proc1Pv+0x50>
				}
			}
			else
			{
				cbi(PORTB,7);
    15fa:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    15fc:	46 e0       	ldi	r20, 0x06	; 6
    15fe:	61 e0       	ldi	r22, 0x01	; 1
    1600:	81 e5       	ldi	r24, 0x51	; 81
    1602:	94 e0       	ldi	r25, 0x04	; 4
    1604:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    1608:	45 e0       	ldi	r20, 0x05	; 5
    160a:	50 e0       	ldi	r21, 0x00	; 0
    160c:	61 e5       	ldi	r22, 0x51	; 81
    160e:	74 e0       	ldi	r23, 0x04	; 4
    1610:	c6 01       	movw	r24, r12
    1612:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    1616:	f4 01       	movw	r30, r8
    1618:	80 81       	ld	r24, Z
    161a:	8f 77       	andi	r24, 0x7F	; 127
    161c:	80 83       	st	Z, r24
				sb->SerialFlush();
    161e:	c6 01       	movw	r24, r12
    1620:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    1624:	d4 01       	movw	r26, r8
    1626:	8c 91       	ld	r24, X
    1628:	80 68       	ori	r24, 0x80	; 128
    162a:	8c 93       	st	X, r24
				sbi(PORTB,7);
    162c:	c7 9a       	sbi	0x18, 7	; 24
    162e:	6d cf       	rjmp	.-294    	; 0x150a <_ZL5proc1Pv+0x50>

00001630 <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1630:	cf 93       	push	r28
    1632:	df 93       	push	r29
    1634:	cd b7       	in	r28, 0x3d	; 61
    1636:	de b7       	in	r29, 0x3e	; 62
    1638:	2a 97       	sbiw	r28, 0x0a	; 10
    163a:	0f b6       	in	r0, 0x3f	; 63
    163c:	f8 94       	cli
    163e:	de bf       	out	0x3e, r29	; 62
    1640:	0f be       	out	0x3f, r0	; 63
    1642:	cd bf       	out	0x3d, r28	; 61
    1644:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    1646:	d1 2c       	mov	r13, r1
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1648:	07 ef       	ldi	r16, 0xF7	; 247
    164a:	13 e0       	ldi	r17, 0x03	; 3
			chatter_flag = 2;
    164c:	68 94       	set
    164e:	77 24       	eor	r7, r7
    1650:	71 f8       	bld	r7, 1
    1652:	4e 01       	movw	r8, r28
    1654:	8c e0       	ldi	r24, 0x0C	; 12
    1656:	88 0e       	add	r8, r24
    1658:	91 1c       	adc	r9, r1
    165a:	68 94       	set
    165c:	33 24       	eor	r3, r3
    165e:	34 f8       	bld	r3, 4
    1660:	66 24       	eor	r6, r6
    1662:	63 94       	inc	r6
    1664:	5e 01       	movw	r10, r28
    1666:	a9 e0       	ldi	r26, 0x09	; 9
    1668:	aa 0e       	add	r10, r26
    166a:	b1 1c       	adc	r11, r1
    166c:	0f 2e       	mov	r0, r31
    166e:	f5 e0       	ldi	r31, 0x05	; 5
    1670:	4f 2e       	mov	r4, r31
    1672:	f0 2d       	mov	r31, r0
							sb->SerialWrite((char*)&exception,sizeof(exception));
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1674:	68 94       	set
    1676:	55 24       	eor	r5, r5
    1678:	52 f8       	bld	r5, 2
    167a:	0e c0       	rjmp	.+28     	; 0x1698 <_ZL4procPv+0x68>
    167c:	c6 2c       	mov	r12, r6
    167e:	d6 2c       	mov	r13, r6
    1680:	0b c0       	rjmp	.+22     	; 0x1698 <_ZL4procPv+0x68>
    1682:	c6 2c       	mov	r12, r6
    1684:	d6 2c       	mov	r13, r6
    1686:	08 c0       	rjmp	.+16     	; 0x1698 <_ZL4procPv+0x68>
    1688:	c5 2c       	mov	r12, r5
    168a:	d6 2c       	mov	r13, r6
    168c:	05 c0       	rjmp	.+10     	; 0x1698 <_ZL4procPv+0x68>
    168e:	c4 2c       	mov	r12, r4
    1690:	d6 2c       	mov	r13, r6
    1692:	02 c0       	rjmp	.+4      	; 0x1698 <_ZL4procPv+0x68>
    1694:	c3 2c       	mov	r12, r3
    1696:	d6 2c       	mov	r13, r6
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    1698:	80 b3       	in	r24, 0x10	; 16
    169a:	8e 3f       	cpi	r24, 0xFE	; 254
    169c:	29 f4       	brne	.+10     	; 0x16a8 <_ZL4procPv+0x78>
    169e:	80 91 f2 03 	lds	r24, 0x03F2	; 0x8003f2 <chatter_flag>
    16a2:	81 30       	cpi	r24, 0x01	; 1
    16a4:	09 f4       	brne	.+2      	; 0x16a8 <_ZL4procPv+0x78>
    16a6:	15 c1       	rjmp	.+554    	; 0x18d2 <_ZL4procPv+0x2a2>
		{
			mem4[COUNT]++;                // Remove Chattering 
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
    16a8:	80 b3       	in	r24, 0x10	; 16
    16aa:	8f 3f       	cpi	r24, 0xFF	; 255
    16ac:	29 f4       	brne	.+10     	; 0x16b8 <_ZL4procPv+0x88>
    16ae:	80 91 f2 03 	lds	r24, 0x03F2	; 0x8003f2 <chatter_flag>
    16b2:	82 30       	cpi	r24, 0x02	; 2
    16b4:	09 f4       	brne	.+2      	; 0x16b8 <_ZL4procPv+0x88>
    16b6:	19 c1       	rjmp	.+562    	; 0x18ea <_ZL4procPv+0x2ba>
		{
			vTaskDelay(20);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    16b8:	f8 01       	movw	r30, r16
    16ba:	84 85       	ldd	r24, Z+12	; 0x0c
    16bc:	95 85       	ldd	r25, Z+13	; 0x0d
    16be:	cc 97       	sbiw	r24, 0x3c	; 60
    16c0:	94 f0       	brlt	.+36     	; 0x16e6 <_ZL4procPv+0xb6>
		{
			mem4[SEC] = 0;
    16c2:	15 86       	std	Z+13, r1	; 0x0d
    16c4:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    16c6:	82 85       	ldd	r24, Z+10	; 0x0a
    16c8:	93 85       	ldd	r25, Z+11	; 0x0b
    16ca:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    16cc:	8c 33       	cpi	r24, 0x3C	; 60
    16ce:	91 05       	cpc	r25, r1
    16d0:	1c f4       	brge	.+6      	; 0x16d8 <_ZL4procPv+0xa8>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    16d2:	93 87       	std	Z+11, r25	; 0x0b
    16d4:	82 87       	std	Z+10, r24	; 0x0a
    16d6:	07 c0       	rjmp	.+14     	; 0x16e6 <_ZL4procPv+0xb6>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    16d8:	13 86       	std	Z+11, r1	; 0x0b
    16da:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    16dc:	80 85       	ldd	r24, Z+8	; 0x08
    16de:	91 85       	ldd	r25, Z+9	; 0x09
    16e0:	01 96       	adiw	r24, 0x01	; 1
    16e2:	91 87       	std	Z+9, r25	; 0x09
    16e4:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    16e6:	d1 10       	cpse	r13, r1
    16e8:	4d c0       	rjmp	.+154    	; 0x1784 <_ZL4procPv+0x154>
		{
			if(sb->SerialAvailable() >= 2)
    16ea:	c7 01       	movw	r24, r14
    16ec:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    16f0:	82 30       	cpi	r24, 0x02	; 2
    16f2:	90 f2       	brcs	.-92     	; 0x1698 <_ZL4procPv+0x68>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    16f4:	c7 01       	movw	r24, r14
    16f6:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    16fa:	89 83       	std	Y+1, r24	; 0x01
    16fc:	c7 01       	movw	r24, r14
    16fe:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1702:	8a 83       	std	Y+2, r24	; 0x02
					#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
					#endif
				}
				if(buf1[0] != 0x01)
    1704:	99 81       	ldd	r25, Y+1	; 0x01
    1706:	91 30       	cpi	r25, 0x01	; 1
    1708:	61 f4       	brne	.+24     	; 0x1722 <_ZL4procPv+0xf2>
				{
				//	read_Flag = 0;
					goto FREAM_ERROR;
				}
				if(buf1[1] == 0x01)
    170a:	81 30       	cpi	r24, 0x01	; 1
    170c:	09 f4       	brne	.+2      	; 0x1710 <_ZL4procPv+0xe0>
    170e:	3f c0       	rjmp	.+126    	; 0x178e <_ZL4procPv+0x15e>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    1710:	84 30       	cpi	r24, 0x04	; 4
    1712:	09 f4       	brne	.+2      	; 0x1716 <_ZL4procPv+0xe6>
    1714:	53 c0       	rjmp	.+166    	; 0x17bc <_ZL4procPv+0x18c>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1716:	85 30       	cpi	r24, 0x05	; 5
    1718:	09 f4       	brne	.+2      	; 0x171c <_ZL4procPv+0xec>
    171a:	8b c0       	rjmp	.+278    	; 0x1832 <_ZL4procPv+0x202>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    171c:	80 31       	cpi	r24, 0x10	; 16
    171e:	09 f4       	brne	.+2      	; 0x1722 <_ZL4procPv+0xf2>
    1720:	ae c0       	rjmp	.+348    	; 0x187e <_ZL4procPv+0x24e>
				{
					FREAM_ERROR:
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    1722:	46 2d       	mov	r20, r6
    1724:	66 2d       	mov	r22, r6
    1726:	81 e5       	ldi	r24, 0x51	; 81
    1728:	94 e0       	ldi	r25, 0x04	; 4
    172a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    172e:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);
    1730:	57 98       	cbi	0x0a, 7	; 10
					dev->getInterfaceAddr(UART0)->Stop_Device();                                                                                                                                                                                                                
    1732:	60 e0       	ldi	r22, 0x00	; 0
    1734:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1738:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    173c:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1740:	dc 01       	movw	r26, r24
    1742:	ed 91       	ld	r30, X+
    1744:	fc 91       	ld	r31, X
    1746:	00 84       	ldd	r0, Z+8	; 0x08
    1748:	f1 85       	ldd	r31, Z+9	; 0x09
    174a:	e0 2d       	mov	r30, r0
    174c:	09 95       	icall
					sb->SerialFlush();
    174e:	c7 01       	movw	r24, r14
    1750:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
					dev->getInterfaceAddr(UART0)->Start_Device();
    1754:	60 e0       	ldi	r22, 0x00	; 0
    1756:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    175a:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    175e:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1762:	dc 01       	movw	r26, r24
    1764:	ed 91       	ld	r30, X+
    1766:	fc 91       	ld	r31, X
    1768:	02 84       	ldd	r0, Z+10	; 0x0a
    176a:	f3 85       	ldd	r31, Z+11	; 0x0b
    176c:	e0 2d       	mov	r30, r0
    176e:	09 95       	icall
					sbi(UCSR0B,RXCIE0);
    1770:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    1772:	45 e0       	ldi	r20, 0x05	; 5
    1774:	50 e0       	ldi	r21, 0x00	; 0
    1776:	61 e5       	ldi	r22, 0x51	; 81
    1778:	74 e0       	ldi	r23, 0x04	; 4
    177a:	c7 01       	movw	r24, r14
    177c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    1780:	c7 9a       	sbi	0x18, 7	; 24
    1782:	8a cf       	rjmp	.-236    	; 0x1698 <_ZL4procPv+0x68>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1784:	b1 e0       	ldi	r27, 0x01	; 1
    1786:	db 12       	cpse	r13, r27
    1788:	87 cf       	rjmp	.-242    	; 0x1698 <_ZL4procPv+0x68>
		{
			if(function_code == 0x01)  
    178a:	cb 12       	cpse	r12, r27
    178c:	14 c0       	rjmp	.+40     	; 0x17b6 <_ZL4procPv+0x186>
			{
				if(sb->SerialAvailable() >= 6)
    178e:	c7 01       	movw	r24, r14
    1790:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1794:	86 30       	cpi	r24, 0x06	; 6
    1796:	08 f4       	brcc	.+2      	; 0x179a <_ZL4procPv+0x16a>
    1798:	71 cf       	rjmp	.-286    	; 0x167c <_ZL4procPv+0x4c>
    179a:	6e 01       	movw	r12, r28
    179c:	e3 e0       	ldi	r30, 0x03	; 3
    179e:	ce 0e       	add	r12, r30
    17a0:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    17a2:	c7 01       	movw	r24, r14
    17a4:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    17a8:	d6 01       	movw	r26, r12
    17aa:	8d 93       	st	X+, r24
    17ac:	6d 01       	movw	r12, r26
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    17ae:	aa 16       	cp	r10, r26
    17b0:	bb 06       	cpc	r11, r27
    17b2:	b9 f7       	brne	.-18     	; 0x17a2 <_ZL4procPv+0x172>
    17b4:	66 cf       	rjmp	.-308    	; 0x1682 <_ZL4procPv+0x52>
						#endif
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    17b6:	b4 e0       	ldi	r27, 0x04	; 4
    17b8:	cb 12       	cpse	r12, r27
    17ba:	38 c0       	rjmp	.+112    	; 0x182c <_ZL4procPv+0x1fc>
			{
				if(sb->SerialAvailable() >= 6)
    17bc:	c7 01       	movw	r24, r14
    17be:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    17c2:	86 30       	cpi	r24, 0x06	; 6
    17c4:	08 f4       	brcc	.+2      	; 0x17c8 <_ZL4procPv+0x198>
    17c6:	60 cf       	rjmp	.-320    	; 0x1688 <_ZL4procPv+0x58>
    17c8:	6e 01       	movw	r12, r28
    17ca:	e3 e0       	ldi	r30, 0x03	; 3
    17cc:	ce 0e       	add	r12, r30
    17ce:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    17d0:	c7 01       	movw	r24, r14
    17d2:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    17d6:	d6 01       	movw	r26, r12
    17d8:	8d 93       	st	X+, r24
    17da:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    17dc:	aa 16       	cp	r10, r26
    17de:	bb 06       	cpc	r11, r27
    17e0:	b9 f7       	brne	.-18     	; 0x17d0 <_ZL4procPv+0x1a0>
						#if PACKET_DEBUG
							sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr > MAX_ENUM)  //주소 사이즈 체크 
    17e2:	8c 81       	ldd	r24, Y+4	; 0x04
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	87 97       	sbiw	r24, 0x27	; 39
    17e8:	84 f0       	brlt	.+32     	; 0x180a <_ZL4procPv+0x1da>
					{
							GetExceptionCode(&exception,0x01,0x02);
    17ea:	47 2d       	mov	r20, r7
    17ec:	66 2d       	mov	r22, r6
    17ee:	81 e5       	ldi	r24, 0x51	; 81
    17f0:	94 e0       	ldi	r25, 0x04	; 4
    17f2:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
							sb->SerialWrite((char*)&exception,sizeof(exception));
    17f6:	45 e0       	ldi	r20, 0x05	; 5
    17f8:	50 e0       	ldi	r21, 0x00	; 0
    17fa:	61 e5       	ldi	r22, 0x51	; 81
    17fc:	74 e0       	ldi	r23, 0x04	; 4
    17fe:	c7 01       	movw	r24, r14
    1800:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1804:	c5 2c       	mov	r12, r5
    1806:	d6 2c       	mov	r13, r6
    1808:	47 cf       	rjmp	.-370    	; 0x1698 <_ZL4procPv+0x68>
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
    180a:	a8 01       	movw	r20, r16
    180c:	61 e6       	ldi	r22, 0x61	; 97
    180e:	74 e0       	ldi	r23, 0x04	; 4
    1810:	ce 01       	movw	r24, r28
    1812:	01 96       	adiw	r24, 0x01	; 1
    1814:	0e 94 82 00 	call	0x104	; 0x104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1818:	47 e0       	ldi	r20, 0x07	; 7
    181a:	50 e0       	ldi	r21, 0x00	; 0
    181c:	61 e6       	ldi	r22, 0x61	; 97
    181e:	74 e0       	ldi	r23, 0x04	; 4
    1820:	c7 01       	movw	r24, r14
    1822:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1826:	c5 2c       	mov	r12, r5
							read_Flag = 0;
    1828:	d1 2c       	mov	r13, r1
    182a:	36 cf       	rjmp	.-404    	; 0x1698 <_ZL4procPv+0x68>
					}

				}
			}
			else if(function_code == 0x05) //터치 버튼 
    182c:	b5 e0       	ldi	r27, 0x05	; 5
    182e:	cb 12       	cpse	r12, r27
    1830:	23 c0       	rjmp	.+70     	; 0x1878 <_ZL4procPv+0x248>
			{
				if(sb->SerialAvailable() >= 6)
    1832:	c7 01       	movw	r24, r14
    1834:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1838:	86 30       	cpi	r24, 0x06	; 6
    183a:	08 f4       	brcc	.+2      	; 0x183e <_ZL4procPv+0x20e>
    183c:	28 cf       	rjmp	.-432    	; 0x168e <_ZL4procPv+0x5e>
    183e:	6e 01       	movw	r12, r28
    1840:	e3 e0       	ldi	r30, 0x03	; 3
    1842:	ce 0e       	add	r12, r30
    1844:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1846:	c7 01       	movw	r24, r14
    1848:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    184c:	d6 01       	movw	r26, r12
    184e:	8d 93       	st	X+, r24
    1850:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1852:	aa 16       	cp	r10, r26
    1854:	bb 06       	cpc	r11, r27
    1856:	b9 f7       	brne	.-18     	; 0x1846 <_ZL4procPv+0x216>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFunc05Data(buf1,&func05);
    1858:	68 e6       	ldi	r22, 0x68	; 104
    185a:	74 e0       	ldi	r23, 0x04	; 4
    185c:	ce 01       	movw	r24, r28
    185e:	01 96       	adiw	r24, 0x01	; 1
    1860:	0e 94 a3 00 	call	0x146	; 0x146 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    1864:	48 e0       	ldi	r20, 0x08	; 8
    1866:	50 e0       	ldi	r21, 0x00	; 0
    1868:	68 e6       	ldi	r22, 0x68	; 104
    186a:	74 e0       	ldi	r23, 0x04	; 4
    186c:	c7 01       	movw	r24, r14
    186e:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1872:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    1874:	d1 2c       	mov	r13, r1
    1876:	10 cf       	rjmp	.-480    	; 0x1698 <_ZL4procPv+0x68>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1878:	b0 e1       	ldi	r27, 0x10	; 16
    187a:	cb 12       	cpse	r12, r27
    187c:	0d cf       	rjmp	.-486    	; 0x1698 <_ZL4procPv+0x68>
			{
				if(sb->SerialAvailable() >= 9)
    187e:	c7 01       	movw	r24, r14
    1880:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1884:	89 30       	cpi	r24, 0x09	; 9
    1886:	08 f4       	brcc	.+2      	; 0x188a <_ZL4procPv+0x25a>
    1888:	05 cf       	rjmp	.-502    	; 0x1694 <_ZL4procPv+0x64>
    188a:	6e 01       	movw	r12, r28
    188c:	e3 e0       	ldi	r30, 0x03	; 3
    188e:	ce 0e       	add	r12, r30
    1890:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    1892:	c7 01       	movw	r24, r14
    1894:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1898:	d6 01       	movw	r26, r12
    189a:	8d 93       	st	X+, r24
    189c:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    189e:	8a 16       	cp	r8, r26
    18a0:	9b 06       	cpc	r9, r27
    18a2:	b9 f7       	brne	.-18     	; 0x1892 <_ZL4procPv+0x262>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    18a4:	a8 01       	movw	r20, r16
    18a6:	66 e5       	ldi	r22, 0x56	; 86
    18a8:	74 e0       	ldi	r23, 0x04	; 4
    18aa:	ce 01       	movw	r24, r28
    18ac:	01 96       	adiw	r24, 0x01	; 1
    18ae:	0e 94 bc 00 	call	0x178	; 0x178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    18b2:	69 e4       	ldi	r22, 0x49	; 73
    18b4:	74 e0       	ldi	r23, 0x04	; 4
    18b6:	ce 01       	movw	r24, r28
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	0e 94 e6 00 	call	0x1cc	; 0x1cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    18be:	48 e0       	ldi	r20, 0x08	; 8
    18c0:	50 e0       	ldi	r21, 0x00	; 0
    18c2:	69 e4       	ldi	r22, 0x49	; 73
    18c4:	74 e0       	ldi	r23, 0x04	; 4
    18c6:	c7 01       	movw	r24, r14
    18c8:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    18cc:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    18ce:	d1 2c       	mov	r13, r1
    18d0:	e3 ce       	rjmp	.-570    	; 0x1698 <_ZL4procPv+0x68>
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    18d2:	f8 01       	movw	r30, r16
    18d4:	86 81       	ldd	r24, Z+6	; 0x06
    18d6:	97 81       	ldd	r25, Z+7	; 0x07
    18d8:	01 96       	adiw	r24, 0x01	; 1
    18da:	97 83       	std	Z+7, r25	; 0x07
    18dc:	86 83       	std	Z+6, r24	; 0x06
			chatter_flag = 2;
    18de:	70 92 f2 03 	sts	0x03F2, r7	; 0x8003f2 <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    18e2:	80 b3       	in	r24, 0x10	; 16
    18e4:	8f 3f       	cpi	r24, 0xFF	; 255
    18e6:	09 f0       	breq	.+2      	; 0x18ea <_ZL4procPv+0x2ba>
    18e8:	e7 ce       	rjmp	.-562    	; 0x16b8 <_ZL4procPv+0x88>
		{
			vTaskDelay(20);
    18ea:	84 e1       	ldi	r24, 0x14	; 20
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	0e 94 2a 15 	call	0x2a54	; 0x2a54 <vTaskDelay>
			chatter_flag = 0;
    18f2:	10 92 f2 03 	sts	0x03F2, r1	; 0x8003f2 <chatter_flag>
    18f6:	e0 ce       	rjmp	.-576    	; 0x16b8 <_ZL4procPv+0x88>

000018f8 <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    18f8:	80 91 70 04 	lds	r24, 0x0470	; 0x800470 <DataStruct>
    18fc:	90 91 71 04 	lds	r25, 0x0471	; 0x800471 <DataStruct+0x1>
    1900:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    1904:	c5 9a       	sbi	0x18, 5	; 24
    1906:	08 95       	ret

00001908 <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    1908:	80 91 72 04 	lds	r24, 0x0472	; 0x800472 <DataStruct+0x2>
    190c:	90 91 73 04 	lds	r25, 0x0473	; 0x800473 <DataStruct+0x3>
    1910:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    1914:	c6 9a       	sbi	0x18, 6	; 24
    1916:	08 95       	ret

00001918 <_Z16Count_Sensor_ISR8Dev_typej>:
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,20,Set_Alarm);
    1918:	41 eb       	ldi	r20, 0xB1	; 177
    191a:	58 e0       	ldi	r21, 0x08	; 8
    191c:	64 e1       	ldi	r22, 0x14	; 20
    191e:	70 e0       	ldi	r23, 0x00	; 0
    1920:	80 e0       	ldi	r24, 0x00	; 0
    1922:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <Alarm_Open>
    1926:	08 95       	ret

00001928 <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    1928:	cf 93       	push	r28
    192a:	df 93       	push	r29
	dev = new Dev_Manager();
    192c:	80 e1       	ldi	r24, 0x10	; 16
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	0e 94 9c 02 	call	0x538	; 0x538 <_ZN11Dev_ManagernwEj>
    1934:	ec 01       	movw	r28, r24
    1936:	0e 94 69 02 	call	0x4d2	; 0x4d2 <_ZN11Dev_ManagerC1Ev>
    193a:	d0 93 79 04 	sts	0x0479, r29	; 0x800479 <dev+0x1>
    193e:	c0 93 78 04 	sts	0x0478, r28	; 0x800478 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    1942:	88 e0       	ldi	r24, 0x08	; 8
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	0a d8       	rcall	.-4076   	; 0x95c <_ZN10UartDrivernwEj>
    1948:	ec 01       	movw	r28, r24
    194a:	0e 94 9a 04 	call	0x934	; 0x934 <_ZN10UartDriverC1Ev>
    194e:	40 e0       	ldi	r20, 0x00	; 0
    1950:	be 01       	movw	r22, r28
    1952:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1956:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    195a:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    195e:	88 e0       	ldi	r24, 0x08	; 8
    1960:	90 e0       	ldi	r25, 0x00	; 0
    1962:	0e 94 0b 04 	call	0x816	; 0x816 <_ZN11RS485DrivernwEj>
    1966:	ec 01       	movw	r28, r24
    1968:	0e 94 f7 03 	call	0x7ee	; 0x7ee <_ZN11RS485DriverC1Ev>
    196c:	41 e0       	ldi	r20, 0x01	; 1
    196e:	be 01       	movw	r22, r28
    1970:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1974:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1978:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    197c:	82 e0       	ldi	r24, 0x02	; 2
    197e:	90 e0       	ldi	r25, 0x00	; 0
    1980:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_ZN5TimernwEj>
    1984:	ec 01       	movw	r28, r24
    1986:	0e 94 cd 03 	call	0x79a	; 0x79a <_ZN5TimerC1Ev>
    198a:	42 e0       	ldi	r20, 0x02	; 2
    198c:	be 01       	movw	r22, r28
    198e:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1992:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1996:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    199a:	82 e0       	ldi	r24, 0x02	; 2
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	0e 94 66 02 	call	0x4cc	; 0x4cc <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    19a2:	2b e0       	ldi	r18, 0x0B	; 11
    19a4:	31 e0       	ldi	r19, 0x01	; 1
    19a6:	fc 01       	movw	r30, r24
    19a8:	31 83       	std	Z+1, r19	; 0x01
    19aa:	20 83       	st	Z, r18
    19ac:	43 e0       	ldi	r20, 0x03	; 3
    19ae:	bc 01       	movw	r22, r24
    19b0:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19b4:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    19b8:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Device_Init(UART0);
    19bc:	60 e0       	ldi	r22, 0x00	; 0
    19be:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19c2:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    19c6:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    19ca:	61 e0       	ldi	r22, 0x01	; 1
    19cc:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19d0:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    19d4:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    19d8:	62 e0       	ldi	r22, 0x02	; 2
    19da:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19de:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    19e2:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    19e6:	63 e0       	ldi	r22, 0x03	; 3
    19e8:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19ec:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    19f0:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    19f4:	47 e4       	ldi	r20, 0x47	; 71
    19f6:	51 e0       	ldi	r21, 0x01	; 1
    19f8:	60 e0       	ldi	r22, 0x00	; 0
    19fa:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    19fe:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1a02:	0e 94 b3 02 	call	0x566	; 0x566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1a06:	4d e6       	ldi	r20, 0x6D	; 109
    1a08:	51 e0       	ldi	r21, 0x01	; 1
    1a0a:	61 e0       	ldi	r22, 0x01	; 1
    1a0c:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1a10:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1a14:	0e 94 b3 02 	call	0x566	; 0x566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    1a18:	df 91       	pop	r29
    1a1a:	cf 91       	pop	r28
    1a1c:	08 95       	ret

00001a1e <main>:

uint8_t chatter_flag = 0; //채터링 방지 플래그 변수
//uint8_t use_external_count_sensor = 0; // 0 PLC  1 EXTERNAL COUTN SENSOR

int main( void )
{
    1a1e:	cf 92       	push	r12
    1a20:	df 92       	push	r13
    1a22:	ef 92       	push	r14
    1a24:	ff 92       	push	r15
    1a26:	0f 93       	push	r16
    1a28:	cf 93       	push	r28
    1a2a:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    1a2c:	80 e0       	ldi	r24, 0x00	; 0
    1a2e:	90 e0       	ldi	r25, 0x00	; 0
    1a30:	0e 94 8c 18 	call	0x3118	; 0x3118 <eeprom_read_byte>
    1a34:	d8 2e       	mov	r13, r24
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <mem4+0x41>
    1a3c:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	90 e0       	ldi	r25, 0x00	; 0
    1a44:	0e 94 8c 18 	call	0x3118	; 0x3118 <eeprom_read_byte>
    1a48:	d8 2f       	mov	r29, r24
    1a4a:	90 e0       	ldi	r25, 0x00	; 0
    1a4c:	90 93 3a 04 	sts	0x043A, r25	; 0x80043a <mem4+0x43>
    1a50:	80 93 39 04 	sts	0x0439, r24	; 0x800439 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    1a54:	82 e0       	ldi	r24, 0x02	; 2
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	0e 94 8c 18 	call	0x3118	; 0x3118 <eeprom_read_byte>
    1a5c:	c8 2f       	mov	r28, r24
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <mem4+0x45>
    1a64:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    1a68:	83 e0       	ldi	r24, 0x03	; 3
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	0e 94 8c 18 	call	0x3118	; 0x3118 <eeprom_read_byte>
    1a70:	28 2f       	mov	r18, r24
    1a72:	30 e0       	ldi	r19, 0x00	; 0
    1a74:	30 93 3e 04 	sts	0x043E, r19	; 0x80043e <mem4+0x47>
    1a78:	20 93 3d 04 	sts	0x043D, r18	; 0x80043d <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    1a7c:	e3 ef       	ldi	r30, 0xF3	; 243
    1a7e:	f3 e0       	ldi	r31, 0x03	; 3
    1a80:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    1a82:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    1a84:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    1a86:	83 83       	std	Z+3, r24	; 0x03

int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1a88:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1a8a:	4e df       	rcall	.-356    	; 0x1928 <_Z8Init_Devv>
    1a8c:	4c e7       	ldi	r20, 0x7C	; 124
    1a8e:	5c e0       	ldi	r21, 0x0C	; 12
    1a90:	60 e0       	ldi	r22, 0x00	; 0
    1a92:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1a96:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1a9a:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1a9e:	44 e8       	ldi	r20, 0x84	; 132
    1aa0:	5c e0       	ldi	r21, 0x0C	; 12
    1aa2:	61 e0       	ldi	r22, 0x01	; 1
    1aa4:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1aa8:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1aac:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    1ab0:	47 ea       	ldi	r20, 0xA7	; 167
    1ab2:	58 e0       	ldi	r21, 0x08	; 8
    1ab4:	62 e0       	ldi	r22, 0x02	; 2
    1ab6:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1aba:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1abe:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    1ac2:	4c e8       	ldi	r20, 0x8C	; 140
    1ac4:	5c e0       	ldi	r21, 0x0C	; 12
    1ac6:	63 e0       	ldi	r22, 0x03	; 3
    1ac8:	80 91 78 04 	lds	r24, 0x0478	; 0x800478 <dev>
    1acc:	90 91 79 04 	lds	r25, 0x0479	; 0x800479 <dev+0x1>
    1ad0:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    1ad4:	88 e8       	ldi	r24, 0x88	; 136
    1ad6:	90 e0       	ldi	r25, 0x00	; 0
    1ad8:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1adc:	6c 01       	movw	r12, r24
    1ade:	60 91 78 04 	lds	r22, 0x0478	; 0x800478 <dev>
    1ae2:	70 91 79 04 	lds	r23, 0x0479	; 0x800479 <dev+0x1>
    1ae6:	40 e0       	ldi	r20, 0x00	; 0
    1ae8:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1aec:	c1 14       	cp	r12, r1
    1aee:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1af0:	21 f4       	brne	.+8      	; 0x1afa <main+0xdc>
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	0e 94 a5 18 	call	0x314a	; 0x314a <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1afa:	88 e8       	ldi	r24, 0x88	; 136
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1b02:	ec 01       	movw	r28, r24
    1b04:	60 91 78 04 	lds	r22, 0x0478	; 0x800478 <dev>
    1b08:	70 91 79 04 	lds	r23, 0x0479	; 0x800479 <dev+0x1>
    1b0c:	41 e0       	ldi	r20, 0x01	; 1
    1b0e:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    1b12:	20 97       	sbiw	r28, 0x00	; 0
	{
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1b14:	21 f4       	brne	.+8      	; 0x1b1e <main+0x100>
    1b16:	81 e0       	ldi	r24, 0x01	; 1
    1b18:	90 e0       	ldi	r25, 0x00	; 0
    1b1a:	0e 94 a5 18 	call	0x314a	; 0x314a <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    1b1e:	e0 e7       	ldi	r30, 0x70	; 112
    1b20:	f4 e0       	ldi	r31, 0x04	; 4
    1b22:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    1b24:	c0 82       	st	Z, r12
    1b26:	d3 83       	std	Z+3, r29	; 0x03
				else if(i == RS485)
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			}
		}
	}
	Alarm_Init(); //알람 초기화
    1b28:	c2 83       	std	Z+2, r28	; 0x02
    1b2a:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Alarm_Init>
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1b2e:	78 94       	sei
    1b30:	e1 2c       	mov	r14, r1
    1b32:	f1 2c       	mov	r15, r1
    1b34:	02 e0       	ldi	r16, 0x02	; 2
    1b36:	96 01       	movw	r18, r12
    1b38:	4e e5       	ldi	r20, 0x5E	; 94
    1b3a:	51 e0       	ldi	r21, 0x01	; 1
    1b3c:	64 e9       	ldi	r22, 0x94	; 148
    1b3e:	71 e0       	ldi	r23, 0x01	; 1
    1b40:	88 e1       	ldi	r24, 0x18	; 24
    1b42:	9b e0       	ldi	r25, 0x0B	; 11
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    1b44:	2b d5       	rcall	.+2646   	; 0x259c <xTaskCreate>
    1b46:	9e 01       	movw	r18, r28
    1b48:	4e e5       	ldi	r20, 0x5E	; 94
    1b4a:	51 e0       	ldi	r21, 0x01	; 1
    1b4c:	6a e9       	ldi	r22, 0x9A	; 154
    1b4e:	71 e0       	ldi	r23, 0x01	; 1
    1b50:	8d e5       	ldi	r24, 0x5D	; 93
    1b52:	9a e0       	ldi	r25, 0x0A	; 10
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    1b54:	23 d5       	rcall	.+2630   	; 0x259c <xTaskCreate>
    1b56:	20 e0       	ldi	r18, 0x00	; 0
    1b58:	30 e0       	ldi	r19, 0x00	; 0
    1b5a:	40 ef       	ldi	r20, 0xF0	; 240
    1b5c:	50 e0       	ldi	r21, 0x00	; 0
    1b5e:	60 ea       	ldi	r22, 0xA0	; 160
    1b60:	71 e0       	ldi	r23, 0x01	; 1
    1b62:	89 eb       	ldi	r24, 0xB9	; 185
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    1b64:	98 e0       	ldi	r25, 0x08	; 8
    1b66:	1a d5       	rcall	.+2612   	; 0x259c <xTaskCreate>
	return 0;
}
    1b68:	17 d6       	rcall	.+3118   	; 0x2798 <vTaskStartScheduler>
    1b6a:	80 e0       	ldi	r24, 0x00	; 0
    1b6c:	90 e0       	ldi	r25, 0x00	; 0
    1b6e:	df 91       	pop	r29
    1b70:	cf 91       	pop	r28
    1b72:	0f 91       	pop	r16
    1b74:	ff 90       	pop	r15
    1b76:	ef 90       	pop	r14
    1b78:	df 90       	pop	r13
    1b7a:	cf 90       	pop	r12
    1b7c:	08 95       	ret

00001b7e <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1b7e:	08 95       	ret

00001b80 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1b80:	cf 93       	push	r28
    1b82:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1b84:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    1b86:	30 d6       	rcall	.+3168   	; 0x27e8 <vTaskSuspendAll>
    1b88:	80 91 7a 04 	lds	r24, 0x047A	; 0x80047a <pucAlignedHeap.2069>
    1b8c:	90 91 7b 04 	lds	r25, 0x047B	; 0x80047b <pucAlignedHeap.2069+0x1>
    1b90:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1b92:	31 f4       	brne	.+12     	; 0x1ba0 <pvPortMalloc+0x20>
    1b94:	8f e7       	ldi	r24, 0x7F	; 127
    1b96:	94 e0       	ldi	r25, 0x04	; 4
    1b98:	90 93 7b 04 	sts	0x047B, r25	; 0x80047b <pucAlignedHeap.2069+0x1>
    1b9c:	80 93 7a 04 	sts	0x047A, r24	; 0x80047a <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1ba0:	20 91 7c 04 	lds	r18, 0x047C	; 0x80047c <xNextFreeByte>
    1ba4:	30 91 7d 04 	lds	r19, 0x047D	; 0x80047d <xNextFreeByte+0x1>
    1ba8:	c9 01       	movw	r24, r18
    1baa:	8c 0f       	add	r24, r28
    1bac:	9d 1f       	adc	r25, r29
    1bae:	8b 3f       	cpi	r24, 0xFB	; 251
    1bb0:	48 e0       	ldi	r20, 0x08	; 8
    1bb2:	94 07       	cpc	r25, r20
    1bb4:	70 f4       	brcc	.+28     	; 0x1bd2 <pvPortMalloc+0x52>
    1bb6:	28 17       	cp	r18, r24
    1bb8:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1bba:	70 f4       	brcc	.+28     	; 0x1bd8 <pvPortMalloc+0x58>
    1bbc:	c0 91 7a 04 	lds	r28, 0x047A	; 0x80047a <pucAlignedHeap.2069>
    1bc0:	d0 91 7b 04 	lds	r29, 0x047B	; 0x80047b <pucAlignedHeap.2069+0x1>
    1bc4:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    1bc6:	d3 1f       	adc	r29, r19
    1bc8:	90 93 7d 04 	sts	0x047D, r25	; 0x80047d <xNextFreeByte+0x1>
    1bcc:	80 93 7c 04 	sts	0x047C, r24	; 0x80047c <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1bd0:	05 c0       	rjmp	.+10     	; 0x1bdc <pvPortMalloc+0x5c>
    1bd2:	c0 e0       	ldi	r28, 0x00	; 0
    1bd4:	d0 e0       	ldi	r29, 0x00	; 0
    1bd6:	02 c0       	rjmp	.+4      	; 0x1bdc <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1bd8:	c0 e0       	ldi	r28, 0x00	; 0
    1bda:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1bdc:	c2 d6       	rcall	.+3460   	; 0x2962 <xTaskResumeAll>
    1bde:	ce 01       	movw	r24, r28
    1be0:	df 91       	pop	r29
    1be2:	cf 91       	pop	r28
    1be4:	08 95       	ret

00001be6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1be6:	08 95       	ret

00001be8 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1be8:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bea:	03 96       	adiw	r24, 0x03	; 3
    1bec:	92 83       	std	Z+2, r25	; 0x02
    1bee:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bf0:	2f ef       	ldi	r18, 0xFF	; 255
    1bf2:	3f ef       	ldi	r19, 0xFF	; 255
    1bf4:	34 83       	std	Z+4, r19	; 0x04
    1bf6:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf8:	96 83       	std	Z+6, r25	; 0x06
    1bfa:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bfc:	90 87       	std	Z+8, r25	; 0x08
    1bfe:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c00:	10 82       	st	Z, r1
    1c02:	08 95       	ret

00001c04 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c04:	fc 01       	movw	r30, r24
    1c06:	11 86       	std	Z+9, r1	; 0x09
    1c08:	10 86       	std	Z+8, r1	; 0x08
    1c0a:	08 95       	ret

00001c0c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c0c:	cf 93       	push	r28
    1c0e:	df 93       	push	r29
    1c10:	9c 01       	movw	r18, r24
    1c12:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c14:	dc 01       	movw	r26, r24
    1c16:	11 96       	adiw	r26, 0x01	; 1
    1c18:	cd 91       	ld	r28, X+
    1c1a:	dc 91       	ld	r29, X
    1c1c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c1e:	d3 83       	std	Z+3, r29	; 0x03
    1c20:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c22:	8c 81       	ldd	r24, Y+4	; 0x04
    1c24:	9d 81       	ldd	r25, Y+5	; 0x05
    1c26:	95 83       	std	Z+5, r25	; 0x05
    1c28:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c2a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c2c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c2e:	dc 01       	movw	r26, r24
    1c30:	13 96       	adiw	r26, 0x03	; 3
    1c32:	7c 93       	st	X, r23
    1c34:	6e 93       	st	-X, r22
    1c36:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1c38:	7d 83       	std	Y+5, r23	; 0x05
    1c3a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c3c:	31 87       	std	Z+9, r19	; 0x09
    1c3e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c40:	f9 01       	movw	r30, r18
    1c42:	80 81       	ld	r24, Z
    1c44:	8f 5f       	subi	r24, 0xFF	; 255
    1c46:	80 83       	st	Z, r24
}
    1c48:	df 91       	pop	r29
    1c4a:	cf 91       	pop	r28
    1c4c:	08 95       	ret

00001c4e <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c4e:	cf 93       	push	r28
    1c50:	df 93       	push	r29
    1c52:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c54:	48 81       	ld	r20, Y
    1c56:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c58:	4f 3f       	cpi	r20, 0xFF	; 255
    1c5a:	2f ef       	ldi	r18, 0xFF	; 255
    1c5c:	52 07       	cpc	r21, r18
    1c5e:	21 f4       	brne	.+8      	; 0x1c68 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c60:	fc 01       	movw	r30, r24
    1c62:	a7 81       	ldd	r26, Z+7	; 0x07
    1c64:	b0 85       	ldd	r27, Z+8	; 0x08
    1c66:	0d c0       	rjmp	.+26     	; 0x1c82 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c68:	dc 01       	movw	r26, r24
    1c6a:	13 96       	adiw	r26, 0x03	; 3
    1c6c:	01 c0       	rjmp	.+2      	; 0x1c70 <vListInsert+0x22>
    1c6e:	df 01       	movw	r26, r30
    1c70:	12 96       	adiw	r26, 0x02	; 2
    1c72:	ed 91       	ld	r30, X+
    1c74:	fc 91       	ld	r31, X
    1c76:	13 97       	sbiw	r26, 0x03	; 3
    1c78:	20 81       	ld	r18, Z
    1c7a:	31 81       	ldd	r19, Z+1	; 0x01
    1c7c:	42 17       	cp	r20, r18
    1c7e:	53 07       	cpc	r21, r19
    1c80:	b0 f7       	brcc	.-20     	; 0x1c6e <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c82:	12 96       	adiw	r26, 0x02	; 2
    1c84:	ed 91       	ld	r30, X+
    1c86:	fc 91       	ld	r31, X
    1c88:	13 97       	sbiw	r26, 0x03	; 3
    1c8a:	fb 83       	std	Y+3, r31	; 0x03
    1c8c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c8e:	d5 83       	std	Z+5, r29	; 0x05
    1c90:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c92:	bd 83       	std	Y+5, r27	; 0x05
    1c94:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c96:	13 96       	adiw	r26, 0x03	; 3
    1c98:	dc 93       	st	X, r29
    1c9a:	ce 93       	st	-X, r28
    1c9c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c9e:	99 87       	std	Y+9, r25	; 0x09
    1ca0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1ca2:	fc 01       	movw	r30, r24
    1ca4:	20 81       	ld	r18, Z
    1ca6:	2f 5f       	subi	r18, 0xFF	; 255
    1ca8:	20 83       	st	Z, r18
}
    1caa:	df 91       	pop	r29
    1cac:	cf 91       	pop	r28
    1cae:	08 95       	ret

00001cb0 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cb0:	cf 93       	push	r28
    1cb2:	df 93       	push	r29
    1cb4:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cb6:	a0 85       	ldd	r26, Z+8	; 0x08
    1cb8:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cba:	c2 81       	ldd	r28, Z+2	; 0x02
    1cbc:	d3 81       	ldd	r29, Z+3	; 0x03
    1cbe:	84 81       	ldd	r24, Z+4	; 0x04
    1cc0:	95 81       	ldd	r25, Z+5	; 0x05
    1cc2:	9d 83       	std	Y+5, r25	; 0x05
    1cc4:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cc6:	c4 81       	ldd	r28, Z+4	; 0x04
    1cc8:	d5 81       	ldd	r29, Z+5	; 0x05
    1cca:	82 81       	ldd	r24, Z+2	; 0x02
    1ccc:	93 81       	ldd	r25, Z+3	; 0x03
    1cce:	9b 83       	std	Y+3, r25	; 0x03
    1cd0:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cd2:	11 96       	adiw	r26, 0x01	; 1
    1cd4:	8d 91       	ld	r24, X+
    1cd6:	9c 91       	ld	r25, X
    1cd8:	12 97       	sbiw	r26, 0x02	; 2
    1cda:	e8 17       	cp	r30, r24
    1cdc:	f9 07       	cpc	r31, r25
    1cde:	31 f4       	brne	.+12     	; 0x1cec <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ce0:	84 81       	ldd	r24, Z+4	; 0x04
    1ce2:	95 81       	ldd	r25, Z+5	; 0x05
    1ce4:	12 96       	adiw	r26, 0x02	; 2
    1ce6:	9c 93       	st	X, r25
    1ce8:	8e 93       	st	-X, r24
    1cea:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1cec:	11 86       	std	Z+9, r1	; 0x09
    1cee:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cf0:	8c 91       	ld	r24, X
    1cf2:	81 50       	subi	r24, 0x01	; 1
    1cf4:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1cf6:	df 91       	pop	r29
    1cf8:	cf 91       	pop	r28
    1cfa:	08 95       	ret

00001cfc <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1cfc:	31 e1       	ldi	r19, 0x11	; 17
    1cfe:	fc 01       	movw	r30, r24
    1d00:	30 83       	st	Z, r19
    1d02:	31 97       	sbiw	r30, 0x01	; 1
    1d04:	22 e2       	ldi	r18, 0x22	; 34
    1d06:	20 83       	st	Z, r18
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	a3 e3       	ldi	r26, 0x33	; 51
    1d0c:	a0 83       	st	Z, r26
    1d0e:	31 97       	sbiw	r30, 0x01	; 1
    1d10:	60 83       	st	Z, r22
    1d12:	31 97       	sbiw	r30, 0x01	; 1
    1d14:	70 83       	st	Z, r23
    1d16:	31 97       	sbiw	r30, 0x01	; 1
    1d18:	10 82       	st	Z, r1
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	60 e8       	ldi	r22, 0x80	; 128
    1d1e:	60 83       	st	Z, r22
    1d20:	31 97       	sbiw	r30, 0x01	; 1
    1d22:	10 82       	st	Z, r1
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	62 e0       	ldi	r22, 0x02	; 2
    1d28:	60 83       	st	Z, r22
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	63 e0       	ldi	r22, 0x03	; 3
    1d2e:	60 83       	st	Z, r22
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	64 e0       	ldi	r22, 0x04	; 4
    1d34:	60 83       	st	Z, r22
    1d36:	31 97       	sbiw	r30, 0x01	; 1
    1d38:	65 e0       	ldi	r22, 0x05	; 5
    1d3a:	60 83       	st	Z, r22
    1d3c:	31 97       	sbiw	r30, 0x01	; 1
    1d3e:	66 e0       	ldi	r22, 0x06	; 6
    1d40:	60 83       	st	Z, r22
    1d42:	31 97       	sbiw	r30, 0x01	; 1
    1d44:	67 e0       	ldi	r22, 0x07	; 7
    1d46:	60 83       	st	Z, r22
    1d48:	31 97       	sbiw	r30, 0x01	; 1
    1d4a:	68 e0       	ldi	r22, 0x08	; 8
    1d4c:	60 83       	st	Z, r22
    1d4e:	31 97       	sbiw	r30, 0x01	; 1
    1d50:	69 e0       	ldi	r22, 0x09	; 9
    1d52:	60 83       	st	Z, r22
    1d54:	31 97       	sbiw	r30, 0x01	; 1
    1d56:	60 e1       	ldi	r22, 0x10	; 16
    1d58:	60 83       	st	Z, r22
    1d5a:	31 97       	sbiw	r30, 0x01	; 1
    1d5c:	30 83       	st	Z, r19
    1d5e:	31 97       	sbiw	r30, 0x01	; 1
    1d60:	32 e1       	ldi	r19, 0x12	; 18
    1d62:	30 83       	st	Z, r19
    1d64:	31 97       	sbiw	r30, 0x01	; 1
    1d66:	33 e1       	ldi	r19, 0x13	; 19
    1d68:	30 83       	st	Z, r19
    1d6a:	31 97       	sbiw	r30, 0x01	; 1
    1d6c:	34 e1       	ldi	r19, 0x14	; 20
    1d6e:	30 83       	st	Z, r19
    1d70:	31 97       	sbiw	r30, 0x01	; 1
    1d72:	35 e1       	ldi	r19, 0x15	; 21
    1d74:	30 83       	st	Z, r19
    1d76:	31 97       	sbiw	r30, 0x01	; 1
    1d78:	36 e1       	ldi	r19, 0x16	; 22
    1d7a:	30 83       	st	Z, r19
    1d7c:	31 97       	sbiw	r30, 0x01	; 1
    1d7e:	37 e1       	ldi	r19, 0x17	; 23
    1d80:	30 83       	st	Z, r19
    1d82:	31 97       	sbiw	r30, 0x01	; 1
    1d84:	38 e1       	ldi	r19, 0x18	; 24
    1d86:	30 83       	st	Z, r19
    1d88:	31 97       	sbiw	r30, 0x01	; 1
    1d8a:	39 e1       	ldi	r19, 0x19	; 25
    1d8c:	30 83       	st	Z, r19
    1d8e:	31 97       	sbiw	r30, 0x01	; 1
    1d90:	30 e2       	ldi	r19, 0x20	; 32
    1d92:	30 83       	st	Z, r19
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	31 e2       	ldi	r19, 0x21	; 33
    1d98:	30 83       	st	Z, r19
    1d9a:	31 97       	sbiw	r30, 0x01	; 1
    1d9c:	20 83       	st	Z, r18
    1d9e:	31 97       	sbiw	r30, 0x01	; 1
    1da0:	23 e2       	ldi	r18, 0x23	; 35
    1da2:	20 83       	st	Z, r18
    1da4:	31 97       	sbiw	r30, 0x01	; 1
    1da6:	40 83       	st	Z, r20
    1da8:	31 97       	sbiw	r30, 0x01	; 1
    1daa:	50 83       	st	Z, r21
    1dac:	31 97       	sbiw	r30, 0x01	; 1
    1dae:	26 e2       	ldi	r18, 0x26	; 38
    1db0:	20 83       	st	Z, r18
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	27 e2       	ldi	r18, 0x27	; 39
    1db6:	20 83       	st	Z, r18
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	28 e2       	ldi	r18, 0x28	; 40
    1dbc:	20 83       	st	Z, r18
    1dbe:	31 97       	sbiw	r30, 0x01	; 1
    1dc0:	29 e2       	ldi	r18, 0x29	; 41
    1dc2:	20 83       	st	Z, r18
    1dc4:	31 97       	sbiw	r30, 0x01	; 1
    1dc6:	20 e3       	ldi	r18, 0x30	; 48
    1dc8:	20 83       	st	Z, r18
    1dca:	31 97       	sbiw	r30, 0x01	; 1
    1dcc:	21 e3       	ldi	r18, 0x31	; 49
    1dce:	20 83       	st	Z, r18
    1dd0:	86 97       	sbiw	r24, 0x26	; 38
    1dd2:	08 95       	ret

00001dd4 <xPortStartScheduler>:
    1dd4:	1b bc       	out	0x2b, r1	; 43
    1dd6:	89 ef       	ldi	r24, 0xF9	; 249
    1dd8:	8a bd       	out	0x2a, r24	; 42
    1dda:	8b e0       	ldi	r24, 0x0B	; 11
    1ddc:	8e bd       	out	0x2e, r24	; 46
    1dde:	87 b7       	in	r24, 0x37	; 55
    1de0:	80 61       	ori	r24, 0x10	; 16
    1de2:	87 bf       	out	0x37, r24	; 55
    1de4:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    1de8:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    1dec:	cd 91       	ld	r28, X+
    1dee:	cd bf       	out	0x3d, r28	; 61
    1df0:	dd 91       	ld	r29, X+
    1df2:	de bf       	out	0x3e, r29	; 62
    1df4:	ff 91       	pop	r31
    1df6:	ef 91       	pop	r30
    1df8:	df 91       	pop	r29
    1dfa:	cf 91       	pop	r28
    1dfc:	bf 91       	pop	r27
    1dfe:	af 91       	pop	r26
    1e00:	9f 91       	pop	r25
    1e02:	8f 91       	pop	r24
    1e04:	7f 91       	pop	r23
    1e06:	6f 91       	pop	r22
    1e08:	5f 91       	pop	r21
    1e0a:	4f 91       	pop	r20
    1e0c:	3f 91       	pop	r19
    1e0e:	2f 91       	pop	r18
    1e10:	1f 91       	pop	r17
    1e12:	0f 91       	pop	r16
    1e14:	ff 90       	pop	r15
    1e16:	ef 90       	pop	r14
    1e18:	df 90       	pop	r13
    1e1a:	cf 90       	pop	r12
    1e1c:	bf 90       	pop	r11
    1e1e:	af 90       	pop	r10
    1e20:	9f 90       	pop	r9
    1e22:	8f 90       	pop	r8
    1e24:	7f 90       	pop	r7
    1e26:	6f 90       	pop	r6
    1e28:	5f 90       	pop	r5
    1e2a:	4f 90       	pop	r4
    1e2c:	3f 90       	pop	r3
    1e2e:	2f 90       	pop	r2
    1e30:	1f 90       	pop	r1
    1e32:	0f 90       	pop	r0
    1e34:	0f be       	out	0x3f, r0	; 63
    1e36:	0f 90       	pop	r0
    1e38:	08 95       	ret
    1e3a:	81 e0       	ldi	r24, 0x01	; 1
    1e3c:	08 95       	ret

00001e3e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1e3e:	0f 92       	push	r0
    1e40:	0f b6       	in	r0, 0x3f	; 63
    1e42:	f8 94       	cli
    1e44:	0f 92       	push	r0
    1e46:	1f 92       	push	r1
    1e48:	11 24       	eor	r1, r1
    1e4a:	2f 92       	push	r2
    1e4c:	3f 92       	push	r3
    1e4e:	4f 92       	push	r4
    1e50:	5f 92       	push	r5
    1e52:	6f 92       	push	r6
    1e54:	7f 92       	push	r7
    1e56:	8f 92       	push	r8
    1e58:	9f 92       	push	r9
    1e5a:	af 92       	push	r10
    1e5c:	bf 92       	push	r11
    1e5e:	cf 92       	push	r12
    1e60:	df 92       	push	r13
    1e62:	ef 92       	push	r14
    1e64:	ff 92       	push	r15
    1e66:	0f 93       	push	r16
    1e68:	1f 93       	push	r17
    1e6a:	2f 93       	push	r18
    1e6c:	3f 93       	push	r19
    1e6e:	4f 93       	push	r20
    1e70:	5f 93       	push	r21
    1e72:	6f 93       	push	r22
    1e74:	7f 93       	push	r23
    1e76:	8f 93       	push	r24
    1e78:	9f 93       	push	r25
    1e7a:	af 93       	push	r26
    1e7c:	bf 93       	push	r27
    1e7e:	cf 93       	push	r28
    1e80:	df 93       	push	r29
    1e82:	ef 93       	push	r30
    1e84:	ff 93       	push	r31
    1e86:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    1e8a:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    1e8e:	0d b6       	in	r0, 0x3d	; 61
    1e90:	0d 92       	st	X+, r0
    1e92:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1e94:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    1e96:	25 d6       	rcall	.+3146   	; 0x2ae2 <vTaskSwitchContext>
    1e98:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    1e9c:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    1ea0:	cd 91       	ld	r28, X+
    1ea2:	cd bf       	out	0x3d, r28	; 61
    1ea4:	dd 91       	ld	r29, X+
    1ea6:	de bf       	out	0x3e, r29	; 62
    1ea8:	ff 91       	pop	r31
    1eaa:	ef 91       	pop	r30
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	bf 91       	pop	r27
    1eb2:	af 91       	pop	r26
    1eb4:	9f 91       	pop	r25
    1eb6:	8f 91       	pop	r24
    1eb8:	7f 91       	pop	r23
    1eba:	6f 91       	pop	r22
    1ebc:	5f 91       	pop	r21
    1ebe:	4f 91       	pop	r20
    1ec0:	3f 91       	pop	r19
    1ec2:	2f 91       	pop	r18
    1ec4:	1f 91       	pop	r17
    1ec6:	0f 91       	pop	r16
    1ec8:	ff 90       	pop	r15
    1eca:	ef 90       	pop	r14
    1ecc:	df 90       	pop	r13
    1ece:	cf 90       	pop	r12
    1ed0:	bf 90       	pop	r11
    1ed2:	af 90       	pop	r10
    1ed4:	9f 90       	pop	r9
    1ed6:	8f 90       	pop	r8
    1ed8:	7f 90       	pop	r7
    1eda:	6f 90       	pop	r6
    1edc:	5f 90       	pop	r5
    1ede:	4f 90       	pop	r4
    1ee0:	3f 90       	pop	r3
    1ee2:	2f 90       	pop	r2
    1ee4:	1f 90       	pop	r1
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1eea:	0f 90       	pop	r0
    1eec:	08 95       	ret

00001eee <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1eee:	0f 92       	push	r0
    1ef0:	0f b6       	in	r0, 0x3f	; 63
    1ef2:	f8 94       	cli
    1ef4:	0f 92       	push	r0
    1ef6:	1f 92       	push	r1
    1ef8:	11 24       	eor	r1, r1
    1efa:	2f 92       	push	r2
    1efc:	3f 92       	push	r3
    1efe:	4f 92       	push	r4
    1f00:	5f 92       	push	r5
    1f02:	6f 92       	push	r6
    1f04:	7f 92       	push	r7
    1f06:	8f 92       	push	r8
    1f08:	9f 92       	push	r9
    1f0a:	af 92       	push	r10
    1f0c:	bf 92       	push	r11
    1f0e:	cf 92       	push	r12
    1f10:	df 92       	push	r13
    1f12:	ef 92       	push	r14
    1f14:	ff 92       	push	r15
    1f16:	0f 93       	push	r16
    1f18:	1f 93       	push	r17
    1f1a:	2f 93       	push	r18
    1f1c:	3f 93       	push	r19
    1f1e:	4f 93       	push	r20
    1f20:	5f 93       	push	r21
    1f22:	6f 93       	push	r22
    1f24:	7f 93       	push	r23
    1f26:	8f 93       	push	r24
    1f28:	9f 93       	push	r25
    1f2a:	af 93       	push	r26
    1f2c:	bf 93       	push	r27
    1f2e:	cf 93       	push	r28
    1f30:	df 93       	push	r29
    1f32:	ef 93       	push	r30
    1f34:	ff 93       	push	r31
    1f36:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    1f3a:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    1f3e:	0d b6       	in	r0, 0x3d	; 61
    1f40:	0d 92       	st	X+, r0
    1f42:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    1f44:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    1f46:	56 d4       	rcall	.+2220   	; 0x27f4 <xTaskIncrementTick>
    1f48:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    1f4a:	cb d5       	rcall	.+2966   	; 0x2ae2 <vTaskSwitchContext>
    1f4c:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    1f50:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    1f54:	cd 91       	ld	r28, X+
    1f56:	cd bf       	out	0x3d, r28	; 61
    1f58:	dd 91       	ld	r29, X+
    1f5a:	de bf       	out	0x3e, r29	; 62
    1f5c:	ff 91       	pop	r31
    1f5e:	ef 91       	pop	r30
    1f60:	df 91       	pop	r29
    1f62:	cf 91       	pop	r28
    1f64:	bf 91       	pop	r27
    1f66:	af 91       	pop	r26
    1f68:	9f 91       	pop	r25
    1f6a:	8f 91       	pop	r24
    1f6c:	7f 91       	pop	r23
    1f6e:	6f 91       	pop	r22
    1f70:	5f 91       	pop	r21
    1f72:	4f 91       	pop	r20
    1f74:	3f 91       	pop	r19
    1f76:	2f 91       	pop	r18
    1f78:	1f 91       	pop	r17
    1f7a:	0f 91       	pop	r16
    1f7c:	ff 90       	pop	r15
    1f7e:	ef 90       	pop	r14
    1f80:	df 90       	pop	r13
    1f82:	cf 90       	pop	r12
    1f84:	bf 90       	pop	r11
    1f86:	af 90       	pop	r10
    1f88:	9f 90       	pop	r9
    1f8a:	8f 90       	pop	r8
    1f8c:	7f 90       	pop	r7
    1f8e:	6f 90       	pop	r6
    1f90:	5f 90       	pop	r5
    1f92:	4f 90       	pop	r4
    1f94:	3f 90       	pop	r3
    1f96:	2f 90       	pop	r2
    1f98:	1f 90       	pop	r1
    1f9a:	0f 90       	pop	r0
    1f9c:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1f9e:	0f 90       	pop	r0
    1fa0:	08 95       	ret

00001fa2 <__vector_12>:
    1fa2:	a5 df       	rcall	.-182    	; 0x1eee <vPortYieldFromTick>
    1fa4:	18 95       	reti

00001fa6 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1fa6:	0f 93       	push	r16
    1fa8:	1f 93       	push	r17
    1faa:	cf 93       	push	r28
    1fac:	df 93       	push	r29
    1fae:	ec 01       	movw	r28, r24
    1fb0:	04 2f       	mov	r16, r20
    1fb2:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1fb4:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1fb6:	41 11       	cpse	r20, r1
    1fb8:	0b c0       	rjmp	.+22     	; 0x1fd0 <prvCopyDataToQueue+0x2a>
    1fba:	88 81       	ld	r24, Y
    1fbc:	99 81       	ldd	r25, Y+1	; 0x01
    1fbe:	89 2b       	or	r24, r25
    1fc0:	09 f0       	breq	.+2      	; 0x1fc4 <prvCopyDataToQueue+0x1e>
    1fc2:	41 c0       	rjmp	.+130    	; 0x2046 <prvCopyDataToQueue+0xa0>
    1fc4:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc6:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc8:	0b d7       	rcall	.+3606   	; 0x2de0 <xTaskPriorityDisinherit>
    1fca:	1b 82       	std	Y+3, r1	; 0x03
    1fcc:	1a 82       	std	Y+2, r1	; 0x02
    1fce:	42 c0       	rjmp	.+132    	; 0x2054 <prvCopyDataToQueue+0xae>
    1fd0:	01 11       	cpse	r16, r1
    1fd2:	17 c0       	rjmp	.+46     	; 0x2002 <prvCopyDataToQueue+0x5c>
    1fd4:	50 e0       	ldi	r21, 0x00	; 0
    1fd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1fda:	0e 94 83 18 	call	0x3106	; 0x3106 <memcpy>
    1fde:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1fe0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fe2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fe4:	82 0f       	add	r24, r18
    1fe6:	91 1d       	adc	r25, r1
    1fe8:	9d 83       	std	Y+5, r25	; 0x05
    1fea:	8c 83       	std	Y+4, r24	; 0x04
    1fec:	2a 81       	ldd	r18, Y+2	; 0x02
    1fee:	3b 81       	ldd	r19, Y+3	; 0x03
    1ff0:	82 17       	cp	r24, r18
    1ff2:	93 07       	cpc	r25, r19
    1ff4:	50 f1       	brcs	.+84     	; 0x204a <prvCopyDataToQueue+0xa4>
    1ff6:	88 81       	ld	r24, Y
    1ff8:	99 81       	ldd	r25, Y+1	; 0x01
    1ffa:	9d 83       	std	Y+5, r25	; 0x05
    1ffc:	8c 83       	std	Y+4, r24	; 0x04
    1ffe:	80 e0       	ldi	r24, 0x00	; 0
    2000:	29 c0       	rjmp	.+82     	; 0x2054 <prvCopyDataToQueue+0xae>
    2002:	50 e0       	ldi	r21, 0x00	; 0
    2004:	8e 81       	ldd	r24, Y+6	; 0x06
    2006:	9f 81       	ldd	r25, Y+7	; 0x07
    2008:	0e 94 83 18 	call	0x3106	; 0x3106 <memcpy>
    200c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	91 95       	neg	r25
    2012:	81 95       	neg	r24
    2014:	91 09       	sbc	r25, r1
    2016:	2e 81       	ldd	r18, Y+6	; 0x06
    2018:	3f 81       	ldd	r19, Y+7	; 0x07
    201a:	28 0f       	add	r18, r24
    201c:	39 1f       	adc	r19, r25
    201e:	3f 83       	std	Y+7, r19	; 0x07
    2020:	2e 83       	std	Y+6, r18	; 0x06
    2022:	48 81       	ld	r20, Y
    2024:	59 81       	ldd	r21, Y+1	; 0x01
    2026:	24 17       	cp	r18, r20
    2028:	35 07       	cpc	r19, r21
    202a:	30 f4       	brcc	.+12     	; 0x2038 <prvCopyDataToQueue+0x92>
    202c:	2a 81       	ldd	r18, Y+2	; 0x02
    202e:	3b 81       	ldd	r19, Y+3	; 0x03
    2030:	82 0f       	add	r24, r18
    2032:	93 1f       	adc	r25, r19
    2034:	9f 83       	std	Y+7, r25	; 0x07
    2036:	8e 83       	std	Y+6, r24	; 0x06
    2038:	02 30       	cpi	r16, 0x02	; 2
    203a:	49 f4       	brne	.+18     	; 0x204e <prvCopyDataToQueue+0xa8>
    203c:	11 23       	and	r17, r17
    203e:	49 f0       	breq	.+18     	; 0x2052 <prvCopyDataToQueue+0xac>
    2040:	11 50       	subi	r17, 0x01	; 1
    2042:	80 e0       	ldi	r24, 0x00	; 0
    2044:	07 c0       	rjmp	.+14     	; 0x2054 <prvCopyDataToQueue+0xae>
    2046:	80 e0       	ldi	r24, 0x00	; 0
    2048:	05 c0       	rjmp	.+10     	; 0x2054 <prvCopyDataToQueue+0xae>
    204a:	80 e0       	ldi	r24, 0x00	; 0
    204c:	03 c0       	rjmp	.+6      	; 0x2054 <prvCopyDataToQueue+0xae>
    204e:	80 e0       	ldi	r24, 0x00	; 0
    2050:	01 c0       	rjmp	.+2      	; 0x2054 <prvCopyDataToQueue+0xae>
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	1f 5f       	subi	r17, 0xFF	; 255
    2056:	1a 8f       	std	Y+26, r17	; 0x1a
    2058:	df 91       	pop	r29
    205a:	cf 91       	pop	r28
    205c:	1f 91       	pop	r17
    205e:	0f 91       	pop	r16
    2060:	08 95       	ret

00002062 <prvCopyDataFromQueue>:
    2062:	fc 01       	movw	r30, r24
    2064:	44 8d       	ldd	r20, Z+28	; 0x1c
    2066:	44 23       	and	r20, r20
    2068:	a9 f0       	breq	.+42     	; 0x2094 <prvCopyDataFromQueue+0x32>
    206a:	50 e0       	ldi	r21, 0x00	; 0
    206c:	26 81       	ldd	r18, Z+6	; 0x06
    206e:	37 81       	ldd	r19, Z+7	; 0x07
    2070:	24 0f       	add	r18, r20
    2072:	35 1f       	adc	r19, r21
    2074:	37 83       	std	Z+7, r19	; 0x07
    2076:	26 83       	std	Z+6, r18	; 0x06
    2078:	82 81       	ldd	r24, Z+2	; 0x02
    207a:	93 81       	ldd	r25, Z+3	; 0x03
    207c:	28 17       	cp	r18, r24
    207e:	39 07       	cpc	r19, r25
    2080:	20 f0       	brcs	.+8      	; 0x208a <prvCopyDataFromQueue+0x28>
    2082:	80 81       	ld	r24, Z
    2084:	91 81       	ldd	r25, Z+1	; 0x01
    2086:	97 83       	std	Z+7, r25	; 0x07
    2088:	86 83       	std	Z+6, r24	; 0x06
    208a:	cb 01       	movw	r24, r22
    208c:	66 81       	ldd	r22, Z+6	; 0x06
    208e:	77 81       	ldd	r23, Z+7	; 0x07
    2090:	0c 94 83 18 	jmp	0x3106	; 0x3106 <memcpy>
    2094:	08 95       	ret

00002096 <prvUnlockQueue>:
    2096:	ef 92       	push	r14
    2098:	ff 92       	push	r15
    209a:	0f 93       	push	r16
    209c:	1f 93       	push	r17
    209e:	cf 93       	push	r28
    20a0:	8c 01       	movw	r16, r24
    20a2:	0f b6       	in	r0, 0x3f	; 63
    20a4:	f8 94       	cli
    20a6:	0f 92       	push	r0
    20a8:	fc 01       	movw	r30, r24
    20aa:	c6 8d       	ldd	r28, Z+30	; 0x1e
    20ac:	1c 16       	cp	r1, r28
    20ae:	9c f4       	brge	.+38     	; 0x20d6 <prvUnlockQueue+0x40>
    20b0:	81 89       	ldd	r24, Z+17	; 0x11
    20b2:	81 11       	cpse	r24, r1
    20b4:	06 c0       	rjmp	.+12     	; 0x20c2 <prvUnlockQueue+0x2c>
    20b6:	0f c0       	rjmp	.+30     	; 0x20d6 <prvUnlockQueue+0x40>
    20b8:	f8 01       	movw	r30, r16
    20ba:	81 89       	ldd	r24, Z+17	; 0x11
    20bc:	81 11       	cpse	r24, r1
    20be:	05 c0       	rjmp	.+10     	; 0x20ca <prvUnlockQueue+0x34>
    20c0:	0a c0       	rjmp	.+20     	; 0x20d6 <prvUnlockQueue+0x40>
    20c2:	78 01       	movw	r14, r16
    20c4:	f1 e1       	ldi	r31, 0x11	; 17
    20c6:	ef 0e       	add	r14, r31
    20c8:	f1 1c       	adc	r15, r1
    20ca:	c7 01       	movw	r24, r14
    20cc:	9a d5       	rcall	.+2868   	; 0x2c02 <xTaskRemoveFromEventList>
    20ce:	81 11       	cpse	r24, r1
    20d0:	21 d6       	rcall	.+3138   	; 0x2d14 <vTaskMissedYield>
    20d2:	c1 50       	subi	r28, 0x01	; 1
    20d4:	89 f7       	brne	.-30     	; 0x20b8 <prvUnlockQueue+0x22>
    20d6:	8f ef       	ldi	r24, 0xFF	; 255
    20d8:	f8 01       	movw	r30, r16
    20da:	86 8f       	std	Z+30, r24	; 0x1e
    20dc:	0f 90       	pop	r0
    20de:	0f be       	out	0x3f, r0	; 63
    20e0:	0f b6       	in	r0, 0x3f	; 63
    20e2:	f8 94       	cli
    20e4:	0f 92       	push	r0
    20e6:	c5 8d       	ldd	r28, Z+29	; 0x1d
    20e8:	1c 16       	cp	r1, r28
    20ea:	9c f4       	brge	.+38     	; 0x2112 <prvUnlockQueue+0x7c>
    20ec:	80 85       	ldd	r24, Z+8	; 0x08
    20ee:	81 11       	cpse	r24, r1
    20f0:	06 c0       	rjmp	.+12     	; 0x20fe <prvUnlockQueue+0x68>
    20f2:	0f c0       	rjmp	.+30     	; 0x2112 <prvUnlockQueue+0x7c>
    20f4:	f8 01       	movw	r30, r16
    20f6:	80 85       	ldd	r24, Z+8	; 0x08
    20f8:	81 11       	cpse	r24, r1
    20fa:	05 c0       	rjmp	.+10     	; 0x2106 <prvUnlockQueue+0x70>
    20fc:	0a c0       	rjmp	.+20     	; 0x2112 <prvUnlockQueue+0x7c>
    20fe:	78 01       	movw	r14, r16
    2100:	f8 e0       	ldi	r31, 0x08	; 8
    2102:	ef 0e       	add	r14, r31
    2104:	f1 1c       	adc	r15, r1
    2106:	c7 01       	movw	r24, r14
    2108:	7c d5       	rcall	.+2808   	; 0x2c02 <xTaskRemoveFromEventList>
    210a:	81 11       	cpse	r24, r1
    210c:	03 d6       	rcall	.+3078   	; 0x2d14 <vTaskMissedYield>
    210e:	c1 50       	subi	r28, 0x01	; 1
    2110:	89 f7       	brne	.-30     	; 0x20f4 <prvUnlockQueue+0x5e>
    2112:	8f ef       	ldi	r24, 0xFF	; 255
    2114:	f8 01       	movw	r30, r16
    2116:	85 8f       	std	Z+29, r24	; 0x1d
    2118:	0f 90       	pop	r0
    211a:	0f be       	out	0x3f, r0	; 63
    211c:	cf 91       	pop	r28
    211e:	1f 91       	pop	r17
    2120:	0f 91       	pop	r16
    2122:	ff 90       	pop	r15
    2124:	ef 90       	pop	r14
    2126:	08 95       	ret

00002128 <xQueueGenericReset>:
    2128:	cf 93       	push	r28
    212a:	df 93       	push	r29
    212c:	ec 01       	movw	r28, r24
    212e:	0f b6       	in	r0, 0x3f	; 63
    2130:	f8 94       	cli
    2132:	0f 92       	push	r0
    2134:	48 81       	ld	r20, Y
    2136:	59 81       	ldd	r21, Y+1	; 0x01
    2138:	2c 8d       	ldd	r18, Y+28	; 0x1c
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    213e:	72 9f       	mul	r23, r18
    2140:	c0 01       	movw	r24, r0
    2142:	73 9f       	mul	r23, r19
    2144:	90 0d       	add	r25, r0
    2146:	11 24       	eor	r1, r1
    2148:	fa 01       	movw	r30, r20
    214a:	e8 0f       	add	r30, r24
    214c:	f9 1f       	adc	r31, r25
    214e:	fb 83       	std	Y+3, r31	; 0x03
    2150:	ea 83       	std	Y+2, r30	; 0x02
    2152:	1a 8e       	std	Y+26, r1	; 0x1a
    2154:	5d 83       	std	Y+5, r21	; 0x05
    2156:	4c 83       	std	Y+4, r20	; 0x04
    2158:	82 1b       	sub	r24, r18
    215a:	93 0b       	sbc	r25, r19
    215c:	84 0f       	add	r24, r20
    215e:	95 1f       	adc	r25, r21
    2160:	9f 83       	std	Y+7, r25	; 0x07
    2162:	8e 83       	std	Y+6, r24	; 0x06
    2164:	8f ef       	ldi	r24, 0xFF	; 255
    2166:	8d 8f       	std	Y+29, r24	; 0x1d
    2168:	8e 8f       	std	Y+30, r24	; 0x1e
    216a:	61 11       	cpse	r22, r1
    216c:	0a c0       	rjmp	.+20     	; 0x2182 <xQueueGenericReset+0x5a>
    216e:	88 85       	ldd	r24, Y+8	; 0x08
    2170:	88 23       	and	r24, r24
    2172:	69 f0       	breq	.+26     	; 0x218e <xQueueGenericReset+0x66>
    2174:	ce 01       	movw	r24, r28
    2176:	08 96       	adiw	r24, 0x08	; 8
    2178:	44 d5       	rcall	.+2696   	; 0x2c02 <xTaskRemoveFromEventList>
    217a:	88 23       	and	r24, r24
    217c:	41 f0       	breq	.+16     	; 0x218e <xQueueGenericReset+0x66>
    217e:	5f de       	rcall	.-834    	; 0x1e3e <vPortYield>
    2180:	06 c0       	rjmp	.+12     	; 0x218e <xQueueGenericReset+0x66>
    2182:	ce 01       	movw	r24, r28
    2184:	08 96       	adiw	r24, 0x08	; 8
    2186:	30 dd       	rcall	.-1440   	; 0x1be8 <vListInitialise>
    2188:	ce 01       	movw	r24, r28
    218a:	41 96       	adiw	r24, 0x11	; 17
    218c:	2d dd       	rcall	.-1446   	; 0x1be8 <vListInitialise>
    218e:	0f 90       	pop	r0
    2190:	0f be       	out	0x3f, r0	; 63
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	df 91       	pop	r29
    2196:	cf 91       	pop	r28
    2198:	08 95       	ret

0000219a <xQueueGenericCreate>:
    219a:	0f 93       	push	r16
    219c:	1f 93       	push	r17
    219e:	cf 93       	push	r28
    21a0:	df 93       	push	r29
    21a2:	08 2f       	mov	r16, r24
    21a4:	16 2f       	mov	r17, r22
    21a6:	66 23       	and	r22, r22
    21a8:	b1 f0       	breq	.+44     	; 0x21d6 <xQueueGenericCreate+0x3c>
    21aa:	86 9f       	mul	r24, r22
    21ac:	c0 01       	movw	r24, r0
    21ae:	11 24       	eor	r1, r1
    21b0:	4f 96       	adiw	r24, 0x1f	; 31
    21b2:	e6 dc       	rcall	.-1588   	; 0x1b80 <pvPortMalloc>
    21b4:	ec 01       	movw	r28, r24
    21b6:	00 97       	sbiw	r24, 0x00	; 0
    21b8:	39 f4       	brne	.+14     	; 0x21c8 <xQueueGenericCreate+0x2e>
    21ba:	13 c0       	rjmp	.+38     	; 0x21e2 <xQueueGenericCreate+0x48>
    21bc:	0b 8f       	std	Y+27, r16	; 0x1b
    21be:	1c 8f       	std	Y+28, r17	; 0x1c
    21c0:	61 e0       	ldi	r22, 0x01	; 1
    21c2:	ce 01       	movw	r24, r28
    21c4:	b1 df       	rcall	.-158    	; 0x2128 <xQueueGenericReset>
    21c6:	0d c0       	rjmp	.+26     	; 0x21e2 <xQueueGenericCreate+0x48>
    21c8:	4f 96       	adiw	r24, 0x1f	; 31
    21ca:	99 83       	std	Y+1, r25	; 0x01
    21cc:	88 83       	st	Y, r24
    21ce:	f6 cf       	rjmp	.-20     	; 0x21bc <xQueueGenericCreate+0x22>
    21d0:	d9 83       	std	Y+1, r29	; 0x01
    21d2:	c8 83       	st	Y, r28
    21d4:	f3 cf       	rjmp	.-26     	; 0x21bc <xQueueGenericCreate+0x22>
    21d6:	8f e1       	ldi	r24, 0x1F	; 31
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	d2 dc       	rcall	.-1628   	; 0x1b80 <pvPortMalloc>
    21dc:	ec 01       	movw	r28, r24
    21de:	89 2b       	or	r24, r25
    21e0:	b9 f7       	brne	.-18     	; 0x21d0 <xQueueGenericCreate+0x36>
    21e2:	ce 01       	movw	r24, r28
    21e4:	df 91       	pop	r29
    21e6:	cf 91       	pop	r28
    21e8:	1f 91       	pop	r17
    21ea:	0f 91       	pop	r16
    21ec:	08 95       	ret

000021ee <xQueueGenericSend>:
    21ee:	9f 92       	push	r9
    21f0:	af 92       	push	r10
    21f2:	bf 92       	push	r11
    21f4:	cf 92       	push	r12
    21f6:	df 92       	push	r13
    21f8:	ef 92       	push	r14
    21fa:	ff 92       	push	r15
    21fc:	0f 93       	push	r16
    21fe:	1f 93       	push	r17
    2200:	cf 93       	push	r28
    2202:	df 93       	push	r29
    2204:	00 d0       	rcall	.+0      	; 0x2206 <xQueueGenericSend+0x18>
    2206:	00 d0       	rcall	.+0      	; 0x2208 <xQueueGenericSend+0x1a>
    2208:	1f 92       	push	r1
    220a:	cd b7       	in	r28, 0x3d	; 61
    220c:	de b7       	in	r29, 0x3e	; 62
    220e:	8c 01       	movw	r16, r24
    2210:	6b 01       	movw	r12, r22
    2212:	5d 83       	std	Y+5, r21	; 0x05
    2214:	4c 83       	std	Y+4, r20	; 0x04
    2216:	a2 2e       	mov	r10, r18
    2218:	b1 2c       	mov	r11, r1
    221a:	99 24       	eor	r9, r9
    221c:	93 94       	inc	r9
    221e:	7c 01       	movw	r14, r24
    2220:	88 e0       	ldi	r24, 0x08	; 8
    2222:	e8 0e       	add	r14, r24
    2224:	f1 1c       	adc	r15, r1
    2226:	0f b6       	in	r0, 0x3f	; 63
    2228:	f8 94       	cli
    222a:	0f 92       	push	r0
    222c:	f8 01       	movw	r30, r16
    222e:	92 8d       	ldd	r25, Z+26	; 0x1a
    2230:	83 8d       	ldd	r24, Z+27	; 0x1b
    2232:	98 17       	cp	r25, r24
    2234:	18 f0       	brcs	.+6      	; 0x223c <xQueueGenericSend+0x4e>
    2236:	f2 e0       	ldi	r31, 0x02	; 2
    2238:	af 12       	cpse	r10, r31
    223a:	15 c0       	rjmp	.+42     	; 0x2266 <xQueueGenericSend+0x78>
    223c:	4a 2d       	mov	r20, r10
    223e:	b6 01       	movw	r22, r12
    2240:	c8 01       	movw	r24, r16
    2242:	b1 de       	rcall	.-670    	; 0x1fa6 <prvCopyDataToQueue>
    2244:	f8 01       	movw	r30, r16
    2246:	91 89       	ldd	r25, Z+17	; 0x11
    2248:	99 23       	and	r25, r25
    224a:	39 f0       	breq	.+14     	; 0x225a <xQueueGenericSend+0x6c>
    224c:	c8 01       	movw	r24, r16
    224e:	41 96       	adiw	r24, 0x11	; 17
    2250:	d8 d4       	rcall	.+2480   	; 0x2c02 <xTaskRemoveFromEventList>
    2252:	88 23       	and	r24, r24
    2254:	21 f0       	breq	.+8      	; 0x225e <xQueueGenericSend+0x70>
    2256:	f3 dd       	rcall	.-1050   	; 0x1e3e <vPortYield>
    2258:	02 c0       	rjmp	.+4      	; 0x225e <xQueueGenericSend+0x70>
    225a:	81 11       	cpse	r24, r1
    225c:	f0 dd       	rcall	.-1056   	; 0x1e3e <vPortYield>
    225e:	0f 90       	pop	r0
    2260:	0f be       	out	0x3f, r0	; 63
    2262:	81 e0       	ldi	r24, 0x01	; 1
    2264:	45 c0       	rjmp	.+138    	; 0x22f0 <xQueueGenericSend+0x102>
    2266:	8c 81       	ldd	r24, Y+4	; 0x04
    2268:	9d 81       	ldd	r25, Y+5	; 0x05
    226a:	89 2b       	or	r24, r25
    226c:	21 f4       	brne	.+8      	; 0x2276 <xQueueGenericSend+0x88>
    226e:	0f 90       	pop	r0
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	80 e0       	ldi	r24, 0x00	; 0
    2274:	3d c0       	rjmp	.+122    	; 0x22f0 <xQueueGenericSend+0x102>
    2276:	b1 10       	cpse	r11, r1
    2278:	04 c0       	rjmp	.+8      	; 0x2282 <xQueueGenericSend+0x94>
    227a:	ce 01       	movw	r24, r28
    227c:	01 96       	adiw	r24, 0x01	; 1
    227e:	07 d5       	rcall	.+2574   	; 0x2c8e <vTaskSetTimeOutState>
    2280:	b9 2c       	mov	r11, r9
    2282:	0f 90       	pop	r0
    2284:	0f be       	out	0x3f, r0	; 63
    2286:	b0 d2       	rcall	.+1376   	; 0x27e8 <vTaskSuspendAll>
    2288:	0f b6       	in	r0, 0x3f	; 63
    228a:	f8 94       	cli
    228c:	0f 92       	push	r0
    228e:	f8 01       	movw	r30, r16
    2290:	85 8d       	ldd	r24, Z+29	; 0x1d
    2292:	8f 3f       	cpi	r24, 0xFF	; 255
    2294:	09 f4       	brne	.+2      	; 0x2298 <xQueueGenericSend+0xaa>
    2296:	15 8e       	std	Z+29, r1	; 0x1d
    2298:	f8 01       	movw	r30, r16
    229a:	86 8d       	ldd	r24, Z+30	; 0x1e
    229c:	8f 3f       	cpi	r24, 0xFF	; 255
    229e:	09 f4       	brne	.+2      	; 0x22a2 <xQueueGenericSend+0xb4>
    22a0:	16 8e       	std	Z+30, r1	; 0x1e
    22a2:	0f 90       	pop	r0
    22a4:	0f be       	out	0x3f, r0	; 63
    22a6:	be 01       	movw	r22, r28
    22a8:	6c 5f       	subi	r22, 0xFC	; 252
    22aa:	7f 4f       	sbci	r23, 0xFF	; 255
    22ac:	ce 01       	movw	r24, r28
    22ae:	01 96       	adiw	r24, 0x01	; 1
    22b0:	f9 d4       	rcall	.+2546   	; 0x2ca4 <xTaskCheckForTimeOut>
    22b2:	81 11       	cpse	r24, r1
    22b4:	19 c0       	rjmp	.+50     	; 0x22e8 <xQueueGenericSend+0xfa>
    22b6:	0f b6       	in	r0, 0x3f	; 63
    22b8:	f8 94       	cli
    22ba:	0f 92       	push	r0
    22bc:	f8 01       	movw	r30, r16
    22be:	92 8d       	ldd	r25, Z+26	; 0x1a
    22c0:	0f 90       	pop	r0
    22c2:	0f be       	out	0x3f, r0	; 63
    22c4:	83 8d       	ldd	r24, Z+27	; 0x1b
    22c6:	98 13       	cpse	r25, r24
    22c8:	0b c0       	rjmp	.+22     	; 0x22e0 <xQueueGenericSend+0xf2>
    22ca:	6c 81       	ldd	r22, Y+4	; 0x04
    22cc:	7d 81       	ldd	r23, Y+5	; 0x05
    22ce:	c7 01       	movw	r24, r14
    22d0:	88 d4       	rcall	.+2320   	; 0x2be2 <vTaskPlaceOnEventList>
    22d2:	c8 01       	movw	r24, r16
    22d4:	e0 de       	rcall	.-576    	; 0x2096 <prvUnlockQueue>
    22d6:	45 d3       	rcall	.+1674   	; 0x2962 <xTaskResumeAll>
    22d8:	81 11       	cpse	r24, r1
    22da:	a5 cf       	rjmp	.-182    	; 0x2226 <xQueueGenericSend+0x38>
    22dc:	b0 dd       	rcall	.-1184   	; 0x1e3e <vPortYield>
    22de:	a3 cf       	rjmp	.-186    	; 0x2226 <xQueueGenericSend+0x38>
    22e0:	c8 01       	movw	r24, r16
    22e2:	d9 de       	rcall	.-590    	; 0x2096 <prvUnlockQueue>
    22e4:	3e d3       	rcall	.+1660   	; 0x2962 <xTaskResumeAll>
    22e6:	9f cf       	rjmp	.-194    	; 0x2226 <xQueueGenericSend+0x38>
    22e8:	c8 01       	movw	r24, r16
    22ea:	d5 de       	rcall	.-598    	; 0x2096 <prvUnlockQueue>
    22ec:	3a d3       	rcall	.+1652   	; 0x2962 <xTaskResumeAll>
    22ee:	80 e0       	ldi	r24, 0x00	; 0
    22f0:	0f 90       	pop	r0
    22f2:	0f 90       	pop	r0
    22f4:	0f 90       	pop	r0
    22f6:	0f 90       	pop	r0
    22f8:	0f 90       	pop	r0
    22fa:	df 91       	pop	r29
    22fc:	cf 91       	pop	r28
    22fe:	1f 91       	pop	r17
    2300:	0f 91       	pop	r16
    2302:	ff 90       	pop	r15
    2304:	ef 90       	pop	r14
    2306:	df 90       	pop	r13
    2308:	cf 90       	pop	r12
    230a:	bf 90       	pop	r11
    230c:	af 90       	pop	r10
    230e:	9f 90       	pop	r9
    2310:	08 95       	ret

00002312 <xQueueCreateMutex>:
    2312:	cf 93       	push	r28
    2314:	df 93       	push	r29
    2316:	48 2f       	mov	r20, r24
    2318:	60 e0       	ldi	r22, 0x00	; 0
    231a:	81 e0       	ldi	r24, 0x01	; 1
    231c:	3e df       	rcall	.-388    	; 0x219a <xQueueGenericCreate>
    231e:	ec 01       	movw	r28, r24
    2320:	00 97       	sbiw	r24, 0x00	; 0
    2322:	59 f0       	breq	.+22     	; 0x233a <xQueueCreateMutex+0x28>
    2324:	1b 82       	std	Y+3, r1	; 0x03
    2326:	1a 82       	std	Y+2, r1	; 0x02
    2328:	19 82       	std	Y+1, r1	; 0x01
    232a:	18 82       	st	Y, r1
    232c:	1e 82       	std	Y+6, r1	; 0x06
    232e:	20 e0       	ldi	r18, 0x00	; 0
    2330:	40 e0       	ldi	r20, 0x00	; 0
    2332:	50 e0       	ldi	r21, 0x00	; 0
    2334:	60 e0       	ldi	r22, 0x00	; 0
    2336:	70 e0       	ldi	r23, 0x00	; 0
    2338:	5a df       	rcall	.-332    	; 0x21ee <xQueueGenericSend>
    233a:	ce 01       	movw	r24, r28
    233c:	df 91       	pop	r29
    233e:	cf 91       	pop	r28
    2340:	08 95       	ret

00002342 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2342:	8f 92       	push	r8
    2344:	9f 92       	push	r9
    2346:	af 92       	push	r10
    2348:	bf 92       	push	r11
    234a:	cf 92       	push	r12
    234c:	df 92       	push	r13
    234e:	ef 92       	push	r14
    2350:	ff 92       	push	r15
    2352:	0f 93       	push	r16
    2354:	1f 93       	push	r17
    2356:	cf 93       	push	r28
    2358:	df 93       	push	r29
    235a:	00 d0       	rcall	.+0      	; 0x235c <xQueueGenericReceive+0x1a>
    235c:	00 d0       	rcall	.+0      	; 0x235e <xQueueGenericReceive+0x1c>
    235e:	1f 92       	push	r1
    2360:	cd b7       	in	r28, 0x3d	; 61
    2362:	de b7       	in	r29, 0x3e	; 62
    2364:	8c 01       	movw	r16, r24
    2366:	5b 01       	movw	r10, r22
    2368:	5d 83       	std	Y+5, r21	; 0x05
    236a:	4c 83       	std	Y+4, r20	; 0x04
    236c:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    236e:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2370:	99 24       	eor	r9, r9
    2372:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2374:	6c 01       	movw	r12, r24
    2376:	81 e1       	ldi	r24, 0x11	; 17
    2378:	c8 0e       	add	r12, r24
    237a:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    237c:	0f b6       	in	r0, 0x3f	; 63
    237e:	f8 94       	cli
    2380:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2382:	f8 01       	movw	r30, r16
    2384:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2386:	ff 20       	and	r15, r15
    2388:	61 f1       	breq	.+88     	; 0x23e2 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    238a:	c6 80       	ldd	r12, Z+6	; 0x06
    238c:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    238e:	b5 01       	movw	r22, r10
    2390:	c8 01       	movw	r24, r16
    2392:	67 de       	rcall	.-818    	; 0x2062 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2394:	81 10       	cpse	r8, r1
    2396:	16 c0       	rjmp	.+44     	; 0x23c4 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2398:	fa 94       	dec	r15
    239a:	f8 01       	movw	r30, r16
    239c:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    239e:	80 81       	ld	r24, Z
    23a0:	91 81       	ldd	r25, Z+1	; 0x01
    23a2:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    23a4:	21 f4       	brne	.+8      	; 0x23ae <xQueueGenericReceive+0x6c>
    23a6:	5c d5       	rcall	.+2744   	; 0x2e60 <pvTaskIncrementMutexHeldCount>
    23a8:	f8 01       	movw	r30, r16
    23aa:	93 83       	std	Z+3, r25	; 0x03
    23ac:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23ae:	f8 01       	movw	r30, r16
    23b0:	80 85       	ldd	r24, Z+8	; 0x08
    23b2:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23b4:	91 f0       	breq	.+36     	; 0x23da <xQueueGenericReceive+0x98>
    23b6:	c8 01       	movw	r24, r16
    23b8:	08 96       	adiw	r24, 0x08	; 8
    23ba:	23 d4       	rcall	.+2118   	; 0x2c02 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    23bc:	88 23       	and	r24, r24
    23be:	69 f0       	breq	.+26     	; 0x23da <xQueueGenericReceive+0x98>
    23c0:	3e dd       	rcall	.-1412   	; 0x1e3e <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    23c2:	0b c0       	rjmp	.+22     	; 0x23da <xQueueGenericReceive+0x98>
    23c4:	f8 01       	movw	r30, r16
    23c6:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23c8:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23ca:	81 89       	ldd	r24, Z+17	; 0x11
    23cc:	88 23       	and	r24, r24
    23ce:	29 f0       	breq	.+10     	; 0x23da <xQueueGenericReceive+0x98>
    23d0:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    23d2:	41 96       	adiw	r24, 0x11	; 17
    23d4:	16 d4       	rcall	.+2092   	; 0x2c02 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    23d6:	81 11       	cpse	r24, r1
    23d8:	32 dd       	rcall	.-1436   	; 0x1e3e <vPortYield>
				return pdPASS;
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23de:	81 e0       	ldi	r24, 0x01	; 1
    23e0:	58 c0       	rjmp	.+176    	; 0x2492 <xQueueGenericReceive+0x150>
    23e2:	8c 81       	ldd	r24, Y+4	; 0x04
    23e4:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23e6:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23e8:	21 f4       	brne	.+8      	; 0x23f2 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    23ea:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23ec:	0f be       	out	0x3f, r0	; 63
    23ee:	80 e0       	ldi	r24, 0x00	; 0
    23f0:	50 c0       	rjmp	.+160    	; 0x2492 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    23f2:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    23f4:	04 c0       	rjmp	.+8      	; 0x23fe <xQueueGenericReceive+0xbc>
    23f6:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23f8:	01 96       	adiw	r24, 0x01	; 1
    23fa:	49 d4       	rcall	.+2194   	; 0x2c8e <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    23fc:	e9 2c       	mov	r14, r9
    23fe:	0f 90       	pop	r0
    2400:	0f be       	out	0x3f, r0	; 63
    2402:	f2 d1       	rcall	.+996    	; 0x27e8 <vTaskSuspendAll>
    2404:	0f b6       	in	r0, 0x3f	; 63
    2406:	f8 94       	cli
    2408:	0f 92       	push	r0
    240a:	f8 01       	movw	r30, r16
    240c:	85 8d       	ldd	r24, Z+29	; 0x1d
    240e:	8f 3f       	cpi	r24, 0xFF	; 255
    2410:	09 f4       	brne	.+2      	; 0x2414 <xQueueGenericReceive+0xd2>
    2412:	15 8e       	std	Z+29, r1	; 0x1d
    2414:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2416:	86 8d       	ldd	r24, Z+30	; 0x1e
    2418:	8f 3f       	cpi	r24, 0xFF	; 255
    241a:	09 f4       	brne	.+2      	; 0x241e <xQueueGenericReceive+0xdc>
    241c:	16 8e       	std	Z+30, r1	; 0x1e
    241e:	0f 90       	pop	r0
    2420:	0f be       	out	0x3f, r0	; 63
    2422:	be 01       	movw	r22, r28
    2424:	6c 5f       	subi	r22, 0xFC	; 252
    2426:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2428:	ce 01       	movw	r24, r28
    242a:	01 96       	adiw	r24, 0x01	; 1
    242c:	3b d4       	rcall	.+2166   	; 0x2ca4 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    242e:	81 11       	cpse	r24, r1
    2430:	24 c0       	rjmp	.+72     	; 0x247a <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2432:	0f b6       	in	r0, 0x3f	; 63
    2434:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2436:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2438:	f8 01       	movw	r30, r16
    243a:	82 8d       	ldd	r24, Z+26	; 0x1a
    243c:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    243e:	0f be       	out	0x3f, r0	; 63
    2440:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2442:	17 c0       	rjmp	.+46     	; 0x2472 <xQueueGenericReceive+0x130>
    2444:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    2446:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2448:	89 2b       	or	r24, r25
    244a:	41 f4       	brne	.+16     	; 0x245c <xQueueGenericReceive+0x11a>
    244c:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    244e:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    2450:	0f 92       	push	r0
    2452:	82 81       	ldd	r24, Z+2	; 0x02
    2454:	93 81       	ldd	r25, Z+3	; 0x03
    2456:	62 d4       	rcall	.+2244   	; 0x2d1c <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    2458:	0f 90       	pop	r0
    245a:	0f be       	out	0x3f, r0	; 63
    245c:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    245e:	7d 81       	ldd	r23, Y+5	; 0x05
    2460:	c6 01       	movw	r24, r12
    2462:	bf d3       	rcall	.+1918   	; 0x2be2 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    2464:	c8 01       	movw	r24, r16
    2466:	17 de       	rcall	.-978    	; 0x2096 <prvUnlockQueue>
    2468:	7c d2       	rcall	.+1272   	; 0x2962 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    246a:	81 11       	cpse	r24, r1
    246c:	87 cf       	rjmp	.-242    	; 0x237c <xQueueGenericReceive+0x3a>
    246e:	e7 dc       	rcall	.-1586   	; 0x1e3e <vPortYield>
			( void ) xTaskResumeAll();
    2470:	85 cf       	rjmp	.-246    	; 0x237c <xQueueGenericReceive+0x3a>
    2472:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2474:	10 de       	rcall	.-992    	; 0x2096 <prvUnlockQueue>
    2476:	75 d2       	rcall	.+1258   	; 0x2962 <xTaskResumeAll>
    2478:	81 cf       	rjmp	.-254    	; 0x237c <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    247a:	c8 01       	movw	r24, r16
    247c:	0c de       	rcall	.-1000   	; 0x2096 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    247e:	71 d2       	rcall	.+1250   	; 0x2962 <xTaskResumeAll>
    2480:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2482:	f8 94       	cli
    2484:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    2486:	f8 01       	movw	r30, r16
    2488:	82 8d       	ldd	r24, Z+26	; 0x1a
    248a:	0f 90       	pop	r0
    248c:	0f be       	out	0x3f, r0	; 63
    248e:	81 11       	cpse	r24, r1
    2490:	75 cf       	rjmp	.-278    	; 0x237c <xQueueGenericReceive+0x3a>
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	0f 90       	pop	r0
    2498:	0f 90       	pop	r0
    249a:	0f 90       	pop	r0
    249c:	df 91       	pop	r29
    249e:	cf 91       	pop	r28
    24a0:	1f 91       	pop	r17
    24a2:	0f 91       	pop	r16
    24a4:	ff 90       	pop	r15
    24a6:	ef 90       	pop	r14
    24a8:	df 90       	pop	r13
    24aa:	cf 90       	pop	r12
    24ac:	bf 90       	pop	r11
    24ae:	af 90       	pop	r10
    24b0:	9f 90       	pop	r9
    24b2:	8f 90       	pop	r8
    24b4:	08 95       	ret

000024b6 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    24b6:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    24ba:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    24be:	80 81       	ld	r24, Z
    24c0:	81 11       	cpse	r24, r1
    24c2:	07 c0       	rjmp	.+14     	; 0x24d2 <prvResetNextTaskUnblockTime+0x1c>
    24c4:	8f ef       	ldi	r24, 0xFF	; 255
    24c6:	9f ef       	ldi	r25, 0xFF	; 255
    24c8:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <xNextTaskUnblockTime+0x1>
    24cc:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xNextTaskUnblockTime>
    24d0:	08 95       	ret
    24d2:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    24d6:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    24da:	05 80       	ldd	r0, Z+5	; 0x05
    24dc:	f6 81       	ldd	r31, Z+6	; 0x06
    24de:	e0 2d       	mov	r30, r0
    24e0:	06 80       	ldd	r0, Z+6	; 0x06
    24e2:	f7 81       	ldd	r31, Z+7	; 0x07
    24e4:	e0 2d       	mov	r30, r0
    24e6:	82 81       	ldd	r24, Z+2	; 0x02
    24e8:	93 81       	ldd	r25, Z+3	; 0x03
    24ea:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <xNextTaskUnblockTime+0x1>
    24ee:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xNextTaskUnblockTime>
    24f2:	08 95       	ret

000024f4 <prvAddCurrentTaskToDelayedList>:
    24f4:	ff 92       	push	r15
    24f6:	0f 93       	push	r16
    24f8:	1f 93       	push	r17
    24fa:	cf 93       	push	r28
    24fc:	df 93       	push	r29
    24fe:	ec 01       	movw	r28, r24
    2500:	f6 2e       	mov	r15, r22
    2502:	00 91 85 0d 	lds	r16, 0x0D85	; 0x800d85 <xTickCount>
    2506:	10 91 86 0d 	lds	r17, 0x0D86	; 0x800d86 <xTickCount+0x1>
    250a:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    250e:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2512:	02 96       	adiw	r24, 0x02	; 2
    2514:	cd db       	rcall	.-2150   	; 0x1cb0 <uxListRemove>
    2516:	cf 3f       	cpi	r28, 0xFF	; 255
    2518:	8f ef       	ldi	r24, 0xFF	; 255
    251a:	d8 07       	cpc	r29, r24
    251c:	61 f4       	brne	.+24     	; 0x2536 <prvAddCurrentTaskToDelayedList+0x42>
    251e:	ff 20       	and	r15, r15
    2520:	51 f0       	breq	.+20     	; 0x2536 <prvAddCurrentTaskToDelayedList+0x42>
    2522:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2526:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    252a:	6e 5f       	subi	r22, 0xFE	; 254
    252c:	7f 4f       	sbci	r23, 0xFF	; 255
    252e:	88 e8       	ldi	r24, 0x88	; 136
    2530:	9d e0       	ldi	r25, 0x0D	; 13
    2532:	6c db       	rcall	.-2344   	; 0x1c0c <vListInsertEnd>
    2534:	2d c0       	rjmp	.+90     	; 0x2590 <prvAddCurrentTaskToDelayedList+0x9c>
    2536:	c0 0f       	add	r28, r16
    2538:	d1 1f       	adc	r29, r17
    253a:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    253e:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2542:	d3 83       	std	Z+3, r29	; 0x03
    2544:	c2 83       	std	Z+2, r28	; 0x02
    2546:	c0 17       	cp	r28, r16
    2548:	d1 07       	cpc	r29, r17
    254a:	60 f4       	brcc	.+24     	; 0x2564 <prvAddCurrentTaskToDelayedList+0x70>
    254c:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2550:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2554:	80 91 a4 0d 	lds	r24, 0x0DA4	; 0x800da4 <pxOverflowDelayedTaskList>
    2558:	90 91 a5 0d 	lds	r25, 0x0DA5	; 0x800da5 <pxOverflowDelayedTaskList+0x1>
    255c:	6e 5f       	subi	r22, 0xFE	; 254
    255e:	7f 4f       	sbci	r23, 0xFF	; 255
    2560:	76 db       	rcall	.-2324   	; 0x1c4e <vListInsert>
    2562:	16 c0       	rjmp	.+44     	; 0x2590 <prvAddCurrentTaskToDelayedList+0x9c>
    2564:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2568:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    256c:	80 91 a6 0d 	lds	r24, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    2570:	90 91 a7 0d 	lds	r25, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    2574:	6e 5f       	subi	r22, 0xFE	; 254
    2576:	7f 4f       	sbci	r23, 0xFF	; 255
    2578:	6a db       	rcall	.-2348   	; 0x1c4e <vListInsert>
    257a:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <xNextTaskUnblockTime>
    257e:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <xNextTaskUnblockTime+0x1>
    2582:	c8 17       	cp	r28, r24
    2584:	d9 07       	cpc	r29, r25
    2586:	20 f4       	brcc	.+8      	; 0x2590 <prvAddCurrentTaskToDelayedList+0x9c>
    2588:	d0 93 7e 0d 	sts	0x0D7E, r29	; 0x800d7e <xNextTaskUnblockTime+0x1>
    258c:	c0 93 7d 0d 	sts	0x0D7D, r28	; 0x800d7d <xNextTaskUnblockTime>
    2590:	df 91       	pop	r29
    2592:	cf 91       	pop	r28
    2594:	1f 91       	pop	r17
    2596:	0f 91       	pop	r16
    2598:	ff 90       	pop	r15
    259a:	08 95       	ret

0000259c <xTaskCreate>:
    259c:	4f 92       	push	r4
    259e:	5f 92       	push	r5
    25a0:	6f 92       	push	r6
    25a2:	7f 92       	push	r7
    25a4:	8f 92       	push	r8
    25a6:	9f 92       	push	r9
    25a8:	af 92       	push	r10
    25aa:	bf 92       	push	r11
    25ac:	cf 92       	push	r12
    25ae:	df 92       	push	r13
    25b0:	ef 92       	push	r14
    25b2:	ff 92       	push	r15
    25b4:	0f 93       	push	r16
    25b6:	cf 93       	push	r28
    25b8:	df 93       	push	r29
    25ba:	4c 01       	movw	r8, r24
    25bc:	6b 01       	movw	r12, r22
    25be:	5a 01       	movw	r10, r20
    25c0:	29 01       	movw	r4, r18
    25c2:	ca 01       	movw	r24, r20
    25c4:	dd da       	rcall	.-2630   	; 0x1b80 <pvPortMalloc>
    25c6:	3c 01       	movw	r6, r24
    25c8:	89 2b       	or	r24, r25
    25ca:	09 f4       	brne	.+2      	; 0x25ce <xTaskCreate+0x32>
    25cc:	d4 c0       	rjmp	.+424    	; 0x2776 <xTaskCreate+0x1da>
    25ce:	88 e2       	ldi	r24, 0x28	; 40
    25d0:	90 e0       	ldi	r25, 0x00	; 0
    25d2:	d6 da       	rcall	.-2644   	; 0x1b80 <pvPortMalloc>
    25d4:	ec 01       	movw	r28, r24
    25d6:	89 2b       	or	r24, r25
    25d8:	71 f0       	breq	.+28     	; 0x25f6 <xTaskCreate+0x5a>
    25da:	78 8e       	std	Y+24, r7	; 0x18
    25dc:	6f 8a       	std	Y+23, r6	; 0x17
    25de:	81 e0       	ldi	r24, 0x01	; 1
    25e0:	a8 1a       	sub	r10, r24
    25e2:	b1 08       	sbc	r11, r1
    25e4:	6a 0c       	add	r6, r10
    25e6:	7b 1c       	adc	r7, r11
    25e8:	d6 01       	movw	r26, r12
    25ea:	8c 91       	ld	r24, X
    25ec:	89 8f       	std	Y+25, r24	; 0x19
    25ee:	8c 91       	ld	r24, X
    25f0:	81 11       	cpse	r24, r1
    25f2:	04 c0       	rjmp	.+8      	; 0x25fc <xTaskCreate+0x60>
    25f4:	17 c0       	rjmp	.+46     	; 0x2624 <xTaskCreate+0x88>
    25f6:	c3 01       	movw	r24, r6
    25f8:	f6 da       	rcall	.-2580   	; 0x1be6 <vPortFree>
    25fa:	bd c0       	rjmp	.+378    	; 0x2776 <xTaskCreate+0x1da>
    25fc:	ae 01       	movw	r20, r28
    25fe:	46 5e       	subi	r20, 0xE6	; 230
    2600:	5f 4f       	sbci	r21, 0xFF	; 255
    2602:	f6 01       	movw	r30, r12
    2604:	31 96       	adiw	r30, 0x01	; 1
    2606:	b8 e0       	ldi	r27, 0x08	; 8
    2608:	cb 0e       	add	r12, r27
    260a:	d1 1c       	adc	r13, r1
    260c:	cf 01       	movw	r24, r30
    260e:	21 91       	ld	r18, Z+
    2610:	da 01       	movw	r26, r20
    2612:	2d 93       	st	X+, r18
    2614:	ad 01       	movw	r20, r26
    2616:	dc 01       	movw	r26, r24
    2618:	8c 91       	ld	r24, X
    261a:	88 23       	and	r24, r24
    261c:	19 f0       	breq	.+6      	; 0x2624 <xTaskCreate+0x88>
    261e:	ec 15       	cp	r30, r12
    2620:	fd 05       	cpc	r31, r13
    2622:	a1 f7       	brne	.-24     	; 0x260c <xTaskCreate+0x70>
    2624:	18 a2       	std	Y+32, r1	; 0x20
    2626:	04 30       	cpi	r16, 0x04	; 4
    2628:	08 f0       	brcs	.+2      	; 0x262c <xTaskCreate+0x90>
    262a:	03 e0       	ldi	r16, 0x03	; 3
    262c:	0e 8b       	std	Y+22, r16	; 0x16
    262e:	09 a3       	std	Y+33, r16	; 0x21
    2630:	1a a2       	std	Y+34, r1	; 0x22
    2632:	6e 01       	movw	r12, r28
    2634:	b2 e0       	ldi	r27, 0x02	; 2
    2636:	cb 0e       	add	r12, r27
    2638:	d1 1c       	adc	r13, r1
    263a:	c6 01       	movw	r24, r12
    263c:	e3 da       	rcall	.-2618   	; 0x1c04 <vListInitialiseItem>
    263e:	ce 01       	movw	r24, r28
    2640:	0c 96       	adiw	r24, 0x0c	; 12
    2642:	e0 da       	rcall	.-2624   	; 0x1c04 <vListInitialiseItem>
    2644:	d9 87       	std	Y+9, r29	; 0x09
    2646:	c8 87       	std	Y+8, r28	; 0x08
    2648:	84 e0       	ldi	r24, 0x04	; 4
    264a:	90 e0       	ldi	r25, 0x00	; 0
    264c:	80 1b       	sub	r24, r16
    264e:	91 09       	sbc	r25, r1
    2650:	9d 87       	std	Y+13, r25	; 0x0d
    2652:	8c 87       	std	Y+12, r24	; 0x0c
    2654:	db 8b       	std	Y+19, r29	; 0x13
    2656:	ca 8b       	std	Y+18, r28	; 0x12
    2658:	1b a2       	std	Y+35, r1	; 0x23
    265a:	1c a2       	std	Y+36, r1	; 0x24
    265c:	1d a2       	std	Y+37, r1	; 0x25
    265e:	1e a2       	std	Y+38, r1	; 0x26
    2660:	1f a2       	std	Y+39, r1	; 0x27
    2662:	a2 01       	movw	r20, r4
    2664:	b4 01       	movw	r22, r8
    2666:	c3 01       	movw	r24, r6
    2668:	49 db       	rcall	.-2414   	; 0x1cfc <pxPortInitialiseStack>
    266a:	99 83       	std	Y+1, r25	; 0x01
    266c:	88 83       	st	Y, r24
    266e:	e1 14       	cp	r14, r1
    2670:	f1 04       	cpc	r15, r1
    2672:	19 f0       	breq	.+6      	; 0x267a <xTaskCreate+0xde>
    2674:	f7 01       	movw	r30, r14
    2676:	d1 83       	std	Z+1, r29	; 0x01
    2678:	c0 83       	st	Z, r28
    267a:	0f b6       	in	r0, 0x3f	; 63
    267c:	f8 94       	cli
    267e:	0f 92       	push	r0
    2680:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <uxCurrentNumberOfTasks>
    2684:	8f 5f       	subi	r24, 0xFF	; 255
    2686:	80 93 87 0d 	sts	0x0D87, r24	; 0x800d87 <uxCurrentNumberOfTasks>
    268a:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    268e:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2692:	89 2b       	or	r24, r25
    2694:	89 f5       	brne	.+98     	; 0x26f8 <xTaskCreate+0x15c>
    2696:	d0 93 df 0d 	sts	0x0DDF, r29	; 0x800ddf <pxCurrentTCB+0x1>
    269a:	c0 93 de 0d 	sts	0x0DDE, r28	; 0x800dde <pxCurrentTCB>
    269e:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <uxCurrentNumberOfTasks>
    26a2:	81 30       	cpi	r24, 0x01	; 1
    26a4:	09 f0       	breq	.+2      	; 0x26a8 <xTaskCreate+0x10c>
    26a6:	38 c0       	rjmp	.+112    	; 0x2718 <xTaskCreate+0x17c>
    26a8:	8a eb       	ldi	r24, 0xBA	; 186
    26aa:	9d e0       	ldi	r25, 0x0D	; 13
    26ac:	9d da       	rcall	.-2758   	; 0x1be8 <vListInitialise>
    26ae:	83 ec       	ldi	r24, 0xC3	; 195
    26b0:	9d e0       	ldi	r25, 0x0D	; 13
    26b2:	9a da       	rcall	.-2764   	; 0x1be8 <vListInitialise>
    26b4:	8c ec       	ldi	r24, 0xCC	; 204
    26b6:	9d e0       	ldi	r25, 0x0D	; 13
    26b8:	97 da       	rcall	.-2770   	; 0x1be8 <vListInitialise>
    26ba:	85 ed       	ldi	r24, 0xD5	; 213
    26bc:	9d e0       	ldi	r25, 0x0D	; 13
    26be:	94 da       	rcall	.-2776   	; 0x1be8 <vListInitialise>
    26c0:	81 eb       	ldi	r24, 0xB1	; 177
    26c2:	9d e0       	ldi	r25, 0x0D	; 13
    26c4:	91 da       	rcall	.-2782   	; 0x1be8 <vListInitialise>
    26c6:	88 ea       	ldi	r24, 0xA8	; 168
    26c8:	9d e0       	ldi	r25, 0x0D	; 13
    26ca:	8e da       	rcall	.-2788   	; 0x1be8 <vListInitialise>
    26cc:	8b e9       	ldi	r24, 0x9B	; 155
    26ce:	9d e0       	ldi	r25, 0x0D	; 13
    26d0:	8b da       	rcall	.-2794   	; 0x1be8 <vListInitialise>
    26d2:	82 e9       	ldi	r24, 0x92	; 146
    26d4:	9d e0       	ldi	r25, 0x0D	; 13
    26d6:	88 da       	rcall	.-2800   	; 0x1be8 <vListInitialise>
    26d8:	88 e8       	ldi	r24, 0x88	; 136
    26da:	9d e0       	ldi	r25, 0x0D	; 13
    26dc:	85 da       	rcall	.-2806   	; 0x1be8 <vListInitialise>
    26de:	81 eb       	ldi	r24, 0xB1	; 177
    26e0:	9d e0       	ldi	r25, 0x0D	; 13
    26e2:	90 93 a7 0d 	sts	0x0DA7, r25	; 0x800da7 <pxDelayedTaskList+0x1>
    26e6:	80 93 a6 0d 	sts	0x0DA6, r24	; 0x800da6 <pxDelayedTaskList>
    26ea:	88 ea       	ldi	r24, 0xA8	; 168
    26ec:	9d e0       	ldi	r25, 0x0D	; 13
    26ee:	90 93 a5 0d 	sts	0x0DA5, r25	; 0x800da5 <pxOverflowDelayedTaskList+0x1>
    26f2:	80 93 a4 0d 	sts	0x0DA4, r24	; 0x800da4 <pxOverflowDelayedTaskList>
    26f6:	10 c0       	rjmp	.+32     	; 0x2718 <xTaskCreate+0x17c>
    26f8:	80 91 83 0d 	lds	r24, 0x0D83	; 0x800d83 <xSchedulerRunning>
    26fc:	81 11       	cpse	r24, r1
    26fe:	0c c0       	rjmp	.+24     	; 0x2718 <xTaskCreate+0x17c>
    2700:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2704:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2708:	96 89       	ldd	r25, Z+22	; 0x16
    270a:	8e 89       	ldd	r24, Y+22	; 0x16
    270c:	89 17       	cp	r24, r25
    270e:	20 f0       	brcs	.+8      	; 0x2718 <xTaskCreate+0x17c>
    2710:	d0 93 df 0d 	sts	0x0DDF, r29	; 0x800ddf <pxCurrentTCB+0x1>
    2714:	c0 93 de 0d 	sts	0x0DDE, r28	; 0x800dde <pxCurrentTCB>
    2718:	80 91 7f 0d 	lds	r24, 0x0D7F	; 0x800d7f <uxTaskNumber>
    271c:	8f 5f       	subi	r24, 0xFF	; 255
    271e:	80 93 7f 0d 	sts	0x0D7F, r24	; 0x800d7f <uxTaskNumber>
    2722:	8e 89       	ldd	r24, Y+22	; 0x16
    2724:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    2728:	98 17       	cp	r25, r24
    272a:	10 f4       	brcc	.+4      	; 0x2730 <xTaskCreate+0x194>
    272c:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    2730:	90 e0       	ldi	r25, 0x00	; 0
    2732:	9c 01       	movw	r18, r24
    2734:	22 0f       	add	r18, r18
    2736:	33 1f       	adc	r19, r19
    2738:	22 0f       	add	r18, r18
    273a:	33 1f       	adc	r19, r19
    273c:	22 0f       	add	r18, r18
    273e:	33 1f       	adc	r19, r19
    2740:	82 0f       	add	r24, r18
    2742:	93 1f       	adc	r25, r19
    2744:	b6 01       	movw	r22, r12
    2746:	86 54       	subi	r24, 0x46	; 70
    2748:	92 4f       	sbci	r25, 0xF2	; 242
    274a:	60 da       	rcall	.-2880   	; 0x1c0c <vListInsertEnd>
    274c:	0f 90       	pop	r0
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	80 91 83 0d 	lds	r24, 0x0D83	; 0x800d83 <xSchedulerRunning>
    2754:	88 23       	and	r24, r24
    2756:	59 f0       	breq	.+22     	; 0x276e <xTaskCreate+0x1d2>
    2758:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    275c:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2760:	96 89       	ldd	r25, Z+22	; 0x16
    2762:	8e 89       	ldd	r24, Y+22	; 0x16
    2764:	98 17       	cp	r25, r24
    2766:	28 f4       	brcc	.+10     	; 0x2772 <xTaskCreate+0x1d6>
    2768:	6a db       	rcall	.-2348   	; 0x1e3e <vPortYield>
    276a:	81 e0       	ldi	r24, 0x01	; 1
    276c:	05 c0       	rjmp	.+10     	; 0x2778 <xTaskCreate+0x1dc>
    276e:	81 e0       	ldi	r24, 0x01	; 1
    2770:	03 c0       	rjmp	.+6      	; 0x2778 <xTaskCreate+0x1dc>
    2772:	81 e0       	ldi	r24, 0x01	; 1
    2774:	01 c0       	rjmp	.+2      	; 0x2778 <xTaskCreate+0x1dc>
    2776:	8f ef       	ldi	r24, 0xFF	; 255
    2778:	df 91       	pop	r29
    277a:	cf 91       	pop	r28
    277c:	0f 91       	pop	r16
    277e:	ff 90       	pop	r15
    2780:	ef 90       	pop	r14
    2782:	df 90       	pop	r13
    2784:	cf 90       	pop	r12
    2786:	bf 90       	pop	r11
    2788:	af 90       	pop	r10
    278a:	9f 90       	pop	r9
    278c:	8f 90       	pop	r8
    278e:	7f 90       	pop	r7
    2790:	6f 90       	pop	r6
    2792:	5f 90       	pop	r5
    2794:	4f 90       	pop	r4
    2796:	08 95       	ret

00002798 <vTaskStartScheduler>:
    2798:	ef 92       	push	r14
    279a:	ff 92       	push	r15
    279c:	0f 93       	push	r16
    279e:	0f 2e       	mov	r0, r31
    27a0:	fb e7       	ldi	r31, 0x7B	; 123
    27a2:	ef 2e       	mov	r14, r31
    27a4:	fd e0       	ldi	r31, 0x0D	; 13
    27a6:	ff 2e       	mov	r15, r31
    27a8:	f0 2d       	mov	r31, r0
    27aa:	00 e0       	ldi	r16, 0x00	; 0
    27ac:	20 e0       	ldi	r18, 0x00	; 0
    27ae:	30 e0       	ldi	r19, 0x00	; 0
    27b0:	45 e5       	ldi	r20, 0x55	; 85
    27b2:	50 e0       	ldi	r21, 0x00	; 0
    27b4:	66 ea       	ldi	r22, 0xA6	; 166
    27b6:	71 e0       	ldi	r23, 0x01	; 1
    27b8:	8a e3       	ldi	r24, 0x3A	; 58
    27ba:	95 e1       	ldi	r25, 0x15	; 21
    27bc:	ef de       	rcall	.-546    	; 0x259c <xTaskCreate>
    27be:	81 30       	cpi	r24, 0x01	; 1
    27c0:	79 f4       	brne	.+30     	; 0x27e0 <vTaskStartScheduler+0x48>
    27c2:	f8 94       	cli
    27c4:	8f ef       	ldi	r24, 0xFF	; 255
    27c6:	9f ef       	ldi	r25, 0xFF	; 255
    27c8:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <xNextTaskUnblockTime+0x1>
    27cc:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xNextTaskUnblockTime>
    27d0:	81 e0       	ldi	r24, 0x01	; 1
    27d2:	80 93 83 0d 	sts	0x0D83, r24	; 0x800d83 <xSchedulerRunning>
    27d6:	10 92 86 0d 	sts	0x0D86, r1	; 0x800d86 <xTickCount+0x1>
    27da:	10 92 85 0d 	sts	0x0D85, r1	; 0x800d85 <xTickCount>
    27de:	fa da       	rcall	.-2572   	; 0x1dd4 <xPortStartScheduler>
    27e0:	0f 91       	pop	r16
    27e2:	ff 90       	pop	r15
    27e4:	ef 90       	pop	r14
    27e6:	08 95       	ret

000027e8 <vTaskSuspendAll>:
    27e8:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    27ec:	8f 5f       	subi	r24, 0xFF	; 255
    27ee:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <uxSchedulerSuspended>
    27f2:	08 95       	ret

000027f4 <xTaskIncrementTick>:
    27f4:	cf 92       	push	r12
    27f6:	df 92       	push	r13
    27f8:	ef 92       	push	r14
    27fa:	ff 92       	push	r15
    27fc:	0f 93       	push	r16
    27fe:	1f 93       	push	r17
    2800:	cf 93       	push	r28
    2802:	df 93       	push	r29
    2804:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    2808:	81 11       	cpse	r24, r1
    280a:	95 c0       	rjmp	.+298    	; 0x2936 <xTaskIncrementTick+0x142>
    280c:	e0 90 85 0d 	lds	r14, 0x0D85	; 0x800d85 <xTickCount>
    2810:	f0 90 86 0d 	lds	r15, 0x0D86	; 0x800d86 <xTickCount+0x1>
    2814:	8f ef       	ldi	r24, 0xFF	; 255
    2816:	e8 1a       	sub	r14, r24
    2818:	f8 0a       	sbc	r15, r24
    281a:	f0 92 86 0d 	sts	0x0D86, r15	; 0x800d86 <xTickCount+0x1>
    281e:	e0 92 85 0d 	sts	0x0D85, r14	; 0x800d85 <xTickCount>
    2822:	e1 14       	cp	r14, r1
    2824:	f1 04       	cpc	r15, r1
    2826:	b1 f4       	brne	.+44     	; 0x2854 <xTaskIncrementTick+0x60>
    2828:	80 91 a6 0d 	lds	r24, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    282c:	90 91 a7 0d 	lds	r25, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    2830:	20 91 a4 0d 	lds	r18, 0x0DA4	; 0x800da4 <pxOverflowDelayedTaskList>
    2834:	30 91 a5 0d 	lds	r19, 0x0DA5	; 0x800da5 <pxOverflowDelayedTaskList+0x1>
    2838:	30 93 a7 0d 	sts	0x0DA7, r19	; 0x800da7 <pxDelayedTaskList+0x1>
    283c:	20 93 a6 0d 	sts	0x0DA6, r18	; 0x800da6 <pxDelayedTaskList>
    2840:	90 93 a5 0d 	sts	0x0DA5, r25	; 0x800da5 <pxOverflowDelayedTaskList+0x1>
    2844:	80 93 a4 0d 	sts	0x0DA4, r24	; 0x800da4 <pxOverflowDelayedTaskList>
    2848:	80 91 80 0d 	lds	r24, 0x0D80	; 0x800d80 <xNumOfOverflows>
    284c:	8f 5f       	subi	r24, 0xFF	; 255
    284e:	80 93 80 0d 	sts	0x0D80, r24	; 0x800d80 <xNumOfOverflows>
    2852:	31 de       	rcall	.-926    	; 0x24b6 <prvResetNextTaskUnblockTime>
    2854:	80 91 7d 0d 	lds	r24, 0x0D7D	; 0x800d7d <xNextTaskUnblockTime>
    2858:	90 91 7e 0d 	lds	r25, 0x0D7E	; 0x800d7e <xNextTaskUnblockTime+0x1>
    285c:	e8 16       	cp	r14, r24
    285e:	f9 06       	cpc	r15, r25
    2860:	10 f4       	brcc	.+4      	; 0x2866 <xTaskIncrementTick+0x72>
    2862:	d1 2c       	mov	r13, r1
    2864:	50 c0       	rjmp	.+160    	; 0x2906 <xTaskIncrementTick+0x112>
    2866:	d1 2c       	mov	r13, r1
    2868:	cc 24       	eor	r12, r12
    286a:	c3 94       	inc	r12
    286c:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    2870:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    2874:	80 81       	ld	r24, Z
    2876:	81 11       	cpse	r24, r1
    2878:	07 c0       	rjmp	.+14     	; 0x2888 <xTaskIncrementTick+0x94>
    287a:	8f ef       	ldi	r24, 0xFF	; 255
    287c:	9f ef       	ldi	r25, 0xFF	; 255
    287e:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <xNextTaskUnblockTime+0x1>
    2882:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xNextTaskUnblockTime>
    2886:	3f c0       	rjmp	.+126    	; 0x2906 <xTaskIncrementTick+0x112>
    2888:	e0 91 a6 0d 	lds	r30, 0x0DA6	; 0x800da6 <pxDelayedTaskList>
    288c:	f0 91 a7 0d 	lds	r31, 0x0DA7	; 0x800da7 <pxDelayedTaskList+0x1>
    2890:	05 80       	ldd	r0, Z+5	; 0x05
    2892:	f6 81       	ldd	r31, Z+6	; 0x06
    2894:	e0 2d       	mov	r30, r0
    2896:	c6 81       	ldd	r28, Z+6	; 0x06
    2898:	d7 81       	ldd	r29, Z+7	; 0x07
    289a:	8a 81       	ldd	r24, Y+2	; 0x02
    289c:	9b 81       	ldd	r25, Y+3	; 0x03
    289e:	e8 16       	cp	r14, r24
    28a0:	f9 06       	cpc	r15, r25
    28a2:	28 f4       	brcc	.+10     	; 0x28ae <xTaskIncrementTick+0xba>
    28a4:	90 93 7e 0d 	sts	0x0D7E, r25	; 0x800d7e <xNextTaskUnblockTime+0x1>
    28a8:	80 93 7d 0d 	sts	0x0D7D, r24	; 0x800d7d <xNextTaskUnblockTime>
    28ac:	2c c0       	rjmp	.+88     	; 0x2906 <xTaskIncrementTick+0x112>
    28ae:	8e 01       	movw	r16, r28
    28b0:	0e 5f       	subi	r16, 0xFE	; 254
    28b2:	1f 4f       	sbci	r17, 0xFF	; 255
    28b4:	c8 01       	movw	r24, r16
    28b6:	fc d9       	rcall	.-3080   	; 0x1cb0 <uxListRemove>
    28b8:	8c 89       	ldd	r24, Y+20	; 0x14
    28ba:	9d 89       	ldd	r25, Y+21	; 0x15
    28bc:	89 2b       	or	r24, r25
    28be:	19 f0       	breq	.+6      	; 0x28c6 <xTaskIncrementTick+0xd2>
    28c0:	ce 01       	movw	r24, r28
    28c2:	0c 96       	adiw	r24, 0x0c	; 12
    28c4:	f5 d9       	rcall	.-3094   	; 0x1cb0 <uxListRemove>
    28c6:	8e 89       	ldd	r24, Y+22	; 0x16
    28c8:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    28cc:	98 17       	cp	r25, r24
    28ce:	10 f4       	brcc	.+4      	; 0x28d4 <xTaskIncrementTick+0xe0>
    28d0:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    28d4:	90 e0       	ldi	r25, 0x00	; 0
    28d6:	9c 01       	movw	r18, r24
    28d8:	22 0f       	add	r18, r18
    28da:	33 1f       	adc	r19, r19
    28dc:	22 0f       	add	r18, r18
    28de:	33 1f       	adc	r19, r19
    28e0:	22 0f       	add	r18, r18
    28e2:	33 1f       	adc	r19, r19
    28e4:	82 0f       	add	r24, r18
    28e6:	93 1f       	adc	r25, r19
    28e8:	b8 01       	movw	r22, r16
    28ea:	86 54       	subi	r24, 0x46	; 70
    28ec:	92 4f       	sbci	r25, 0xF2	; 242
    28ee:	8e d9       	rcall	.-3300   	; 0x1c0c <vListInsertEnd>
    28f0:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    28f4:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    28f8:	9e 89       	ldd	r25, Y+22	; 0x16
    28fa:	86 89       	ldd	r24, Z+22	; 0x16
    28fc:	98 17       	cp	r25, r24
    28fe:	08 f4       	brcc	.+2      	; 0x2902 <xTaskIncrementTick+0x10e>
    2900:	b5 cf       	rjmp	.-150    	; 0x286c <xTaskIncrementTick+0x78>
    2902:	dc 2c       	mov	r13, r12
    2904:	b3 cf       	rjmp	.-154    	; 0x286c <xTaskIncrementTick+0x78>
    2906:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    290a:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    290e:	86 89       	ldd	r24, Z+22	; 0x16
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	fc 01       	movw	r30, r24
    2914:	ee 0f       	add	r30, r30
    2916:	ff 1f       	adc	r31, r31
    2918:	ee 0f       	add	r30, r30
    291a:	ff 1f       	adc	r31, r31
    291c:	ee 0f       	add	r30, r30
    291e:	ff 1f       	adc	r31, r31
    2920:	8e 0f       	add	r24, r30
    2922:	9f 1f       	adc	r25, r31
    2924:	fc 01       	movw	r30, r24
    2926:	e6 54       	subi	r30, 0x46	; 70
    2928:	f2 4f       	sbci	r31, 0xF2	; 242
    292a:	80 81       	ld	r24, Z
    292c:	82 30       	cpi	r24, 0x02	; 2
    292e:	48 f0       	brcs	.+18     	; 0x2942 <xTaskIncrementTick+0x14e>
    2930:	dd 24       	eor	r13, r13
    2932:	d3 94       	inc	r13
    2934:	06 c0       	rjmp	.+12     	; 0x2942 <xTaskIncrementTick+0x14e>
    2936:	80 91 82 0d 	lds	r24, 0x0D82	; 0x800d82 <uxPendedTicks>
    293a:	8f 5f       	subi	r24, 0xFF	; 255
    293c:	80 93 82 0d 	sts	0x0D82, r24	; 0x800d82 <uxPendedTicks>
    2940:	d1 2c       	mov	r13, r1
    2942:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <xYieldPending>
    2946:	88 23       	and	r24, r24
    2948:	11 f0       	breq	.+4      	; 0x294e <xTaskIncrementTick+0x15a>
    294a:	dd 24       	eor	r13, r13
    294c:	d3 94       	inc	r13
    294e:	8d 2d       	mov	r24, r13
    2950:	df 91       	pop	r29
    2952:	cf 91       	pop	r28
    2954:	1f 91       	pop	r17
    2956:	0f 91       	pop	r16
    2958:	ff 90       	pop	r15
    295a:	ef 90       	pop	r14
    295c:	df 90       	pop	r13
    295e:	cf 90       	pop	r12
    2960:	08 95       	ret

00002962 <xTaskResumeAll>:
    2962:	df 92       	push	r13
    2964:	ef 92       	push	r14
    2966:	ff 92       	push	r15
    2968:	0f 93       	push	r16
    296a:	1f 93       	push	r17
    296c:	cf 93       	push	r28
    296e:	df 93       	push	r29
    2970:	0f b6       	in	r0, 0x3f	; 63
    2972:	f8 94       	cli
    2974:	0f 92       	push	r0
    2976:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    297a:	81 50       	subi	r24, 0x01	; 1
    297c:	80 93 7a 0d 	sts	0x0D7A, r24	; 0x800d7a <uxSchedulerSuspended>
    2980:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    2984:	81 11       	cpse	r24, r1
    2986:	59 c0       	rjmp	.+178    	; 0x2a3a <xTaskResumeAll+0xd8>
    2988:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <uxCurrentNumberOfTasks>
    298c:	81 11       	cpse	r24, r1
    298e:	30 c0       	rjmp	.+96     	; 0x29f0 <xTaskResumeAll+0x8e>
    2990:	57 c0       	rjmp	.+174    	; 0x2a40 <xTaskResumeAll+0xde>
    2992:	d7 01       	movw	r26, r14
    2994:	15 96       	adiw	r26, 0x05	; 5
    2996:	ed 91       	ld	r30, X+
    2998:	fc 91       	ld	r31, X
    299a:	16 97       	sbiw	r26, 0x06	; 6
    299c:	c6 81       	ldd	r28, Z+6	; 0x06
    299e:	d7 81       	ldd	r29, Z+7	; 0x07
    29a0:	ce 01       	movw	r24, r28
    29a2:	0c 96       	adiw	r24, 0x0c	; 12
    29a4:	85 d9       	rcall	.-3318   	; 0x1cb0 <uxListRemove>
    29a6:	8e 01       	movw	r16, r28
    29a8:	0e 5f       	subi	r16, 0xFE	; 254
    29aa:	1f 4f       	sbci	r17, 0xFF	; 255
    29ac:	c8 01       	movw	r24, r16
    29ae:	80 d9       	rcall	.-3328   	; 0x1cb0 <uxListRemove>
    29b0:	8e 89       	ldd	r24, Y+22	; 0x16
    29b2:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    29b6:	98 17       	cp	r25, r24
    29b8:	10 f4       	brcc	.+4      	; 0x29be <xTaskResumeAll+0x5c>
    29ba:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    29be:	90 e0       	ldi	r25, 0x00	; 0
    29c0:	9c 01       	movw	r18, r24
    29c2:	22 0f       	add	r18, r18
    29c4:	33 1f       	adc	r19, r19
    29c6:	22 0f       	add	r18, r18
    29c8:	33 1f       	adc	r19, r19
    29ca:	22 0f       	add	r18, r18
    29cc:	33 1f       	adc	r19, r19
    29ce:	82 0f       	add	r24, r18
    29d0:	93 1f       	adc	r25, r19
    29d2:	b8 01       	movw	r22, r16
    29d4:	86 54       	subi	r24, 0x46	; 70
    29d6:	92 4f       	sbci	r25, 0xF2	; 242
    29d8:	19 d9       	rcall	.-3534   	; 0x1c0c <vListInsertEnd>
    29da:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    29de:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    29e2:	9e 89       	ldd	r25, Y+22	; 0x16
    29e4:	86 89       	ldd	r24, Z+22	; 0x16
    29e6:	98 17       	cp	r25, r24
    29e8:	68 f0       	brcs	.+26     	; 0x2a04 <xTaskResumeAll+0xa2>
    29ea:	d0 92 81 0d 	sts	0x0D81, r13	; 0x800d81 <xYieldPending>
    29ee:	0a c0       	rjmp	.+20     	; 0x2a04 <xTaskResumeAll+0xa2>
    29f0:	c0 e0       	ldi	r28, 0x00	; 0
    29f2:	d0 e0       	ldi	r29, 0x00	; 0
    29f4:	0f 2e       	mov	r0, r31
    29f6:	fb e9       	ldi	r31, 0x9B	; 155
    29f8:	ef 2e       	mov	r14, r31
    29fa:	fd e0       	ldi	r31, 0x0D	; 13
    29fc:	ff 2e       	mov	r15, r31
    29fe:	f0 2d       	mov	r31, r0
    2a00:	dd 24       	eor	r13, r13
    2a02:	d3 94       	inc	r13
    2a04:	f7 01       	movw	r30, r14
    2a06:	80 81       	ld	r24, Z
    2a08:	81 11       	cpse	r24, r1
    2a0a:	c3 cf       	rjmp	.-122    	; 0x2992 <xTaskResumeAll+0x30>
    2a0c:	cd 2b       	or	r28, r29
    2a0e:	09 f0       	breq	.+2      	; 0x2a12 <xTaskResumeAll+0xb0>
    2a10:	52 dd       	rcall	.-1372   	; 0x24b6 <prvResetNextTaskUnblockTime>
    2a12:	c0 91 82 0d 	lds	r28, 0x0D82	; 0x800d82 <uxPendedTicks>
    2a16:	cc 23       	and	r28, r28
    2a18:	49 f0       	breq	.+18     	; 0x2a2c <xTaskResumeAll+0xca>
    2a1a:	d1 e0       	ldi	r29, 0x01	; 1
    2a1c:	eb de       	rcall	.-554    	; 0x27f4 <xTaskIncrementTick>
    2a1e:	81 11       	cpse	r24, r1
    2a20:	d0 93 81 0d 	sts	0x0D81, r29	; 0x800d81 <xYieldPending>
    2a24:	c1 50       	subi	r28, 0x01	; 1
    2a26:	d1 f7       	brne	.-12     	; 0x2a1c <xTaskResumeAll+0xba>
    2a28:	10 92 82 0d 	sts	0x0D82, r1	; 0x800d82 <uxPendedTicks>
    2a2c:	80 91 81 0d 	lds	r24, 0x0D81	; 0x800d81 <xYieldPending>
    2a30:	88 23       	and	r24, r24
    2a32:	29 f0       	breq	.+10     	; 0x2a3e <xTaskResumeAll+0xdc>
    2a34:	04 da       	rcall	.-3064   	; 0x1e3e <vPortYield>
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	03 c0       	rjmp	.+6      	; 0x2a40 <xTaskResumeAll+0xde>
    2a3a:	80 e0       	ldi	r24, 0x00	; 0
    2a3c:	01 c0       	rjmp	.+2      	; 0x2a40 <xTaskResumeAll+0xde>
    2a3e:	80 e0       	ldi	r24, 0x00	; 0
    2a40:	0f 90       	pop	r0
    2a42:	0f be       	out	0x3f, r0	; 63
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	1f 91       	pop	r17
    2a4a:	0f 91       	pop	r16
    2a4c:	ff 90       	pop	r15
    2a4e:	ef 90       	pop	r14
    2a50:	df 90       	pop	r13
    2a52:	08 95       	ret

00002a54 <vTaskDelay>:
    2a54:	cf 93       	push	r28
    2a56:	df 93       	push	r29
    2a58:	ec 01       	movw	r28, r24
    2a5a:	89 2b       	or	r24, r25
    2a5c:	39 f0       	breq	.+14     	; 0x2a6c <vTaskDelay+0x18>
    2a5e:	c4 de       	rcall	.-632    	; 0x27e8 <vTaskSuspendAll>
    2a60:	60 e0       	ldi	r22, 0x00	; 0
    2a62:	ce 01       	movw	r24, r28
    2a64:	47 dd       	rcall	.-1394   	; 0x24f4 <prvAddCurrentTaskToDelayedList>
    2a66:	7d df       	rcall	.-262    	; 0x2962 <xTaskResumeAll>
    2a68:	81 11       	cpse	r24, r1
    2a6a:	01 c0       	rjmp	.+2      	; 0x2a6e <vTaskDelay+0x1a>
    2a6c:	e8 d9       	rcall	.-3120   	; 0x1e3e <vPortYield>
    2a6e:	df 91       	pop	r29
    2a70:	cf 91       	pop	r28
    2a72:	08 95       	ret

00002a74 <prvIdleTask>:
    2a74:	02 e9       	ldi	r16, 0x92	; 146
    2a76:	1d e0       	ldi	r17, 0x0D	; 13
    2a78:	0f 2e       	mov	r0, r31
    2a7a:	fa eb       	ldi	r31, 0xBA	; 186
    2a7c:	ef 2e       	mov	r14, r31
    2a7e:	fd e0       	ldi	r31, 0x0D	; 13
    2a80:	ff 2e       	mov	r15, r31
    2a82:	f0 2d       	mov	r31, r0
    2a84:	24 c0       	rjmp	.+72     	; 0x2ace <prvIdleTask+0x5a>
    2a86:	b0 de       	rcall	.-672    	; 0x27e8 <vTaskSuspendAll>
    2a88:	d8 01       	movw	r26, r16
    2a8a:	cc 91       	ld	r28, X
    2a8c:	6a df       	rcall	.-300    	; 0x2962 <xTaskResumeAll>
    2a8e:	cc 23       	and	r28, r28
    2a90:	f1 f0       	breq	.+60     	; 0x2ace <prvIdleTask+0x5a>
    2a92:	0f b6       	in	r0, 0x3f	; 63
    2a94:	f8 94       	cli
    2a96:	0f 92       	push	r0
    2a98:	d8 01       	movw	r26, r16
    2a9a:	15 96       	adiw	r26, 0x05	; 5
    2a9c:	ed 91       	ld	r30, X+
    2a9e:	fc 91       	ld	r31, X
    2aa0:	16 97       	sbiw	r26, 0x06	; 6
    2aa2:	c6 81       	ldd	r28, Z+6	; 0x06
    2aa4:	d7 81       	ldd	r29, Z+7	; 0x07
    2aa6:	ce 01       	movw	r24, r28
    2aa8:	02 96       	adiw	r24, 0x02	; 2
    2aaa:	02 d9       	rcall	.-3580   	; 0x1cb0 <uxListRemove>
    2aac:	80 91 87 0d 	lds	r24, 0x0D87	; 0x800d87 <uxCurrentNumberOfTasks>
    2ab0:	81 50       	subi	r24, 0x01	; 1
    2ab2:	80 93 87 0d 	sts	0x0D87, r24	; 0x800d87 <uxCurrentNumberOfTasks>
    2ab6:	80 91 91 0d 	lds	r24, 0x0D91	; 0x800d91 <uxDeletedTasksWaitingCleanUp>
    2aba:	81 50       	subi	r24, 0x01	; 1
    2abc:	80 93 91 0d 	sts	0x0D91, r24	; 0x800d91 <uxDeletedTasksWaitingCleanUp>
    2ac0:	0f 90       	pop	r0
    2ac2:	0f be       	out	0x3f, r0	; 63
    2ac4:	8f 89       	ldd	r24, Y+23	; 0x17
    2ac6:	98 8d       	ldd	r25, Y+24	; 0x18
    2ac8:	8e d8       	rcall	.-3812   	; 0x1be6 <vPortFree>
    2aca:	ce 01       	movw	r24, r28
    2acc:	8c d8       	rcall	.-3816   	; 0x1be6 <vPortFree>
    2ace:	80 91 91 0d 	lds	r24, 0x0D91	; 0x800d91 <uxDeletedTasksWaitingCleanUp>
    2ad2:	81 11       	cpse	r24, r1
    2ad4:	d8 cf       	rjmp	.-80     	; 0x2a86 <prvIdleTask+0x12>
    2ad6:	f7 01       	movw	r30, r14
    2ad8:	80 81       	ld	r24, Z
    2ada:	82 30       	cpi	r24, 0x02	; 2
    2adc:	c0 f3       	brcs	.-16     	; 0x2ace <prvIdleTask+0x5a>
    2ade:	af d9       	rcall	.-3234   	; 0x1e3e <vPortYield>
    2ae0:	f6 cf       	rjmp	.-20     	; 0x2ace <prvIdleTask+0x5a>

00002ae2 <vTaskSwitchContext>:
    2ae2:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    2ae6:	88 23       	and	r24, r24
    2ae8:	21 f0       	breq	.+8      	; 0x2af2 <vTaskSwitchContext+0x10>
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xYieldPending>
    2af0:	08 95       	ret
    2af2:	10 92 81 0d 	sts	0x0D81, r1	; 0x800d81 <xYieldPending>
    2af6:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2afa:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2afe:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2b02:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2b06:	2d 91       	ld	r18, X+
    2b08:	3c 91       	ld	r19, X
    2b0a:	87 89       	ldd	r24, Z+23	; 0x17
    2b0c:	90 8d       	ldd	r25, Z+24	; 0x18
    2b0e:	82 17       	cp	r24, r18
    2b10:	93 07       	cpc	r25, r19
    2b12:	58 f0       	brcs	.+22     	; 0x2b2a <vTaskSwitchContext+0x48>
    2b14:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2b18:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2b1c:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2b20:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2b24:	67 5e       	subi	r22, 0xE7	; 231
    2b26:	7f 4f       	sbci	r23, 0xFF	; 255
    2b28:	2a d8       	rcall	.-4012   	; 0x1b7e <vApplicationStackOverflowHook>
    2b2a:	20 91 84 0d 	lds	r18, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    2b2e:	82 2f       	mov	r24, r18
    2b30:	90 e0       	ldi	r25, 0x00	; 0
    2b32:	fc 01       	movw	r30, r24
    2b34:	ee 0f       	add	r30, r30
    2b36:	ff 1f       	adc	r31, r31
    2b38:	ee 0f       	add	r30, r30
    2b3a:	ff 1f       	adc	r31, r31
    2b3c:	ee 0f       	add	r30, r30
    2b3e:	ff 1f       	adc	r31, r31
    2b40:	e8 0f       	add	r30, r24
    2b42:	f9 1f       	adc	r31, r25
    2b44:	e6 54       	subi	r30, 0x46	; 70
    2b46:	f2 4f       	sbci	r31, 0xF2	; 242
    2b48:	30 81       	ld	r19, Z
    2b4a:	31 11       	cpse	r19, r1
    2b4c:	11 c0       	rjmp	.+34     	; 0x2b70 <vTaskSwitchContext+0x8e>
    2b4e:	21 50       	subi	r18, 0x01	; 1
    2b50:	82 2f       	mov	r24, r18
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	fc 01       	movw	r30, r24
    2b56:	ee 0f       	add	r30, r30
    2b58:	ff 1f       	adc	r31, r31
    2b5a:	ee 0f       	add	r30, r30
    2b5c:	ff 1f       	adc	r31, r31
    2b5e:	ee 0f       	add	r30, r30
    2b60:	ff 1f       	adc	r31, r31
    2b62:	e8 0f       	add	r30, r24
    2b64:	f9 1f       	adc	r31, r25
    2b66:	e6 54       	subi	r30, 0x46	; 70
    2b68:	f2 4f       	sbci	r31, 0xF2	; 242
    2b6a:	30 81       	ld	r19, Z
    2b6c:	33 23       	and	r19, r19
    2b6e:	79 f3       	breq	.-34     	; 0x2b4e <vTaskSwitchContext+0x6c>
    2b70:	ac 01       	movw	r20, r24
    2b72:	44 0f       	add	r20, r20
    2b74:	55 1f       	adc	r21, r21
    2b76:	44 0f       	add	r20, r20
    2b78:	55 1f       	adc	r21, r21
    2b7a:	44 0f       	add	r20, r20
    2b7c:	55 1f       	adc	r21, r21
    2b7e:	48 0f       	add	r20, r24
    2b80:	59 1f       	adc	r21, r25
    2b82:	da 01       	movw	r26, r20
    2b84:	a6 54       	subi	r26, 0x46	; 70
    2b86:	b2 4f       	sbci	r27, 0xF2	; 242
    2b88:	11 96       	adiw	r26, 0x01	; 1
    2b8a:	ed 91       	ld	r30, X+
    2b8c:	fc 91       	ld	r31, X
    2b8e:	12 97       	sbiw	r26, 0x02	; 2
    2b90:	02 80       	ldd	r0, Z+2	; 0x02
    2b92:	f3 81       	ldd	r31, Z+3	; 0x03
    2b94:	e0 2d       	mov	r30, r0
    2b96:	12 96       	adiw	r26, 0x02	; 2
    2b98:	fc 93       	st	X, r31
    2b9a:	ee 93       	st	-X, r30
    2b9c:	11 97       	sbiw	r26, 0x01	; 1
    2b9e:	43 54       	subi	r20, 0x43	; 67
    2ba0:	52 4f       	sbci	r21, 0xF2	; 242
    2ba2:	e4 17       	cp	r30, r20
    2ba4:	f5 07       	cpc	r31, r21
    2ba6:	29 f4       	brne	.+10     	; 0x2bb2 <vTaskSwitchContext+0xd0>
    2ba8:	42 81       	ldd	r20, Z+2	; 0x02
    2baa:	53 81       	ldd	r21, Z+3	; 0x03
    2bac:	fd 01       	movw	r30, r26
    2bae:	52 83       	std	Z+2, r21	; 0x02
    2bb0:	41 83       	std	Z+1, r20	; 0x01
    2bb2:	fc 01       	movw	r30, r24
    2bb4:	ee 0f       	add	r30, r30
    2bb6:	ff 1f       	adc	r31, r31
    2bb8:	ee 0f       	add	r30, r30
    2bba:	ff 1f       	adc	r31, r31
    2bbc:	ee 0f       	add	r30, r30
    2bbe:	ff 1f       	adc	r31, r31
    2bc0:	8e 0f       	add	r24, r30
    2bc2:	9f 1f       	adc	r25, r31
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	e6 54       	subi	r30, 0x46	; 70
    2bc8:	f2 4f       	sbci	r31, 0xF2	; 242
    2bca:	01 80       	ldd	r0, Z+1	; 0x01
    2bcc:	f2 81       	ldd	r31, Z+2	; 0x02
    2bce:	e0 2d       	mov	r30, r0
    2bd0:	86 81       	ldd	r24, Z+6	; 0x06
    2bd2:	97 81       	ldd	r25, Z+7	; 0x07
    2bd4:	90 93 df 0d 	sts	0x0DDF, r25	; 0x800ddf <pxCurrentTCB+0x1>
    2bd8:	80 93 de 0d 	sts	0x0DDE, r24	; 0x800dde <pxCurrentTCB>
    2bdc:	20 93 84 0d 	sts	0x0D84, r18	; 0x800d84 <uxTopReadyPriority>
    2be0:	08 95       	ret

00002be2 <vTaskPlaceOnEventList>:
    2be2:	cf 93       	push	r28
    2be4:	df 93       	push	r29
    2be6:	eb 01       	movw	r28, r22
    2be8:	60 91 de 0d 	lds	r22, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2bec:	70 91 df 0d 	lds	r23, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2bf0:	64 5f       	subi	r22, 0xF4	; 244
    2bf2:	7f 4f       	sbci	r23, 0xFF	; 255
    2bf4:	2c d8       	rcall	.-4008   	; 0x1c4e <vListInsert>
    2bf6:	61 e0       	ldi	r22, 0x01	; 1
    2bf8:	ce 01       	movw	r24, r28
    2bfa:	7c dc       	rcall	.-1800   	; 0x24f4 <prvAddCurrentTaskToDelayedList>
    2bfc:	df 91       	pop	r29
    2bfe:	cf 91       	pop	r28
    2c00:	08 95       	ret

00002c02 <xTaskRemoveFromEventList>:
    2c02:	0f 93       	push	r16
    2c04:	1f 93       	push	r17
    2c06:	cf 93       	push	r28
    2c08:	df 93       	push	r29
    2c0a:	dc 01       	movw	r26, r24
    2c0c:	15 96       	adiw	r26, 0x05	; 5
    2c0e:	ed 91       	ld	r30, X+
    2c10:	fc 91       	ld	r31, X
    2c12:	16 97       	sbiw	r26, 0x06	; 6
    2c14:	c6 81       	ldd	r28, Z+6	; 0x06
    2c16:	d7 81       	ldd	r29, Z+7	; 0x07
    2c18:	8e 01       	movw	r16, r28
    2c1a:	04 5f       	subi	r16, 0xF4	; 244
    2c1c:	1f 4f       	sbci	r17, 0xFF	; 255
    2c1e:	c8 01       	movw	r24, r16
    2c20:	47 d8       	rcall	.-3954   	; 0x1cb0 <uxListRemove>
    2c22:	80 91 7a 0d 	lds	r24, 0x0D7A	; 0x800d7a <uxSchedulerSuspended>
    2c26:	81 11       	cpse	r24, r1
    2c28:	1b c0       	rjmp	.+54     	; 0x2c60 <xTaskRemoveFromEventList+0x5e>
    2c2a:	0a 50       	subi	r16, 0x0A	; 10
    2c2c:	11 09       	sbc	r17, r1
    2c2e:	c8 01       	movw	r24, r16
    2c30:	3f d8       	rcall	.-3970   	; 0x1cb0 <uxListRemove>
    2c32:	8e 89       	ldd	r24, Y+22	; 0x16
    2c34:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    2c38:	98 17       	cp	r25, r24
    2c3a:	10 f4       	brcc	.+4      	; 0x2c40 <xTaskRemoveFromEventList+0x3e>
    2c3c:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	9c 01       	movw	r18, r24
    2c44:	22 0f       	add	r18, r18
    2c46:	33 1f       	adc	r19, r19
    2c48:	22 0f       	add	r18, r18
    2c4a:	33 1f       	adc	r19, r19
    2c4c:	22 0f       	add	r18, r18
    2c4e:	33 1f       	adc	r19, r19
    2c50:	82 0f       	add	r24, r18
    2c52:	93 1f       	adc	r25, r19
    2c54:	b8 01       	movw	r22, r16
    2c56:	86 54       	subi	r24, 0x46	; 70
    2c58:	92 4f       	sbci	r25, 0xF2	; 242
    2c5a:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vListInsertEnd>
    2c5e:	05 c0       	rjmp	.+10     	; 0x2c6a <xTaskRemoveFromEventList+0x68>
    2c60:	b8 01       	movw	r22, r16
    2c62:	8b e9       	ldi	r24, 0x9B	; 155
    2c64:	9d e0       	ldi	r25, 0x0D	; 13
    2c66:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vListInsertEnd>
    2c6a:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2c6e:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2c72:	9e 89       	ldd	r25, Y+22	; 0x16
    2c74:	86 89       	ldd	r24, Z+22	; 0x16
    2c76:	89 17       	cp	r24, r25
    2c78:	20 f4       	brcc	.+8      	; 0x2c82 <xTaskRemoveFromEventList+0x80>
    2c7a:	81 e0       	ldi	r24, 0x01	; 1
    2c7c:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xYieldPending>
    2c80:	01 c0       	rjmp	.+2      	; 0x2c84 <xTaskRemoveFromEventList+0x82>
    2c82:	80 e0       	ldi	r24, 0x00	; 0
    2c84:	df 91       	pop	r29
    2c86:	cf 91       	pop	r28
    2c88:	1f 91       	pop	r17
    2c8a:	0f 91       	pop	r16
    2c8c:	08 95       	ret

00002c8e <vTaskSetTimeOutState>:
    2c8e:	20 91 80 0d 	lds	r18, 0x0D80	; 0x800d80 <xNumOfOverflows>
    2c92:	fc 01       	movw	r30, r24
    2c94:	20 83       	st	Z, r18
    2c96:	20 91 85 0d 	lds	r18, 0x0D85	; 0x800d85 <xTickCount>
    2c9a:	30 91 86 0d 	lds	r19, 0x0D86	; 0x800d86 <xTickCount+0x1>
    2c9e:	32 83       	std	Z+2, r19	; 0x02
    2ca0:	21 83       	std	Z+1, r18	; 0x01
    2ca2:	08 95       	ret

00002ca4 <xTaskCheckForTimeOut>:
    2ca4:	0f b6       	in	r0, 0x3f	; 63
    2ca6:	f8 94       	cli
    2ca8:	0f 92       	push	r0
    2caa:	40 91 85 0d 	lds	r20, 0x0D85	; 0x800d85 <xTickCount>
    2cae:	50 91 86 0d 	lds	r21, 0x0D86	; 0x800d86 <xTickCount+0x1>
    2cb2:	db 01       	movw	r26, r22
    2cb4:	2d 91       	ld	r18, X+
    2cb6:	3c 91       	ld	r19, X
    2cb8:	2f 3f       	cpi	r18, 0xFF	; 255
    2cba:	bf ef       	ldi	r27, 0xFF	; 255
    2cbc:	3b 07       	cpc	r19, r27
    2cbe:	11 f1       	breq	.+68     	; 0x2d04 <xTaskCheckForTimeOut+0x60>
    2cc0:	e0 91 80 0d 	lds	r30, 0x0D80	; 0x800d80 <xNumOfOverflows>
    2cc4:	dc 01       	movw	r26, r24
    2cc6:	fc 91       	ld	r31, X
    2cc8:	fe 17       	cp	r31, r30
    2cca:	39 f0       	breq	.+14     	; 0x2cda <xTaskCheckForTimeOut+0x36>
    2ccc:	11 96       	adiw	r26, 0x01	; 1
    2cce:	ed 91       	ld	r30, X+
    2cd0:	fc 91       	ld	r31, X
    2cd2:	12 97       	sbiw	r26, 0x02	; 2
    2cd4:	4e 17       	cp	r20, r30
    2cd6:	5f 07       	cpc	r21, r31
    2cd8:	b8 f4       	brcc	.+46     	; 0x2d08 <xTaskCheckForTimeOut+0x64>
    2cda:	dc 01       	movw	r26, r24
    2cdc:	11 96       	adiw	r26, 0x01	; 1
    2cde:	ed 91       	ld	r30, X+
    2ce0:	fc 91       	ld	r31, X
    2ce2:	12 97       	sbiw	r26, 0x02	; 2
    2ce4:	da 01       	movw	r26, r20
    2ce6:	ae 1b       	sub	r26, r30
    2ce8:	bf 0b       	sbc	r27, r31
    2cea:	a2 17       	cp	r26, r18
    2cec:	b3 07       	cpc	r27, r19
    2cee:	70 f4       	brcc	.+28     	; 0x2d0c <xTaskCheckForTimeOut+0x68>
    2cf0:	db 01       	movw	r26, r22
    2cf2:	e4 1b       	sub	r30, r20
    2cf4:	f5 0b       	sbc	r31, r21
    2cf6:	2e 0f       	add	r18, r30
    2cf8:	3f 1f       	adc	r19, r31
    2cfa:	2d 93       	st	X+, r18
    2cfc:	3c 93       	st	X, r19
    2cfe:	c7 df       	rcall	.-114    	; 0x2c8e <vTaskSetTimeOutState>
    2d00:	80 e0       	ldi	r24, 0x00	; 0
    2d02:	05 c0       	rjmp	.+10     	; 0x2d0e <xTaskCheckForTimeOut+0x6a>
    2d04:	80 e0       	ldi	r24, 0x00	; 0
    2d06:	03 c0       	rjmp	.+6      	; 0x2d0e <xTaskCheckForTimeOut+0x6a>
    2d08:	81 e0       	ldi	r24, 0x01	; 1
    2d0a:	01 c0       	rjmp	.+2      	; 0x2d0e <xTaskCheckForTimeOut+0x6a>
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	0f 90       	pop	r0
    2d10:	0f be       	out	0x3f, r0	; 63
    2d12:	08 95       	ret

00002d14 <vTaskMissedYield>:
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	80 93 81 0d 	sts	0x0D81, r24	; 0x800d81 <xYieldPending>
    2d1a:	08 95       	ret

00002d1c <vTaskPriorityInherit>:
    2d1c:	0f 93       	push	r16
    2d1e:	1f 93       	push	r17
    2d20:	cf 93       	push	r28
    2d22:	df 93       	push	r29
    2d24:	fc 01       	movw	r30, r24
    2d26:	89 2b       	or	r24, r25
    2d28:	09 f4       	brne	.+2      	; 0x2d2c <vTaskPriorityInherit+0x10>
    2d2a:	55 c0       	rjmp	.+170    	; 0x2dd6 <vTaskPriorityInherit+0xba>
    2d2c:	26 89       	ldd	r18, Z+22	; 0x16
    2d2e:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2d32:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2d36:	56 96       	adiw	r26, 0x16	; 22
    2d38:	8c 91       	ld	r24, X
    2d3a:	28 17       	cp	r18, r24
    2d3c:	08 f0       	brcs	.+2      	; 0x2d40 <vTaskPriorityInherit+0x24>
    2d3e:	4b c0       	rjmp	.+150    	; 0x2dd6 <vTaskPriorityInherit+0xba>
    2d40:	84 85       	ldd	r24, Z+12	; 0x0c
    2d42:	95 85       	ldd	r25, Z+13	; 0x0d
    2d44:	99 23       	and	r25, r25
    2d46:	64 f0       	brlt	.+24     	; 0x2d60 <vTaskPriorityInherit+0x44>
    2d48:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2d4c:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2d50:	56 96       	adiw	r26, 0x16	; 22
    2d52:	3c 91       	ld	r19, X
    2d54:	84 e0       	ldi	r24, 0x04	; 4
    2d56:	90 e0       	ldi	r25, 0x00	; 0
    2d58:	83 1b       	sub	r24, r19
    2d5a:	91 09       	sbc	r25, r1
    2d5c:	95 87       	std	Z+13, r25	; 0x0d
    2d5e:	84 87       	std	Z+12, r24	; 0x0c
    2d60:	30 e0       	ldi	r19, 0x00	; 0
    2d62:	c9 01       	movw	r24, r18
    2d64:	88 0f       	add	r24, r24
    2d66:	99 1f       	adc	r25, r25
    2d68:	88 0f       	add	r24, r24
    2d6a:	99 1f       	adc	r25, r25
    2d6c:	88 0f       	add	r24, r24
    2d6e:	99 1f       	adc	r25, r25
    2d70:	28 0f       	add	r18, r24
    2d72:	39 1f       	adc	r19, r25
    2d74:	26 54       	subi	r18, 0x46	; 70
    2d76:	32 4f       	sbci	r19, 0xF2	; 242
    2d78:	82 85       	ldd	r24, Z+10	; 0x0a
    2d7a:	93 85       	ldd	r25, Z+11	; 0x0b
    2d7c:	82 17       	cp	r24, r18
    2d7e:	93 07       	cpc	r25, r19
    2d80:	19 f5       	brne	.+70     	; 0x2dc8 <vTaskPriorityInherit+0xac>
    2d82:	8f 01       	movw	r16, r30
    2d84:	ef 01       	movw	r28, r30
    2d86:	22 96       	adiw	r28, 0x02	; 2
    2d88:	ce 01       	movw	r24, r28
    2d8a:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <uxListRemove>
    2d8e:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2d92:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2d96:	86 89       	ldd	r24, Z+22	; 0x16
    2d98:	f8 01       	movw	r30, r16
    2d9a:	86 8b       	std	Z+22, r24	; 0x16
    2d9c:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    2da0:	98 17       	cp	r25, r24
    2da2:	10 f4       	brcc	.+4      	; 0x2da8 <vTaskPriorityInherit+0x8c>
    2da4:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    2da8:	90 e0       	ldi	r25, 0x00	; 0
    2daa:	9c 01       	movw	r18, r24
    2dac:	22 0f       	add	r18, r18
    2dae:	33 1f       	adc	r19, r19
    2db0:	22 0f       	add	r18, r18
    2db2:	33 1f       	adc	r19, r19
    2db4:	22 0f       	add	r18, r18
    2db6:	33 1f       	adc	r19, r19
    2db8:	82 0f       	add	r24, r18
    2dba:	93 1f       	adc	r25, r19
    2dbc:	be 01       	movw	r22, r28
    2dbe:	86 54       	subi	r24, 0x46	; 70
    2dc0:	92 4f       	sbci	r25, 0xF2	; 242
    2dc2:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vListInsertEnd>
    2dc6:	07 c0       	rjmp	.+14     	; 0x2dd6 <vTaskPriorityInherit+0xba>
    2dc8:	a0 91 de 0d 	lds	r26, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2dcc:	b0 91 df 0d 	lds	r27, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2dd0:	56 96       	adiw	r26, 0x16	; 22
    2dd2:	8c 91       	ld	r24, X
    2dd4:	86 8b       	std	Z+22, r24	; 0x16
    2dd6:	df 91       	pop	r29
    2dd8:	cf 91       	pop	r28
    2dda:	1f 91       	pop	r17
    2ddc:	0f 91       	pop	r16
    2dde:	08 95       	ret

00002de0 <xTaskPriorityDisinherit>:
    2de0:	0f 93       	push	r16
    2de2:	1f 93       	push	r17
    2de4:	cf 93       	push	r28
    2de6:	df 93       	push	r29
    2de8:	fc 01       	movw	r30, r24
    2dea:	89 2b       	or	r24, r25
    2dec:	79 f1       	breq	.+94     	; 0x2e4c <xTaskPriorityDisinherit+0x6c>
    2dee:	82 a1       	ldd	r24, Z+34	; 0x22
    2df0:	81 50       	subi	r24, 0x01	; 1
    2df2:	82 a3       	std	Z+34, r24	; 0x22
    2df4:	26 89       	ldd	r18, Z+22	; 0x16
    2df6:	91 a1       	ldd	r25, Z+33	; 0x21
    2df8:	29 17       	cp	r18, r25
    2dfa:	51 f1       	breq	.+84     	; 0x2e50 <xTaskPriorityDisinherit+0x70>
    2dfc:	81 11       	cpse	r24, r1
    2dfe:	2a c0       	rjmp	.+84     	; 0x2e54 <xTaskPriorityDisinherit+0x74>
    2e00:	ef 01       	movw	r28, r30
    2e02:	8f 01       	movw	r16, r30
    2e04:	0e 5f       	subi	r16, 0xFE	; 254
    2e06:	1f 4f       	sbci	r17, 0xFF	; 255
    2e08:	c8 01       	movw	r24, r16
    2e0a:	0e 94 58 0e 	call	0x1cb0	; 0x1cb0 <uxListRemove>
    2e0e:	89 a1       	ldd	r24, Y+33	; 0x21
    2e10:	8e 8b       	std	Y+22, r24	; 0x16
    2e12:	24 e0       	ldi	r18, 0x04	; 4
    2e14:	30 e0       	ldi	r19, 0x00	; 0
    2e16:	28 1b       	sub	r18, r24
    2e18:	31 09       	sbc	r19, r1
    2e1a:	3d 87       	std	Y+13, r19	; 0x0d
    2e1c:	2c 87       	std	Y+12, r18	; 0x0c
    2e1e:	90 91 84 0d 	lds	r25, 0x0D84	; 0x800d84 <uxTopReadyPriority>
    2e22:	98 17       	cp	r25, r24
    2e24:	10 f4       	brcc	.+4      	; 0x2e2a <xTaskPriorityDisinherit+0x4a>
    2e26:	80 93 84 0d 	sts	0x0D84, r24	; 0x800d84 <uxTopReadyPriority>
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	9c 01       	movw	r18, r24
    2e2e:	22 0f       	add	r18, r18
    2e30:	33 1f       	adc	r19, r19
    2e32:	22 0f       	add	r18, r18
    2e34:	33 1f       	adc	r19, r19
    2e36:	22 0f       	add	r18, r18
    2e38:	33 1f       	adc	r19, r19
    2e3a:	82 0f       	add	r24, r18
    2e3c:	93 1f       	adc	r25, r19
    2e3e:	b8 01       	movw	r22, r16
    2e40:	86 54       	subi	r24, 0x46	; 70
    2e42:	92 4f       	sbci	r25, 0xF2	; 242
    2e44:	0e 94 06 0e 	call	0x1c0c	; 0x1c0c <vListInsertEnd>
    2e48:	81 e0       	ldi	r24, 0x01	; 1
    2e4a:	05 c0       	rjmp	.+10     	; 0x2e56 <xTaskPriorityDisinherit+0x76>
    2e4c:	80 e0       	ldi	r24, 0x00	; 0
    2e4e:	03 c0       	rjmp	.+6      	; 0x2e56 <xTaskPriorityDisinherit+0x76>
    2e50:	80 e0       	ldi	r24, 0x00	; 0
    2e52:	01 c0       	rjmp	.+2      	; 0x2e56 <xTaskPriorityDisinherit+0x76>
    2e54:	80 e0       	ldi	r24, 0x00	; 0
    2e56:	df 91       	pop	r29
    2e58:	cf 91       	pop	r28
    2e5a:	1f 91       	pop	r17
    2e5c:	0f 91       	pop	r16
    2e5e:	08 95       	ret

00002e60 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2e60:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2e64:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2e68:	89 2b       	or	r24, r25
    2e6a:	39 f0       	breq	.+14     	; 0x2e7a <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2e6c:	e0 91 de 0d 	lds	r30, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2e70:	f0 91 df 0d 	lds	r31, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
    2e74:	82 a1       	ldd	r24, Z+34	; 0x22
    2e76:	8f 5f       	subi	r24, 0xFF	; 255
    2e78:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2e7a:	80 91 de 0d 	lds	r24, 0x0DDE	; 0x800dde <pxCurrentTCB>
    2e7e:	90 91 df 0d 	lds	r25, 0x0DDF	; 0x800ddf <pxCurrentTCB+0x1>
	}
    2e82:	08 95       	ret

00002e84 <__subsf3>:
    2e84:	50 58       	subi	r21, 0x80	; 128

00002e86 <__addsf3>:
    2e86:	bb 27       	eor	r27, r27
    2e88:	aa 27       	eor	r26, r26
    2e8a:	0e d0       	rcall	.+28     	; 0x2ea8 <__addsf3x>
    2e8c:	e0 c0       	rjmp	.+448    	; 0x304e <__fp_round>
    2e8e:	d1 d0       	rcall	.+418    	; 0x3032 <__fp_pscA>
    2e90:	30 f0       	brcs	.+12     	; 0x2e9e <__addsf3+0x18>
    2e92:	d6 d0       	rcall	.+428    	; 0x3040 <__fp_pscB>
    2e94:	20 f0       	brcs	.+8      	; 0x2e9e <__addsf3+0x18>
    2e96:	31 f4       	brne	.+12     	; 0x2ea4 <__addsf3+0x1e>
    2e98:	9f 3f       	cpi	r25, 0xFF	; 255
    2e9a:	11 f4       	brne	.+4      	; 0x2ea0 <__addsf3+0x1a>
    2e9c:	1e f4       	brtc	.+6      	; 0x2ea4 <__addsf3+0x1e>
    2e9e:	c6 c0       	rjmp	.+396    	; 0x302c <__fp_nan>
    2ea0:	0e f4       	brtc	.+2      	; 0x2ea4 <__addsf3+0x1e>
    2ea2:	e0 95       	com	r30
    2ea4:	e7 fb       	bst	r30, 7
    2ea6:	bc c0       	rjmp	.+376    	; 0x3020 <__fp_inf>

00002ea8 <__addsf3x>:
    2ea8:	e9 2f       	mov	r30, r25
    2eaa:	e2 d0       	rcall	.+452    	; 0x3070 <__fp_split3>
    2eac:	80 f3       	brcs	.-32     	; 0x2e8e <__addsf3+0x8>
    2eae:	ba 17       	cp	r27, r26
    2eb0:	62 07       	cpc	r22, r18
    2eb2:	73 07       	cpc	r23, r19
    2eb4:	84 07       	cpc	r24, r20
    2eb6:	95 07       	cpc	r25, r21
    2eb8:	18 f0       	brcs	.+6      	; 0x2ec0 <__addsf3x+0x18>
    2eba:	71 f4       	brne	.+28     	; 0x2ed8 <__addsf3x+0x30>
    2ebc:	9e f5       	brtc	.+102    	; 0x2f24 <__addsf3x+0x7c>
    2ebe:	fa c0       	rjmp	.+500    	; 0x30b4 <__fp_zero>
    2ec0:	0e f4       	brtc	.+2      	; 0x2ec4 <__addsf3x+0x1c>
    2ec2:	e0 95       	com	r30
    2ec4:	0b 2e       	mov	r0, r27
    2ec6:	ba 2f       	mov	r27, r26
    2ec8:	a0 2d       	mov	r26, r0
    2eca:	0b 01       	movw	r0, r22
    2ecc:	b9 01       	movw	r22, r18
    2ece:	90 01       	movw	r18, r0
    2ed0:	0c 01       	movw	r0, r24
    2ed2:	ca 01       	movw	r24, r20
    2ed4:	a0 01       	movw	r20, r0
    2ed6:	11 24       	eor	r1, r1
    2ed8:	ff 27       	eor	r31, r31
    2eda:	59 1b       	sub	r21, r25
    2edc:	99 f0       	breq	.+38     	; 0x2f04 <__addsf3x+0x5c>
    2ede:	59 3f       	cpi	r21, 0xF9	; 249
    2ee0:	50 f4       	brcc	.+20     	; 0x2ef6 <__addsf3x+0x4e>
    2ee2:	50 3e       	cpi	r21, 0xE0	; 224
    2ee4:	68 f1       	brcs	.+90     	; 0x2f40 <__addsf3x+0x98>
    2ee6:	1a 16       	cp	r1, r26
    2ee8:	f0 40       	sbci	r31, 0x00	; 0
    2eea:	a2 2f       	mov	r26, r18
    2eec:	23 2f       	mov	r18, r19
    2eee:	34 2f       	mov	r19, r20
    2ef0:	44 27       	eor	r20, r20
    2ef2:	58 5f       	subi	r21, 0xF8	; 248
    2ef4:	f3 cf       	rjmp	.-26     	; 0x2edc <__addsf3x+0x34>
    2ef6:	46 95       	lsr	r20
    2ef8:	37 95       	ror	r19
    2efa:	27 95       	ror	r18
    2efc:	a7 95       	ror	r26
    2efe:	f0 40       	sbci	r31, 0x00	; 0
    2f00:	53 95       	inc	r21
    2f02:	c9 f7       	brne	.-14     	; 0x2ef6 <__addsf3x+0x4e>
    2f04:	7e f4       	brtc	.+30     	; 0x2f24 <__addsf3x+0x7c>
    2f06:	1f 16       	cp	r1, r31
    2f08:	ba 0b       	sbc	r27, r26
    2f0a:	62 0b       	sbc	r22, r18
    2f0c:	73 0b       	sbc	r23, r19
    2f0e:	84 0b       	sbc	r24, r20
    2f10:	ba f0       	brmi	.+46     	; 0x2f40 <__addsf3x+0x98>
    2f12:	91 50       	subi	r25, 0x01	; 1
    2f14:	a1 f0       	breq	.+40     	; 0x2f3e <__addsf3x+0x96>
    2f16:	ff 0f       	add	r31, r31
    2f18:	bb 1f       	adc	r27, r27
    2f1a:	66 1f       	adc	r22, r22
    2f1c:	77 1f       	adc	r23, r23
    2f1e:	88 1f       	adc	r24, r24
    2f20:	c2 f7       	brpl	.-16     	; 0x2f12 <__addsf3x+0x6a>
    2f22:	0e c0       	rjmp	.+28     	; 0x2f40 <__addsf3x+0x98>
    2f24:	ba 0f       	add	r27, r26
    2f26:	62 1f       	adc	r22, r18
    2f28:	73 1f       	adc	r23, r19
    2f2a:	84 1f       	adc	r24, r20
    2f2c:	48 f4       	brcc	.+18     	; 0x2f40 <__addsf3x+0x98>
    2f2e:	87 95       	ror	r24
    2f30:	77 95       	ror	r23
    2f32:	67 95       	ror	r22
    2f34:	b7 95       	ror	r27
    2f36:	f7 95       	ror	r31
    2f38:	9e 3f       	cpi	r25, 0xFE	; 254
    2f3a:	08 f0       	brcs	.+2      	; 0x2f3e <__addsf3x+0x96>
    2f3c:	b3 cf       	rjmp	.-154    	; 0x2ea4 <__addsf3+0x1e>
    2f3e:	93 95       	inc	r25
    2f40:	88 0f       	add	r24, r24
    2f42:	08 f0       	brcs	.+2      	; 0x2f46 <__addsf3x+0x9e>
    2f44:	99 27       	eor	r25, r25
    2f46:	ee 0f       	add	r30, r30
    2f48:	97 95       	ror	r25
    2f4a:	87 95       	ror	r24
    2f4c:	08 95       	ret

00002f4e <__fixunssfsi>:
    2f4e:	98 d0       	rcall	.+304    	; 0x3080 <__fp_splitA>
    2f50:	88 f0       	brcs	.+34     	; 0x2f74 <__fixunssfsi+0x26>
    2f52:	9f 57       	subi	r25, 0x7F	; 127
    2f54:	90 f0       	brcs	.+36     	; 0x2f7a <__fixunssfsi+0x2c>
    2f56:	b9 2f       	mov	r27, r25
    2f58:	99 27       	eor	r25, r25
    2f5a:	b7 51       	subi	r27, 0x17	; 23
    2f5c:	a0 f0       	brcs	.+40     	; 0x2f86 <__fixunssfsi+0x38>
    2f5e:	d1 f0       	breq	.+52     	; 0x2f94 <__fixunssfsi+0x46>
    2f60:	66 0f       	add	r22, r22
    2f62:	77 1f       	adc	r23, r23
    2f64:	88 1f       	adc	r24, r24
    2f66:	99 1f       	adc	r25, r25
    2f68:	1a f0       	brmi	.+6      	; 0x2f70 <__fixunssfsi+0x22>
    2f6a:	ba 95       	dec	r27
    2f6c:	c9 f7       	brne	.-14     	; 0x2f60 <__fixunssfsi+0x12>
    2f6e:	12 c0       	rjmp	.+36     	; 0x2f94 <__fixunssfsi+0x46>
    2f70:	b1 30       	cpi	r27, 0x01	; 1
    2f72:	81 f0       	breq	.+32     	; 0x2f94 <__fixunssfsi+0x46>
    2f74:	9f d0       	rcall	.+318    	; 0x30b4 <__fp_zero>
    2f76:	b1 e0       	ldi	r27, 0x01	; 1
    2f78:	08 95       	ret
    2f7a:	9c c0       	rjmp	.+312    	; 0x30b4 <__fp_zero>
    2f7c:	67 2f       	mov	r22, r23
    2f7e:	78 2f       	mov	r23, r24
    2f80:	88 27       	eor	r24, r24
    2f82:	b8 5f       	subi	r27, 0xF8	; 248
    2f84:	39 f0       	breq	.+14     	; 0x2f94 <__fixunssfsi+0x46>
    2f86:	b9 3f       	cpi	r27, 0xF9	; 249
    2f88:	cc f3       	brlt	.-14     	; 0x2f7c <__fixunssfsi+0x2e>
    2f8a:	86 95       	lsr	r24
    2f8c:	77 95       	ror	r23
    2f8e:	67 95       	ror	r22
    2f90:	b3 95       	inc	r27
    2f92:	d9 f7       	brne	.-10     	; 0x2f8a <__fixunssfsi+0x3c>
    2f94:	3e f4       	brtc	.+14     	; 0x2fa4 <__fixunssfsi+0x56>
    2f96:	90 95       	com	r25
    2f98:	80 95       	com	r24
    2f9a:	70 95       	com	r23
    2f9c:	61 95       	neg	r22
    2f9e:	7f 4f       	sbci	r23, 0xFF	; 255
    2fa0:	8f 4f       	sbci	r24, 0xFF	; 255
    2fa2:	9f 4f       	sbci	r25, 0xFF	; 255
    2fa4:	08 95       	ret

00002fa6 <__floatunsisf>:
    2fa6:	e8 94       	clt
    2fa8:	09 c0       	rjmp	.+18     	; 0x2fbc <__floatsisf+0x12>

00002faa <__floatsisf>:
    2faa:	97 fb       	bst	r25, 7
    2fac:	3e f4       	brtc	.+14     	; 0x2fbc <__floatsisf+0x12>
    2fae:	90 95       	com	r25
    2fb0:	80 95       	com	r24
    2fb2:	70 95       	com	r23
    2fb4:	61 95       	neg	r22
    2fb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb8:	8f 4f       	sbci	r24, 0xFF	; 255
    2fba:	9f 4f       	sbci	r25, 0xFF	; 255
    2fbc:	99 23       	and	r25, r25
    2fbe:	a9 f0       	breq	.+42     	; 0x2fea <__floatsisf+0x40>
    2fc0:	f9 2f       	mov	r31, r25
    2fc2:	96 e9       	ldi	r25, 0x96	; 150
    2fc4:	bb 27       	eor	r27, r27
    2fc6:	93 95       	inc	r25
    2fc8:	f6 95       	lsr	r31
    2fca:	87 95       	ror	r24
    2fcc:	77 95       	ror	r23
    2fce:	67 95       	ror	r22
    2fd0:	b7 95       	ror	r27
    2fd2:	f1 11       	cpse	r31, r1
    2fd4:	f8 cf       	rjmp	.-16     	; 0x2fc6 <__floatsisf+0x1c>
    2fd6:	fa f4       	brpl	.+62     	; 0x3016 <__floatsisf+0x6c>
    2fd8:	bb 0f       	add	r27, r27
    2fda:	11 f4       	brne	.+4      	; 0x2fe0 <__floatsisf+0x36>
    2fdc:	60 ff       	sbrs	r22, 0
    2fde:	1b c0       	rjmp	.+54     	; 0x3016 <__floatsisf+0x6c>
    2fe0:	6f 5f       	subi	r22, 0xFF	; 255
    2fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fe4:	8f 4f       	sbci	r24, 0xFF	; 255
    2fe6:	9f 4f       	sbci	r25, 0xFF	; 255
    2fe8:	16 c0       	rjmp	.+44     	; 0x3016 <__floatsisf+0x6c>
    2fea:	88 23       	and	r24, r24
    2fec:	11 f0       	breq	.+4      	; 0x2ff2 <__floatsisf+0x48>
    2fee:	96 e9       	ldi	r25, 0x96	; 150
    2ff0:	11 c0       	rjmp	.+34     	; 0x3014 <__floatsisf+0x6a>
    2ff2:	77 23       	and	r23, r23
    2ff4:	21 f0       	breq	.+8      	; 0x2ffe <__floatsisf+0x54>
    2ff6:	9e e8       	ldi	r25, 0x8E	; 142
    2ff8:	87 2f       	mov	r24, r23
    2ffa:	76 2f       	mov	r23, r22
    2ffc:	05 c0       	rjmp	.+10     	; 0x3008 <__floatsisf+0x5e>
    2ffe:	66 23       	and	r22, r22
    3000:	71 f0       	breq	.+28     	; 0x301e <__floatsisf+0x74>
    3002:	96 e8       	ldi	r25, 0x86	; 134
    3004:	86 2f       	mov	r24, r22
    3006:	70 e0       	ldi	r23, 0x00	; 0
    3008:	60 e0       	ldi	r22, 0x00	; 0
    300a:	2a f0       	brmi	.+10     	; 0x3016 <__floatsisf+0x6c>
    300c:	9a 95       	dec	r25
    300e:	66 0f       	add	r22, r22
    3010:	77 1f       	adc	r23, r23
    3012:	88 1f       	adc	r24, r24
    3014:	da f7       	brpl	.-10     	; 0x300c <__floatsisf+0x62>
    3016:	88 0f       	add	r24, r24
    3018:	96 95       	lsr	r25
    301a:	87 95       	ror	r24
    301c:	97 f9       	bld	r25, 7
    301e:	08 95       	ret

00003020 <__fp_inf>:
    3020:	97 f9       	bld	r25, 7
    3022:	9f 67       	ori	r25, 0x7F	; 127
    3024:	80 e8       	ldi	r24, 0x80	; 128
    3026:	70 e0       	ldi	r23, 0x00	; 0
    3028:	60 e0       	ldi	r22, 0x00	; 0
    302a:	08 95       	ret

0000302c <__fp_nan>:
    302c:	9f ef       	ldi	r25, 0xFF	; 255
    302e:	80 ec       	ldi	r24, 0xC0	; 192
    3030:	08 95       	ret

00003032 <__fp_pscA>:
    3032:	00 24       	eor	r0, r0
    3034:	0a 94       	dec	r0
    3036:	16 16       	cp	r1, r22
    3038:	17 06       	cpc	r1, r23
    303a:	18 06       	cpc	r1, r24
    303c:	09 06       	cpc	r0, r25
    303e:	08 95       	ret

00003040 <__fp_pscB>:
    3040:	00 24       	eor	r0, r0
    3042:	0a 94       	dec	r0
    3044:	12 16       	cp	r1, r18
    3046:	13 06       	cpc	r1, r19
    3048:	14 06       	cpc	r1, r20
    304a:	05 06       	cpc	r0, r21
    304c:	08 95       	ret

0000304e <__fp_round>:
    304e:	09 2e       	mov	r0, r25
    3050:	03 94       	inc	r0
    3052:	00 0c       	add	r0, r0
    3054:	11 f4       	brne	.+4      	; 0x305a <__fp_round+0xc>
    3056:	88 23       	and	r24, r24
    3058:	52 f0       	brmi	.+20     	; 0x306e <__fp_round+0x20>
    305a:	bb 0f       	add	r27, r27
    305c:	40 f4       	brcc	.+16     	; 0x306e <__fp_round+0x20>
    305e:	bf 2b       	or	r27, r31
    3060:	11 f4       	brne	.+4      	; 0x3066 <__fp_round+0x18>
    3062:	60 ff       	sbrs	r22, 0
    3064:	04 c0       	rjmp	.+8      	; 0x306e <__fp_round+0x20>
    3066:	6f 5f       	subi	r22, 0xFF	; 255
    3068:	7f 4f       	sbci	r23, 0xFF	; 255
    306a:	8f 4f       	sbci	r24, 0xFF	; 255
    306c:	9f 4f       	sbci	r25, 0xFF	; 255
    306e:	08 95       	ret

00003070 <__fp_split3>:
    3070:	57 fd       	sbrc	r21, 7
    3072:	90 58       	subi	r25, 0x80	; 128
    3074:	44 0f       	add	r20, r20
    3076:	55 1f       	adc	r21, r21
    3078:	59 f0       	breq	.+22     	; 0x3090 <__fp_splitA+0x10>
    307a:	5f 3f       	cpi	r21, 0xFF	; 255
    307c:	71 f0       	breq	.+28     	; 0x309a <__fp_splitA+0x1a>
    307e:	47 95       	ror	r20

00003080 <__fp_splitA>:
    3080:	88 0f       	add	r24, r24
    3082:	97 fb       	bst	r25, 7
    3084:	99 1f       	adc	r25, r25
    3086:	61 f0       	breq	.+24     	; 0x30a0 <__fp_splitA+0x20>
    3088:	9f 3f       	cpi	r25, 0xFF	; 255
    308a:	79 f0       	breq	.+30     	; 0x30aa <__fp_splitA+0x2a>
    308c:	87 95       	ror	r24
    308e:	08 95       	ret
    3090:	12 16       	cp	r1, r18
    3092:	13 06       	cpc	r1, r19
    3094:	14 06       	cpc	r1, r20
    3096:	55 1f       	adc	r21, r21
    3098:	f2 cf       	rjmp	.-28     	; 0x307e <__fp_split3+0xe>
    309a:	46 95       	lsr	r20
    309c:	f1 df       	rcall	.-30     	; 0x3080 <__fp_splitA>
    309e:	08 c0       	rjmp	.+16     	; 0x30b0 <__fp_splitA+0x30>
    30a0:	16 16       	cp	r1, r22
    30a2:	17 06       	cpc	r1, r23
    30a4:	18 06       	cpc	r1, r24
    30a6:	99 1f       	adc	r25, r25
    30a8:	f1 cf       	rjmp	.-30     	; 0x308c <__fp_splitA+0xc>
    30aa:	86 95       	lsr	r24
    30ac:	71 05       	cpc	r23, r1
    30ae:	61 05       	cpc	r22, r1
    30b0:	08 94       	sec
    30b2:	08 95       	ret

000030b4 <__fp_zero>:
    30b4:	e8 94       	clt

000030b6 <__fp_szero>:
    30b6:	bb 27       	eor	r27, r27
    30b8:	66 27       	eor	r22, r22
    30ba:	77 27       	eor	r23, r23
    30bc:	cb 01       	movw	r24, r22
    30be:	97 f9       	bld	r25, 7
    30c0:	08 95       	ret

000030c2 <__udivmodsi4>:
    30c2:	a1 e2       	ldi	r26, 0x21	; 33
    30c4:	1a 2e       	mov	r1, r26
    30c6:	aa 1b       	sub	r26, r26
    30c8:	bb 1b       	sub	r27, r27
    30ca:	fd 01       	movw	r30, r26
    30cc:	0d c0       	rjmp	.+26     	; 0x30e8 <__udivmodsi4_ep>

000030ce <__udivmodsi4_loop>:
    30ce:	aa 1f       	adc	r26, r26
    30d0:	bb 1f       	adc	r27, r27
    30d2:	ee 1f       	adc	r30, r30
    30d4:	ff 1f       	adc	r31, r31
    30d6:	a2 17       	cp	r26, r18
    30d8:	b3 07       	cpc	r27, r19
    30da:	e4 07       	cpc	r30, r20
    30dc:	f5 07       	cpc	r31, r21
    30de:	20 f0       	brcs	.+8      	; 0x30e8 <__udivmodsi4_ep>
    30e0:	a2 1b       	sub	r26, r18
    30e2:	b3 0b       	sbc	r27, r19
    30e4:	e4 0b       	sbc	r30, r20
    30e6:	f5 0b       	sbc	r31, r21

000030e8 <__udivmodsi4_ep>:
    30e8:	66 1f       	adc	r22, r22
    30ea:	77 1f       	adc	r23, r23
    30ec:	88 1f       	adc	r24, r24
    30ee:	99 1f       	adc	r25, r25
    30f0:	1a 94       	dec	r1
    30f2:	69 f7       	brne	.-38     	; 0x30ce <__udivmodsi4_loop>
    30f4:	60 95       	com	r22
    30f6:	70 95       	com	r23
    30f8:	80 95       	com	r24
    30fa:	90 95       	com	r25
    30fc:	9b 01       	movw	r18, r22
    30fe:	ac 01       	movw	r20, r24
    3100:	bd 01       	movw	r22, r26
    3102:	cf 01       	movw	r24, r30
    3104:	08 95       	ret

00003106 <memcpy>:
    3106:	fb 01       	movw	r30, r22
    3108:	dc 01       	movw	r26, r24
    310a:	02 c0       	rjmp	.+4      	; 0x3110 <memcpy+0xa>
    310c:	01 90       	ld	r0, Z+
    310e:	0d 92       	st	X+, r0
    3110:	41 50       	subi	r20, 0x01	; 1
    3112:	50 40       	sbci	r21, 0x00	; 0
    3114:	d8 f7       	brcc	.-10     	; 0x310c <memcpy+0x6>
    3116:	08 95       	ret

00003118 <eeprom_read_byte>:
    3118:	e1 99       	sbic	0x1c, 1	; 28
    311a:	fe cf       	rjmp	.-4      	; 0x3118 <eeprom_read_byte>
    311c:	9f bb       	out	0x1f, r25	; 31
    311e:	8e bb       	out	0x1e, r24	; 30
    3120:	e0 9a       	sbi	0x1c, 0	; 28
    3122:	99 27       	eor	r25, r25
    3124:	8d b3       	in	r24, 0x1d	; 29
    3126:	08 95       	ret

00003128 <eeprom_update_byte>:
    3128:	26 2f       	mov	r18, r22

0000312a <eeprom_update_r18>:
    312a:	e1 99       	sbic	0x1c, 1	; 28
    312c:	fe cf       	rjmp	.-4      	; 0x312a <eeprom_update_r18>
    312e:	9f bb       	out	0x1f, r25	; 31
    3130:	8e bb       	out	0x1e, r24	; 30
    3132:	e0 9a       	sbi	0x1c, 0	; 28
    3134:	01 97       	sbiw	r24, 0x01	; 1
    3136:	0d b2       	in	r0, 0x1d	; 29
    3138:	02 16       	cp	r0, r18
    313a:	31 f0       	breq	.+12     	; 0x3148 <eeprom_update_r18+0x1e>
    313c:	2d bb       	out	0x1d, r18	; 29
    313e:	0f b6       	in	r0, 0x3f	; 63
    3140:	f8 94       	cli
    3142:	e2 9a       	sbi	0x1c, 2	; 28
    3144:	e1 9a       	sbi	0x1c, 1	; 28
    3146:	0f be       	out	0x3f, r0	; 63
    3148:	08 95       	ret

0000314a <_exit>:
    314a:	f8 94       	cli

0000314c <__stop_program>:
    314c:	ff cf       	rjmp	.-2      	; 0x314c <__stop_program>
