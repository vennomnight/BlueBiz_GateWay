
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800100  00003992  00003a26  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003992  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000de6  008001bc  008001bc  00003ae2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003ae2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003b14  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a78  00000000  00000000  00003b58  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000d903  00000000  00000000  000045d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000039e7  00000000  00000000  00011ed3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005b2a  00000000  00000000  000158ba  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001bdc  00000000  00000000  0001b3e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003b15  00000000  00000000  0001cfc0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008afb  00000000  00000000  00020ad5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000a68  00000000  00000000  000295d0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	28 c2       	rjmp	.+1104   	; 0x452 <__ctors_end>
       2:	00 00       	nop
       4:	53 c5       	rjmp	.+2726   	; 0xaac <__vector_1>
       6:	00 00       	nop
       8:	43 c2       	rjmp	.+1158   	; 0x490 <__bad_interrupt>
       a:	00 00       	nop
       c:	41 c2       	rjmp	.+1154   	; 0x490 <__bad_interrupt>
       e:	00 00       	nop
      10:	3f c2       	rjmp	.+1150   	; 0x490 <__bad_interrupt>
      12:	00 00       	nop
      14:	3d c2       	rjmp	.+1146   	; 0x490 <__bad_interrupt>
      16:	00 00       	nop
      18:	3b c2       	rjmp	.+1142   	; 0x490 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	39 c2       	rjmp	.+1138   	; 0x490 <__bad_interrupt>
      1e:	00 00       	nop
      20:	37 c2       	rjmp	.+1134   	; 0x490 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c6       	rjmp	.+3234   	; 0xcc8 <__vector_9>
      26:	00 00       	nop
      28:	33 c2       	rjmp	.+1126   	; 0x490 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	31 c2       	rjmp	.+1122   	; 0x490 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 a0 13 	jmp	0x2740	; 0x2740 <__vector_12>
      34:	2d c2       	rjmp	.+1114   	; 0x490 <__bad_interrupt>
      36:	00 00       	nop
      38:	2b c2       	rjmp	.+1110   	; 0x490 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	c5 c3       	rjmp	.+1930   	; 0x7c8 <__vector_15>
      3e:	00 00       	nop
      40:	27 c2       	rjmp	.+1102   	; 0x490 <__bad_interrupt>
      42:	00 00       	nop
      44:	25 c2       	rjmp	.+1098   	; 0x490 <__bad_interrupt>
      46:	00 00       	nop
      48:	a0 c4       	rjmp	.+2368   	; 0x98a <__vector_18>
      4a:	00 00       	nop
      4c:	21 c2       	rjmp	.+1090   	; 0x490 <__bad_interrupt>
      4e:	00 00       	nop
      50:	1f c2       	rjmp	.+1086   	; 0x490 <__bad_interrupt>
      52:	00 00       	nop
      54:	5b c5       	rjmp	.+2742   	; 0xb0c <__vector_21>
      56:	00 00       	nop
      58:	1b c2       	rjmp	.+1078   	; 0x490 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	19 c2       	rjmp	.+1074   	; 0x490 <__bad_interrupt>
      5e:	00 00       	nop
      60:	17 c2       	rjmp	.+1070   	; 0x490 <__bad_interrupt>
      62:	00 00       	nop
      64:	15 c2       	rjmp	.+1066   	; 0x490 <__bad_interrupt>
      66:	00 00       	nop
      68:	13 c2       	rjmp	.+1062   	; 0x490 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	11 c2       	rjmp	.+1058   	; 0x490 <__bad_interrupt>
      6e:	00 00       	nop
      70:	ed c4       	rjmp	.+2522   	; 0xa4c <__vector_28>
      72:	00 00       	nop
      74:	0d c2       	rjmp	.+1050   	; 0x490 <__bad_interrupt>
      76:	00 00       	nop
      78:	b8 c4       	rjmp	.+2416   	; 0x9ea <__vector_30>
      7a:	00 00       	nop
      7c:	09 c2       	rjmp	.+1042   	; 0x490 <__bad_interrupt>
      7e:	00 00       	nop
      80:	07 c2       	rjmp	.+1038   	; 0x490 <__bad_interrupt>
      82:	00 00       	nop
      84:	05 c2       	rjmp	.+1034   	; 0x490 <__bad_interrupt>
      86:	00 00       	nop
      88:	03 c2       	rjmp	.+1030   	; 0x490 <__bad_interrupt>
	...

0000008c <__trampolines_end>:
      8c:	d8 ff       	.word	0xffd8	; ????
      8e:	d9 ff       	.word	0xffd9	; ????
      90:	da ff       	.word	0xffda	; ????
      92:	db ff       	.word	0xffdb	; ????
      94:	dc ff       	.word	0xffdc	; ????
      96:	dd ff       	.word	0xffdd	; ????
      98:	de ff       	.word	0xffde	; ????
      9a:	df ff       	.word	0xffdf	; ????
      9c:	e0 ff       	sbrs	r30, 0
      9e:	e1 ff       	sbrs	r30, 1
      a0:	e2 ff       	sbrs	r30, 2
      a2:	e3 ff       	sbrs	r30, 3
      a4:	e4 ff       	sbrs	r30, 4
      a6:	e5 ff       	sbrs	r30, 5
      a8:	e6 ff       	sbrs	r30, 6
      aa:	e7 ff       	sbrs	r30, 7
      ac:	e8 ff       	.word	0xffe8	; ????
      ae:	e9 ff       	.word	0xffe9	; ????
      b0:	ea ff       	.word	0xffea	; ????
      b2:	eb ff       	.word	0xffeb	; ????
      b4:	ec ff       	.word	0xffec	; ????
      b6:	ed ff       	.word	0xffed	; ????
      b8:	ee ff       	.word	0xffee	; ????
      ba:	ef ff       	.word	0xffef	; ????
      bc:	f0 ff       	sbrs	r31, 0
      be:	f1 ff       	sbrs	r31, 1
      c0:	f2 ff       	sbrs	r31, 2
      c2:	f3 ff       	sbrs	r31, 3
      c4:	f4 ff       	sbrs	r31, 4
      c6:	f5 ff       	sbrs	r31, 5
      c8:	f6 ff       	sbrs	r31, 6
      ca:	f7 ff       	sbrs	r31, 7
      cc:	f8 ff       	.word	0xfff8	; ????
      ce:	f9 ff       	.word	0xfff9	; ????
      d0:	fa ff       	.word	0xfffa	; ????
      d2:	fb ff       	.word	0xfffb	; ????
      d4:	fc ff       	.word	0xfffc	; ????
      d6:	fd ff       	.word	0xfffd	; ????
      d8:	fe ff       	.word	0xfffe	; ????
      da:	ff ff       	.word	0xffff	; ????
      dc:	00 00       	nop
      de:	01 00       	.word	0x0001	; ????
      e0:	02 00       	.word	0x0002	; ????
      e2:	03 00       	.word	0x0003	; ????
      e4:	04 00       	.word	0x0004	; ????
      e6:	05 00       	.word	0x0005	; ????
      e8:	06 00       	.word	0x0006	; ????
      ea:	07 00       	.word	0x0007	; ????
      ec:	08 00       	.word	0x0008	; ????
      ee:	09 00       	.word	0x0009	; ????
      f0:	0a 00       	.word	0x000a	; ????
      f2:	0b 00       	.word	0x000b	; ????
      f4:	0c 00       	.word	0x000c	; ????
      f6:	0d 00       	.word	0x000d	; ????
      f8:	0e 00       	.word	0x000e	; ????
      fa:	0f 00       	.word	0x000f	; ????
      fc:	10 00       	.word	0x0010	; ????
      fe:	11 00       	.word	0x0011	; ????
     100:	12 00       	.word	0x0012	; ????
     102:	13 00       	.word	0x0013	; ????
     104:	14 00       	.word	0x0014	; ????
     106:	15 00       	.word	0x0015	; ????
     108:	16 00       	.word	0x0016	; ????
     10a:	17 00       	.word	0x0017	; ????
     10c:	18 00       	.word	0x0018	; ????
     10e:	19 00       	.word	0x0019	; ????
     110:	1a 00       	.word	0x001a	; ????
     112:	1b 00       	.word	0x001b	; ????
     114:	1c 00       	.word	0x001c	; ????
     116:	1d 00       	.word	0x001d	; ????
     118:	1e 00       	.word	0x001e	; ????
     11a:	1f 00       	.word	0x001f	; ????
     11c:	20 00       	.word	0x0020	; ????
     11e:	21 00       	.word	0x0021	; ????
     120:	22 00       	.word	0x0022	; ????
     122:	23 00       	.word	0x0023	; ????
     124:	24 00       	.word	0x0024	; ????
     126:	25 00       	.word	0x0025	; ????
     128:	26 00       	.word	0x0026	; ????
     12a:	27 00       	.word	0x0027	; ????
     12c:	28 00       	.word	0x0028	; ????
     12e:	29 00       	.word	0x0029	; ????
     130:	2a 00       	.word	0x002a	; ????
     132:	2b 00       	.word	0x002b	; ????
     134:	2c 00       	.word	0x002c	; ????
     136:	2d 00       	.word	0x002d	; ????
     138:	2e 00       	.word	0x002e	; ????
     13a:	2f 00       	.word	0x002f	; ????
     13c:	30 00       	.word	0x0030	; ????
     13e:	31 00       	.word	0x0031	; ????
     140:	32 00       	.word	0x0032	; ????
     142:	33 00       	.word	0x0033	; ????
     144:	34 00       	.word	0x0034	; ????
     146:	35 00       	.word	0x0035	; ????
     148:	36 00       	.word	0x0036	; ????
     14a:	37 00       	.word	0x0037	; ????
     14c:	38 00       	.word	0x0038	; ????
     14e:	39 00       	.word	0x0039	; ????
     150:	3a 00       	.word	0x003a	; ????
     152:	3b 00       	.word	0x003b	; ????
     154:	3c 00       	.word	0x003c	; ????
     156:	3d 00       	.word	0x003d	; ????
     158:	3e 00       	.word	0x003e	; ????
     15a:	3f 00       	.word	0x003f	; ????
     15c:	40 00       	.word	0x0040	; ????
     15e:	41 00       	.word	0x0041	; ????
     160:	42 00       	.word	0x0042	; ????
     162:	43 00       	.word	0x0043	; ????
     164:	44 00       	.word	0x0044	; ????
     166:	45 00       	.word	0x0045	; ????
     168:	46 00       	.word	0x0046	; ????
     16a:	47 00       	.word	0x0047	; ????
     16c:	48 00       	.word	0x0048	; ????
     16e:	49 00       	.word	0x0049	; ????
     170:	4a 00       	.word	0x004a	; ????
     172:	4b 00       	.word	0x004b	; ????
     174:	4c 00       	.word	0x004c	; ????
     176:	4d 00       	.word	0x004d	; ????
     178:	4e 00       	.word	0x004e	; ????
     17a:	4f 00       	.word	0x004f	; ????
     17c:	50 00       	.word	0x0050	; ????
     17e:	51 00       	.word	0x0051	; ????
     180:	52 00       	.word	0x0052	; ????
     182:	53 00       	.word	0x0053	; ????
     184:	54 00       	.word	0x0054	; ????
     186:	55 00       	.word	0x0055	; ????
     188:	56 00       	.word	0x0056	; ????
     18a:	57 00       	.word	0x0057	; ????
     18c:	58 00       	.word	0x0058	; ????
     18e:	59 00       	.word	0x0059	; ????
     190:	5a 00       	.word	0x005a	; ????
     192:	5b 00       	.word	0x005b	; ????
     194:	5c 00       	.word	0x005c	; ????
     196:	5d 00       	.word	0x005d	; ????
     198:	5e 00       	.word	0x005e	; ????
     19a:	5f 00       	.word	0x005f	; ????
     19c:	60 00       	.word	0x0060	; ????
     19e:	61 00       	.word	0x0061	; ????
     1a0:	62 00       	.word	0x0062	; ????
     1a2:	63 00       	.word	0x0063	; ????
     1a4:	64 00       	.word	0x0064	; ????
     1a6:	65 00       	.word	0x0065	; ????
     1a8:	66 00       	.word	0x0066	; ????
     1aa:	67 00       	.word	0x0067	; ????
     1ac:	68 00       	.word	0x0068	; ????
     1ae:	69 00       	.word	0x0069	; ????
     1b0:	6a 00       	.word	0x006a	; ????
     1b2:	6b 00       	.word	0x006b	; ????
     1b4:	6c 00       	.word	0x006c	; ????
     1b6:	6d 00       	.word	0x006d	; ????
     1b8:	6e 00       	.word	0x006e	; ????
     1ba:	6f 00       	.word	0x006f	; ????
     1bc:	70 00       	.word	0x0070	; ????
     1be:	71 00       	.word	0x0071	; ????
     1c0:	72 00       	.word	0x0072	; ????
     1c2:	73 00       	.word	0x0073	; ????
     1c4:	74 00       	.word	0x0074	; ????
     1c6:	75 00       	.word	0x0075	; ????
     1c8:	76 00       	.word	0x0076	; ????
     1ca:	77 00       	.word	0x0077	; ????
     1cc:	78 00       	.word	0x0078	; ????

000001ce <_ZL9g_alfVolt>:
     1ce:	a1 84 89 3e cd 92 90 3e 60 ea 97 3e 97 90 9f 3e     ...>...>`..>...>
     1de:	73 85 a7 3e 92 cb af 3e 95 65 b8 3e ca 54 c1 3e     s..>...>.e.>.T.>
     1ee:	80 9a ca 3e 09 38 d4 3e 51 31 de 3e 59 86 e8 3e     ...>.8.>Q1.>Y..>
     1fe:	c1 39 f3 3e 88 4b fe 3e 7f de 04 3f 08 c9 0a 3f     .9.>.K.>...?...?
     20e:	11 e4 10 3f 90 31 17 3f 85 b1 1d 3f f1 63 24 3f     ...?.1.?...?.c$?
     21e:	7b 49 2b 3f 24 62 32 3f 92 ae 39 3f c7 2e 41 3f     {I+?$b2?..9?..A?
     22e:	19 e2 48 3f 32 c9 50 3f c1 e2 58 3f 16 30 61 3f     ..H?2.P?..X?.0a?
     23e:	3a af 69 3f 2d 60 72 3f ee 42 7b 3f 17 2b 82 3f     :.i?-`r?.B{?.+.?
     24e:	a3 cc 86 3f c6 85 8b 3f da 55 90 3f 36 3c 95 3f     ...?...?.U.?6<.?
     25e:	32 38 9a 3f cf 49 9f 3f 69 6f a4 3f 00 a9 a9 3f     28.?.I.?io.?...?
     26e:	99 f5 ae 3f e3 53 b4 3f df c3 b9 3f e9 43 bf 3f     ...?.S.?...?.C.?
     27e:	07 d3 c4 3f e3 70 ca 3f da 1b d0 3f 46 d3 d5 3f     ...?.p.?...?F..?
     28e:	d5 95 db 3f 8d 62 e1 3f 71 38 e7 3f 33 16 ed 3f     ...?.b.?q8.?3..?
     29e:	83 fa f2 3f b8 e4 f8 3f 84 d3 fe 3f cc 62 02 40     ...?...?...?.b.@
     2ae:	fb 5c 05 40 a8 57 08 40 7e 52 0b 40 ad 4c 0e 40     .\.@.W.@~R.@.L.@
     2be:	b7 45 11 40 1d 3d 14 40 61 32 17 40 dd 24 1a 40     .E.@.=.@a2.@.$.@
     2ce:	3c 14 1d 40 00 00 20 40 82 e7 22 40 97 ca 25 40     <..@.. @.."@..%@
     2de:	6d a8 28 40 dc 80 2b 40 8f 53 2e 40 de 1f 31 40     m.(@..+@.S.@..1@
     2ee:	9f e5 33 40 7f a4 36 40 ff 5b 39 40 f6 0b 3c 40     ..3@..6@.[9@..<@
     2fe:	e5 b3 3e 40 ce 53 41 40 85 eb 43 40 63 7a 46 40     ..>@.SA@..C@czF@
     30e:	93 00 49 40 bf 7d 4b 40 bf f1 4d 40 92 5c 50 40     ..I@.}K@..M@.\P@
     31e:	e4 bd 52 40 8c 15 55 40 b2 63 57 40 2f a8 59 40     ..R@..U@.cW@/.Y@
     32e:	d6 e2 5b 40 a9 13 5e 40 a8 3a 60 40 d1 57 62 40     ..[@..^@.:`@.Wb@
     33e:	fd 6a 64 40 54 74 66 40 00 74 68 40 ad 69 6a 40     .jd@Ttf@.th@.ij@
     34e:	b0 55 6c 40 df 37 6e 40 8c 10 70 40 8f df 71 40     .Ul@.7n@..p@..q@
     35e:	12 a5 73 40 3d 61 75 40 12 14 77 40 ba bd 78 40     ..s@=au@..w@..x@
     36e:	0b 5e 7a 40 ae f5 7b 40 23 84 7d 40 13 0a 7f 40     .^z@..{@#.}@...@
     37e:	96 43 80 40 f4 fd 80 40 0f b4 81 40 27 66 82 40     .C.@...@...@'f.@
     38e:	12 14 83 40 0e be 83 40 1b 64 84 40 4f 06 85 40     ...@...@.d.@O..@
     39e:	d3 a4 85 40 7d 3f 86 40 a1 d6 86 40 2b 6a 87 40     ...@}?.@...@+j.@
     3ae:	2f fa 87 40 c2 86 88 40 0e 10 89 40 ff 95 89 40     /..@...@...@...@
     3be:	d2 18 8a 40 5f 98 8a 40 f9 14 8b 40 75 8e 8b 40     ...@_..@...@u..@
     3ce:	14 05 8c 40 c0 78 8c 40 a3 e9 8c 40 d1 57 8d 40     ...@.x.@...@.W.@
     3de:	4c c3 8d 40 28 2c 8e 40 64 92 8e 40 2b f6 8e 40     L..@(,.@d..@+..@
     3ee:	93 57 8f 40 85 b6 8f 40 2b 13 90 40 87 6d 90 40     .W.@...@+..@.m.@
     3fe:	ac c5 90 40 b0 1b 91 40 93 6f 91 40 6a c1 91 40     ...@...@.o.@j..@
     40e:	49 11 92 40 1c 5f 92 40 22 ab 92 40 45 f5 92 40     I..@._.@"..@E..@
     41e:	86 3d 93 40 0e 84 93 40 f3 c8 93 40 0b 0c 94 40     .=.@...@...@...@
     42e:	94 4d 94 40 7a 8d 94 40 e6 cb 94 40 c4 08 95 40     .M.@z..@...@...@
     43e:	28 44 95 40 13 7e 95 40 ae b6 95 40 d0 ed 95 40     (D.@.~.@...@...@
     44e:	b8 23 96 40                                         .#.@

00000452 <__ctors_end>:
     452:	11 24       	eor	r1, r1
     454:	1f be       	out	0x3f, r1	; 63
     456:	cf ef       	ldi	r28, 0xFF	; 255
     458:	d0 e1       	ldi	r29, 0x10	; 16
     45a:	de bf       	out	0x3e, r29	; 62
     45c:	cd bf       	out	0x3d, r28	; 61

0000045e <__do_copy_data>:
     45e:	11 e0       	ldi	r17, 0x01	; 1
     460:	a0 e0       	ldi	r26, 0x00	; 0
     462:	b1 e0       	ldi	r27, 0x01	; 1
     464:	e2 e9       	ldi	r30, 0x92	; 146
     466:	f9 e3       	ldi	r31, 0x39	; 57
     468:	00 e0       	ldi	r16, 0x00	; 0
     46a:	0b bf       	out	0x3b, r16	; 59
     46c:	02 c0       	rjmp	.+4      	; 0x472 <__do_copy_data+0x14>
     46e:	07 90       	elpm	r0, Z+
     470:	0d 92       	st	X+, r0
     472:	ac 3b       	cpi	r26, 0xBC	; 188
     474:	b1 07       	cpc	r27, r17
     476:	d9 f7       	brne	.-10     	; 0x46e <__do_copy_data+0x10>

00000478 <__do_clear_bss>:
     478:	2f e0       	ldi	r18, 0x0F	; 15
     47a:	ac eb       	ldi	r26, 0xBC	; 188
     47c:	b1 e0       	ldi	r27, 0x01	; 1
     47e:	01 c0       	rjmp	.+2      	; 0x482 <.do_clear_bss_start>

00000480 <.do_clear_bss_loop>:
     480:	1d 92       	st	X+, r1

00000482 <.do_clear_bss_start>:
     482:	a2 3a       	cpi	r26, 0xA2	; 162
     484:	b2 07       	cpc	r27, r18
     486:	e1 f7       	brne	.-8      	; 0x480 <.do_clear_bss_loop>
     488:	0e 94 be 0f 	call	0x1f7c	; 0x1f7c <main>
     48c:	0c 94 c7 1c 	jmp	0x398e	; 0x398e <_exit>

00000490 <__bad_interrupt>:
     490:	b7 cd       	rjmp	.-1170   	; 0x0 <__vectors>

00000492 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
     492:	fc 01       	movw	r30, r24
     494:	68 0f       	add	r22, r24
     496:	79 1f       	adc	r23, r25
     498:	8f ef       	ldi	r24, 0xFF	; 255
     49a:	9f ef       	ldi	r25, 0xFF	; 255
     49c:	e6 17       	cp	r30, r22
     49e:	f7 07       	cpc	r31, r23
     4a0:	99 f0       	breq	.+38     	; 0x4c8 <_Z5CRC16Phi+0x36>
     4a2:	21 91       	ld	r18, Z+
     4a4:	82 27       	eor	r24, r18
     4a6:	28 e0       	ldi	r18, 0x08	; 8
     4a8:	30 e0       	ldi	r19, 0x00	; 0
     4aa:	ac 01       	movw	r20, r24
     4ac:	41 70       	andi	r20, 0x01	; 1
     4ae:	55 27       	eor	r21, r21
     4b0:	96 95       	lsr	r25
     4b2:	87 95       	ror	r24
     4b4:	45 2b       	or	r20, r21
     4b6:	21 f0       	breq	.+8      	; 0x4c0 <_Z5CRC16Phi+0x2e>
     4b8:	41 e0       	ldi	r20, 0x01	; 1
     4ba:	84 27       	eor	r24, r20
     4bc:	40 ea       	ldi	r20, 0xA0	; 160
     4be:	94 27       	eor	r25, r20
     4c0:	21 50       	subi	r18, 0x01	; 1
     4c2:	31 09       	sbc	r19, r1
     4c4:	91 f7       	brne	.-28     	; 0x4aa <_Z5CRC16Phi+0x18>
     4c6:	ea cf       	rjmp	.-44     	; 0x49c <_Z5CRC16Phi+0xa>
     4c8:	08 95       	ret

000004ca <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     4ca:	cf 93       	push	r28
     4cc:	df 93       	push	r29
     4ce:	fc 01       	movw	r30, r24
     4d0:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     4d2:	80 81       	ld	r24, Z
     4d4:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     4d6:	81 81       	ldd	r24, Z+1	; 0x01
     4d8:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     4da:	83 81       	ldd	r24, Z+3	; 0x03
	function04->ByteCount = 0x02;
     4dc:	92 e0       	ldi	r25, 0x02	; 2
     4de:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     4e0:	fa 01       	movw	r30, r20
     4e2:	e8 0f       	add	r30, r24
     4e4:	f1 1d       	adc	r31, r1
     4e6:	e8 0f       	add	r30, r24
     4e8:	f1 1d       	adc	r31, r1
     4ea:	81 81       	ldd	r24, Z+1	; 0x01
     4ec:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     4ee:	80 81       	ld	r24, Z
     4f0:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     4f2:	65 e0       	ldi	r22, 0x05	; 5
     4f4:	70 e0       	ldi	r23, 0x00	; 0
     4f6:	ce 01       	movw	r24, r28
     4f8:	cc df       	rcall	.-104    	; 0x492 <_Z5CRC16Phi>
	function04->CRC = crc16;
     4fa:	9e 83       	std	Y+6, r25	; 0x06
     4fc:	8d 83       	std	Y+5, r24	; 0x05
}
     4fe:	df 91       	pop	r29
     500:	cf 91       	pop	r28
     502:	08 95       	ret

00000504 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     504:	cf 93       	push	r28
     506:	df 93       	push	r29
     508:	fc 01       	movw	r30, r24
     50a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     50c:	80 81       	ld	r24, Z
     50e:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     510:	81 81       	ldd	r24, Z+1	; 0x01
     512:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     514:	82 81       	ldd	r24, Z+2	; 0x02
     516:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     518:	83 81       	ldd	r24, Z+3	; 0x03
     51a:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     51c:	84 81       	ldd	r24, Z+4	; 0x04
     51e:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     520:	85 81       	ldd	r24, Z+5	; 0x05
     522:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     524:	66 e0       	ldi	r22, 0x06	; 6
     526:	70 e0       	ldi	r23, 0x00	; 0
     528:	ce 01       	movw	r24, r28
     52a:	b3 df       	rcall	.-154    	; 0x492 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     52c:	9f 83       	std	Y+7, r25	; 0x07
     52e:	8e 83       	std	Y+6, r24	; 0x06
}
     530:	df 91       	pop	r29
     532:	cf 91       	pop	r28
     534:	08 95       	ret

00000536 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     536:	cf 93       	push	r28
     538:	df 93       	push	r29
     53a:	fc 01       	movw	r30, r24
     53c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     53e:	80 81       	ld	r24, Z
     540:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     542:	81 81       	ldd	r24, Z+1	; 0x01
     544:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     546:	82 81       	ldd	r24, Z+2	; 0x02
     548:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     54a:	93 81       	ldd	r25, Z+3	; 0x03
     54c:	9b 83       	std	Y+3, r25	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     54e:	84 81       	ldd	r24, Z+4	; 0x04
     550:	8c 83       	std	Y+4, r24	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     552:	85 81       	ldd	r24, Z+5	; 0x05
     554:	8d 83       	std	Y+5, r24	; 0x05
	function10->byteCount = *(buf + 6);
     556:	86 81       	ldd	r24, Z+6	; 0x06
     558:	8e 83       	std	Y+6, r24	; 0x06
	function10->registerValueHi = *(buf + 7);
     55a:	27 81       	ldd	r18, Z+7	; 0x07
     55c:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     55e:	80 85       	ldd	r24, Z+8	; 0x08
     560:	88 87       	std	Y+8, r24	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     562:	fa 01       	movw	r30, r20
     564:	e9 0f       	add	r30, r25
     566:	f1 1d       	adc	r31, r1
     568:	e9 0f       	add	r30, r25
     56a:	f1 1d       	adc	r31, r1
     56c:	90 e0       	ldi	r25, 0x00	; 0
     56e:	92 2b       	or	r25, r18
     570:	91 83       	std	Z+1, r25	; 0x01
     572:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     574:	69 e0       	ldi	r22, 0x09	; 9
     576:	70 e0       	ldi	r23, 0x00	; 0
     578:	ce 01       	movw	r24, r28
     57a:	8b df       	rcall	.-234    	; 0x492 <_Z5CRC16Phi>
	function10->CRC = crc16;
     57c:	9a 87       	std	Y+10, r25	; 0x0a
     57e:	89 87       	std	Y+9, r24	; 0x09
}
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	08 95       	ret

00000586 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
     58a:	fc 01       	movw	r30, r24
     58c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     58e:	80 81       	ld	r24, Z
     590:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     592:	81 81       	ldd	r24, Z+1	; 0x01
     594:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     596:	82 81       	ldd	r24, Z+2	; 0x02
     598:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     59a:	83 81       	ldd	r24, Z+3	; 0x03
     59c:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     59e:	84 81       	ldd	r24, Z+4	; 0x04
     5a0:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     5a2:	85 81       	ldd	r24, Z+5	; 0x05
     5a4:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     5a6:	66 e0       	ldi	r22, 0x06	; 6
     5a8:	70 e0       	ldi	r23, 0x00	; 0
     5aa:	ce 01       	movw	r24, r28
     5ac:	72 df       	rcall	.-284    	; 0x492 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     5ae:	9f 83       	std	Y+7, r25	; 0x07
     5b0:	8e 83       	std	Y+6, r24	; 0x06
}
     5b2:	df 91       	pop	r29
     5b4:	cf 91       	pop	r28
     5b6:	08 95       	ret

000005b8 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     5b8:	cf 93       	push	r28
     5ba:	df 93       	push	r29
     5bc:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     5be:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     5c0:	81 e8       	ldi	r24, 0x81	; 129
     5c2:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     5c4:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     5c6:	63 e0       	ldi	r22, 0x03	; 3
     5c8:	70 e0       	ldi	r23, 0x00	; 0
     5ca:	ce 01       	movw	r24, r28
     5cc:	62 df       	rcall	.-316    	; 0x492 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     5ce:	9c 83       	std	Y+4, r25	; 0x04
     5d0:	8b 83       	std	Y+3, r24	; 0x03
}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	08 95       	ret

000005d8 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	dev->Write(this->type,Temp);

	
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);
     5d8:	ff 92       	push	r15
     5da:	0f 93       	push	r16
     5dc:	1f 93       	push	r17
     5de:	cf 93       	push	r28
     5e0:	df 93       	push	r29
     5e2:	ec 01       	movw	r28, r24
     5e4:	cb 01       	movw	r24, r22
     5e6:	f4 2e       	mov	r15, r20
     5e8:	8e 01       	movw	r16, r28
     5ea:	0a 57       	subi	r16, 0x7A	; 122
     5ec:	1f 4f       	sbci	r17, 0xFF	; 255
     5ee:	f8 01       	movw	r30, r16
     5f0:	71 83       	std	Z+1, r23	; 0x01
     5f2:	60 83       	st	Z, r22
     5f4:	64 2f       	mov	r22, r20
     5f6:	b5 d1       	rcall	.+874    	; 0x962 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     5f8:	88 23       	and	r24, r24
     5fa:	71 f0       	breq	.+28     	; 0x618 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x40>
     5fc:	fe 01       	movw	r30, r28
     5fe:	eb 57       	subi	r30, 0x7B	; 123
     600:	ff 4f       	sbci	r31, 0xFF	; 255
     602:	f0 82       	st	Z, r15
     604:	31 97       	sbiw	r30, 0x01	; 1
     606:	10 82       	st	Z, r1
     608:	34 97       	sbiw	r30, 0x04	; 4
     60a:	11 82       	std	Z+1, r1	; 0x01
     60c:	10 82       	st	Z, r1
     60e:	ce 57       	subi	r28, 0x7E	; 126
     610:	df 4f       	sbci	r29, 0xFF	; 255
     612:	19 82       	std	Y+1, r1	; 0x01
     614:	18 82       	st	Y, r1
     616:	03 c0       	rjmp	.+6      	; 0x61e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x46>
     618:	f8 01       	movw	r30, r16
     61a:	11 82       	std	Z+1, r1	; 0x01
     61c:	10 82       	st	Z, r1
     61e:	df 91       	pop	r29
     620:	cf 91       	pop	r28
     622:	1f 91       	pop	r17
     624:	0f 91       	pop	r16
     626:	ff 90       	pop	r15
     628:	08 95       	ret

0000062a <_ZN12SerialBuffernwEj>:
     62a:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

0000062e <_ZN12SerialBuffer11SerialstoreEc>:
     62e:	fc 01       	movw	r30, r24
     630:	e0 58       	subi	r30, 0x80	; 128
     632:	ff 4f       	sbci	r31, 0xFF	; 255
     634:	20 81       	ld	r18, Z
     636:	2f 5f       	subi	r18, 0xFF	; 255
     638:	2f 77       	andi	r18, 0x7F	; 127
     63a:	19 f4       	brne	.+6      	; 0x642 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     63c:	11 82       	std	Z+1, r1	; 0x01
     63e:	10 82       	st	Z, r1
     640:	21 e0       	ldi	r18, 0x01	; 1
     642:	30 e0       	ldi	r19, 0x00	; 0
     644:	dc 01       	movw	r26, r24
     646:	ae 57       	subi	r26, 0x7E	; 126
     648:	bf 4f       	sbci	r27, 0xFF	; 255
     64a:	4d 91       	ld	r20, X+
     64c:	5c 91       	ld	r21, X
     64e:	24 17       	cp	r18, r20
     650:	35 07       	cpc	r19, r21
     652:	71 f0       	breq	.+28     	; 0x670 <_ZN12SerialBuffer11SerialstoreEc+0x42>
     654:	a0 81       	ld	r26, Z
     656:	b1 81       	ldd	r27, Z+1	; 0x01
     658:	a8 0f       	add	r26, r24
     65a:	b9 1f       	adc	r27, r25
     65c:	11 96       	adiw	r26, 0x01	; 1
     65e:	6c 93       	st	X, r22
     660:	31 83       	std	Z+1, r19	; 0x01
     662:	20 83       	st	Z, r18
     664:	fc 01       	movw	r30, r24
     666:	ec 57       	subi	r30, 0x7C	; 124
     668:	ff 4f       	sbci	r31, 0xFF	; 255
     66a:	80 81       	ld	r24, Z
     66c:	8f 5f       	subi	r24, 0xFF	; 255
     66e:	80 83       	st	Z, r24
     670:	08 95       	ret

00000672 <_ZN12SerialBuffer11SerialWriteEPKci>:
     672:	bf 92       	push	r11
     674:	cf 92       	push	r12
     676:	df 92       	push	r13
     678:	ef 92       	push	r14
     67a:	ff 92       	push	r15
     67c:	0f 93       	push	r16
     67e:	1f 93       	push	r17
     680:	cf 93       	push	r28
     682:	df 93       	push	r29
     684:	7b 01       	movw	r14, r22
     686:	6a 01       	movw	r12, r20
     688:	8c 01       	movw	r16, r24
     68a:	0b 57       	subi	r16, 0x7B	; 123
     68c:	1f 4f       	sbci	r17, 0xFF	; 255
     68e:	ec 01       	movw	r28, r24
     690:	ca 57       	subi	r28, 0x7A	; 122
     692:	df 4f       	sbci	r29, 0xFF	; 255
     694:	f8 01       	movw	r30, r16
     696:	60 81       	ld	r22, Z
     698:	88 81       	ld	r24, Y
     69a:	99 81       	ldd	r25, Y+1	; 0x01
     69c:	6e d1       	rcall	.+732    	; 0x97a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     69e:	89 2b       	or	r24, r25
     6a0:	89 f0       	breq	.+34     	; 0x6c4 <_ZN12SerialBuffer11SerialWriteEPKci+0x52>
     6a2:	b1 2c       	mov	r11, r1
     6a4:	8b 2d       	mov	r24, r11
     6a6:	90 e0       	ldi	r25, 0x00	; 0
     6a8:	8c 15       	cp	r24, r12
     6aa:	9d 05       	cpc	r25, r13
     6ac:	5c f4       	brge	.+22     	; 0x6c4 <_ZN12SerialBuffer11SerialWriteEPKci+0x52>
     6ae:	f7 01       	movw	r30, r14
     6b0:	e8 0f       	add	r30, r24
     6b2:	f9 1f       	adc	r31, r25
     6b4:	40 81       	ld	r20, Z
     6b6:	f8 01       	movw	r30, r16
     6b8:	60 81       	ld	r22, Z
     6ba:	88 81       	ld	r24, Y
     6bc:	99 81       	ldd	r25, Y+1	; 0x01
     6be:	10 d1       	rcall	.+544    	; 0x8e0 <_ZN11Dev_Manager5WriteE8Dev_typec>
     6c0:	b3 94       	inc	r11
     6c2:	f0 cf       	rjmp	.-32     	; 0x6a4 <_ZN12SerialBuffer11SerialWriteEPKci+0x32>
     6c4:	df 91       	pop	r29
     6c6:	cf 91       	pop	r28
     6c8:	1f 91       	pop	r17
     6ca:	0f 91       	pop	r16
     6cc:	ff 90       	pop	r15
     6ce:	ef 90       	pop	r14
     6d0:	df 90       	pop	r13
     6d2:	cf 90       	pop	r12
     6d4:	bf 90       	pop	r11
     6d6:	08 95       	ret

000006d8 <_ZN12SerialBuffer10SerialReadEv>:

	
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
     6d8:	cf 93       	push	r28
     6da:	df 93       	push	r29
	if (ib.head == ib.tail)
     6dc:	dc 01       	movw	r26, r24
     6de:	ae 57       	subi	r26, 0x7E	; 126
     6e0:	bf 4f       	sbci	r27, 0xFF	; 255
     6e2:	2d 91       	ld	r18, X+
     6e4:	3c 91       	ld	r19, X
     6e6:	11 97       	sbiw	r26, 0x01	; 1
     6e8:	ec 01       	movw	r28, r24
     6ea:	c0 58       	subi	r28, 0x80	; 128
     6ec:	df 4f       	sbci	r29, 0xFF	; 255
     6ee:	48 81       	ld	r20, Y
     6f0:	59 81       	ldd	r21, Y+1	; 0x01
     6f2:	42 17       	cp	r20, r18
     6f4:	53 07       	cpc	r21, r19
     6f6:	c9 f0       	breq	.+50     	; 0x72a <_ZN12SerialBuffer10SerialReadEv+0x52>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     6f8:	2f 5f       	subi	r18, 0xFF	; 255
     6fa:	3f 4f       	sbci	r19, 0xFF	; 255
     6fc:	fc 01       	movw	r30, r24
     6fe:	e2 0f       	add	r30, r18
     700:	f3 1f       	adc	r31, r19
     702:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     704:	2f 77       	andi	r18, 0x7F	; 127
     706:	33 27       	eor	r19, r19
     708:	11 96       	adiw	r26, 0x01	; 1
     70a:	3c 93       	st	X, r19
     70c:	2e 93       	st	-X, r18
		if (ib.tail == num)
     70e:	fc 01       	movw	r30, r24
     710:	ec 57       	subi	r30, 0x7C	; 124
     712:	ff 4f       	sbci	r31, 0xFF	; 255
     714:	80 81       	ld	r24, Z
     716:	90 e0       	ldi	r25, 0x00	; 0
     718:	28 17       	cp	r18, r24
     71a:	39 07       	cpc	r19, r25
     71c:	41 f4       	brne	.+16     	; 0x72e <_ZN12SerialBuffer10SerialReadEv+0x56>
		{
			ib.tail = 0;
     71e:	1d 92       	st	X+, r1
     720:	1c 92       	st	X, r1
			ib.head = 0;
     722:	19 82       	std	Y+1, r1	; 0x01
     724:	18 82       	st	Y, r1
			num = 0;
     726:	10 82       	st	Z, r1
     728:	02 c0       	rjmp	.+4      	; 0x72e <_ZN12SerialBuffer10SerialReadEv+0x56>
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     72a:	8f ef       	ldi	r24, 0xFF	; 255
     72c:	01 c0       	rjmp	.+2      	; 0x730 <_ZN12SerialBuffer10SerialReadEv+0x58>
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     72e:	84 2f       	mov	r24, r20
	}
}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	08 95       	ret

00000736 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     736:	dc 01       	movw	r26, r24
     738:	a0 58       	subi	r26, 0x80	; 128
     73a:	bf 4f       	sbci	r27, 0xFF	; 255
     73c:	fc 01       	movw	r30, r24
     73e:	ee 57       	subi	r30, 0x7E	; 126
     740:	ff 4f       	sbci	r31, 0xFF	; 255
     742:	8c 91       	ld	r24, X
     744:	90 81       	ld	r25, Z
     746:	89 1b       	sub	r24, r25
}
     748:	8f 77       	andi	r24, 0x7F	; 127
     74a:	08 95       	ret

0000074c <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     74c:	fc 01       	movw	r30, r24
     74e:	ee 57       	subi	r30, 0x7E	; 126
     750:	ff 4f       	sbci	r31, 0xFF	; 255
     752:	11 82       	std	Z+1, r1	; 0x01
     754:	10 82       	st	Z, r1
	ib.head = 0;
     756:	32 97       	sbiw	r30, 0x02	; 2
     758:	11 82       	std	Z+1, r1	; 0x01
     75a:	10 82       	st	Z, r1
	num = 0;
     75c:	34 96       	adiw	r30, 0x04	; 4
     75e:	10 82       	st	Z, r1
     760:	08 95       	ret

00000762 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
	virtual void Device_Writes(const char* data){}
     762:	08 95       	ret

00000764 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
     764:	08 95       	ret

00000766 <_ZN20DeviceDriveInterFace11Stop_DeviceEv>:
	virtual void Stop_Device(void){}
     766:	08 95       	ret

00000768 <_ZN3Adc11Device_InitEv>:
{
	return channel_inf;
}
void Adc::Read_Set()
{
	read_flag = 0;
     768:	80 e4       	ldi	r24, 0x40	; 64
     76a:	87 b9       	out	0x07, r24	; 7
     76c:	87 e8       	ldi	r24, 0x87	; 135
     76e:	86 b9       	out	0x06, r24	; 6
     770:	08 95       	ret

00000772 <_ZN3Adc12Start_DeviceEh>:
     772:	36 99       	sbic	0x06, 6	; 6
     774:	fe cf       	rjmp	.-4      	; 0x772 <_ZN3Adc12Start_DeviceEh>
     776:	87 b1       	in	r24, 0x07	; 7
     778:	80 7e       	andi	r24, 0xE0	; 224
     77a:	68 2b       	or	r22, r24
     77c:	67 b9       	out	0x07, r22	; 7
     77e:	36 9a       	sbi	0x06, 6	; 6
     780:	08 95       	ret

00000782 <_ZNK3Adc11Device_ReadEv>:
     782:	fc 01       	movw	r30, r24
     784:	82 81       	ldd	r24, Z+2	; 0x02
     786:	08 95       	ret

00000788 <_ZN3AdcnwEj>:
}
void* Adc::operator new(size_t size)
{
	return malloc(size);
     788:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

0000078c <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
     78c:	8c e0       	ldi	r24, 0x0C	; 12
     78e:	83 bf       	out	0x33, r24	; 51
     790:	8c e7       	ldi	r24, 0x7C	; 124
     792:	81 bf       	out	0x31, r24	; 49
     794:	87 b7       	in	r24, 0x37	; 55
     796:	82 60       	ori	r24, 0x02	; 2
     798:	87 bf       	out	0x37, r24	; 55
     79a:	08 95       	ret

0000079c <Alarm_Stop>:
     79c:	87 b7       	in	r24, 0x37	; 55
     79e:	8d 7f       	andi	r24, 0xFD	; 253
     7a0:	87 bf       	out	0x37, r24	; 55
     7a2:	08 95       	ret

000007a4 <Alarm_Start>:
     7a4:	87 b7       	in	r24, 0x37	; 55
     7a6:	82 60       	ori	r24, 0x02	; 2
     7a8:	87 bf       	out	0x37, r24	; 55
     7aa:	08 95       	ret

000007ac <Alarm_Open>:
     7ac:	26 e0       	ldi	r18, 0x06	; 6
     7ae:	82 9f       	mul	r24, r18
     7b0:	c0 01       	movw	r24, r0
     7b2:	11 24       	eor	r1, r1
     7b4:	fc 01       	movw	r30, r24
     7b6:	e4 54       	subi	r30, 0x44	; 68
     7b8:	fe 4f       	sbci	r31, 0xFE	; 254
     7ba:	71 83       	std	Z+1, r23	; 0x01
     7bc:	60 83       	st	Z, r22
     7be:	13 82       	std	Z+3, r1	; 0x03
     7c0:	12 82       	std	Z+2, r1	; 0x02
     7c2:	55 83       	std	Z+5, r21	; 0x05
     7c4:	44 83       	std	Z+4, r20	; 0x04
     7c6:	08 95       	ret

000007c8 <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
     7c8:	1f 92       	push	r1
     7ca:	0f 92       	push	r0
     7cc:	0f b6       	in	r0, 0x3f	; 63
     7ce:	0f 92       	push	r0
     7d0:	11 24       	eor	r1, r1
     7d2:	0b b6       	in	r0, 0x3b	; 59
     7d4:	0f 92       	push	r0
     7d6:	2f 93       	push	r18
     7d8:	3f 93       	push	r19
     7da:	4f 93       	push	r20
     7dc:	5f 93       	push	r21
     7de:	6f 93       	push	r22
     7e0:	7f 93       	push	r23
     7e2:	8f 93       	push	r24
     7e4:	9f 93       	push	r25
     7e6:	af 93       	push	r26
     7e8:	bf 93       	push	r27
     7ea:	cf 93       	push	r28
     7ec:	df 93       	push	r29
     7ee:	ef 93       	push	r30
     7f0:	ff 93       	push	r31
     7f2:	cc eb       	ldi	r28, 0xBC	; 188
     7f4:	d1 e0       	ldi	r29, 0x01	; 1
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
     7f6:	ec 81       	ldd	r30, Y+4	; 0x04
     7f8:	fd 81       	ldd	r31, Y+5	; 0x05
     7fa:	30 97       	sbiw	r30, 0x00	; 0
     7fc:	79 f0       	breq	.+30     	; 0x81c <__vector_15+0x54>
		{
			AlarmTable[i].Time++;
     7fe:	8a 81       	ldd	r24, Y+2	; 0x02
     800:	9b 81       	ldd	r25, Y+3	; 0x03
     802:	01 96       	adiw	r24, 0x01	; 1
     804:	9b 83       	std	Y+3, r25	; 0x03
     806:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
     808:	28 81       	ld	r18, Y
     80a:	39 81       	ldd	r19, Y+1	; 0x01
     80c:	82 17       	cp	r24, r18
     80e:	93 07       	cpc	r25, r19
     810:	29 f4       	brne	.+10     	; 0x81c <__vector_15+0x54>
			{
				AlarmTable[i].Time = 0;
     812:	1b 82       	std	Y+3, r1	; 0x03
     814:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
     816:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
     818:	1d 82       	std	Y+5, r1	; 0x05
     81a:	1c 82       	std	Y+4, r1	; 0x04
     81c:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
     81e:	81 e0       	ldi	r24, 0x01	; 1
     820:	ca 3d       	cpi	r28, 0xDA	; 218
     822:	d8 07       	cpc	r29, r24
     824:	41 f7       	brne	.-48     	; 0x7f6 <__vector_15+0x2e>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
     826:	ff 91       	pop	r31
     828:	ef 91       	pop	r30
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	bf 91       	pop	r27
     830:	af 91       	pop	r26
     832:	9f 91       	pop	r25
     834:	8f 91       	pop	r24
     836:	7f 91       	pop	r23
     838:	6f 91       	pop	r22
     83a:	5f 91       	pop	r21
     83c:	4f 91       	pop	r20
     83e:	3f 91       	pop	r19
     840:	2f 91       	pop	r18
     842:	0f 90       	pop	r0
     844:	0b be       	out	0x3b, r0	; 59
     846:	0f 90       	pop	r0
     848:	0f be       	out	0x3f, r0	; 63
     84a:	0f 90       	pop	r0
     84c:	1f 90       	pop	r1
     84e:	18 95       	reti

00000850 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
     850:	80 e0       	ldi	r24, 0x00	; 0
     852:	08 95       	ret

00000854 <_ZN20DeviceDriveInterFace12Start_DeviceEh>:
	virtual void Device_Writes(const char* data){}
	virtual void Device_Write(char data){}
	virtual void Stop_Device(void){}
	virtual void Start_Device(unsigned char){}
     854:	08 95       	ret

00000856 <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
     856:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
     858:	8f ef       	ldi	r24, 0xFF	; 255
     85a:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
     85c:	ea e6       	ldi	r30, 0x6A	; 106
     85e:	f0 e0       	ldi	r31, 0x00	; 0
     860:	80 81       	ld	r24, Z
     862:	82 60       	ori	r24, 0x02	; 2
     864:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
     866:	80 81       	ld	r24, Z
     868:	8e 7f       	andi	r24, 0xFE	; 254
     86a:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
     86c:	89 b7       	in	r24, 0x39	; 57
     86e:	81 60       	ori	r24, 0x01	; 1
     870:	89 bf       	out	0x39, r24	; 57
     872:	08 95       	ret

00000874 <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
     874:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

00000878 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     878:	2a e0       	ldi	r18, 0x0A	; 10
     87a:	dc 01       	movw	r26, r24
     87c:	e2 2f       	mov	r30, r18
     87e:	1d 92       	st	X+, r1
     880:	ea 95       	dec	r30
     882:	e9 f7       	brne	.-6      	; 0x87e <_ZN11Dev_ManagerC1Ev+0x6>
     884:	fc 01       	movw	r30, r24
     886:	3a 96       	adiw	r30, 0x0a	; 10
     888:	df 01       	movw	r26, r30
     88a:	1d 92       	st	X+, r1
     88c:	2a 95       	dec	r18
     88e:	e9 f7       	brne	.-6      	; 0x88a <_ZN11Dev_ManagerC1Ev+0x12>
     890:	90 93 db 01 	sts	0x01DB, r25	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
     894:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <_ZN11Dev_Manager4instE>
     898:	08 95       	ret

0000089a <_ZN11Dev_Manager11getInstanceEv>:
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <_ZN11Dev_Manager4instE>
     8a2:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
     8a6:	89 2b       	or	r24, r25
     8a8:	51 f4       	brne	.+20     	; 0x8be <_ZN11Dev_Manager11getInstanceEv+0x24>
     8aa:	84 e1       	ldi	r24, 0x14	; 20
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	0e 94 8e 11 	call	0x231c	; 0x231c <pvPortMalloc>
     8b2:	ec 01       	movw	r28, r24
     8b4:	e1 df       	rcall	.-62     	; 0x878 <_ZN11Dev_ManagerC1Ev>
     8b6:	d0 93 db 01 	sts	0x01DB, r29	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
     8ba:	c0 93 da 01 	sts	0x01DA, r28	; 0x8001da <_ZN11Dev_Manager4instE>
     8be:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <_ZN11Dev_Manager4instE>
     8c2:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
     8c6:	df 91       	pop	r29
     8c8:	cf 91       	pop	r28
     8ca:	08 95       	ret

000008cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     8cc:	84 0f       	add	r24, r20
     8ce:	91 1d       	adc	r25, r1
     8d0:	84 0f       	add	r24, r20
     8d2:	91 1d       	adc	r25, r1
     8d4:	fc 01       	movw	r30, r24
     8d6:	71 83       	std	Z+1, r23	; 0x01
     8d8:	60 83       	st	Z, r22
     8da:	08 95       	ret

000008dc <_ZN11Dev_ManagernwEj>:
     8dc:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

000008e0 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     8e0:	86 0f       	add	r24, r22
     8e2:	91 1d       	adc	r25, r1
     8e4:	86 0f       	add	r24, r22
     8e6:	91 1d       	adc	r25, r1
     8e8:	dc 01       	movw	r26, r24
     8ea:	8d 91       	ld	r24, X+
     8ec:	9c 91       	ld	r25, X
     8ee:	00 97       	sbiw	r24, 0x00	; 0
     8f0:	41 f0       	breq	.+16     	; 0x902 <_ZN11Dev_Manager5WriteE8Dev_typec+0x22>
     8f2:	dc 01       	movw	r26, r24
     8f4:	ed 91       	ld	r30, X+
     8f6:	fc 91       	ld	r31, X
     8f8:	06 80       	ldd	r0, Z+6	; 0x06
     8fa:	f7 81       	ldd	r31, Z+7	; 0x07
     8fc:	e0 2d       	mov	r30, r0
     8fe:	64 2f       	mov	r22, r20
     900:	09 94       	ijmp
     902:	08 95       	ret

00000904 <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     904:	86 0f       	add	r24, r22
     906:	91 1d       	adc	r25, r1
     908:	86 0f       	add	r24, r22
     90a:	91 1d       	adc	r25, r1
     90c:	dc 01       	movw	r26, r24
     90e:	8d 91       	ld	r24, X+
     910:	9c 91       	ld	r25, X
     912:	00 97       	sbiw	r24, 0x00	; 0
     914:	41 f0       	breq	.+16     	; 0x926 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x22>
     916:	dc 01       	movw	r26, r24
     918:	ed 91       	ld	r30, X+
     91a:	fc 91       	ld	r31, X
     91c:	04 80       	ldd	r0, Z+4	; 0x04
     91e:	f5 81       	ldd	r31, Z+5	; 0x05
     920:	e0 2d       	mov	r30, r0
     922:	ba 01       	movw	r22, r20
     924:	09 94       	ijmp
     926:	08 95       	ret

00000928 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     928:	86 0f       	add	r24, r22
     92a:	91 1d       	adc	r25, r1
     92c:	86 0f       	add	r24, r22
     92e:	91 1d       	adc	r25, r1
     930:	dc 01       	movw	r26, r24
     932:	8d 91       	ld	r24, X+
     934:	9c 91       	ld	r25, X
     936:	00 97       	sbiw	r24, 0x00	; 0
     938:	39 f0       	breq	.+14     	; 0x948 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x20>
     93a:	dc 01       	movw	r26, r24
     93c:	ed 91       	ld	r30, X+
     93e:	fc 91       	ld	r31, X
     940:	01 90       	ld	r0, Z+
     942:	f0 81       	ld	r31, Z
     944:	e0 2d       	mov	r30, r0
     946:	09 94       	ijmp
     948:	08 95       	ret

0000094a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     94a:	86 0f       	add	r24, r22
     94c:	91 1d       	adc	r25, r1
     94e:	86 0f       	add	r24, r22
     950:	91 1d       	adc	r25, r1
     952:	fc 01       	movw	r30, r24
     954:	20 81       	ld	r18, Z
     956:	31 81       	ldd	r19, Z+1	; 0x01
     958:	23 2b       	or	r18, r19
     95a:	11 f0       	breq	.+4      	; 0x960 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x16>
     95c:	53 87       	std	Z+11, r21	; 0x0b
     95e:	42 87       	std	Z+10, r20	; 0x0a
     960:	08 95       	ret

00000962 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     962:	fc 01       	movw	r30, r24
     964:	e6 0f       	add	r30, r22
     966:	f1 1d       	adc	r31, r1
     968:	e6 0f       	add	r30, r22
     96a:	f1 1d       	adc	r31, r1
     96c:	81 e0       	ldi	r24, 0x01	; 1
     96e:	20 81       	ld	r18, Z
     970:	31 81       	ldd	r19, Z+1	; 0x01
     972:	23 2b       	or	r18, r19
     974:	09 f4       	brne	.+2      	; 0x978 <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x16>
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	08 95       	ret

0000097a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* const Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     97a:	86 0f       	add	r24, r22
     97c:	91 1d       	adc	r25, r1
     97e:	86 0f       	add	r24, r22
     980:	91 1d       	adc	r25, r1
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     982:	fc 01       	movw	r30, r24
     984:	80 81       	ld	r24, Z
     986:	91 81       	ldd	r25, Z+1	; 0x01
     988:	08 95       	ret

0000098a <__vector_18>:
ISR(USART0_RX_vect)
{
     98a:	1f 92       	push	r1
     98c:	0f 92       	push	r0
     98e:	0f b6       	in	r0, 0x3f	; 63
     990:	0f 92       	push	r0
     992:	11 24       	eor	r1, r1
     994:	0b b6       	in	r0, 0x3b	; 59
     996:	0f 92       	push	r0
     998:	2f 93       	push	r18
     99a:	3f 93       	push	r19
     99c:	4f 93       	push	r20
     99e:	5f 93       	push	r21
     9a0:	6f 93       	push	r22
     9a2:	7f 93       	push	r23
     9a4:	8f 93       	push	r24
     9a6:	9f 93       	push	r25
     9a8:	af 93       	push	r26
     9aa:	bf 93       	push	r27
     9ac:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     9ae:	ff 93       	push	r31
     9b0:	74 df       	rcall	.-280    	; 0x89a <_ZN11Dev_Manager11getInstanceEv>
     9b2:	6c b1       	in	r22, 0x0c	; 12
     9b4:	70 e0       	ldi	r23, 0x00	; 0
     9b6:	dc 01       	movw	r26, r24
     9b8:	1a 96       	adiw	r26, 0x0a	; 10
     9ba:	ed 91       	ld	r30, X+
     9bc:	fc 91       	ld	r31, X
     9be:	1b 97       	sbiw	r26, 0x0b	; 11
     9c0:	80 e0       	ldi	r24, 0x00	; 0
}
     9c2:	09 95       	icall
     9c4:	ff 91       	pop	r31
     9c6:	ef 91       	pop	r30
     9c8:	bf 91       	pop	r27
     9ca:	af 91       	pop	r26
     9cc:	9f 91       	pop	r25
     9ce:	8f 91       	pop	r24
     9d0:	7f 91       	pop	r23
     9d2:	6f 91       	pop	r22
     9d4:	5f 91       	pop	r21
     9d6:	4f 91       	pop	r20
     9d8:	3f 91       	pop	r19
     9da:	2f 91       	pop	r18
     9dc:	0f 90       	pop	r0
     9de:	0b be       	out	0x3b, r0	; 59
     9e0:	0f 90       	pop	r0
     9e2:	0f be       	out	0x3f, r0	; 63
     9e4:	0f 90       	pop	r0
     9e6:	1f 90       	pop	r1
     9e8:	18 95       	reti

000009ea <__vector_30>:
ISR(USART1_RX_vect)
{
     9ea:	1f 92       	push	r1
     9ec:	0f 92       	push	r0
     9ee:	0f b6       	in	r0, 0x3f	; 63
     9f0:	0f 92       	push	r0
     9f2:	11 24       	eor	r1, r1
     9f4:	0b b6       	in	r0, 0x3b	; 59
     9f6:	0f 92       	push	r0
     9f8:	2f 93       	push	r18
     9fa:	3f 93       	push	r19
     9fc:	4f 93       	push	r20
     9fe:	5f 93       	push	r21
     a00:	6f 93       	push	r22
     a02:	7f 93       	push	r23
     a04:	8f 93       	push	r24
     a06:	9f 93       	push	r25
     a08:	af 93       	push	r26
     a0a:	bf 93       	push	r27
     a0c:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     a0e:	ff 93       	push	r31
     a10:	44 df       	rcall	.-376    	; 0x89a <_ZN11Dev_Manager11getInstanceEv>
     a12:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     a16:	70 e0       	ldi	r23, 0x00	; 0
     a18:	dc 01       	movw	r26, r24
     a1a:	1c 96       	adiw	r26, 0x0c	; 12
     a1c:	ed 91       	ld	r30, X+
     a1e:	fc 91       	ld	r31, X
     a20:	1d 97       	sbiw	r26, 0x0d	; 13
     a22:	81 e0       	ldi	r24, 0x01	; 1
}
     a24:	09 95       	icall
     a26:	ff 91       	pop	r31
     a28:	ef 91       	pop	r30
     a2a:	bf 91       	pop	r27
     a2c:	af 91       	pop	r26
     a2e:	9f 91       	pop	r25
     a30:	8f 91       	pop	r24
     a32:	7f 91       	pop	r23
     a34:	6f 91       	pop	r22
     a36:	5f 91       	pop	r21
     a38:	4f 91       	pop	r20
     a3a:	3f 91       	pop	r19
     a3c:	2f 91       	pop	r18
     a3e:	0f 90       	pop	r0
     a40:	0b be       	out	0x3b, r0	; 59
     a42:	0f 90       	pop	r0
     a44:	0f be       	out	0x3f, r0	; 63
     a46:	0f 90       	pop	r0
     a48:	1f 90       	pop	r1
     a4a:	18 95       	reti

00000a4c <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     a4c:	1f 92       	push	r1
     a4e:	0f 92       	push	r0
     a50:	0f b6       	in	r0, 0x3f	; 63
     a52:	0f 92       	push	r0
     a54:	11 24       	eor	r1, r1
     a56:	0b b6       	in	r0, 0x3b	; 59
     a58:	0f 92       	push	r0
     a5a:	2f 93       	push	r18
     a5c:	3f 93       	push	r19
     a5e:	4f 93       	push	r20
     a60:	5f 93       	push	r21
     a62:	6f 93       	push	r22
     a64:	7f 93       	push	r23
     a66:	8f 93       	push	r24
     a68:	9f 93       	push	r25
     a6a:	af 93       	push	r26
     a6c:	bf 93       	push	r27
     a6e:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
     a70:	ff 93       	push	r31
     a72:	13 df       	rcall	.-474    	; 0x89a <_ZN11Dev_Manager11getInstanceEv>
     a74:	dc 01       	movw	r26, r24
     a76:	1e 96       	adiw	r26, 0x0e	; 14
     a78:	ed 91       	ld	r30, X+
     a7a:	fc 91       	ld	r31, X
     a7c:	1f 97       	sbiw	r26, 0x0f	; 15
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	70 e0       	ldi	r23, 0x00	; 0
     a82:	82 e0       	ldi	r24, 0x02	; 2
}
     a84:	09 95       	icall
     a86:	ff 91       	pop	r31
     a88:	ef 91       	pop	r30
     a8a:	bf 91       	pop	r27
     a8c:	af 91       	pop	r26
     a8e:	9f 91       	pop	r25
     a90:	8f 91       	pop	r24
     a92:	7f 91       	pop	r23
     a94:	6f 91       	pop	r22
     a96:	5f 91       	pop	r21
     a98:	4f 91       	pop	r20
     a9a:	3f 91       	pop	r19
     a9c:	2f 91       	pop	r18
     a9e:	0f 90       	pop	r0
     aa0:	0b be       	out	0x3b, r0	; 59
     aa2:	0f 90       	pop	r0
     aa4:	0f be       	out	0x3f, r0	; 63
     aa6:	0f 90       	pop	r0
     aa8:	1f 90       	pop	r1
     aaa:	18 95       	reti

00000aac <__vector_1>:
ISR(INT0_vect)
{
     aac:	1f 92       	push	r1
     aae:	0f 92       	push	r0
     ab0:	0f b6       	in	r0, 0x3f	; 63
     ab2:	0f 92       	push	r0
     ab4:	11 24       	eor	r1, r1
     ab6:	0b b6       	in	r0, 0x3b	; 59
     ab8:	0f 92       	push	r0
     aba:	2f 93       	push	r18
     abc:	3f 93       	push	r19
     abe:	4f 93       	push	r20
     ac0:	5f 93       	push	r21
     ac2:	6f 93       	push	r22
     ac4:	7f 93       	push	r23
     ac6:	8f 93       	push	r24
     ac8:	9f 93       	push	r25
     aca:	af 93       	push	r26
     acc:	bf 93       	push	r27
     ace:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
     ad0:	ff 93       	push	r31
     ad2:	e3 de       	rcall	.-570    	; 0x89a <_ZN11Dev_Manager11getInstanceEv>
     ad4:	dc 01       	movw	r26, r24
     ad6:	50 96       	adiw	r26, 0x10	; 16
     ad8:	ed 91       	ld	r30, X+
     ada:	fc 91       	ld	r31, X
     adc:	51 97       	sbiw	r26, 0x11	; 17
     ade:	60 e0       	ldi	r22, 0x00	; 0
     ae0:	70 e0       	ldi	r23, 0x00	; 0
     ae2:	83 e0       	ldi	r24, 0x03	; 3
}
     ae4:	09 95       	icall
     ae6:	ff 91       	pop	r31
     ae8:	ef 91       	pop	r30
     aea:	bf 91       	pop	r27
     aec:	af 91       	pop	r26
     aee:	9f 91       	pop	r25
     af0:	8f 91       	pop	r24
     af2:	7f 91       	pop	r23
     af4:	6f 91       	pop	r22
     af6:	5f 91       	pop	r21
     af8:	4f 91       	pop	r20
     afa:	3f 91       	pop	r19
     afc:	2f 91       	pop	r18
     afe:	0f 90       	pop	r0
     b00:	0b be       	out	0x3b, r0	; 59
     b02:	0f 90       	pop	r0
     b04:	0f be       	out	0x3f, r0	; 63
     b06:	0f 90       	pop	r0
     b08:	1f 90       	pop	r1
     b0a:	18 95       	reti

00000b0c <__vector_21>:
ISR(ADC_vect)
{	
     b0c:	1f 92       	push	r1
     b0e:	0f 92       	push	r0
     b10:	0f b6       	in	r0, 0x3f	; 63
     b12:	0f 92       	push	r0
     b14:	11 24       	eor	r1, r1
     b16:	0b b6       	in	r0, 0x3b	; 59
     b18:	0f 92       	push	r0
     b1a:	2f 93       	push	r18
     b1c:	3f 93       	push	r19
     b1e:	4f 93       	push	r20
     b20:	5f 93       	push	r21
     b22:	6f 93       	push	r22
     b24:	7f 93       	push	r23
     b26:	8f 93       	push	r24
     b28:	9f 93       	push	r25
     b2a:	af 93       	push	r26
     b2c:	bf 93       	push	r27
     b2e:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[_ADC](_ADC,ADCL+((uint16_t)ADCH << 8));
     b30:	ff 93       	push	r31
     b32:	b3 de       	rcall	.-666    	; 0x89a <_ZN11Dev_Manager11getInstanceEv>
     b34:	24 b1       	in	r18, 0x04	; 4
     b36:	65 b1       	in	r22, 0x05	; 5
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	76 2f       	mov	r23, r22
     b3c:	66 27       	eor	r22, r22
     b3e:	62 0f       	add	r22, r18
     b40:	71 1d       	adc	r23, r1
     b42:	dc 01       	movw	r26, r24
     b44:	52 96       	adiw	r26, 0x12	; 18
     b46:	ed 91       	ld	r30, X+
     b48:	fc 91       	ld	r31, X
     b4a:	53 97       	sbiw	r26, 0x13	; 19
     b4c:	84 e0       	ldi	r24, 0x04	; 4
}
     b4e:	09 95       	icall
     b50:	ff 91       	pop	r31
     b52:	ef 91       	pop	r30
     b54:	bf 91       	pop	r27
     b56:	af 91       	pop	r26
     b58:	9f 91       	pop	r25
     b5a:	8f 91       	pop	r24
     b5c:	7f 91       	pop	r23
     b5e:	6f 91       	pop	r22
     b60:	5f 91       	pop	r21
     b62:	4f 91       	pop	r20
     b64:	3f 91       	pop	r19
     b66:	2f 91       	pop	r18
     b68:	0f 90       	pop	r0
     b6a:	0b be       	out	0x3b, r0	; 59
     b6c:	0f 90       	pop	r0
     b6e:	0f be       	out	0x3f, r0	; 63
     b70:	0f 90       	pop	r0
     b72:	1f 90       	pop	r1
     b74:	18 95       	reti

00000b76 <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
     b76:	80 e4       	ldi	r24, 0x40	; 64
     b78:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
     b7c:	84 e0       	ldi	r24, 0x04	; 4
     b7e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
     b82:	88 e0       	ldi	r24, 0x08	; 8
     b84:	9d e3       	ldi	r25, 0x3D	; 61
     b86:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     b8a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
     b8e:	82 e0       	ldi	r24, 0x02	; 2
     b90:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     b94:	08 95       	ret

00000b96 <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
     b96:	2b e2       	ldi	r18, 0x2B	; 43
     b98:	31 e0       	ldi	r19, 0x01	; 1
     b9a:	fc 01       	movw	r30, r24
     b9c:	31 83       	std	Z+1, r19	; 0x01
     b9e:	20 83       	st	Z, r18
     ba0:	08 95       	ret

00000ba2 <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
     ba2:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

00000ba6 <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
     baa:	ec 01       	movw	r28, r24
     bac:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     bb0:	88 e9       	ldi	r24, 0x98	; 152
     bb2:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     bb6:	86 e0       	ldi	r24, 0x06	; 6
     bb8:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     bbc:	be 01       	movw	r22, r28
     bbe:	6e 5f       	subi	r22, 0xFE	; 254
     bc0:	7f 4f       	sbci	r23, 0xFF	; 255
     bc2:	ce 01       	movw	r24, r28
     bc4:	28 d1       	rcall	.+592    	; 0xe16 <_ZN4Ubbr10Ubbr_ValueERKj>
     bc6:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     bca:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <xQueueCreateMutex>
     bd4:	9f 83       	std	Y+7, r25	; 0x07
     bd6:	8e 83       	std	Y+6, r24	; 0x06
     bd8:	81 e0       	ldi	r24, 0x01	; 1
     bda:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <xQueueCreateMutex>
     bde:	9d 83       	std	Y+5, r25	; 0x05
     be0:	8c 83       	std	Y+4, r24	; 0x04
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	08 95       	ret

00000be8 <_ZN11RS485DriverC1Ev>:
     be8:	2b e3       	ldi	r18, 0x3B	; 59
     bea:	31 e0       	ldi	r19, 0x01	; 1
     bec:	fc 01       	movw	r30, r24
     bee:	31 83       	std	Z+1, r19	; 0x01
     bf0:	20 83       	st	Z, r18
     bf2:	20 e8       	ldi	r18, 0x80	; 128
     bf4:	35 e2       	ldi	r19, 0x25	; 37
     bf6:	33 83       	std	Z+3, r19	; 0x03
     bf8:	22 83       	std	Z+2, r18	; 0x02
     bfa:	20 91 dc 01 	lds	r18, 0x01DC	; 0x8001dc <_ZN11RS485Driver4instE>
     bfe:	30 91 dd 01 	lds	r19, 0x01DD	; 0x8001dd <_ZN11RS485Driver4instE+0x1>
     c02:	23 2b       	or	r18, r19
     c04:	21 f4       	brne	.+8      	; 0xc0e <_ZN11RS485DriverC1Ev+0x26>
     c06:	90 93 dd 01 	sts	0x01DD, r25	; 0x8001dd <_ZN11RS485Driver4instE+0x1>
     c0a:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <_ZN11RS485Driver4instE>
     c0e:	08 95       	ret

00000c10 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     c10:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

00000c14 <_ZN11RS485Driver12UART_PutcharEc>:
}
void RS485Driver::UART_Putchar(const char data)
{
     c14:	1f 93       	push	r17
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
     c1a:	ec 01       	movw	r28, r24
     c1c:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     c1e:	20 e0       	ldi	r18, 0x00	; 0
     c20:	44 e6       	ldi	r20, 0x64	; 100
     c22:	50 e0       	ldi	r21, 0x00	; 0
     c24:	60 e0       	ldi	r22, 0x00	; 0
     c26:	70 e0       	ldi	r23, 0x00	; 0
     c28:	8c 81       	ldd	r24, Y+4	; 0x04
     c2a:	9d 81       	ldd	r25, Y+5	; 0x05
     c2c:	0e 94 44 15 	call	0x2a88	; 0x2a88 <xQueueGenericReceive>
     c30:	81 30       	cpi	r24, 0x01	; 1
     c32:	91 f4       	brne	.+36     	; 0xc58 <_ZN11RS485Driver12UART_PutcharEc+0x44>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     c34:	80 91 9b 00 	lds	r24, 0x009B	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     c38:	85 ff       	sbrs	r24, 5
     c3a:	fc cf       	rjmp	.-8      	; 0xc34 <_ZN11RS485Driver12UART_PutcharEc+0x20>
		UDR1 = data;
     c3c:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     c40:	20 e0       	ldi	r18, 0x00	; 0
     c42:	40 e0       	ldi	r20, 0x00	; 0
     c44:	50 e0       	ldi	r21, 0x00	; 0
     c46:	60 e0       	ldi	r22, 0x00	; 0
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	8c 81       	ldd	r24, Y+4	; 0x04
     c4c:	9d 81       	ldd	r25, Y+5	; 0x05
	}
}
     c4e:	df 91       	pop	r29
     c50:	cf 91       	pop	r28
     c52:	1f 91       	pop	r17
{
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
		UDR1 = data;
		xSemaphoreGive(char_Mutex);
     c54:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <xQueueGenericSend>
	}
}
     c58:	df 91       	pop	r29
     c5a:	cf 91       	pop	r28
     c5c:	1f 91       	pop	r17
     c5e:	08 95       	ret

00000c60 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     c60:	d9 cf       	rjmp	.-78     	; 0xc14 <_ZN11RS485Driver12UART_PutcharEc>

00000c62 <_ZN11RS485Driver14UART_PutStringEPKc>:
     c62:	ef 92       	push	r14
     c64:	ff 92       	push	r15
     c66:	0f 93       	push	r16
     c68:	1f 93       	push	r17
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	8c 01       	movw	r16, r24
     c70:	7b 01       	movw	r14, r22
     c72:	20 e0       	ldi	r18, 0x00	; 0
     c74:	44 e6       	ldi	r20, 0x64	; 100
     c76:	50 e0       	ldi	r21, 0x00	; 0
     c78:	60 e0       	ldi	r22, 0x00	; 0
     c7a:	70 e0       	ldi	r23, 0x00	; 0
     c7c:	fc 01       	movw	r30, r24
     c7e:	86 81       	ldd	r24, Z+6	; 0x06
     c80:	97 81       	ldd	r25, Z+7	; 0x07
     c82:	0e 94 44 15 	call	0x2a88	; 0x2a88 <xQueueGenericReceive>
     c86:	81 30       	cpi	r24, 0x01	; 1
     c88:	b9 f4       	brne	.+46     	; 0xcb8 <_ZN11RS485Driver14UART_PutStringEPKc+0x56>
     c8a:	e7 01       	movw	r28, r14
     c8c:	69 91       	ld	r22, Y+
     c8e:	66 23       	and	r22, r22
     c90:	19 f0       	breq	.+6      	; 0xc98 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     c92:	c8 01       	movw	r24, r16
     c94:	bf df       	rcall	.-130    	; 0xc14 <_ZN11RS485Driver12UART_PutcharEc>
     c96:	fa cf       	rjmp	.-12     	; 0xc8c <_ZN11RS485Driver14UART_PutStringEPKc+0x2a>
     c98:	20 e0       	ldi	r18, 0x00	; 0
     c9a:	40 e0       	ldi	r20, 0x00	; 0
     c9c:	50 e0       	ldi	r21, 0x00	; 0
     c9e:	60 e0       	ldi	r22, 0x00	; 0
     ca0:	70 e0       	ldi	r23, 0x00	; 0
     ca2:	f8 01       	movw	r30, r16
     ca4:	86 81       	ldd	r24, Z+6	; 0x06
     ca6:	97 81       	ldd	r25, Z+7	; 0x07
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	ff 90       	pop	r15
     cb2:	ef 90       	pop	r14
     cb4:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <xQueueGenericSend>
     cb8:	df 91       	pop	r29
     cba:	cf 91       	pop	r28
     cbc:	1f 91       	pop	r17
     cbe:	0f 91       	pop	r16
     cc0:	ff 90       	pop	r15
     cc2:	ef 90       	pop	r14
     cc4:	08 95       	ret

00000cc6 <_ZN11RS485Driver13Device_WritesEPKc>:
     cc6:	cd cf       	rjmp	.-102    	; 0xc62 <_ZN11RS485Driver14UART_PutStringEPKc>

00000cc8 <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
     cc8:	1f 92       	push	r1
     cca:	0f 92       	push	r0
     ccc:	0f b6       	in	r0, 0x3f	; 63
     cce:	0f 92       	push	r0
     cd0:	11 24       	eor	r1, r1
     cd2:	0b b6       	in	r0, 0x3b	; 59
     cd4:	0f 92       	push	r0
     cd6:	8f 93       	push	r24
     cd8:	9f 93       	push	r25
     cda:	ef 93       	push	r30
     cdc:	ff 93       	push	r31
	mem4[3]++;
     cde:	e4 ec       	ldi	r30, 0xC4	; 196
     ce0:	f2 e0       	ldi	r31, 0x02	; 2
     ce2:	86 81       	ldd	r24, Z+6	; 0x06
     ce4:	97 81       	ldd	r25, Z+7	; 0x07
     ce6:	01 96       	adiw	r24, 0x01	; 1
     ce8:	97 83       	std	Z+7, r25	; 0x07
     cea:	86 83       	std	Z+6, r24	; 0x06
}
     cec:	ff 91       	pop	r31
     cee:	ef 91       	pop	r30
     cf0:	9f 91       	pop	r25
     cf2:	8f 91       	pop	r24
     cf4:	0f 90       	pop	r0
     cf6:	0b be       	out	0x3b, r0	; 59
     cf8:	0f 90       	pop	r0
     cfa:	0f be       	out	0x3f, r0	; 63
     cfc:	0f 90       	pop	r0
     cfe:	1f 90       	pop	r1
     d00:	18 95       	reti

00000d02 <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     d02:	cf 93       	push	r28
     d04:	df 93       	push	r29
     d06:	ec 01       	movw	r28, r24
     d08:	88 e9       	ldi	r24, 0x98	; 152
     d0a:	8a b9       	out	0x0a, r24	; 10
     d0c:	86 e0       	ldi	r24, 0x06	; 6
     d0e:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     d12:	be 01       	movw	r22, r28
     d14:	6e 5f       	subi	r22, 0xFE	; 254
     d16:	7f 4f       	sbci	r23, 0xFF	; 255
     d18:	ce 01       	movw	r24, r28
     d1a:	7d d0       	rcall	.+250    	; 0xe16 <_ZN4Ubbr10Ubbr_ValueERKj>
     d1c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     d20:	99 b9       	out	0x09, r25	; 9
     d22:	81 e0       	ldi	r24, 0x01	; 1
     d24:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <xQueueCreateMutex>
     d28:	9f 83       	std	Y+7, r25	; 0x07
     d2a:	8e 83       	std	Y+6, r24	; 0x06
     d2c:	81 e0       	ldi	r24, 0x01	; 1
     d2e:	0e 94 2c 15 	call	0x2a58	; 0x2a58 <xQueueCreateMutex>
     d32:	9d 83       	std	Y+5, r25	; 0x05
     d34:	8c 83       	std	Y+4, r24	; 0x04
     d36:	df 91       	pop	r29
     d38:	cf 91       	pop	r28
     d3a:	08 95       	ret

00000d3c <_ZN10UartDriverC1Ev>:
     d3c:	2b e4       	ldi	r18, 0x4B	; 75
     d3e:	31 e0       	ldi	r19, 0x01	; 1
     d40:	fc 01       	movw	r30, r24
     d42:	31 83       	std	Z+1, r19	; 0x01
     d44:	20 83       	st	Z, r18
     d46:	20 e4       	ldi	r18, 0x40	; 64
     d48:	38 e3       	ldi	r19, 0x38	; 56
     d4a:	33 83       	std	Z+3, r19	; 0x03
     d4c:	22 83       	std	Z+2, r18	; 0x02
     d4e:	20 91 de 01 	lds	r18, 0x01DE	; 0x8001de <_ZN10UartDriver4instE>
     d52:	30 91 df 01 	lds	r19, 0x01DF	; 0x8001df <_ZN10UartDriver4instE+0x1>
     d56:	23 2b       	or	r18, r19
     d58:	21 f4       	brne	.+8      	; 0xd62 <_ZN10UartDriverC1Ev+0x26>
     d5a:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <_ZN10UartDriver4instE+0x1>
     d5e:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <_ZN10UartDriver4instE>
     d62:	08 95       	ret

00000d64 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     d64:	0c 94 8e 11 	jmp	0x231c	; 0x231c <pvPortMalloc>

00000d68 <_ZN10UartDriver12UART_PutcharEc>:
}
void UartDriver::UART_Putchar(const char data)
{
     d68:	1f 93       	push	r17
     d6a:	cf 93       	push	r28
     d6c:	df 93       	push	r29
     d6e:	ec 01       	movw	r28, r24
     d70:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     d72:	20 e0       	ldi	r18, 0x00	; 0
     d74:	44 e6       	ldi	r20, 0x64	; 100
     d76:	50 e0       	ldi	r21, 0x00	; 0
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	70 e0       	ldi	r23, 0x00	; 0
     d7c:	8c 81       	ldd	r24, Y+4	; 0x04
     d7e:	9d 81       	ldd	r25, Y+5	; 0x05
     d80:	0e 94 44 15 	call	0x2a88	; 0x2a88 <xQueueGenericReceive>
     d84:	81 30       	cpi	r24, 0x01	; 1
     d86:	79 f4       	brne	.+30     	; 0xda6 <_ZN10UartDriver12UART_PutcharEc+0x3e>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     d88:	5d 9b       	sbis	0x0b, 5	; 11
     d8a:	fe cf       	rjmp	.-4      	; 0xd88 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     d8c:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     d8e:	20 e0       	ldi	r18, 0x00	; 0
     d90:	40 e0       	ldi	r20, 0x00	; 0
     d92:	50 e0       	ldi	r21, 0x00	; 0
     d94:	60 e0       	ldi	r22, 0x00	; 0
     d96:	70 e0       	ldi	r23, 0x00	; 0
     d98:	8c 81       	ldd	r24, Y+4	; 0x04
     d9a:	9d 81       	ldd	r25, Y+5	; 0x05
	}
}
     d9c:	df 91       	pop	r29
     d9e:	cf 91       	pop	r28
     da0:	1f 91       	pop	r17
{
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
		UDR0 = data;
		xSemaphoreGive(char_Mutex);
     da2:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <xQueueGenericSend>
	}
}
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	1f 91       	pop	r17
     dac:	08 95       	ret

00000dae <_ZN10UartDriver12Device_WriteEc>:
     dae:	dc cf       	rjmp	.-72     	; 0xd68 <_ZN10UartDriver12UART_PutcharEc>

00000db0 <_ZN10UartDriver14UART_PutStringEPKc>:
     db0:	ef 92       	push	r14
     db2:	ff 92       	push	r15
     db4:	0f 93       	push	r16
     db6:	1f 93       	push	r17
     db8:	cf 93       	push	r28
     dba:	df 93       	push	r29
     dbc:	8c 01       	movw	r16, r24
     dbe:	7b 01       	movw	r14, r22
     dc0:	20 e0       	ldi	r18, 0x00	; 0
     dc2:	44 e6       	ldi	r20, 0x64	; 100
     dc4:	50 e0       	ldi	r21, 0x00	; 0
     dc6:	60 e0       	ldi	r22, 0x00	; 0
     dc8:	70 e0       	ldi	r23, 0x00	; 0
     dca:	fc 01       	movw	r30, r24
     dcc:	86 81       	ldd	r24, Z+6	; 0x06
     dce:	97 81       	ldd	r25, Z+7	; 0x07
     dd0:	0e 94 44 15 	call	0x2a88	; 0x2a88 <xQueueGenericReceive>
     dd4:	81 30       	cpi	r24, 0x01	; 1
     dd6:	b9 f4       	brne	.+46     	; 0xe06 <_ZN10UartDriver14UART_PutStringEPKc+0x56>
     dd8:	e7 01       	movw	r28, r14
     dda:	69 91       	ld	r22, Y+
     ddc:	66 23       	and	r22, r22
     dde:	19 f0       	breq	.+6      	; 0xde6 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     de0:	c8 01       	movw	r24, r16
     de2:	c2 df       	rcall	.-124    	; 0xd68 <_ZN10UartDriver12UART_PutcharEc>
     de4:	fa cf       	rjmp	.-12     	; 0xdda <_ZN10UartDriver14UART_PutStringEPKc+0x2a>
     de6:	20 e0       	ldi	r18, 0x00	; 0
     de8:	40 e0       	ldi	r20, 0x00	; 0
     dea:	50 e0       	ldi	r21, 0x00	; 0
     dec:	60 e0       	ldi	r22, 0x00	; 0
     dee:	70 e0       	ldi	r23, 0x00	; 0
     df0:	f8 01       	movw	r30, r16
     df2:	86 81       	ldd	r24, Z+6	; 0x06
     df4:	97 81       	ldd	r25, Z+7	; 0x07
     df6:	df 91       	pop	r29
     df8:	cf 91       	pop	r28
     dfa:	1f 91       	pop	r17
     dfc:	0f 91       	pop	r16
     dfe:	ff 90       	pop	r15
     e00:	ef 90       	pop	r14
     e02:	0c 94 a4 14 	jmp	0x2948	; 0x2948 <xQueueGenericSend>
     e06:	df 91       	pop	r29
     e08:	cf 91       	pop	r28
     e0a:	1f 91       	pop	r17
     e0c:	0f 91       	pop	r16
     e0e:	ff 90       	pop	r15
     e10:	ef 90       	pop	r14
     e12:	08 95       	ret

00000e14 <_ZN10UartDriver13Device_WritesEPKc>:
     e14:	cd cf       	rjmp	.-102    	; 0xdb0 <_ZN10UartDriver14UART_PutStringEPKc>

00000e16 <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     e16:	cf 92       	push	r12
     e18:	df 92       	push	r13
     e1a:	ef 92       	push	r14
     e1c:	ff 92       	push	r15
     e1e:	cf 93       	push	r28
     e20:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
     e22:	fb 01       	movw	r30, r22
     e24:	20 81       	ld	r18, Z
     e26:	31 81       	ldd	r19, Z+1	; 0x01
	float ubbr_h = (uint16_t)(temp + 0.5);
     e28:	c9 01       	movw	r24, r18
     e2a:	a0 e0       	ldi	r26, 0x00	; 0
     e2c:	b0 e0       	ldi	r27, 0x00	; 0
     e2e:	9c 01       	movw	r18, r24
     e30:	ad 01       	movw	r20, r26
     e32:	84 e0       	ldi	r24, 0x04	; 4
     e34:	22 0f       	add	r18, r18
     e36:	33 1f       	adc	r19, r19
     e38:	44 1f       	adc	r20, r20
     e3a:	55 1f       	adc	r21, r21
     e3c:	8a 95       	dec	r24
     e3e:	d1 f7       	brne	.-12     	; 0xe34 <_ZN4Ubbr10Ubbr_ValueERKj+0x1e>
     e40:	60 e0       	ldi	r22, 0x00	; 0
     e42:	74 e2       	ldi	r23, 0x24	; 36
     e44:	84 ef       	ldi	r24, 0xF4	; 244
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	0e 94 83 1c 	call	0x3906	; 0x3906 <__udivmodsi4>
     e4c:	ca 01       	movw	r24, r20
     e4e:	b9 01       	movw	r22, r18
     e50:	61 50       	subi	r22, 0x01	; 1
     e52:	71 09       	sbc	r23, r1
     e54:	81 09       	sbc	r24, r1
     e56:	91 09       	sbc	r25, r1
     e58:	0e 94 4a 1b 	call	0x3694	; 0x3694 <__floatunsisf>
     e5c:	20 e0       	ldi	r18, 0x00	; 0
     e5e:	30 e0       	ldi	r19, 0x00	; 0
     e60:	40 e0       	ldi	r20, 0x00	; 0
     e62:	5f e3       	ldi	r21, 0x3F	; 63
     e64:	0e 94 4d 1a 	call	0x349a	; 0x349a <__addsf3>
     e68:	6b 01       	movw	r12, r22
     e6a:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     e6c:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
     e70:	d6 2f       	mov	r29, r22
     e72:	f0 e0       	ldi	r31, 0x00	; 0
     e74:	cf 2f       	mov	r28, r31
     e76:	c7 01       	movw	r24, r14
     e78:	b6 01       	movw	r22, r12
     e7a:	0e 94 1e 1b 	call	0x363c	; 0x363c <__fixunssfsi>
}
     e7e:	ce 01       	movw	r24, r28
     e80:	86 2b       	or	r24, r22
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	ff 90       	pop	r15
     e88:	ef 90       	pop	r14
     e8a:	df 90       	pop	r13
     e8c:	cf 90       	pop	r12
     e8e:	08 95       	ret

00000e90 <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     e90:	c0 98       	cbi	0x18, 0	; 24
     e92:	96 2f       	mov	r25, r22
     e94:	9f 71       	andi	r25, 0x1F	; 31
     e96:	89 2b       	or	r24, r25
     e98:	8f b9       	out	0x0f, r24	; 15
     e9a:	77 9b       	sbis	0x0e, 7	; 14
     e9c:	fe cf       	rjmp	.-4      	; 0xe9a <_Z14enc28j60ReadOphh+0xa>
     e9e:	1f b8       	out	0x0f, r1	; 15
     ea0:	77 9b       	sbis	0x0e, 7	; 14
     ea2:	fe cf       	rjmp	.-4      	; 0xea0 <_Z14enc28j60ReadOphh+0x10>
     ea4:	67 fd       	sbrc	r22, 7
     ea6:	03 c0       	rjmp	.+6      	; 0xeae <_Z14enc28j60ReadOphh+0x1e>
     ea8:	c0 9a       	sbi	0x18, 0	; 24
     eaa:	8f b1       	in	r24, 0x0f	; 15
     eac:	08 95       	ret
     eae:	1f b8       	out	0x0f, r1	; 15
     eb0:	77 9b       	sbis	0x0e, 7	; 14
     eb2:	fe cf       	rjmp	.-4      	; 0xeb0 <_Z14enc28j60ReadOphh+0x20>
     eb4:	f9 cf       	rjmp	.-14     	; 0xea8 <_Z14enc28j60ReadOphh+0x18>

00000eb6 <_Z15enc28j60WriteOphhh>:
     eb6:	c0 98       	cbi	0x18, 0	; 24
     eb8:	6f 71       	andi	r22, 0x1F	; 31
     eba:	86 2b       	or	r24, r22
     ebc:	8f b9       	out	0x0f, r24	; 15
     ebe:	77 9b       	sbis	0x0e, 7	; 14
     ec0:	fe cf       	rjmp	.-4      	; 0xebe <_Z15enc28j60WriteOphhh+0x8>
     ec2:	4f b9       	out	0x0f, r20	; 15
     ec4:	77 9b       	sbis	0x0e, 7	; 14
     ec6:	fe cf       	rjmp	.-4      	; 0xec4 <_Z15enc28j60WriteOphhh+0xe>
     ec8:	c0 9a       	sbi	0x18, 0	; 24
     eca:	08 95       	ret

00000ecc <_Z18enc28j60ReadBufferjPh>:
     ecc:	fb 01       	movw	r30, r22
     ece:	c0 98       	cbi	0x18, 0	; 24
     ed0:	2a e3       	ldi	r18, 0x3A	; 58
     ed2:	2f b9       	out	0x0f, r18	; 15
     ed4:	77 9b       	sbis	0x0e, 7	; 14
     ed6:	fe cf       	rjmp	.-4      	; 0xed4 <_Z18enc28j60ReadBufferjPh+0x8>
     ed8:	8e 0f       	add	r24, r30
     eda:	9f 1f       	adc	r25, r31
     edc:	e8 17       	cp	r30, r24
     ede:	f9 07       	cpc	r31, r25
     ee0:	31 f0       	breq	.+12     	; 0xeee <_Z18enc28j60ReadBufferjPh+0x22>
     ee2:	1f b8       	out	0x0f, r1	; 15
     ee4:	77 9b       	sbis	0x0e, 7	; 14
     ee6:	fe cf       	rjmp	.-4      	; 0xee4 <_Z18enc28j60ReadBufferjPh+0x18>
     ee8:	2f b1       	in	r18, 0x0f	; 15
     eea:	21 93       	st	Z+, r18
     eec:	f7 cf       	rjmp	.-18     	; 0xedc <_Z18enc28j60ReadBufferjPh+0x10>
     eee:	10 82       	st	Z, r1
     ef0:	c0 9a       	sbi	0x18, 0	; 24
     ef2:	08 95       	ret

00000ef4 <_Z19enc28j60WriteBufferjPh>:
     ef4:	c0 98       	cbi	0x18, 0	; 24
     ef6:	2a e7       	ldi	r18, 0x7A	; 122
     ef8:	2f b9       	out	0x0f, r18	; 15
     efa:	77 9b       	sbis	0x0e, 7	; 14
     efc:	fe cf       	rjmp	.-4      	; 0xefa <_Z19enc28j60WriteBufferjPh+0x6>
     efe:	86 0f       	add	r24, r22
     f00:	97 1f       	adc	r25, r23
     f02:	68 17       	cp	r22, r24
     f04:	79 07       	cpc	r23, r25
     f06:	39 f0       	breq	.+14     	; 0xf16 <_Z19enc28j60WriteBufferjPh+0x22>
     f08:	fb 01       	movw	r30, r22
     f0a:	21 91       	ld	r18, Z+
     f0c:	bf 01       	movw	r22, r30
     f0e:	2f b9       	out	0x0f, r18	; 15
     f10:	77 9b       	sbis	0x0e, 7	; 14
     f12:	fe cf       	rjmp	.-4      	; 0xf10 <_Z19enc28j60WriteBufferjPh+0x1c>
     f14:	f6 cf       	rjmp	.-20     	; 0xf02 <_Z19enc28j60WriteBufferjPh+0xe>
     f16:	c0 9a       	sbi	0x18, 0	; 24
     f18:	08 95       	ret

00000f1a <_Z15enc28j60SetBankh>:
     f1a:	1f 93       	push	r17
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	18 2f       	mov	r17, r24
     f22:	10 76       	andi	r17, 0x60	; 96
     f24:	c1 2f       	mov	r28, r17
     f26:	d0 e0       	ldi	r29, 0x00	; 0
     f28:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <_ZL12Enc28j60Bank>
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	c8 17       	cp	r28, r24
     f30:	d9 07       	cpc	r29, r25
     f32:	79 f0       	breq	.+30     	; 0xf52 <_Z15enc28j60SetBankh+0x38>
     f34:	43 e0       	ldi	r20, 0x03	; 3
     f36:	6f e1       	ldi	r22, 0x1F	; 31
     f38:	80 ea       	ldi	r24, 0xA0	; 160
     f3a:	bd df       	rcall	.-134    	; 0xeb6 <_Z15enc28j60WriteOphhh>
     f3c:	ae 01       	movw	r20, r28
     f3e:	85 e0       	ldi	r24, 0x05	; 5
     f40:	55 95       	asr	r21
     f42:	47 95       	ror	r20
     f44:	8a 95       	dec	r24
     f46:	e1 f7       	brne	.-8      	; 0xf40 <_Z15enc28j60SetBankh+0x26>
     f48:	6f e1       	ldi	r22, 0x1F	; 31
     f4a:	80 e8       	ldi	r24, 0x80	; 128
     f4c:	b4 df       	rcall	.-152    	; 0xeb6 <_Z15enc28j60WriteOphhh>
     f4e:	10 93 e2 01 	sts	0x01E2, r17	; 0x8001e2 <_ZL12Enc28j60Bank>
     f52:	df 91       	pop	r29
     f54:	cf 91       	pop	r28
     f56:	1f 91       	pop	r17
     f58:	08 95       	ret

00000f5a <_Z12enc28j60Readh>:
     f5a:	cf 93       	push	r28
     f5c:	c8 2f       	mov	r28, r24
     f5e:	dd df       	rcall	.-70     	; 0xf1a <_Z15enc28j60SetBankh>
     f60:	6c 2f       	mov	r22, r28
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	cf 91       	pop	r28
     f66:	94 cf       	rjmp	.-216    	; 0xe90 <_Z14enc28j60ReadOphh>

00000f68 <_Z13enc28j60Writehh>:
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
     f6c:	c8 2f       	mov	r28, r24
     f6e:	d6 2f       	mov	r29, r22
     f70:	d4 df       	rcall	.-88     	; 0xf1a <_Z15enc28j60SetBankh>
     f72:	4d 2f       	mov	r20, r29
     f74:	6c 2f       	mov	r22, r28
     f76:	80 e4       	ldi	r24, 0x40	; 64
     f78:	df 91       	pop	r29
     f7a:	cf 91       	pop	r28
     f7c:	9c cf       	rjmp	.-200    	; 0xeb6 <_Z15enc28j60WriteOphhh>

00000f7e <_Z16enc28j60PhyWritehj>:
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
     f82:	d6 2f       	mov	r29, r22
     f84:	c7 2f       	mov	r28, r23
     f86:	68 2f       	mov	r22, r24
     f88:	84 ed       	ldi	r24, 0xD4	; 212
     f8a:	ee df       	rcall	.-36     	; 0xf68 <_Z13enc28j60Writehh>
     f8c:	6d 2f       	mov	r22, r29
     f8e:	86 ed       	ldi	r24, 0xD6	; 214
     f90:	eb df       	rcall	.-42     	; 0xf68 <_Z13enc28j60Writehh>
     f92:	6c 2f       	mov	r22, r28
     f94:	87 ed       	ldi	r24, 0xD7	; 215
     f96:	e8 df       	rcall	.-48     	; 0xf68 <_Z13enc28j60Writehh>
     f98:	8a ee       	ldi	r24, 0xEA	; 234
     f9a:	df df       	rcall	.-66     	; 0xf5a <_Z12enc28j60Readh>
     f9c:	80 ff       	sbrs	r24, 0
     f9e:	04 c0       	rjmp	.+8      	; 0xfa8 <_Z16enc28j60PhyWritehj+0x2a>
     fa0:	85 e0       	ldi	r24, 0x05	; 5
     fa2:	8a 95       	dec	r24
     fa4:	f1 f7       	brne	.-4      	; 0xfa2 <_Z16enc28j60PhyWritehj+0x24>
     fa6:	f8 cf       	rjmp	.-16     	; 0xf98 <_Z16enc28j60PhyWritehj+0x1a>
     fa8:	df 91       	pop	r29
     faa:	cf 91       	pop	r28
     fac:	08 95       	ret

00000fae <_Z14enc28j60clkouth>:
     fae:	68 2f       	mov	r22, r24
     fb0:	67 70       	andi	r22, 0x07	; 7
     fb2:	85 e7       	ldi	r24, 0x75	; 117
     fb4:	d9 cf       	rjmp	.-78     	; 0xf68 <_Z13enc28j60Writehh>

00000fb6 <_Z12enc28j60InitPh>:
     fb6:	cf 93       	push	r28
     fb8:	df 93       	push	r29
     fba:	ec 01       	movw	r28, r24
     fbc:	b8 9a       	sbi	0x17, 0	; 23
     fbe:	c0 9a       	sbi	0x18, 0	; 24
     fc0:	69 d2       	rcall	.+1234   	; 0x1494 <_Z8spi_initv>
     fc2:	4f ef       	ldi	r20, 0xFF	; 255
     fc4:	60 e0       	ldi	r22, 0x00	; 0
     fc6:	8f ef       	ldi	r24, 0xFF	; 255
     fc8:	76 df       	rcall	.-276    	; 0xeb6 <_Z15enc28j60WriteOphhh>
     fca:	82 e3       	ldi	r24, 0x32	; 50
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	6c d2       	rcall	.+1240   	; 0x14a8 <_Z8delay_msj>
     fd0:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
     fd4:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <_ZL13NextPacketPtr>
     fd8:	60 e0       	ldi	r22, 0x00	; 0
     fda:	88 e0       	ldi	r24, 0x08	; 8
     fdc:	c5 df       	rcall	.-118    	; 0xf68 <_Z13enc28j60Writehh>
     fde:	60 e0       	ldi	r22, 0x00	; 0
     fe0:	89 e0       	ldi	r24, 0x09	; 9
     fe2:	c2 df       	rcall	.-124    	; 0xf68 <_Z13enc28j60Writehh>
     fe4:	60 e0       	ldi	r22, 0x00	; 0
     fe6:	8c e0       	ldi	r24, 0x0C	; 12
     fe8:	bf df       	rcall	.-130    	; 0xf68 <_Z13enc28j60Writehh>
     fea:	60 e0       	ldi	r22, 0x00	; 0
     fec:	8d e0       	ldi	r24, 0x0D	; 13
     fee:	bc df       	rcall	.-136    	; 0xf68 <_Z13enc28j60Writehh>
     ff0:	6e ef       	ldi	r22, 0xFE	; 254
     ff2:	8a e0       	ldi	r24, 0x0A	; 10
     ff4:	b9 df       	rcall	.-142    	; 0xf68 <_Z13enc28j60Writehh>
     ff6:	69 e1       	ldi	r22, 0x19	; 25
     ff8:	8b e0       	ldi	r24, 0x0B	; 11
     ffa:	b6 df       	rcall	.-148    	; 0xf68 <_Z13enc28j60Writehh>
     ffc:	6f ef       	ldi	r22, 0xFF	; 255
     ffe:	84 e0       	ldi	r24, 0x04	; 4
    1000:	b3 df       	rcall	.-154    	; 0xf68 <_Z13enc28j60Writehh>
    1002:	69 e1       	ldi	r22, 0x19	; 25
    1004:	85 e0       	ldi	r24, 0x05	; 5
    1006:	b0 df       	rcall	.-160    	; 0xf68 <_Z13enc28j60Writehh>
    1008:	6f ef       	ldi	r22, 0xFF	; 255
    100a:	86 e0       	ldi	r24, 0x06	; 6
    100c:	ad df       	rcall	.-166    	; 0xf68 <_Z13enc28j60Writehh>
    100e:	6f e1       	ldi	r22, 0x1F	; 31
    1010:	87 e0       	ldi	r24, 0x07	; 7
    1012:	aa df       	rcall	.-172    	; 0xf68 <_Z13enc28j60Writehh>
    1014:	60 eb       	ldi	r22, 0xB0	; 176
    1016:	88 e3       	ldi	r24, 0x38	; 56
    1018:	a7 df       	rcall	.-178    	; 0xf68 <_Z13enc28j60Writehh>
    101a:	6f e3       	ldi	r22, 0x3F	; 63
    101c:	88 e2       	ldi	r24, 0x28	; 40
    101e:	a4 df       	rcall	.-184    	; 0xf68 <_Z13enc28j60Writehh>
    1020:	60 e3       	ldi	r22, 0x30	; 48
    1022:	89 e2       	ldi	r24, 0x29	; 41
    1024:	a1 df       	rcall	.-190    	; 0xf68 <_Z13enc28j60Writehh>
    1026:	69 ef       	ldi	r22, 0xF9	; 249
    1028:	80 e3       	ldi	r24, 0x30	; 48
    102a:	9e df       	rcall	.-196    	; 0xf68 <_Z13enc28j60Writehh>
    102c:	67 ef       	ldi	r22, 0xF7	; 247
    102e:	81 e3       	ldi	r24, 0x31	; 49
    1030:	9b df       	rcall	.-202    	; 0xf68 <_Z13enc28j60Writehh>
    1032:	6d e0       	ldi	r22, 0x0D	; 13
    1034:	80 ec       	ldi	r24, 0xC0	; 192
    1036:	98 df       	rcall	.-208    	; 0xf68 <_Z13enc28j60Writehh>
    1038:	60 e0       	ldi	r22, 0x00	; 0
    103a:	81 ec       	ldi	r24, 0xC1	; 193
    103c:	95 df       	rcall	.-214    	; 0xf68 <_Z13enc28j60Writehh>
    103e:	42 e3       	ldi	r20, 0x32	; 50
    1040:	62 ec       	ldi	r22, 0xC2	; 194
    1042:	80 e8       	ldi	r24, 0x80	; 128
    1044:	38 df       	rcall	.-400    	; 0xeb6 <_Z15enc28j60WriteOphhh>
    1046:	62 e1       	ldi	r22, 0x12	; 18
    1048:	86 ec       	ldi	r24, 0xC6	; 198
    104a:	8e df       	rcall	.-228    	; 0xf68 <_Z13enc28j60Writehh>
    104c:	6c e0       	ldi	r22, 0x0C	; 12
    104e:	87 ec       	ldi	r24, 0xC7	; 199
    1050:	8b df       	rcall	.-234    	; 0xf68 <_Z13enc28j60Writehh>
    1052:	62 e1       	ldi	r22, 0x12	; 18
    1054:	84 ec       	ldi	r24, 0xC4	; 196
    1056:	88 df       	rcall	.-240    	; 0xf68 <_Z13enc28j60Writehh>
    1058:	6c ed       	ldi	r22, 0xDC	; 220
    105a:	8a ec       	ldi	r24, 0xCA	; 202
    105c:	85 df       	rcall	.-246    	; 0xf68 <_Z13enc28j60Writehh>
    105e:	65 e0       	ldi	r22, 0x05	; 5
    1060:	8b ec       	ldi	r24, 0xCB	; 203
    1062:	82 df       	rcall	.-252    	; 0xf68 <_Z13enc28j60Writehh>
    1064:	68 81       	ld	r22, Y
    1066:	84 ee       	ldi	r24, 0xE4	; 228
    1068:	7f df       	rcall	.-258    	; 0xf68 <_Z13enc28j60Writehh>
    106a:	69 81       	ldd	r22, Y+1	; 0x01
    106c:	85 ee       	ldi	r24, 0xE5	; 229
    106e:	7c df       	rcall	.-264    	; 0xf68 <_Z13enc28j60Writehh>
    1070:	6a 81       	ldd	r22, Y+2	; 0x02
    1072:	82 ee       	ldi	r24, 0xE2	; 226
    1074:	79 df       	rcall	.-270    	; 0xf68 <_Z13enc28j60Writehh>
    1076:	6b 81       	ldd	r22, Y+3	; 0x03
    1078:	83 ee       	ldi	r24, 0xE3	; 227
    107a:	76 df       	rcall	.-276    	; 0xf68 <_Z13enc28j60Writehh>
    107c:	6c 81       	ldd	r22, Y+4	; 0x04
    107e:	80 ee       	ldi	r24, 0xE0	; 224
    1080:	73 df       	rcall	.-282    	; 0xf68 <_Z13enc28j60Writehh>
    1082:	6d 81       	ldd	r22, Y+5	; 0x05
    1084:	81 ee       	ldi	r24, 0xE1	; 225
    1086:	70 df       	rcall	.-288    	; 0xf68 <_Z13enc28j60Writehh>
    1088:	60 e0       	ldi	r22, 0x00	; 0
    108a:	71 e0       	ldi	r23, 0x01	; 1
    108c:	80 e1       	ldi	r24, 0x10	; 16
    108e:	77 df       	rcall	.-274    	; 0xf7e <_Z16enc28j60PhyWritehj>
    1090:	8f e1       	ldi	r24, 0x1F	; 31
    1092:	43 df       	rcall	.-378    	; 0xf1a <_Z15enc28j60SetBankh>
    1094:	40 ec       	ldi	r20, 0xC0	; 192
    1096:	6b e1       	ldi	r22, 0x1B	; 27
    1098:	80 e8       	ldi	r24, 0x80	; 128
    109a:	0d df       	rcall	.-486    	; 0xeb6 <_Z15enc28j60WriteOphhh>
    109c:	44 e0       	ldi	r20, 0x04	; 4
    109e:	6f e1       	ldi	r22, 0x1F	; 31
    10a0:	80 e8       	ldi	r24, 0x80	; 128
    10a2:	df 91       	pop	r29
    10a4:	cf 91       	pop	r28
    10a6:	07 cf       	rjmp	.-498    	; 0xeb6 <_Z15enc28j60WriteOphhh>

000010a8 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
    10a8:	0f 93       	push	r16
    10aa:	1f 93       	push	r17
    10ac:	cf 93       	push	r28
    10ae:	df 93       	push	r29
    10b0:	ec 01       	movw	r28, r24
    10b2:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
    10b4:	6f ef       	ldi	r22, 0xFF	; 255
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	57 df       	rcall	.-338    	; 0xf68 <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    10ba:	69 e1       	ldi	r22, 0x19	; 25
    10bc:	83 e0       	ldi	r24, 0x03	; 3
    10be:	54 df       	rcall	.-344    	; 0xf68 <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
    10c0:	6c 2f       	mov	r22, r28
    10c2:	61 50       	subi	r22, 0x01	; 1
    10c4:	86 e0       	ldi	r24, 0x06	; 6
    10c6:	50 df       	rcall	.-352    	; 0xf68 <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    10c8:	ce 01       	movw	r24, r28
    10ca:	81 50       	subi	r24, 0x01	; 1
    10cc:	96 4e       	sbci	r25, 0xE6	; 230
    10ce:	69 2f       	mov	r22, r25
    10d0:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    10d2:	4a df       	rcall	.-364    	; 0xf68 <_Z13enc28j60Writehh>
    10d4:	40 e0       	ldi	r20, 0x00	; 0
    10d6:	60 e0       	ldi	r22, 0x00	; 0
    10d8:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
    10da:	ed de       	rcall	.-550    	; 0xeb6 <_Z15enc28j60WriteOphhh>
    10dc:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    10de:	ce 01       	movw	r24, r28
    10e0:	09 df       	rcall	.-494    	; 0xef4 <_Z19enc28j60WriteBufferjPh>
    10e2:	48 e0       	ldi	r20, 0x08	; 8
    10e4:	6f e1       	ldi	r22, 0x1F	; 31
    10e6:	80 e8       	ldi	r24, 0x80	; 128
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
    10e8:	e6 de       	rcall	.-564    	; 0xeb6 <_Z15enc28j60WriteOphhh>
    10ea:	8c e1       	ldi	r24, 0x1C	; 28
    10ec:	36 df       	rcall	.-404    	; 0xf5a <_Z12enc28j60Readh>
    10ee:	81 ff       	sbrs	r24, 1
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
    10f0:	08 c0       	rjmp	.+16     	; 0x1102 <__stack+0x3>
    10f2:	48 e0       	ldi	r20, 0x08	; 8
    10f4:	6f e1       	ldi	r22, 0x1F	; 31
        }
}
    10f6:	80 ea       	ldi	r24, 0xA0	; 160
    10f8:	df 91       	pop	r29
    10fa:	cf 91       	pop	r28
    10fc:	1f 91       	pop	r17
	enc28j60WriteBuffer(len, packet);
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
    10fe:	0f 91       	pop	r16
    1100:	da ce       	rjmp	.-588    	; 0xeb6 <_Z15enc28j60WriteOphhh>
        }
}
    1102:	df 91       	pop	r29
    1104:	cf 91       	pop	r28
    1106:	1f 91       	pop	r17
    1108:	0f 91       	pop	r16
    110a:	08 95       	ret

0000110c <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
    110c:	9f 92       	push	r9
    110e:	af 92       	push	r10
    1110:	bf 92       	push	r11
    1112:	cf 92       	push	r12
    1114:	df 92       	push	r13
    1116:	ef 92       	push	r14
    1118:	ff 92       	push	r15
    111a:	0f 93       	push	r16
    111c:	1f 93       	push	r17
    111e:	cf 93       	push	r28
    1120:	df 93       	push	r29
    1122:	6c 01       	movw	r12, r24
    1124:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
    1126:	89 e3       	ldi	r24, 0x39	; 57
    1128:	18 df       	rcall	.-464    	; 0xf5a <_Z12enc28j60Readh>
    112a:	88 23       	and	r24, r24
    112c:	09 f4       	brne	.+2      	; 0x1130 <_Z21enc28j60PacketReceivejPh+0x24>
    112e:	42 c0       	rjmp	.+132    	; 0x11b4 <_Z21enc28j60PacketReceivejPh+0xa8>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
    1130:	60 91 e0 01 	lds	r22, 0x01E0	; 0x8001e0 <_ZL13NextPacketPtr>
    1134:	c0 91 e1 01 	lds	r28, 0x01E1	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
    1138:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
    113a:	16 df       	rcall	.-468    	; 0xf68 <_Z13enc28j60Writehh>
    113c:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    113e:	81 e0       	ldi	r24, 0x01	; 1
    1140:	13 df       	rcall	.-474    	; 0xf68 <_Z13enc28j60Writehh>
    1142:	60 e0       	ldi	r22, 0x00	; 0
    1144:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1146:	a4 de       	rcall	.-696    	; 0xe90 <_Z14enc28j60ReadOphh>
    1148:	08 2f       	mov	r16, r24
    114a:	60 e0       	ldi	r22, 0x00	; 0
    114c:	8a e3       	ldi	r24, 0x3A	; 58
    114e:	a0 de       	rcall	.-704    	; 0xe90 <_Z14enc28j60ReadOphh>
    1150:	10 e0       	ldi	r17, 0x00	; 0
    1152:	18 2b       	or	r17, r24
    1154:	10 93 e1 01 	sts	0x01E1, r17	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1158:	00 93 e0 01 	sts	0x01E0, r16	; 0x8001e0 <_ZL13NextPacketPtr>
    115c:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    115e:	8a e3       	ldi	r24, 0x3A	; 58
    1160:	97 de       	rcall	.-722    	; 0xe90 <_Z14enc28j60ReadOphh>
    1162:	c8 2f       	mov	r28, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1164:	60 e0       	ldi	r22, 0x00	; 0
    1166:	8a e3       	ldi	r24, 0x3A	; 58
    1168:	93 de       	rcall	.-730    	; 0xe90 <_Z14enc28j60ReadOphh>
    116a:	98 2e       	mov	r9, r24
    116c:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
    116e:	8a e3       	ldi	r24, 0x3A	; 58
    1170:	8f de       	rcall	.-738    	; 0xe90 <_Z14enc28j60ReadOphh>
    1172:	a8 2e       	mov	r10, r24
    1174:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
    1176:	8a e3       	ldi	r24, 0x3A	; 58
    1178:	8b de       	rcall	.-746    	; 0xe90 <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
    117a:	a7 fe       	sbrs	r10, 7
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    117c:	0d c0       	rjmp	.+26     	; 0x1198 <_Z21enc28j60PacketReceivejPh+0x8c>
    117e:	c6 01       	movw	r24, r12
    1180:	01 97       	sbiw	r24, 0x01	; 1
    1182:	d0 e0       	ldi	r29, 0x00	; 0
    1184:	d9 29       	or	r29, r9
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
    1186:	24 97       	sbiw	r28, 0x04	; 4
    1188:	8c 17       	cp	r24, r28
    118a:	9d 07       	cpc	r25, r29
    118c:	08 f4       	brcc	.+2      	; 0x1190 <_Z21enc28j60PacketReceivejPh+0x84>
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
    118e:	ec 01       	movw	r28, r24
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
    1190:	b7 01       	movw	r22, r14
    1192:	ce 01       	movw	r24, r28
    1194:	9b de       	rcall	.-714    	; 0xecc <_Z18enc28j60ReadBufferjPh>
    1196:	02 c0       	rjmp	.+4      	; 0x119c <_Z21enc28j60PacketReceivejPh+0x90>
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
    1198:	c0 e0       	ldi	r28, 0x00	; 0
    119a:	d0 e0       	ldi	r29, 0x00	; 0
    119c:	60 2f       	mov	r22, r16
    119e:	8c e0       	ldi	r24, 0x0C	; 12
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    11a0:	e3 de       	rcall	.-570    	; 0xf68 <_Z13enc28j60Writehh>
    11a2:	61 2f       	mov	r22, r17
    11a4:	8d e0       	ldi	r24, 0x0D	; 13
    11a6:	e0 de       	rcall	.-576    	; 0xf68 <_Z13enc28j60Writehh>
    11a8:	40 e4       	ldi	r20, 0x40	; 64
	return(len);
    11aa:	6e e1       	ldi	r22, 0x1E	; 30
    11ac:	80 e8       	ldi	r24, 0x80	; 128
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
    11ae:	83 de       	rcall	.-762    	; 0xeb6 <_Z15enc28j60WriteOphhh>
    11b0:	ce 01       	movw	r24, r28
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
    11b2:	02 c0       	rjmp	.+4      	; 0x11b8 <_Z21enc28j60PacketReceivejPh+0xac>
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	90 e0       	ldi	r25, 0x00	; 0
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	cf 90       	pop	r12
    11c8:	bf 90       	pop	r11
    11ca:	af 90       	pop	r10
    11cc:	9f 90       	pop	r9
    11ce:	08 95       	ret

000011d0 <_Z8checksumPhjh>:
                // 24 bytes:
                buf[TCP_HEADER_LEN_P]=0x60;
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
    11d0:	0f 93       	push	r16
    11d2:	1f 93       	push	r17
    11d4:	cf 93       	push	r28
    11d6:	df 93       	push	r29
    11d8:	fc 01       	movw	r30, r24
    11da:	9b 01       	movw	r18, r22
    11dc:	41 30       	cpi	r20, 0x01	; 1
    11de:	51 f4       	brne	.+20     	; 0x11f4 <_Z8checksumPhjh+0x24>
    11e0:	ab 01       	movw	r20, r22
    11e2:	48 50       	subi	r20, 0x08	; 8
    11e4:	51 09       	sbc	r21, r1
    11e6:	60 e0       	ldi	r22, 0x00	; 0
    11e8:	70 e0       	ldi	r23, 0x00	; 0
    11ea:	4f 5e       	subi	r20, 0xEF	; 239
    11ec:	5f 4f       	sbci	r21, 0xFF	; 255
    11ee:	6f 4f       	sbci	r22, 0xFF	; 255
    11f0:	7f 4f       	sbci	r23, 0xFF	; 255
    11f2:	0f c0       	rjmp	.+30     	; 0x1212 <_Z8checksumPhjh+0x42>
    11f4:	42 30       	cpi	r20, 0x02	; 2
    11f6:	51 f4       	brne	.+20     	; 0x120c <_Z8checksumPhjh+0x3c>
    11f8:	ab 01       	movw	r20, r22
    11fa:	48 50       	subi	r20, 0x08	; 8
    11fc:	51 09       	sbc	r21, r1
    11fe:	60 e0       	ldi	r22, 0x00	; 0
    1200:	70 e0       	ldi	r23, 0x00	; 0
    1202:	4a 5f       	subi	r20, 0xFA	; 250
    1204:	5f 4f       	sbci	r21, 0xFF	; 255
    1206:	6f 4f       	sbci	r22, 0xFF	; 255
    1208:	7f 4f       	sbci	r23, 0xFF	; 255
    120a:	03 c0       	rjmp	.+6      	; 0x1212 <_Z8checksumPhjh+0x42>
    120c:	40 e0       	ldi	r20, 0x00	; 0
    120e:	50 e0       	ldi	r21, 0x00	; 0
    1210:	ba 01       	movw	r22, r20
    1212:	c9 01       	movw	r24, r18
    1214:	ef 01       	movw	r28, r30
    1216:	82 30       	cpi	r24, 0x02	; 2
    1218:	91 05       	cpc	r25, r1
    121a:	58 f0       	brcs	.+22     	; 0x1232 <_Z8checksumPhjh+0x62>
    121c:	a9 91       	ld	r26, Y+
    121e:	b9 91       	ld	r27, Y+
    1220:	ba 27       	eor	r27, r26
    1222:	ab 27       	eor	r26, r27
    1224:	ba 27       	eor	r27, r26
    1226:	4a 0f       	add	r20, r26
    1228:	5b 1f       	adc	r21, r27
    122a:	61 1d       	adc	r22, r1
    122c:	71 1d       	adc	r23, r1
    122e:	02 97       	sbiw	r24, 0x02	; 2
    1230:	f2 cf       	rjmp	.-28     	; 0x1216 <_Z8checksumPhjh+0x46>
    1232:	c9 01       	movw	r24, r18
    1234:	8e 7f       	andi	r24, 0xFE	; 254
    1236:	e8 0f       	add	r30, r24
    1238:	f9 1f       	adc	r31, r25
    123a:	28 17       	cp	r18, r24
    123c:	39 07       	cpc	r19, r25
    123e:	61 f0       	breq	.+24     	; 0x1258 <_Z8checksumPhjh+0x88>
    1240:	80 81       	ld	r24, Z
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	a0 e0       	ldi	r26, 0x00	; 0
    1246:	b0 e0       	ldi	r27, 0x00	; 0
    1248:	ba 2f       	mov	r27, r26
    124a:	a9 2f       	mov	r26, r25
    124c:	98 2f       	mov	r25, r24
    124e:	88 27       	eor	r24, r24
    1250:	48 0f       	add	r20, r24
    1252:	59 1f       	adc	r21, r25
    1254:	6a 1f       	adc	r22, r26
    1256:	7b 1f       	adc	r23, r27
    1258:	8b 01       	movw	r16, r22
    125a:	22 27       	eor	r18, r18
    125c:	33 27       	eor	r19, r19
    125e:	01 15       	cp	r16, r1
    1260:	11 05       	cpc	r17, r1
    1262:	21 05       	cpc	r18, r1
    1264:	31 05       	cpc	r19, r1
    1266:	39 f0       	breq	.+14     	; 0x1276 <_Z8checksumPhjh+0xa6>
    1268:	66 27       	eor	r22, r22
    126a:	77 27       	eor	r23, r23
    126c:	40 0f       	add	r20, r16
    126e:	51 1f       	adc	r21, r17
    1270:	62 1f       	adc	r22, r18
    1272:	73 1f       	adc	r23, r19
    1274:	f1 cf       	rjmp	.-30     	; 0x1258 <_Z8checksumPhjh+0x88>
    1276:	ca 01       	movw	r24, r20
    1278:	80 95       	com	r24
    127a:	90 95       	com	r25
    127c:	df 91       	pop	r29
    127e:	cf 91       	pop	r28
    1280:	1f 91       	pop	r17
    1282:	0f 91       	pop	r16
    1284:	08 95       	ret

00001286 <_Z19init_ip_arp_udp_tcpPhS_h>:
    1286:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
    128a:	fb 01       	movw	r30, r22
    128c:	a3 ee       	ldi	r26, 0xE3	; 227
    128e:	b1 e0       	ldi	r27, 0x01	; 1
    1290:	21 91       	ld	r18, Z+
    1292:	2d 93       	st	X+, r18
    1294:	21 e0       	ldi	r18, 0x01	; 1
    1296:	a7 3e       	cpi	r26, 0xE7	; 231
    1298:	b2 07       	cpc	r27, r18
    129a:	d1 f7       	brne	.-12     	; 0x1290 <_Z19init_ip_arp_udp_tcpPhS_h+0xa>
    129c:	fc 01       	movw	r30, r24
    129e:	a7 ee       	ldi	r26, 0xE7	; 231
    12a0:	b1 e0       	ldi	r27, 0x01	; 1
    12a2:	81 91       	ld	r24, Z+
    12a4:	8d 93       	st	X+, r24
    12a6:	81 e0       	ldi	r24, 0x01	; 1
    12a8:	ad 3e       	cpi	r26, 0xED	; 237
    12aa:	b8 07       	cpc	r27, r24
    12ac:	d1 f7       	brne	.-12     	; 0x12a2 <_Z19init_ip_arp_udp_tcpPhS_h+0x1c>
    12ae:	08 95       	ret

000012b0 <_Z25eth_type_is_arp_and_my_ipPhj>:
    12b0:	69 32       	cpi	r22, 0x29	; 41
    12b2:	71 05       	cpc	r23, r1
    12b4:	a0 f0       	brcs	.+40     	; 0x12de <_Z25eth_type_is_arp_and_my_ipPhj+0x2e>
    12b6:	fc 01       	movw	r30, r24
    12b8:	24 85       	ldd	r18, Z+12	; 0x0c
    12ba:	28 30       	cpi	r18, 0x08	; 8
    12bc:	81 f4       	brne	.+32     	; 0x12de <_Z25eth_type_is_arp_and_my_ipPhj+0x2e>
    12be:	25 85       	ldd	r18, Z+13	; 0x0d
    12c0:	26 30       	cpi	r18, 0x06	; 6
    12c2:	69 f4       	brne	.+26     	; 0x12de <_Z25eth_type_is_arp_and_my_ipPhj+0x2e>
    12c4:	b6 96       	adiw	r30, 0x26	; 38
    12c6:	a3 ee       	ldi	r26, 0xE3	; 227
    12c8:	b1 e0       	ldi	r27, 0x01	; 1
    12ca:	8a 96       	adiw	r24, 0x2a	; 42
    12cc:	31 91       	ld	r19, Z+
    12ce:	2d 91       	ld	r18, X+
    12d0:	32 13       	cpse	r19, r18
    12d2:	05 c0       	rjmp	.+10     	; 0x12de <_Z25eth_type_is_arp_and_my_ipPhj+0x2e>
    12d4:	e8 17       	cp	r30, r24
    12d6:	f9 07       	cpc	r31, r25
    12d8:	c9 f7       	brne	.-14     	; 0x12cc <_Z25eth_type_is_arp_and_my_ipPhj+0x1c>
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	08 95       	ret
    12de:	80 e0       	ldi	r24, 0x00	; 0
    12e0:	08 95       	ret

000012e2 <_Z24eth_type_is_ip_and_my_ipPhj>:
    12e2:	cf 93       	push	r28
    12e4:	df 93       	push	r29
    12e6:	fc 01       	movw	r30, r24
    12e8:	6a 32       	cpi	r22, 0x2A	; 42
    12ea:	71 05       	cpc	r23, r1
    12ec:	b8 f0       	brcs	.+46     	; 0x131c <_Z24eth_type_is_ip_and_my_ipPhj+0x3a>
    12ee:	84 85       	ldd	r24, Z+12	; 0x0c
    12f0:	88 30       	cpi	r24, 0x08	; 8
    12f2:	a1 f4       	brne	.+40     	; 0x131c <_Z24eth_type_is_ip_and_my_ipPhj+0x3a>
    12f4:	85 85       	ldd	r24, Z+13	; 0x0d
    12f6:	81 11       	cpse	r24, r1
    12f8:	11 c0       	rjmp	.+34     	; 0x131c <_Z24eth_type_is_ip_and_my_ipPhj+0x3a>
    12fa:	96 85       	ldd	r25, Z+14	; 0x0e
    12fc:	95 34       	cpi	r25, 0x45	; 69
    12fe:	79 f4       	brne	.+30     	; 0x131e <_Z24eth_type_is_ip_and_my_ipPhj+0x3c>
    1300:	df 01       	movw	r26, r30
    1302:	5e 96       	adiw	r26, 0x1e	; 30
    1304:	c3 ee       	ldi	r28, 0xE3	; 227
    1306:	d1 e0       	ldi	r29, 0x01	; 1
    1308:	b2 96       	adiw	r30, 0x22	; 34
    130a:	2d 91       	ld	r18, X+
    130c:	99 91       	ld	r25, Y+
    130e:	29 13       	cpse	r18, r25
    1310:	06 c0       	rjmp	.+12     	; 0x131e <_Z24eth_type_is_ip_and_my_ipPhj+0x3c>
    1312:	ae 17       	cp	r26, r30
    1314:	bf 07       	cpc	r27, r31
    1316:	c9 f7       	brne	.-14     	; 0x130a <_Z24eth_type_is_ip_and_my_ipPhj+0x28>
    1318:	81 e0       	ldi	r24, 0x01	; 1
    131a:	01 c0       	rjmp	.+2      	; 0x131e <_Z24eth_type_is_ip_and_my_ipPhj+0x3c>
    131c:	80 e0       	ldi	r24, 0x00	; 0
    131e:	df 91       	pop	r29
    1320:	cf 91       	pop	r28
    1322:	08 95       	ret

00001324 <_Z8make_ethPh>:
    1324:	fc 01       	movw	r30, r24
    1326:	a7 ee       	ldi	r26, 0xE7	; 231
    1328:	b1 e0       	ldi	r27, 0x01	; 1
    132a:	06 96       	adiw	r24, 0x06	; 6
    132c:	26 81       	ldd	r18, Z+6	; 0x06
    132e:	21 93       	st	Z+, r18
    1330:	2d 91       	ld	r18, X+
    1332:	25 83       	std	Z+5, r18	; 0x05
    1334:	e8 17       	cp	r30, r24
    1336:	f9 07       	cpc	r31, r25
    1338:	c9 f7       	brne	.-14     	; 0x132c <_Z8make_ethPh+0x8>
    133a:	08 95       	ret

0000133c <_Z20fill_ip_hdr_checksumPh>:
    133c:	cf 93       	push	r28
    133e:	df 93       	push	r29
    1340:	ec 01       	movw	r28, r24
    1342:	18 8e       	std	Y+24, r1	; 0x18
    1344:	19 8e       	std	Y+25, r1	; 0x19
    1346:	80 e4       	ldi	r24, 0x40	; 64
    1348:	8c 8b       	std	Y+20, r24	; 0x14
    134a:	1d 8a       	std	Y+21, r1	; 0x15
    134c:	8e 8b       	std	Y+22, r24	; 0x16
    134e:	40 e0       	ldi	r20, 0x00	; 0
    1350:	64 e1       	ldi	r22, 0x14	; 20
    1352:	70 e0       	ldi	r23, 0x00	; 0
    1354:	ce 01       	movw	r24, r28
    1356:	0e 96       	adiw	r24, 0x0e	; 14
    1358:	3b df       	rcall	.-394    	; 0x11d0 <_Z8checksumPhjh>
    135a:	98 8f       	std	Y+24, r25	; 0x18
    135c:	89 8f       	std	Y+25, r24	; 0x19
    135e:	df 91       	pop	r29
    1360:	cf 91       	pop	r28
    1362:	08 95       	ret

00001364 <_Z7make_ipPh>:
    1364:	a3 ee       	ldi	r26, 0xE3	; 227
    1366:	b1 e0       	ldi	r27, 0x01	; 1
    1368:	fc 01       	movw	r30, r24
    136a:	7a 96       	adiw	r30, 0x1a	; 26
    136c:	9c 01       	movw	r18, r24
    136e:	22 5e       	subi	r18, 0xE2	; 226
    1370:	3f 4f       	sbci	r19, 0xFF	; 255
    1372:	40 81       	ld	r20, Z
    1374:	44 83       	std	Z+4, r20	; 0x04
    1376:	4d 91       	ld	r20, X+
    1378:	41 93       	st	Z+, r20
    137a:	e2 17       	cp	r30, r18
    137c:	f3 07       	cpc	r31, r19
    137e:	c9 f7       	brne	.-14     	; 0x1372 <_Z7make_ipPh+0xe>
    1380:	dd cf       	rjmp	.-70     	; 0x133c <_Z20fill_ip_hdr_checksumPh>

00001382 <_Z28make_arp_answer_from_requestPh>:
        }
}

void make_arp_answer_from_request(uint8_t *buf)
{
    1382:	cf 93       	push	r28
    1384:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    1386:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    1388:	cd df       	rcall	.-102    	; 0x1324 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    138a:	1c 8a       	std	Y+20, r1	; 0x14
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	8d 8b       	std	Y+21, r24	; 0x15
    1390:	87 ee       	ldi	r24, 0xE7	; 231
    1392:	91 e0       	ldi	r25, 0x01	; 1
    1394:	ae 01       	movw	r20, r28
    1396:	4a 5e       	subi	r20, 0xEA	; 234
    1398:	5f 4f       	sbci	r21, 0xFF	; 255
    139a:	fe 01       	movw	r30, r28
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    139c:	7c 96       	adiw	r30, 0x1c	; 28
    139e:	da 01       	movw	r26, r20
    13a0:	2c 91       	ld	r18, X
    13a2:	1a 96       	adiw	r26, 0x0a	; 10
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    13a4:	2c 93       	st	X, r18
    13a6:	dc 01       	movw	r26, r24
    13a8:	2d 91       	ld	r18, X+
    13aa:	cd 01       	movw	r24, r26
    13ac:	da 01       	movw	r26, r20
    13ae:	2d 93       	st	X+, r18
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    13b0:	ad 01       	movw	r20, r26
    13b2:	ae 17       	cp	r26, r30
    13b4:	bf 07       	cpc	r27, r31
    13b6:	99 f7       	brne	.-26     	; 0x139e <_Z28make_arp_answer_from_requestPh+0x1c>
    13b8:	a3 ee       	ldi	r26, 0xE3	; 227
    13ba:	b1 e0       	ldi	r27, 0x01	; 1
    13bc:	ce 01       	movw	r24, r28
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    13be:	80 96       	adiw	r24, 0x20	; 32
    13c0:	20 81       	ld	r18, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    13c2:	22 87       	std	Z+10, r18	; 0x0a
    13c4:	2d 91       	ld	r18, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    13c6:	21 93       	st	Z+, r18
    13c8:	e8 17       	cp	r30, r24
    13ca:	f9 07       	cpc	r31, r25
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    13cc:	c9 f7       	brne	.-14     	; 0x13c0 <_Z28make_arp_answer_from_requestPh+0x3e>
    13ce:	be 01       	movw	r22, r28
    13d0:	8a e2       	ldi	r24, 0x2A	; 42
}
    13d2:	90 e0       	ldi	r25, 0x00	; 0
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    13d4:	df 91       	pop	r29
    13d6:	cf 91       	pop	r28
    13d8:	67 ce       	rjmp	.-818    	; 0x10a8 <_Z18enc28j60PacketSendjPh>

000013da <_Z28make_echo_reply_from_requestPhj>:
}

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    13da:	0f 93       	push	r16
    13dc:	1f 93       	push	r17
    13de:	cf 93       	push	r28
    13e0:	df 93       	push	r29
    13e2:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    13e4:	8b 01       	movw	r16, r22
    13e6:	9e df       	rcall	.-196    	; 0x1324 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    13e8:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    13ea:	bc df       	rcall	.-136    	; 0x1364 <_Z7make_ipPh>
    13ec:	1a a2       	std	Y+34, r1	; 0x22
    13ee:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    13f0:	88 3f       	cpi	r24, 0xF8	; 248
    13f2:	18 f0       	brcs	.+6      	; 0x13fa <_Z28make_echo_reply_from_requestPhj+0x20>
    13f4:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    13f6:	9f 5f       	subi	r25, 0xFF	; 255
    13f8:	9d a3       	std	Y+37, r25	; 0x25
        //
        enc28j60PacketSend(len,buf);
    13fa:	88 5f       	subi	r24, 0xF8	; 248
    13fc:	8c a3       	std	Y+36, r24	; 0x24
}
    13fe:	be 01       	movw	r22, r28
    1400:	c8 01       	movw	r24, r16
    1402:	df 91       	pop	r29
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
                buf[ICMP_CHECKSUM_P+1]++;
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
        //
        enc28j60PacketSend(len,buf);
    1404:	cf 91       	pop	r28
    1406:	1f 91       	pop	r17
    1408:	0f 91       	pop	r16
    140a:	4e ce       	rjmp	.-868    	; 0x10a8 <_Z18enc28j60PacketSendjPh>

0000140c <_Z27make_udp_reply_from_requestPhPchj>:
}

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    140c:	df 92       	push	r13
    140e:	ef 92       	push	r14
    1410:	ff 92       	push	r15
    1412:	0f 93       	push	r16
    1414:	1f 93       	push	r17
    1416:	cf 93       	push	r28
    1418:	df 93       	push	r29
    141a:	ec 01       	movw	r28, r24
    141c:	16 2f       	mov	r17, r22
    141e:	f7 2e       	mov	r15, r23
    1420:	04 2f       	mov	r16, r20
    1422:	e2 2e       	mov	r14, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    1424:	d3 2e       	mov	r13, r19
    1426:	7e df       	rcall	.-260    	; 0x1324 <_Z8make_ethPh>
    1428:	0d 3d       	cpi	r16, 0xDD	; 221
    142a:	08 f0       	brcs	.+2      	; 0x142e <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    142c:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    142e:	18 8a       	std	Y+16, r1	; 0x10
    1430:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    1432:	80 0f       	add	r24, r16
    1434:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    1436:	ce 01       	movw	r24, r28
    1438:	95 df       	rcall	.-214    	; 0x1364 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    143a:	8a a1       	ldd	r24, Y+34	; 0x22
    143c:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    143e:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    1440:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    1442:	da a2       	std	Y+34, r13	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    1444:	eb a2       	std	Y+35, r14	; 0x23
    1446:	1e a2       	std	Y+38, r1	; 0x26
    1448:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    144a:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    144c:	8f a3       	std	Y+39, r24	; 0x27
    144e:	18 a6       	std	Y+40, r1	; 0x28
    1450:	19 a6       	std	Y+41, r1	; 0x29
    1452:	91 2f       	mov	r25, r17
    1454:	de 01       	movw	r26, r28
    1456:	9a 96       	adiw	r26, 0x2a	; 42
        // copy the data:
        while(i<datalen){
    1458:	e1 2f       	mov	r30, r17
    145a:	ff 2d       	mov	r31, r15
    145c:	8e 2f       	mov	r24, r30
    145e:	89 1b       	sub	r24, r25
                buf[UDP_DATA_P+i]=data[i];
    1460:	80 17       	cp	r24, r16
    1462:	18 f4       	brcc	.+6      	; 0x146a <_Z27make_udp_reply_from_requestPhPchj+0x5e>
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    1464:	81 91       	ld	r24, Z+
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    1466:	8d 93       	st	X+, r24
    1468:	f9 cf       	rjmp	.-14     	; 0x145c <_Z27make_udp_reply_from_requestPhPchj+0x50>
    146a:	10 e0       	ldi	r17, 0x00	; 0
    146c:	b8 01       	movw	r22, r16
    146e:	60 5f       	subi	r22, 0xF0	; 240
    1470:	7f 4f       	sbci	r23, 0xFF	; 255
    1472:	41 e0       	ldi	r20, 0x01	; 1
    1474:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1476:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
    1478:	ab de       	rcall	.-682    	; 0x11d0 <_Z8checksumPhjh>
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    147a:	98 a7       	std	Y+40, r25	; 0x28
    147c:	89 a7       	std	Y+41, r24	; 0x29
    147e:	be 01       	movw	r22, r28
}
    1480:	c8 01       	movw	r24, r16
    1482:	8a 96       	adiw	r24, 0x2a	; 42
    1484:	df 91       	pop	r29
    1486:	cf 91       	pop	r28
    1488:	1f 91       	pop	r17
    148a:	0f 91       	pop	r16
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
        buf[UDP_CHECKSUM_H_P]=ck>>8;
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    148c:	ff 90       	pop	r15
    148e:	ef 90       	pop	r14
    1490:	df 90       	pop	r13
    1492:	0a ce       	rjmp	.-1004   	; 0x10a8 <_Z18enc28j60PacketSendjPh>

00001494 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1494:	87 b3       	in	r24, 0x17	; 23
    1496:	86 60       	ori	r24, 0x06	; 6
    1498:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    149a:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    149c:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    149e:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    14a0:	80 e5       	ldi	r24, 0x50	; 80
    14a2:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    14a4:	70 9a       	sbi	0x0e, 0	; 14
    14a6:	08 95       	ret

000014a8 <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    14a8:	00 97       	sbiw	r24, 0x00	; 0
    14aa:	41 f0       	breq	.+16     	; 0x14bc <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    14ac:	ef eb       	ldi	r30, 0xBF	; 191
    14ae:	f0 e0       	ldi	r31, 0x00	; 0
    14b0:	31 97       	sbiw	r30, 0x01	; 1
    14b2:	f1 f7       	brne	.-4      	; 0x14b0 <_Z8delay_msj+0x8>
    14b4:	00 c0       	rjmp	.+0      	; 0x14b6 <_Z8delay_msj+0xe>
    14b6:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    14b8:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    14ba:	f6 cf       	rjmp	.-20     	; 0x14a8 <_Z8delay_msj>
    14bc:	08 95       	ret

000014be <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    14be:	e4 ec       	ldi	r30, 0xC4	; 196
    14c0:	f2 e0       	ldi	r31, 0x02	; 2
    14c2:	84 85       	ldd	r24, Z+12	; 0x0c
    14c4:	95 85       	ldd	r25, Z+13	; 0x0d
    14c6:	01 96       	adiw	r24, 0x01	; 1
    14c8:	95 87       	std	Z+13, r25	; 0x0d
    14ca:	84 87       	std	Z+12, r24	; 0x0c
	Ctl_LCD_Cursor++;
    14cc:	80 91 ab 02 	lds	r24, 0x02AB	; 0x8002ab <Ctl_LCD_Cursor>
    14d0:	8f 5f       	subi	r24, 0xFF	; 255
    14d2:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <Ctl_LCD_Cursor>
	cbi(PORTB,5); //통신 램프 클리어
    14d6:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6); //통신 램프 클리어 	
    14d8:	c6 98       	cbi	0x18, 6	; 24
	#if USE_SYSTEM_SEC
		//mem4[SYSTEM_SEC_CLOCK]++;
		current_states_times++;
    14da:	80 91 36 03 	lds	r24, 0x0336	; 0x800336 <current_states_times>
    14de:	90 91 37 03 	lds	r25, 0x0337	; 0x800337 <current_states_times+0x1>
    14e2:	a0 91 38 03 	lds	r26, 0x0338	; 0x800338 <current_states_times+0x2>
    14e6:	b0 91 39 03 	lds	r27, 0x0339	; 0x800339 <current_states_times+0x3>
    14ea:	01 96       	adiw	r24, 0x01	; 1
    14ec:	a1 1d       	adc	r26, r1
    14ee:	b1 1d       	adc	r27, r1
    14f0:	80 93 36 03 	sts	0x0336, r24	; 0x800336 <current_states_times>
    14f4:	90 93 37 03 	sts	0x0337, r25	; 0x800337 <current_states_times+0x1>
    14f8:	a0 93 38 03 	sts	0x0338, r26	; 0x800338 <current_states_times+0x2>
    14fc:	b0 93 39 03 	sts	0x0339, r27	; 0x800339 <current_states_times+0x3>
	#endif
	#if USE_ETH
		led_flag = ~led_flag;
    1500:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <_ZL8led_flag>
    1504:	80 95       	com	r24
    1506:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <_ZL8led_flag>
    150a:	08 95       	ret

0000150c <_Z7ADC_ISR8Dev_typej>:
	#endif
}
void ADC_ISR(Dev_type Device,uint16_t Arg)
{
    150c:	08 95       	ret

0000150e <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,80,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    150e:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    1512:	81 11       	cpse	r24, r1
    1514:	03 c0       	rjmp	.+6      	; 0x151c <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <chatter_flag>
    151c:	08 95       	ret

0000151e <_ZL5proc2Pv>:

#if USE_ETH
static uint8_t buf[BUFFER_SIZE+1];
//SemaphoreHandle_t eth_mutex;
static void proc2(void* pvParam)
{
    151e:	cf 93       	push	r28
    1520:	df 93       	push	r29
    1522:	cd b7       	in	r28, 0x3d	; 61
    1524:	de b7       	in	r29, 0x3e	; 62
    1526:	60 97       	sbiw	r28, 0x10	; 16
    1528:	0f b6       	in	r0, 0x3f	; 63
    152a:	f8 94       	cli
    152c:	de bf       	out	0x3e, r29	; 62
    152e:	0f be       	out	0x3f, r0	; 63
    1530:	cd bf       	out	0x3d, r28	; 61
	//xSemaphoreGive(eth_mutex);
    
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		

	uint16_t plen;
	DDRB = 0xff;
    1532:	dd 24       	eor	r13, r13
    1534:	da 94       	dec	r13
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01)  //리눅스 서버용 파싱 
		 {
			 uint8_t temp[16] = {0};
    1536:	e0 e1       	ldi	r30, 0x10	; 16
    1538:	ce 2e       	mov	r12, r30
    153a:	ce 01       	movw	r24, r28
    153c:	01 96       	adiw	r24, 0x01	; 1
    153e:	7c 01       	movw	r14, r24

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1540:	bb 24       	eor	r11, r11
    1542:	b3 94       	inc	r11
			 data[7] = mem4[HOUR];
			 data[8] = mem4[CURRENT_RUN_NUMBER];  //현재 생산 페이지
			 data[9] = mem4[CURRENT_STATE_ON]; //혀재 생산 상태 값을 보냄. 가동중 or 가동 아닌 상태
			 data[10] = mem4[START_BUTTON]; //현재 시작 버튼의 상태를 보냄
			 data[11] = mem4[CURRENT_PAGE]; //현재 뷰 페이지 정보 
			 data[12] = device_serial;
    1544:	01 e0       	ldi	r16, 0x01	; 1
    1546:	10 ef       	ldi	r17, 0xF0	; 240
{
	//eth_mutex= xSemaphoreCreateMutex();
RESET_ETH:
	//xSemaphoreGive(eth_mutex);
    
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1548:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <cmp_mem>
    154c:	90 91 ad 02 	lds	r25, 0x02AD	; 0x8002ad <cmp_mem+0x1>
    1550:	a0 91 ae 02 	lds	r26, 0x02AE	; 0x8002ae <cmp_mem+0x2>
    1554:	b0 91 af 02 	lds	r27, 0x02AF	; 0x8002af <cmp_mem+0x3>
    1558:	80 93 a4 02 	sts	0x02A4, r24	; 0x8002a4 <_ZL4myip>
    155c:	90 93 a5 02 	sts	0x02A5, r25	; 0x8002a5 <_ZL4myip+0x1>
    1560:	a0 93 a6 02 	sts	0x02A6, r26	; 0x8002a6 <_ZL4myip+0x2>
    1564:	b0 93 a7 02 	sts	0x02A7, r27	; 0x8002a7 <_ZL4myip+0x3>

	uint16_t plen;
	DDRB = 0xff;
    1568:	d7 ba       	out	0x17, r13	; 23
	PORTB = 0xff;
    156a:	d8 ba       	out	0x18, r13	; 24
	 enc28j60Init(mymac);
    156c:	81 e0       	ldi	r24, 0x01	; 1
    156e:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    1570:	22 dd       	rcall	.-1468   	; 0xfb6 <_Z12enc28j60InitPh>
    1572:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    1574:	1c dd       	rcall	.-1480   	; 0xfae <_Z14enc28j60clkouth>
    1576:	8a e0       	ldi	r24, 0x0A	; 10
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	0e 94 9b 18 	call	0x3136	; 0x3136 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    157e:	66 e7       	ldi	r22, 0x76	; 118
    1580:	74 e0       	ldi	r23, 0x04	; 4
    1582:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    1584:	fc dc       	rcall	.-1544   	; 0xf7e <_Z16enc28j60PhyWritehj>
    1586:	84 e1       	ldi	r24, 0x14	; 20
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	0e 94 9b 18 	call	0x3136	; 0x3136 <vTaskDelay>
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    158e:	40 e5       	ldi	r20, 0x50	; 80
    1590:	64 ea       	ldi	r22, 0xA4	; 164
    1592:	72 e0       	ldi	r23, 0x02	; 2
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	91 e0       	ldi	r25, 0x01	; 1

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1598:	76 de       	rcall	.-788    	; 0x1286 <_Z19init_ip_arp_udp_tcpPhS_h>
    159a:	80 91 ac 02 	lds	r24, 0x02AC	; 0x8002ac <cmp_mem>
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	60 91 04 03 	lds	r22, 0x0304	; 0x800304 <mem4+0x40>
    15a4:	70 91 05 03 	lds	r23, 0x0305	; 0x800305 <mem4+0x41>
    15a8:	40 91 ad 02 	lds	r20, 0x02AD	; 0x8002ad <cmp_mem+0x1>
    15ac:	50 e0       	ldi	r21, 0x00	; 0
    15ae:	31 e0       	ldi	r19, 0x01	; 1
    15b0:	e0 91 06 03 	lds	r30, 0x0306	; 0x800306 <mem4+0x42>
    15b4:	f0 91 07 03 	lds	r31, 0x0307	; 0x800307 <mem4+0x43>
    15b8:	4e 17       	cp	r20, r30
    15ba:	5f 07       	cpc	r21, r31
    15bc:	09 f4       	brne	.+2      	; 0x15c0 <_ZL5proc2Pv+0xa2>
    15be:	30 e0       	ldi	r19, 0x00	; 0
    15c0:	21 e0       	ldi	r18, 0x01	; 1
    15c2:	86 17       	cp	r24, r22
    15c4:	97 07       	cpc	r25, r23
    15c6:	09 f4       	brne	.+2      	; 0x15ca <_ZL5proc2Pv+0xac>
    15c8:	20 e0       	ldi	r18, 0x00	; 0
    15ca:	32 2b       	or	r19, r18
    15cc:	40 91 ae 02 	lds	r20, 0x02AE	; 0x8002ae <cmp_mem+0x2>
    15d0:	50 e0       	ldi	r21, 0x00	; 0
    15d2:	21 e0       	ldi	r18, 0x01	; 1
    15d4:	e0 91 08 03 	lds	r30, 0x0308	; 0x800308 <mem4+0x44>
    15d8:	f0 91 09 03 	lds	r31, 0x0309	; 0x800309 <mem4+0x45>
    15dc:	4e 17       	cp	r20, r30
    15de:	5f 07       	cpc	r21, r31
    15e0:	09 f4       	brne	.+2      	; 0x15e4 <_ZL5proc2Pv+0xc6>
    15e2:	20 e0       	ldi	r18, 0x00	; 0
    15e4:	23 2b       	or	r18, r19
    15e6:	59 f4       	brne	.+22     	; 0x15fe <_ZL5proc2Pv+0xe0>
    15e8:	20 91 af 02 	lds	r18, 0x02AF	; 0x8002af <cmp_mem+0x3>
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	40 91 0a 03 	lds	r20, 0x030A	; 0x80030a <mem4+0x46>
    15f2:	50 91 0b 03 	lds	r21, 0x030B	; 0x80030b <mem4+0x47>
    15f6:	24 17       	cp	r18, r20
    15f8:	35 07       	cpc	r19, r21
    15fa:	09 f4       	brne	.+2      	; 0x15fe <_ZL5proc2Pv+0xe0>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    15fc:	44 c0       	rjmp	.+136    	; 0x1686 <_ZL5proc2Pv+0x168>
    15fe:	86 17       	cp	r24, r22
    1600:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    1602:	41 f0       	breq	.+16     	; 0x1614 <_ZL5proc2Pv+0xf6>
    1604:	80 e0       	ldi	r24, 0x00	; 0
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	0e 94 b6 1c 	call	0x396c	; 0x396c <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    160c:	80 91 04 03 	lds	r24, 0x0304	; 0x800304 <mem4+0x40>
    1610:	80 93 ac 02 	sts	0x02AC, r24	; 0x8002ac <cmp_mem>
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    1614:	60 91 06 03 	lds	r22, 0x0306	; 0x800306 <mem4+0x42>
    1618:	70 91 07 03 	lds	r23, 0x0307	; 0x800307 <mem4+0x43>
    161c:	80 91 ad 02 	lds	r24, 0x02AD	; 0x8002ad <cmp_mem+0x1>
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	86 17       	cp	r24, r22
    1624:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    1626:	41 f0       	breq	.+16     	; 0x1638 <_ZL5proc2Pv+0x11a>
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	0e 94 b6 1c 	call	0x396c	; 0x396c <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    1630:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <mem4+0x42>
    1634:	80 93 ad 02 	sts	0x02AD, r24	; 0x8002ad <cmp_mem+0x1>
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    1638:	60 91 08 03 	lds	r22, 0x0308	; 0x800308 <mem4+0x44>
    163c:	70 91 09 03 	lds	r23, 0x0309	; 0x800309 <mem4+0x45>
    1640:	80 91 ae 02 	lds	r24, 0x02AE	; 0x8002ae <cmp_mem+0x2>
    1644:	90 e0       	ldi	r25, 0x00	; 0
    1646:	86 17       	cp	r24, r22
    1648:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    164a:	41 f0       	breq	.+16     	; 0x165c <_ZL5proc2Pv+0x13e>
    164c:	82 e0       	ldi	r24, 0x02	; 2
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	0e 94 b6 1c 	call	0x396c	; 0x396c <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    1654:	80 91 08 03 	lds	r24, 0x0308	; 0x800308 <mem4+0x44>
    1658:	80 93 ae 02 	sts	0x02AE, r24	; 0x8002ae <cmp_mem+0x2>
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    165c:	60 91 0a 03 	lds	r22, 0x030A	; 0x80030a <mem4+0x46>
    1660:	70 91 0b 03 	lds	r23, 0x030B	; 0x80030b <mem4+0x47>
    1664:	80 91 af 02 	lds	r24, 0x02AF	; 0x8002af <cmp_mem+0x3>
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	86 17       	cp	r24, r22
    166c:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    166e:	41 f0       	breq	.+16     	; 0x1680 <_ZL5proc2Pv+0x162>
    1670:	83 e0       	ldi	r24, 0x03	; 3
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	0e 94 b6 1c 	call	0x396c	; 0x396c <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    1678:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <mem4+0x46>
    167c:	80 93 af 02 	sts	0x02AF, r24	; 0x8002af <cmp_mem+0x3>
			 }
			 cls_var = 1;
    1680:	b0 92 a8 02 	sts	0x02A8, r11	; 0x8002a8 <cls_var>
			 goto RESET_ETH;
		 }
		// xSemaphoreTake(eth_mutex,100);
			 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    1684:	61 cf       	rjmp	.-318    	; 0x1548 <_ZL5proc2Pv+0x2a>
    1686:	63 e1       	ldi	r22, 0x13	; 19
    1688:	72 e0       	ldi	r23, 0x02	; 2
    168a:	80 e8       	ldi	r24, 0x80	; 128
    168c:	90 e0       	ldi	r25, 0x00	; 0
		// xSemaphoreGive(eth_mutex);
		 if(plen==0)
    168e:	3e dd       	rcall	.-1412   	; 0x110c <_Z21enc28j60PacketReceivejPh>
    1690:	4c 01       	movw	r8, r24
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    1692:	00 97       	sbiw	r24, 0x00	; 0
    1694:	09 f4       	brne	.+2      	; 0x1698 <_ZL5proc2Pv+0x17a>
    1696:	6f c0       	rjmp	.+222    	; 0x1776 <_ZL5proc2Pv+0x258>
    1698:	bc 01       	movw	r22, r24
    169a:	83 e1       	ldi	r24, 0x13	; 19
    169c:	92 e0       	ldi	r25, 0x02	; 2
		 {
			 make_arp_answer_from_request(buf);
    169e:	08 de       	rcall	.-1008   	; 0x12b0 <_Z25eth_type_is_arp_and_my_ipPhj>
    16a0:	88 23       	and	r24, r24
    16a2:	21 f0       	breq	.+8      	; 0x16ac <_ZL5proc2Pv+0x18e>
			 continue;
    16a4:	83 e1       	ldi	r24, 0x13	; 19
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    16a6:	92 e0       	ldi	r25, 0x02	; 2
    16a8:	6c de       	rcall	.-808    	; 0x1382 <_Z28make_arp_answer_from_requestPh>
    16aa:	77 cf       	rjmp	.-274    	; 0x159a <_ZL5proc2Pv+0x7c>
    16ac:	b4 01       	movw	r22, r8
    16ae:	83 e1       	ldi	r24, 0x13	; 19
    16b0:	92 e0       	ldi	r25, 0x02	; 2
    16b2:	17 de       	rcall	.-978    	; 0x12e2 <_Z24eth_type_is_ip_and_my_ipPhj>
    16b4:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    16b6:	09 f4       	brne	.+2      	; 0x16ba <_ZL5proc2Pv+0x19c>
    16b8:	70 cf       	rjmp	.-288    	; 0x159a <_ZL5proc2Pv+0x7c>
    16ba:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <_ZL3buf+0x17>
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	49 f4       	brne	.+18     	; 0x16d4 <_ZL5proc2Pv+0x1b6>
    16c2:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <_ZL3buf+0x22>
		 {
			make_echo_reply_from_request(buf,plen);
    16c6:	88 30       	cpi	r24, 0x08	; 8
    16c8:	29 f4       	brne	.+10     	; 0x16d4 <_ZL5proc2Pv+0x1b6>
    16ca:	b4 01       	movw	r22, r8
    16cc:	83 e1       	ldi	r24, 0x13	; 19
			continue;
    16ce:	92 e0       	ldi	r25, 0x02	; 2
		 }
		 if(buf[UDP_DATA_P] == 0x01)  //리눅스 서버용 파싱 
    16d0:	84 de       	rcall	.-760    	; 0x13da <_Z28make_echo_reply_from_requestPhj>
    16d2:	63 cf       	rjmp	.-314    	; 0x159a <_ZL5proc2Pv+0x7c>
    16d4:	80 91 3d 02 	lds	r24, 0x023D	; 0x80023d <_ZL3buf+0x2a>
    16d8:	81 30       	cpi	r24, 0x01	; 1
		 {
			 uint8_t temp[16] = {0};
    16da:	09 f0       	breq	.+2      	; 0x16de <_ZL5proc2Pv+0x1c0>
    16dc:	4c c0       	rjmp	.+152    	; 0x1776 <_ZL5proc2Pv+0x258>
    16de:	f7 01       	movw	r30, r14
    16e0:	8c 2d       	mov	r24, r12
    16e2:	11 92       	st	Z+, r1
			 uint8_t loop = buf[UDP_DATA_P + 1];
    16e4:	8a 95       	dec	r24
    16e6:	e9 f7       	brne	.-6      	; 0x16e2 <_ZL5proc2Pv+0x1c4>
			 uint8_t start = 2;
			 uint8_t num = 0;
			 if(loop > 12)
    16e8:	20 91 3e 02 	lds	r18, 0x023E	; 0x80023e <_ZL3buf+0x2b>
    16ec:	2d 30       	cpi	r18, 0x0D	; 13
    16ee:	08 f0       	brcs	.+2      	; 0x16f2 <_ZL5proc2Pv+0x1d4>
    16f0:	42 c0       	rjmp	.+132    	; 0x1776 <_ZL5proc2Pv+0x258>
			 {
				 goto UDP_SEND;
			 }
			 for(uint8_t i=1;i<loop+1;i++)
    16f2:	41 e0       	ldi	r20, 0x01	; 1
    16f4:	50 e0       	ldi	r21, 0x00	; 0
    16f6:	30 e0       	ldi	r19, 0x00	; 0
    16f8:	84 2f       	mov	r24, r20
    16fa:	90 e0       	ldi	r25, 0x00	; 0
    16fc:	28 17       	cp	r18, r24
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    16fe:	39 07       	cpc	r19, r25
    1700:	f4 f0       	brlt	.+60     	; 0x173e <_ZL5proc2Pv+0x220>
    1702:	fc 01       	movw	r30, r24
    1704:	ed 5e       	subi	r30, 0xED	; 237
    1706:	fd 4f       	sbci	r31, 0xFD	; 253
    1708:	63 a5       	ldd	r22, Z+43	; 0x2b
    170a:	fe 01       	movw	r30, r28
    170c:	e8 0f       	add	r30, r24
				 if(i % 2 == 0)
    170e:	f9 1f       	adc	r31, r25
    1710:	60 83       	st	Z, r22
				 {
					 mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    1712:	40 fd       	sbrc	r20, 0
    1714:	12 c0       	rjmp	.+36     	; 0x173a <_ZL5proc2Pv+0x21c>
    1716:	e5 2f       	mov	r30, r21
    1718:	f0 e0       	ldi	r31, 0x00	; 0
    171a:	ee 0f       	add	r30, r30
    171c:	ff 1f       	adc	r31, r31
    171e:	e8 52       	subi	r30, 0x28	; 40
    1720:	fd 4f       	sbci	r31, 0xFD	; 253
    1722:	af ef       	ldi	r26, 0xFF	; 255
    1724:	bf ef       	ldi	r27, 0xFF	; 255
    1726:	ac 0f       	add	r26, r28
    1728:	bd 1f       	adc	r27, r29
    172a:	a8 0f       	add	r26, r24
    172c:	b9 1f       	adc	r27, r25
    172e:	8c 91       	ld	r24, X
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	96 2b       	or	r25, r22
					 num++;
    1734:	91 83       	std	Z+1, r25	; 0x01
			 uint8_t num = 0;
			 if(loop > 12)
			 {
				 goto UDP_SEND;
			 }
			 for(uint8_t i=1;i<loop+1;i++)
    1736:	80 83       	st	Z, r24
    1738:	5f 5f       	subi	r21, 0xFF	; 255
				 {
					 mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					 num++;
				 }
			 }
			  mem4[GOAL_CNT] =  (0xff00 & (buf[UDP_DATA_P + 14] << 8))| (0x00ff & buf[UDP_DATA_P + 15]);
    173a:	4f 5f       	subi	r20, 0xFF	; 255
    173c:	dd cf       	rjmp	.-70     	; 0x16f8 <_ZL5proc2Pv+0x1da>
    173e:	80 91 4b 02 	lds	r24, 0x024B	; 0x80024b <_ZL3buf+0x38>
    1742:	90 e0       	ldi	r25, 0x00	; 0
    1744:	98 2f       	mov	r25, r24
    1746:	88 27       	eor	r24, r24
    1748:	20 91 4c 02 	lds	r18, 0x024C	; 0x80024c <_ZL3buf+0x39>
    174c:	82 2b       	or	r24, r18
    174e:	90 93 d5 02 	sts	0x02D5, r25	; 0x8002d5 <mem4+0x11>
			  mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1752:	80 93 d4 02 	sts	0x02D4, r24	; 0x8002d4 <mem4+0x10>
    1756:	90 93 01 03 	sts	0x0301, r25	; 0x800301 <mem4+0x3d>
			  mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    175a:	80 93 00 03 	sts	0x0300, r24	; 0x800300 <mem4+0x3c>
    175e:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <mem4+0x39>
			  mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1762:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <mem4+0x38>
    1766:	90 93 fb 02 	sts	0x02FB, r25	; 0x8002fb <mem4+0x37>
			  mem4[TARGET_CMP] = mem4[GOAL_CNT];
    176a:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <mem4+0x36>
    176e:	90 93 03 03 	sts	0x0303, r25	; 0x800303 <mem4+0x3f>
				 }
			 }
		 }*/
		 UDP_SEND:
			 
			 if(led_flag)
    1772:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <mem4+0x3e>
    1776:	80 91 7f 03 	lds	r24, 0x037F	; 0x80037f <_ZL8led_flag>
			 {
				 PORTB = sbi(PORTB,4);
    177a:	88 23       	and	r24, r24
    177c:	19 f0       	breq	.+6      	; 0x1784 <_ZL5proc2Pv+0x266>
    177e:	88 b3       	in	r24, 0x18	; 24
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    1780:	80 61       	ori	r24, 0x10	; 16
    1782:	02 c0       	rjmp	.+4      	; 0x1788 <_ZL5proc2Pv+0x26a>
    1784:	88 b3       	in	r24, 0x18	; 24
    1786:	8f 7e       	andi	r24, 0xEF	; 239
			 }
			 static int data[19] = {0};
			 data[0] = mem4[TEMP];
    1788:	88 bb       	out	0x18, r24	; 24
    178a:	88 bb       	out	0x18, r24	; 24
    178c:	80 91 c6 02 	lds	r24, 0x02C6	; 0x8002c6 <mem4+0x2>
    1790:	90 91 c7 02 	lds	r25, 0x02C7	; 0x8002c7 <mem4+0x3>
    1794:	90 93 ee 01 	sts	0x01EE, r25	; 0x8001ee <_ZZL5proc2PvE4data+0x1>
			 data[1] = mem4[COUNT];
    1798:	80 93 ed 01 	sts	0x01ED, r24	; 0x8001ed <_ZZL5proc2PvE4data>
    179c:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <mem4+0x6>
    17a0:	90 91 cb 02 	lds	r25, 0x02CB	; 0x8002cb <mem4+0x7>
    17a4:	90 93 f0 01 	sts	0x01F0, r25	; 0x8001f0 <_ZZL5proc2PvE4data+0x3>
			 data[2] = mem4[PRESSURE];
    17a8:	80 93 ef 01 	sts	0x01EF, r24	; 0x8001ef <_ZZL5proc2PvE4data+0x2>
    17ac:	80 91 c8 02 	lds	r24, 0x02C8	; 0x8002c8 <mem4+0x4>
    17b0:	90 91 c9 02 	lds	r25, 0x02C9	; 0x8002c9 <mem4+0x5>
    17b4:	90 93 f2 01 	sts	0x01F2, r25	; 0x8001f2 <_ZZL5proc2PvE4data+0x5>
			 data[3] = mem4[GOAL_CNT];
    17b8:	80 93 f1 01 	sts	0x01F1, r24	; 0x8001f1 <_ZZL5proc2PvE4data+0x4>
    17bc:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <mem4+0x10>
    17c0:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <mem4+0x11>
    17c4:	90 93 f4 01 	sts	0x01F4, r25	; 0x8001f4 <_ZZL5proc2PvE4data+0x7>
			 data[4] = mem4[MACHINE_STATES];
    17c8:	80 93 f3 01 	sts	0x01F3, r24	; 0x8001f3 <_ZZL5proc2PvE4data+0x6>
    17cc:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <mem4+0x12>
    17d0:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <mem4+0x13>
    17d4:	90 93 f6 01 	sts	0x01F6, r25	; 0x8001f6 <_ZZL5proc2PvE4data+0x9>
			 data[5] = mem4[SEC];
    17d8:	80 93 f5 01 	sts	0x01F5, r24	; 0x8001f5 <_ZZL5proc2PvE4data+0x8>
    17dc:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <mem4+0xc>
    17e0:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <mem4+0xd>
    17e4:	90 93 f8 01 	sts	0x01F8, r25	; 0x8001f8 <_ZZL5proc2PvE4data+0xb>
			 data[6] = mem4[MIN];
    17e8:	80 93 f7 01 	sts	0x01F7, r24	; 0x8001f7 <_ZZL5proc2PvE4data+0xa>
    17ec:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <mem4+0xa>
    17f0:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <mem4+0xb>
    17f4:	90 93 fa 01 	sts	0x01FA, r25	; 0x8001fa <_ZZL5proc2PvE4data+0xd>
			 data[7] = mem4[HOUR];
    17f8:	80 93 f9 01 	sts	0x01F9, r24	; 0x8001f9 <_ZZL5proc2PvE4data+0xc>
    17fc:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <mem4+0x8>
    1800:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <mem4+0x9>
    1804:	90 93 fc 01 	sts	0x01FC, r25	; 0x8001fc <_ZZL5proc2PvE4data+0xf>
			 data[8] = mem4[CURRENT_RUN_NUMBER];  //현재 생산 페이지
    1808:	80 93 fb 01 	sts	0x01FB, r24	; 0x8001fb <_ZZL5proc2PvE4data+0xe>
    180c:	80 91 18 03 	lds	r24, 0x0318	; 0x800318 <mem4+0x54>
    1810:	90 91 19 03 	lds	r25, 0x0319	; 0x800319 <mem4+0x55>
    1814:	90 93 fe 01 	sts	0x01FE, r25	; 0x8001fe <_ZZL5proc2PvE4data+0x11>
			 data[9] = mem4[CURRENT_STATE_ON]; //혀재 생산 상태 값을 보냄. 가동중 or 가동 아닌 상태
    1818:	80 93 fd 01 	sts	0x01FD, r24	; 0x8001fd <_ZZL5proc2PvE4data+0x10>
    181c:	80 91 16 03 	lds	r24, 0x0316	; 0x800316 <mem4+0x52>
    1820:	90 91 17 03 	lds	r25, 0x0317	; 0x800317 <mem4+0x53>
    1824:	90 93 00 02 	sts	0x0200, r25	; 0x800200 <_ZZL5proc2PvE4data+0x13>
			 data[10] = mem4[START_BUTTON]; //현재 시작 버튼의 상태를 보냄
    1828:	80 93 ff 01 	sts	0x01FF, r24	; 0x8001ff <_ZZL5proc2PvE4data+0x12>
    182c:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <mem4+0x4c>
    1830:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <mem4+0x4d>
    1834:	90 93 02 02 	sts	0x0202, r25	; 0x800202 <_ZZL5proc2PvE4data+0x15>
			 data[11] = mem4[CURRENT_PAGE]; //현재 뷰 페이지 정보 
    1838:	80 93 01 02 	sts	0x0201, r24	; 0x800201 <_ZZL5proc2PvE4data+0x14>
    183c:	80 91 14 03 	lds	r24, 0x0314	; 0x800314 <mem4+0x50>
    1840:	90 91 15 03 	lds	r25, 0x0315	; 0x800315 <mem4+0x51>
    1844:	90 93 04 02 	sts	0x0204, r25	; 0x800204 <_ZZL5proc2PvE4data+0x17>
			 data[12] = device_serial;
    1848:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <_ZZL5proc2PvE4data+0x16>
    184c:	10 93 06 02 	sts	0x0206, r17	; 0x800206 <_ZZL5proc2PvE4data+0x19>
			 data[13] = mem4[UDP_DATA0];
    1850:	00 93 05 02 	sts	0x0205, r16	; 0x800205 <_ZZL5proc2PvE4data+0x18>
    1854:	80 91 d8 02 	lds	r24, 0x02D8	; 0x8002d8 <mem4+0x14>
    1858:	90 91 d9 02 	lds	r25, 0x02D9	; 0x8002d9 <mem4+0x15>
    185c:	90 93 08 02 	sts	0x0208, r25	; 0x800208 <_ZZL5proc2PvE4data+0x1b>
			 data[14] = mem4[UDP_DATA1];
    1860:	80 93 07 02 	sts	0x0207, r24	; 0x800207 <_ZZL5proc2PvE4data+0x1a>
    1864:	80 91 da 02 	lds	r24, 0x02DA	; 0x8002da <mem4+0x16>
    1868:	90 91 db 02 	lds	r25, 0x02DB	; 0x8002db <mem4+0x17>
    186c:	90 93 0a 02 	sts	0x020A, r25	; 0x80020a <_ZZL5proc2PvE4data+0x1d>
			 data[15] = mem4[UDP_DATA2];
    1870:	80 93 09 02 	sts	0x0209, r24	; 0x800209 <_ZZL5proc2PvE4data+0x1c>
    1874:	80 91 dc 02 	lds	r24, 0x02DC	; 0x8002dc <mem4+0x18>
    1878:	90 91 dd 02 	lds	r25, 0x02DD	; 0x8002dd <mem4+0x19>
    187c:	90 93 0c 02 	sts	0x020C, r25	; 0x80020c <_ZZL5proc2PvE4data+0x1f>
			 data[16] = mem4[UDP_DATA3];
    1880:	80 93 0b 02 	sts	0x020B, r24	; 0x80020b <_ZZL5proc2PvE4data+0x1e>
    1884:	80 91 de 02 	lds	r24, 0x02DE	; 0x8002de <mem4+0x1a>
    1888:	90 91 df 02 	lds	r25, 0x02DF	; 0x8002df <mem4+0x1b>
    188c:	90 93 0e 02 	sts	0x020E, r25	; 0x80020e <_ZZL5proc2PvE4data+0x21>
			 data[17] = mem4[UDP_DATA4];
    1890:	80 93 0d 02 	sts	0x020D, r24	; 0x80020d <_ZZL5proc2PvE4data+0x20>
    1894:	80 91 e0 02 	lds	r24, 0x02E0	; 0x8002e0 <mem4+0x1c>
    1898:	90 91 e1 02 	lds	r25, 0x02E1	; 0x8002e1 <mem4+0x1d>
    189c:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <_ZZL5proc2PvE4data+0x23>
			 data[18] = mem4[UDP_DATA5];
    18a0:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <_ZZL5proc2PvE4data+0x22>
    18a4:	80 91 e2 02 	lds	r24, 0x02E2	; 0x8002e2 <mem4+0x1e>
    18a8:	90 91 e3 02 	lds	r25, 0x02E3	; 0x8002e3 <mem4+0x1f>
    18ac:	90 93 12 02 	sts	0x0212, r25	; 0x800212 <_ZZL5proc2PvE4data+0x25>
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    18b0:	80 93 11 02 	sts	0x0211, r24	; 0x800211 <_ZZL5proc2PvE4data+0x24>
    18b4:	2f e0       	ldi	r18, 0x0F	; 15
    18b6:	37 e2       	ldi	r19, 0x27	; 39
    18b8:	46 e2       	ldi	r20, 0x26	; 38
    18ba:	6d ee       	ldi	r22, 0xED	; 237
    18bc:	71 e0       	ldi	r23, 0x01	; 1
			// memcpy(buf,data,sizeof(data));
			 //enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+sizeof(data),buf);
			 //vTaskDelay(500);
			 //memset(buf,0,sizeof(buf));
			 //vTaskDelay(100);
			 lcd_cnt++;
    18be:	83 e1       	ldi	r24, 0x13	; 19
    18c0:	92 e0       	ldi	r25, 0x02	; 2
    18c2:	a4 dd       	rcall	.-1208   	; 0x140c <_Z27make_udp_reply_from_requestPhPchj>
    18c4:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <lcd_cnt>
			taskYIELD();
    18c8:	8f 5f       	subi	r24, 0xFF	; 255
    18ca:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <lcd_cnt>
    18ce:	86 d6       	rcall	.+3340   	; 0x25dc <vPortYield>
    18d0:	64 ce       	rjmp	.-824    	; 0x159a <_ZL5proc2Pv+0x7c>

000018d2 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    18d2:	cf 93       	push	r28
    18d4:	df 93       	push	r29
    18d6:	cd b7       	in	r28, 0x3d	; 61
    18d8:	de b7       	in	r29, 0x3e	; 62
    18da:	2f 97       	sbiw	r28, 0x0f	; 15
    18dc:	0f b6       	in	r0, 0x3f	; 63
    18de:	f8 94       	cli
    18e0:	de bf       	out	0x3e, r29	; 62
    18e2:	0f be       	out	0x3f, r0	; 63
    18e4:	cd bf       	out	0x3d, r28	; 61
    18e6:	8c 01       	movw	r16, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    18e8:	ce 01       	movw	r24, r28
    18ea:	01 96       	adiw	r24, 0x01	; 1
    18ec:	7c 01       	movw	r14, r24
    18ee:	8f e0       	ldi	r24, 0x0F	; 15
    18f0:	f7 01       	movw	r30, r14
    18f2:	11 92       	st	Z+, r1
    18f4:	8a 95       	dec	r24
    18f6:	e9 f7       	brne	.-6      	; 0x18f2 <_ZL5proc1Pv+0x20>
    18f8:	6e 01       	movw	r12, r28
    18fa:	f0 e1       	ldi	r31, 0x10	; 16
    18fc:	cf 0e       	add	r12, r31
    18fe:	d1 1c       	adc	r13, r1

				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1900:	43 e0       	ldi	r20, 0x03	; 3
    1902:	a4 2e       	mov	r10, r20
    1904:	b1 2c       	mov	r11, r1
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
		
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1906:	80 91 d4 02 	lds	r24, 0x02D4	; 0x8002d4 <mem4+0x10>
    190a:	90 91 d5 02 	lds	r25, 0x02D5	; 0x8002d5 <mem4+0x11>
    190e:	20 91 02 03 	lds	r18, 0x0302	; 0x800302 <mem4+0x3e>
    1912:	30 91 03 03 	lds	r19, 0x0303	; 0x800303 <mem4+0x3f>
    1916:	28 17       	cp	r18, r24
    1918:	39 07       	cpc	r19, r25
    191a:	81 f0       	breq	.+32     	; 0x193c <_ZL5proc1Pv+0x6a>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    191c:	90 93 01 03 	sts	0x0301, r25	; 0x800301 <mem4+0x3d>
    1920:	80 93 00 03 	sts	0x0300, r24	; 0x800300 <mem4+0x3c>
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    1924:	90 93 fd 02 	sts	0x02FD, r25	; 0x8002fd <mem4+0x39>
    1928:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <mem4+0x38>
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    192c:	90 93 fb 02 	sts	0x02FB, r25	; 0x8002fb <mem4+0x37>
    1930:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <mem4+0x36>
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    1934:	90 93 03 03 	sts	0x0303, r25	; 0x800303 <mem4+0x3f>
    1938:	80 93 02 03 	sts	0x0302, r24	; 0x800302 <mem4+0x3e>
		}
		if(sb->SerialAvailable() >= 15)
    193c:	c8 01       	movw	r24, r16
    193e:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1942:	8f 30       	cpi	r24, 0x0F	; 15
    1944:	00 f3       	brcs	.-64     	; 0x1906 <_ZL5proc1Pv+0x34>
    1946:	47 01       	movw	r8, r14
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    1948:	c8 01       	movw	r24, r16
    194a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    194e:	f4 01       	movw	r30, r8
    1950:	81 93       	st	Z+, r24
    1952:	4f 01       	movw	r8, r30
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1954:	ce 16       	cp	r12, r30
    1956:	df 06       	cpc	r13, r31
    1958:	b9 f7       	brne	.-18     	; 0x1948 <_ZL5proc1Pv+0x76>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    195a:	89 81       	ldd	r24, Y+1	; 0x01
    195c:	82 30       	cpi	r24, 0x02	; 2
    195e:	09 f0       	breq	.+2      	; 0x1962 <_ZL5proc1Pv+0x90>
    1960:	7c c0       	rjmp	.+248    	; 0x1a5a <_ZL5proc1Pv+0x188>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1962:	88 85       	ldd	r24, Y+8	; 0x08
    1964:	99 85       	ldd	r25, Y+9	; 0x09
    1966:	98 27       	eor	r25, r24
    1968:	89 27       	eor	r24, r25
    196a:	98 27       	eor	r25, r24
    196c:	90 93 49 03 	sts	0x0349, r25	; 0x800349 <count_number+0x1>
    1970:	80 93 48 03 	sts	0x0348, r24	; 0x800348 <count_number>
    1974:	8a 85       	ldd	r24, Y+10	; 0x0a
    1976:	9b 85       	ldd	r25, Y+11	; 0x0b
    1978:	98 27       	eor	r25, r24
    197a:	89 27       	eor	r24, r25
    197c:	98 27       	eor	r25, r24
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    197e:	90 93 47 03 	sts	0x0347, r25	; 0x800347 <current_temp+0x1>
    1982:	80 93 46 03 	sts	0x0346, r24	; 0x800346 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    1986:	2c 85       	ldd	r18, Y+12	; 0x0c
    1988:	3d 85       	ldd	r19, Y+13	; 0x0d
    198a:	32 27       	eor	r19, r18
    198c:	23 27       	eor	r18, r19
    198e:	32 27       	eor	r19, r18
    1990:	30 93 45 03 	sts	0x0345, r19	; 0x800345 <current_pressure+0x1>
    1994:	20 93 44 03 	sts	0x0344, r18	; 0x800344 <current_pressure>
				if(mem4[TARGET_TEMP_SENSOR] != 1)
    1998:	20 91 0e 03 	lds	r18, 0x030E	; 0x80030e <mem4+0x4a>
    199c:	30 91 0f 03 	lds	r19, 0x030F	; 0x80030f <mem4+0x4b>
    19a0:	21 30       	cpi	r18, 0x01	; 1
    19a2:	31 05       	cpc	r19, r1
    19a4:	21 f0       	breq	.+8      	; 0x19ae <_ZL5proc1Pv+0xdc>
				{
					mem4[TEMP] = current_temp;
    19a6:	90 93 c7 02 	sts	0x02C7, r25	; 0x8002c7 <mem4+0x3>
    19aa:	80 93 c6 02 	sts	0x02C6, r24	; 0x8002c6 <mem4+0x2>
				}
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    19ae:	80 91 0c 03 	lds	r24, 0x030C	; 0x80030c <mem4+0x48>
    19b2:	90 91 0d 03 	lds	r25, 0x030D	; 0x80030d <mem4+0x49>
    19b6:	89 2b       	or	r24, r25
    19b8:	19 f0       	breq	.+6      	; 0x19c0 <_ZL5proc1Pv+0xee>
				{
					Alarm_Start();
    19ba:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <Alarm_Start>
    19be:	2d c0       	rjmp	.+90     	; 0x1a1a <_ZL5proc1Pv+0x148>
				}
				else //PLC
				{
					Alarm_Stop();
    19c0:	0e 94 ce 03 	call	0x79c	; 0x79c <Alarm_Stop>
					if(mem4[START_BUTTON] == ON)
    19c4:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <mem4+0x4c>
    19c8:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <mem4+0x4d>
    19cc:	01 97       	sbiw	r24, 0x01	; 1
    19ce:	29 f5       	brne	.+74     	; 0x1a1a <_ZL5proc1Pv+0x148>
    19d0:	ea e3       	ldi	r30, 0x3A	; 58
    19d2:	f3 e0       	ldi	r31, 0x03	; 3
    19d4:	80 e0       	ldi	r24, 0x00	; 0
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	28 2f       	mov	r18, r24
					{
						uint8_t i;
						for(i=0;i<PAGE_MAX;i++)
						{
							if(current_states_lookup_table[i] == ON)
    19da:	31 91       	ld	r19, Z+
    19dc:	31 30       	cpi	r19, 0x01	; 1
    19de:	61 f4       	brne	.+24     	; 0x19f8 <_ZL5proc1Pv+0x126>
							{
								current_cnt_mem[i] = count_number;
    19e0:	88 0f       	add	r24, r24
    19e2:	99 1f       	adc	r25, r25
    19e4:	fc 01       	movw	r30, r24
    19e6:	e0 55       	subi	r30, 0x50	; 80
    19e8:	fd 4f       	sbci	r31, 0xFD	; 253
    19ea:	80 91 48 03 	lds	r24, 0x0348	; 0x800348 <count_number>
    19ee:	90 91 49 03 	lds	r25, 0x0349	; 0x800349 <count_number+0x1>
    19f2:	91 83       	std	Z+1, r25	; 0x01
    19f4:	80 83       	st	Z, r24
								break;
    19f6:	05 c0       	rjmp	.+10     	; 0x1a02 <_ZL5proc1Pv+0x130>
    19f8:	01 96       	adiw	r24, 0x01	; 1
				{
					Alarm_Stop();
					if(mem4[START_BUTTON] == ON)
					{
						uint8_t i;
						for(i=0;i<PAGE_MAX;i++)
    19fa:	8a 30       	cpi	r24, 0x0A	; 10
    19fc:	91 05       	cpc	r25, r1
    19fe:	61 f7       	brne	.-40     	; 0x19d8 <_ZL5proc1Pv+0x106>
    1a00:	2a e0       	ldi	r18, 0x0A	; 10
							{
								current_cnt_mem[i] = count_number;
								break;
							}
						}
						mem4[COUNT] = current_cnt_mem[i]; 
    1a02:	e2 2f       	mov	r30, r18
    1a04:	f0 e0       	ldi	r31, 0x00	; 0
    1a06:	ee 0f       	add	r30, r30
    1a08:	ff 1f       	adc	r31, r31
    1a0a:	e0 55       	subi	r30, 0x50	; 80
    1a0c:	fd 4f       	sbci	r31, 0xFD	; 253
    1a0e:	80 81       	ld	r24, Z
    1a10:	91 81       	ldd	r25, Z+1	; 0x01
    1a12:	90 93 cb 02 	sts	0x02CB, r25	; 0x8002cb <mem4+0x7>
    1a16:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <mem4+0x6>
					}

				}
				mem4[PRESSURE] = current_pressure;
    1a1a:	80 91 44 03 	lds	r24, 0x0344	; 0x800344 <current_pressure>
    1a1e:	90 91 45 03 	lds	r25, 0x0345	; 0x800345 <current_pressure+0x1>
    1a22:	90 93 c9 02 	sts	0x02C9, r25	; 0x8002c9 <mem4+0x5>
    1a26:	80 93 c8 02 	sts	0x02C8, r24	; 0x8002c8 <mem4+0x4>
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    1a2a:	20 91 d4 02 	lds	r18, 0x02D4	; 0x8002d4 <mem4+0x10>
    1a2e:	30 91 d5 02 	lds	r19, 0x02D5	; 0x8002d5 <mem4+0x11>
    1a32:	80 91 ca 02 	lds	r24, 0x02CA	; 0x8002ca <mem4+0x6>
    1a36:	90 91 cb 02 	lds	r25, 0x02CB	; 0x8002cb <mem4+0x7>
    1a3a:	28 17       	cp	r18, r24
    1a3c:	39 07       	cpc	r19, r25
    1a3e:	09 f0       	breq	.+2      	; 0x1a42 <_ZL5proc1Pv+0x170>
    1a40:	62 cf       	rjmp	.-316    	; 0x1906 <_ZL5proc1Pv+0x34>
    1a42:	80 91 d6 02 	lds	r24, 0x02D6	; 0x8002d6 <mem4+0x12>
    1a46:	90 91 d7 02 	lds	r25, 0x02D7	; 0x8002d7 <mem4+0x13>
    1a4a:	89 2b       	or	r24, r25
    1a4c:	09 f0       	breq	.+2      	; 0x1a50 <_ZL5proc1Pv+0x17e>
    1a4e:	5b cf       	rjmp	.-330    	; 0x1906 <_ZL5proc1Pv+0x34>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1a50:	b0 92 d7 02 	sts	0x02D7, r11	; 0x8002d7 <mem4+0x13>
    1a54:	a0 92 d6 02 	sts	0x02D6, r10	; 0x8002d6 <mem4+0x12>
    1a58:	56 cf       	rjmp	.-340    	; 0x1906 <_ZL5proc1Pv+0x34>
				}
			}
			else
			{
				cbi(PORTB,7);
    1a5a:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    1a5c:	46 e0       	ldi	r20, 0x06	; 6
    1a5e:	61 e0       	ldi	r22, 0x01	; 1
    1a60:	82 e5       	ldi	r24, 0x52	; 82
    1a62:	93 e0       	ldi	r25, 0x03	; 3
    1a64:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    1a68:	45 e0       	ldi	r20, 0x05	; 5
    1a6a:	50 e0       	ldi	r21, 0x00	; 0
    1a6c:	62 e5       	ldi	r22, 0x52	; 82
    1a6e:	73 e0       	ldi	r23, 0x03	; 3
    1a70:	c8 01       	movw	r24, r16
    1a72:	0e 94 39 03 	call	0x672	; 0x672 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    1a76:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    1a7a:	8f 77       	andi	r24, 0x7F	; 127
    1a7c:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
				sb->SerialFlush();
    1a80:	c8 01       	movw	r24, r16
    1a82:	0e 94 a6 03 	call	0x74c	; 0x74c <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    1a86:	80 91 9a 00 	lds	r24, 0x009A	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    1a8a:	80 68       	ori	r24, 0x80	; 128
    1a8c:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
				sbi(PORTB,7);
    1a90:	c7 9a       	sbi	0x18, 7	; 24
    1a92:	39 cf       	rjmp	.-398    	; 0x1906 <_ZL5proc1Pv+0x34>

00001a94 <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1a94:	cf 93       	push	r28
    1a96:	df 93       	push	r29
    1a98:	cd b7       	in	r28, 0x3d	; 61
    1a9a:	de b7       	in	r29, 0x3e	; 62
    1a9c:	2a 97       	sbiw	r28, 0x0a	; 10
    1a9e:	0f b6       	in	r0, 0x3f	; 63
    1aa0:	f8 94       	cli
    1aa2:	de bf       	out	0x3e, r29	; 62
    1aa4:	0f be       	out	0x3f, r0	; 63
    1aa6:	cd bf       	out	0x3d, r28	; 61
    1aa8:	8c 01       	movw	r16, r24
	char read_Flag = 0;
    1aaa:	c1 2c       	mov	r12, r1
				if(current_states_lookup_table[mem4[CURRENT_RUN_NUMBER]] == ON)
				{
					current_cnt_mem[mem4[CURRENT_RUN_NUMBER]]++;
				}
			}
			chatter_flag = 2;
    1aac:	82 e0       	ldi	r24, 0x02	; 2
    1aae:	38 2e       	mov	r3, r24
    1ab0:	22 24       	eor	r2, r2
    1ab2:	23 94       	inc	r2
    1ab4:	7e 01       	movw	r14, r28
    1ab6:	89 e0       	ldi	r24, 0x09	; 9
    1ab8:	e8 0e       	add	r14, r24
    1aba:	f1 1c       	adc	r15, r1
    1abc:	2e 01       	movw	r4, r28
    1abe:	ac e0       	ldi	r26, 0x0C	; 12
    1ac0:	4a 0e       	add	r4, r26
    1ac2:	51 1c       	adc	r5, r1
						{
						
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == ON)
							{
								current_states_lookup_table[mem4[CURRENT_PAGE]] = 0;
								mem4[START_BUTTON] = OFF;
    1ac4:	92 e0       	ldi	r25, 0x02	; 2
    1ac6:	69 2e       	mov	r6, r25
    1ac8:	71 2c       	mov	r7, r1
						if(func10.startingAddressLo == 38)
						{
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == 0) //룩업 테이블은 처음 시작시 0값이어야 함,
							{
								uint8_t flag = 0;
								mem4[START_BUTTON] = ON;
    1aca:	aa 24       	eor	r10, r10
    1acc:	a3 94       	inc	r10
    1ace:	b1 2c       	mov	r11, r1
    1ad0:	34 e4       	ldi	r19, 0x44	; 68
    1ad2:	83 2e       	mov	r8, r19
    1ad4:	33 e0       	ldi	r19, 0x03	; 3
    1ad6:	93 2e       	mov	r9, r19
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    1ad8:	80 b3       	in	r24, 0x10	; 16
    1ada:	8e 3f       	cpi	r24, 0xFE	; 254
    1adc:	f9 f4       	brne	.+62     	; 0x1b1c <_ZL4procPv+0x88>
    1ade:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    1ae2:	81 30       	cpi	r24, 0x01	; 1
    1ae4:	d9 f4       	brne	.+54     	; 0x1b1c <_ZL4procPv+0x88>
		{
			if(mem4[START_BUTTON] == ON)
    1ae6:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <mem4+0x4c>
    1aea:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <mem4+0x4d>
    1aee:	01 97       	sbiw	r24, 0x01	; 1
    1af0:	99 f4       	brne	.+38     	; 0x1b18 <_ZL4procPv+0x84>
			{
				if(current_states_lookup_table[mem4[CURRENT_RUN_NUMBER]] == ON)
    1af2:	e0 91 18 03 	lds	r30, 0x0318	; 0x800318 <mem4+0x54>
    1af6:	f0 91 19 03 	lds	r31, 0x0319	; 0x800319 <mem4+0x55>
    1afa:	df 01       	movw	r26, r30
    1afc:	a6 5c       	subi	r26, 0xC6	; 198
    1afe:	bc 4f       	sbci	r27, 0xFC	; 252
    1b00:	8c 91       	ld	r24, X
    1b02:	81 30       	cpi	r24, 0x01	; 1
    1b04:	49 f4       	brne	.+18     	; 0x1b18 <_ZL4procPv+0x84>
				{
					current_cnt_mem[mem4[CURRENT_RUN_NUMBER]]++;
    1b06:	ee 0f       	add	r30, r30
    1b08:	ff 1f       	adc	r31, r31
    1b0a:	e0 55       	subi	r30, 0x50	; 80
    1b0c:	fd 4f       	sbci	r31, 0xFD	; 253
    1b0e:	80 81       	ld	r24, Z
    1b10:	91 81       	ldd	r25, Z+1	; 0x01
    1b12:	01 96       	adiw	r24, 0x01	; 1
    1b14:	91 83       	std	Z+1, r25	; 0x01
    1b16:	80 83       	st	Z, r24
				}
			}
			chatter_flag = 2;
    1b18:	30 92 aa 02 	sts	0x02AA, r3	; 0x8002aa <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    1b1c:	80 b3       	in	r24, 0x10	; 16
    1b1e:	8f 3f       	cpi	r24, 0xFF	; 255
    1b20:	29 f4       	brne	.+10     	; 0x1b2c <_ZL4procPv+0x98>
    1b22:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    1b26:	82 30       	cpi	r24, 0x02	; 2
    1b28:	09 f4       	brne	.+2      	; 0x1b2c <_ZL4procPv+0x98>
    1b2a:	63 c1       	rjmp	.+710    	; 0x1df2 <_ZL4procPv+0x35e>
		{
			vTaskDelay(10);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    1b2c:	80 91 d0 02 	lds	r24, 0x02D0	; 0x8002d0 <mem4+0xc>
    1b30:	90 91 d1 02 	lds	r25, 0x02D1	; 0x8002d1 <mem4+0xd>
    1b34:	cc 97       	sbiw	r24, 0x3c	; 60
    1b36:	f4 f0       	brlt	.+60     	; 0x1b74 <_ZL4procPv+0xe0>
		{
			mem4[SEC] = 0;
    1b38:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <mem4+0xd>
    1b3c:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <mem4+0xc>
			mem4[MIN]++;
    1b40:	80 91 ce 02 	lds	r24, 0x02CE	; 0x8002ce <mem4+0xa>
    1b44:	90 91 cf 02 	lds	r25, 0x02CF	; 0x8002cf <mem4+0xb>
    1b48:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    1b4a:	8c 33       	cpi	r24, 0x3C	; 60
    1b4c:	91 05       	cpc	r25, r1
    1b4e:	2c f4       	brge	.+10     	; 0x1b5a <_ZL4procPv+0xc6>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    1b50:	90 93 cf 02 	sts	0x02CF, r25	; 0x8002cf <mem4+0xb>
    1b54:	80 93 ce 02 	sts	0x02CE, r24	; 0x8002ce <mem4+0xa>
    1b58:	0d c0       	rjmp	.+26     	; 0x1b74 <_ZL4procPv+0xe0>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    1b5a:	10 92 cf 02 	sts	0x02CF, r1	; 0x8002cf <mem4+0xb>
    1b5e:	10 92 ce 02 	sts	0x02CE, r1	; 0x8002ce <mem4+0xa>
				mem4[HOUR]++;
    1b62:	80 91 cc 02 	lds	r24, 0x02CC	; 0x8002cc <mem4+0x8>
    1b66:	90 91 cd 02 	lds	r25, 0x02CD	; 0x8002cd <mem4+0x9>
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	90 93 cd 02 	sts	0x02CD, r25	; 0x8002cd <mem4+0x9>
    1b70:	80 93 cc 02 	sts	0x02CC, r24	; 0x8002cc <mem4+0x8>
			}
		}
		mem4[COUNT] = current_cnt_mem[mem4[CURRENT_PAGE]];
    1b74:	e0 91 14 03 	lds	r30, 0x0314	; 0x800314 <mem4+0x50>
    1b78:	f0 91 15 03 	lds	r31, 0x0315	; 0x800315 <mem4+0x51>
    1b7c:	ee 0f       	add	r30, r30
    1b7e:	ff 1f       	adc	r31, r31
    1b80:	e0 55       	subi	r30, 0x50	; 80
    1b82:	fd 4f       	sbci	r31, 0xFD	; 253
    1b84:	80 81       	ld	r24, Z
    1b86:	91 81       	ldd	r25, Z+1	; 0x01
    1b88:	90 93 cb 02 	sts	0x02CB, r25	; 0x8002cb <mem4+0x7>
    1b8c:	80 93 ca 02 	sts	0x02CA, r24	; 0x8002ca <mem4+0x6>
		if(read_Flag == 0)
    1b90:	c1 10       	cpse	r12, r1
    1b92:	7c c0       	rjmp	.+248    	; 0x1c8c <_ZL4procPv+0x1f8>
		{
			if(sb->SerialAvailable() >= 2)
    1b94:	c8 01       	movw	r24, r16
    1b96:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1b9a:	82 30       	cpi	r24, 0x02	; 2
    1b9c:	08 f4       	brcc	.+2      	; 0x1ba0 <_ZL4procPv+0x10c>
    1b9e:	3c c1       	rjmp	.+632    	; 0x1e18 <_ZL4procPv+0x384>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    1ba0:	c8 01       	movw	r24, r16
    1ba2:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1ba6:	89 83       	std	Y+1, r24	; 0x01
    1ba8:	c8 01       	movw	r24, r16
    1baa:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1bae:	8a 83       	std	Y+2, r24	; 0x02
					#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
					#endif
				}
				if(buf1[0] != 0x01)
    1bb0:	99 81       	ldd	r25, Y+1	; 0x01
    1bb2:	91 30       	cpi	r25, 0x01	; 1
    1bb4:	c9 f5       	brne	.+114    	; 0x1c28 <_ZL4procPv+0x194>
				{
				//	read_Flag = 0;
					goto FREAM_ERROR;
				}
				if(buf1[1] == 0x01)
    1bb6:	81 30       	cpi	r24, 0x01	; 1
    1bb8:	09 f4       	brne	.+2      	; 0x1bbc <_ZL4procPv+0x128>
    1bba:	6b c0       	rjmp	.+214    	; 0x1c92 <_ZL4procPv+0x1fe>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    1bbc:	84 30       	cpi	r24, 0x04	; 4
    1bbe:	51 f4       	brne	.+20     	; 0x1bd4 <_ZL4procPv+0x140>

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
    1bc0:	c8 01       	movw	r24, r16
    1bc2:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1bc6:	86 30       	cpi	r24, 0x06	; 6
    1bc8:	d8 f4       	brcc	.+54     	; 0x1c00 <_ZL4procPv+0x16c>
    1bca:	e4 e0       	ldi	r30, 0x04	; 4
    1bcc:	de 2e       	mov	r13, r30
    1bce:	cc 24       	eor	r12, r12
    1bd0:	c3 94       	inc	r12
    1bd2:	82 cf       	rjmp	.-252    	; 0x1ad8 <_ZL4procPv+0x44>
				else if(buf1[1] == 0x04)
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1bd4:	85 30       	cpi	r24, 0x05	; 5
    1bd6:	49 f4       	brne	.+18     	; 0x1bea <_ZL4procPv+0x156>

				}
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
    1bd8:	c8 01       	movw	r24, r16
    1bda:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1bde:	86 30       	cpi	r24, 0x06	; 6
    1be0:	08 f0       	brcs	.+2      	; 0x1be4 <_ZL4procPv+0x150>
    1be2:	7f c0       	rjmp	.+254    	; 0x1ce2 <_ZL4procPv+0x24e>
    1be4:	75 e0       	ldi	r23, 0x05	; 5
    1be6:	d7 2e       	mov	r13, r23
    1be8:	f2 cf       	rjmp	.-28     	; 0x1bce <_ZL4procPv+0x13a>
				else if(buf1[1] == 0x05)
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1bea:	80 31       	cpi	r24, 0x10	; 16
    1bec:	e9 f4       	brne	.+58     	; 0x1c28 <_ZL4procPv+0x194>
	
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
    1bee:	c8 01       	movw	r24, r16
    1bf0:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1bf4:	89 30       	cpi	r24, 0x09	; 9
    1bf6:	08 f0       	brcs	.+2      	; 0x1bfa <_ZL4procPv+0x166>
    1bf8:	98 c0       	rjmp	.+304    	; 0x1d2a <_ZL4procPv+0x296>
    1bfa:	60 e1       	ldi	r22, 0x10	; 16
    1bfc:	d6 2e       	mov	r13, r22
    1bfe:	e7 cf       	rjmp	.-50     	; 0x1bce <_ZL4procPv+0x13a>
    1c00:	6e 01       	movw	r12, r28
    1c02:	83 e0       	ldi	r24, 0x03	; 3
    1c04:	c8 0e       	add	r12, r24
    1c06:	d1 1c       	adc	r13, r1
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1c08:	c8 01       	movw	r24, r16
    1c0a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1c0e:	d6 01       	movw	r26, r12
    1c10:	8d 93       	st	X+, r24
    1c12:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1c14:	ea 16       	cp	r14, r26
    1c16:	fb 06       	cpc	r15, r27
    1c18:	b9 f7       	brne	.-18     	; 0x1c08 <_ZL4procPv+0x174>
						#if PACKET_DEBUG
							sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크 
    1c1a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c1c:	90 e0       	ldi	r25, 0x00	; 0
    1c1e:	c9 97       	sbiw	r24, 0x39	; 57
    1c20:	0c f4       	brge	.+2      	; 0x1c24 <_ZL4procPv+0x190>
    1c22:	4d c0       	rjmp	.+154    	; 0x1cbe <_ZL4procPv+0x22a>
    1c24:	54 e0       	ldi	r21, 0x04	; 4
    1c26:	d5 2e       	mov	r13, r21
				{
					FREAM_ERROR:
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    1c28:	41 e0       	ldi	r20, 0x01	; 1
    1c2a:	61 e0       	ldi	r22, 0x01	; 1
    1c2c:	82 e5       	ldi	r24, 0x52	; 82
    1c2e:	93 e0       	ldi	r25, 0x03	; 3
    1c30:	0e 94 dc 02 	call	0x5b8	; 0x5b8 <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    1c34:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);
    1c36:	57 98       	cbi	0x0a, 7	; 10
					dev->getInterfaceAddr(UART0)->Stop_Device();                                                                                                                                                                                                                
    1c38:	60 e0       	ldi	r22, 0x00	; 0
    1c3a:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1c3e:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1c42:	0e 94 bd 04 	call	0x97a	; 0x97a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1c46:	dc 01       	movw	r26, r24
    1c48:	ed 91       	ld	r30, X+
    1c4a:	fc 91       	ld	r31, X
    1c4c:	00 84       	ldd	r0, Z+8	; 0x08
    1c4e:	f1 85       	ldd	r31, Z+9	; 0x09
    1c50:	e0 2d       	mov	r30, r0
    1c52:	09 95       	icall
					sb->SerialFlush();
    1c54:	c8 01       	movw	r24, r16
    1c56:	0e 94 a6 03 	call	0x74c	; 0x74c <_ZN12SerialBuffer11SerialFlushEv>
					dev->getInterfaceAddr(UART0)->Start_Device(0);
    1c5a:	60 e0       	ldi	r22, 0x00	; 0
    1c5c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1c60:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1c64:	0e 94 bd 04 	call	0x97a	; 0x97a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1c68:	dc 01       	movw	r26, r24
    1c6a:	ed 91       	ld	r30, X+
    1c6c:	fc 91       	ld	r31, X
    1c6e:	02 84       	ldd	r0, Z+10	; 0x0a
    1c70:	f3 85       	ldd	r31, Z+11	; 0x0b
    1c72:	e0 2d       	mov	r30, r0
    1c74:	60 e0       	ldi	r22, 0x00	; 0
    1c76:	09 95       	icall
					sbi(UCSR0B,RXCIE0);
    1c78:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    1c7a:	45 e0       	ldi	r20, 0x05	; 5
    1c7c:	50 e0       	ldi	r21, 0x00	; 0
    1c7e:	62 e5       	ldi	r22, 0x52	; 82
    1c80:	73 e0       	ldi	r23, 0x03	; 3
    1c82:	c8 01       	movw	r24, r16
    1c84:	0e 94 39 03 	call	0x672	; 0x672 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    1c88:	c7 9a       	sbi	0x18, 7	; 24
    1c8a:	c6 c0       	rjmp	.+396    	; 0x1e18 <_ZL4procPv+0x384>
			}
			
		}
		if(read_Flag == 1)
		{
			if(function_code == 0x01)  
    1c8c:	b1 e0       	ldi	r27, 0x01	; 1
    1c8e:	db 12       	cpse	r13, r27
    1c90:	b7 c0       	rjmp	.+366    	; 0x1e00 <_ZL4procPv+0x36c>
			{
				if(sb->SerialAvailable() >= 6)
    1c92:	c8 01       	movw	r24, r16
    1c94:	0e 94 9b 03 	call	0x736	; 0x736 <_ZN12SerialBuffer15SerialAvailableEv>
    1c98:	86 30       	cpi	r24, 0x06	; 6
    1c9a:	18 f4       	brcc	.+6      	; 0x1ca2 <_ZL4procPv+0x20e>
    1c9c:	dd 24       	eor	r13, r13
    1c9e:	d3 94       	inc	r13
    1ca0:	96 cf       	rjmp	.-212    	; 0x1bce <_ZL4procPv+0x13a>
    1ca2:	6e 01       	movw	r12, r28
    1ca4:	b3 e0       	ldi	r27, 0x03	; 3
    1ca6:	cb 0e       	add	r12, r27
    1ca8:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1caa:	c8 01       	movw	r24, r16
    1cac:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1cb0:	f6 01       	movw	r30, r12
    1cb2:	81 93       	st	Z+, r24
    1cb4:	6f 01       	movw	r12, r30
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1cb6:	ee 15       	cp	r30, r14
    1cb8:	ff 05       	cpc	r31, r15
    1cba:	b9 f7       	brne	.-18     	; 0x1caa <_ZL4procPv+0x216>
    1cbc:	ef cf       	rjmp	.-34     	; 0x1c9c <_ZL4procPv+0x208>
							//sb->SerialWrite((char*)&exception,sizeof(exception));
							goto FREAM_ERROR;
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
    1cbe:	44 ec       	ldi	r20, 0xC4	; 196
    1cc0:	52 e0       	ldi	r21, 0x02	; 2
    1cc2:	62 e6       	ldi	r22, 0x62	; 98
    1cc4:	73 e0       	ldi	r23, 0x03	; 3
    1cc6:	ce 01       	movw	r24, r28
    1cc8:	01 96       	adiw	r24, 0x01	; 1
    1cca:	0e 94 65 02 	call	0x4ca	; 0x4ca <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1cce:	47 e0       	ldi	r20, 0x07	; 7
    1cd0:	50 e0       	ldi	r21, 0x00	; 0
    1cd2:	62 e6       	ldi	r22, 0x62	; 98
    1cd4:	73 e0       	ldi	r23, 0x03	; 3
    1cd6:	c8 01       	movw	r24, r16
    1cd8:	0e 94 39 03 	call	0x672	; 0x672 <_ZN12SerialBuffer11SerialWriteEPKci>
    1cdc:	24 e0       	ldi	r18, 0x04	; 4
    1cde:	d2 2e       	mov	r13, r18
    1ce0:	9b c0       	rjmp	.+310    	; 0x1e18 <_ZL4procPv+0x384>
    1ce2:	6e 01       	movw	r12, r28
    1ce4:	e3 e0       	ldi	r30, 0x03	; 3
    1ce6:	ce 0e       	add	r12, r30
    1ce8:	d1 1c       	adc	r13, r1
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1cea:	c8 01       	movw	r24, r16
    1cec:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1cf0:	d6 01       	movw	r26, r12
    1cf2:	8d 93       	st	X+, r24
    1cf4:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1cf6:	ea 16       	cp	r14, r26
    1cf8:	fb 06       	cpc	r15, r27
    1cfa:	b9 f7       	brne	.-18     	; 0x1cea <_ZL4procPv+0x256>
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크
    1cfc:	8c 81       	ldd	r24, Y+4	; 0x04
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	c9 97       	sbiw	r24, 0x39	; 57
    1d02:	1c f0       	brlt	.+6      	; 0x1d0a <_ZL4procPv+0x276>
    1d04:	45 e0       	ldi	r20, 0x05	; 5
    1d06:	d4 2e       	mov	r13, r20
    1d08:	8f cf       	rjmp	.-226    	; 0x1c28 <_ZL4procPv+0x194>
					{
						goto FREAM_ERROR;
					}
					else
					{
						GetFunc05Data(buf1,&func05);
    1d0a:	69 e6       	ldi	r22, 0x69	; 105
    1d0c:	73 e0       	ldi	r23, 0x03	; 3
    1d0e:	ce 01       	movw	r24, r28
    1d10:	01 96       	adiw	r24, 0x01	; 1
    1d12:	0e 94 82 02 	call	0x504	; 0x504 <_Z13GetFunc05DataPcP17GetFunctionCode05>
						sb->SerialWrite((char*)&func05,sizeof(func05));
    1d16:	48 e0       	ldi	r20, 0x08	; 8
    1d18:	50 e0       	ldi	r21, 0x00	; 0
    1d1a:	69 e6       	ldi	r22, 0x69	; 105
    1d1c:	73 e0       	ldi	r23, 0x03	; 3
    1d1e:	c8 01       	movw	r24, r16
    1d20:	0e 94 39 03 	call	0x672	; 0x672 <_ZN12SerialBuffer11SerialWriteEPKci>
    1d24:	95 e0       	ldi	r25, 0x05	; 5
    1d26:	d9 2e       	mov	r13, r25
    1d28:	77 c0       	rjmp	.+238    	; 0x1e18 <_ZL4procPv+0x384>
    1d2a:	6e 01       	movw	r12, r28
    1d2c:	e3 e0       	ldi	r30, 0x03	; 3
    1d2e:	ce 0e       	add	r12, r30
    1d30:	d1 1c       	adc	r13, r1
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    1d32:	c8 01       	movw	r24, r16
    1d34:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <_ZN12SerialBuffer10SerialReadEv>
    1d38:	d6 01       	movw	r26, r12
    1d3a:	8d 93       	st	X+, r24
    1d3c:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    1d3e:	4a 16       	cp	r4, r26
    1d40:	5b 06       	cpc	r5, r27
    1d42:	b9 f7       	brne	.-18     	; 0x1d32 <_ZL4procPv+0x29e>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1d44:	44 ec       	ldi	r20, 0xC4	; 196
    1d46:	52 e0       	ldi	r21, 0x02	; 2
    1d48:	67 e5       	ldi	r22, 0x57	; 87
    1d4a:	73 e0       	ldi	r23, 0x03	; 3
    1d4c:	ce 01       	movw	r24, r28
    1d4e:	01 96       	adiw	r24, 0x01	; 1
    1d50:	0e 94 9b 02 	call	0x536	; 0x536 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크
    1d54:	8c 81       	ldd	r24, Y+4	; 0x04
    1d56:	90 e0       	ldi	r25, 0x00	; 0
    1d58:	c9 97       	sbiw	r24, 0x39	; 57
    1d5a:	1c f0       	brlt	.+6      	; 0x1d62 <_ZL4procPv+0x2ce>
    1d5c:	30 e1       	ldi	r19, 0x10	; 16
    1d5e:	d3 2e       	mov	r13, r19
    1d60:	63 cf       	rjmp	.-314    	; 0x1c28 <_ZL4procPv+0x194>
					{
						goto FREAM_ERROR;
					}
					else
					{
						if(func10.startingAddressLo == 38)
    1d62:	80 91 5a 03 	lds	r24, 0x035A	; 0x80035a <func10+0x3>
    1d66:	86 32       	cpi	r24, 0x26	; 38
    1d68:	01 f5       	brne	.+64     	; 0x1daa <_ZL4procPv+0x316>
						{
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == 0) //룩업 테이블은 처음 시작시 0값이어야 함,
    1d6a:	80 91 14 03 	lds	r24, 0x0314	; 0x800314 <mem4+0x50>
    1d6e:	90 91 15 03 	lds	r25, 0x0315	; 0x800315 <mem4+0x51>
    1d72:	dc 01       	movw	r26, r24
    1d74:	a6 5c       	subi	r26, 0xC6	; 198
    1d76:	bc 4f       	sbci	r27, 0xFC	; 252
    1d78:	2c 91       	ld	r18, X
    1d7a:	21 11       	cpse	r18, r1
    1d7c:	2a c0       	rjmp	.+84     	; 0x1dd2 <_ZL4procPv+0x33e>
							{
								uint8_t flag = 0;
								mem4[START_BUTTON] = ON;
    1d7e:	b0 92 11 03 	sts	0x0311, r11	; 0x800311 <mem4+0x4d>
    1d82:	a0 92 10 03 	sts	0x0310, r10	; 0x800310 <mem4+0x4c>
								mem4[CURRENT_STATE_ON] = ON; // 시작 등 ON
    1d86:	b0 92 17 03 	sts	0x0317, r11	; 0x800317 <mem4+0x53>
    1d8a:	a0 92 16 03 	sts	0x0316, r10	; 0x800316 <mem4+0x52>
    1d8e:	ea e3       	ldi	r30, 0x3A	; 58
    1d90:	f3 e0       	ldi	r31, 0x03	; 3
								//룩업 테이블을 먼저 확인 함. 한개라도 가동중이면 리턴함, 가동이 반드시 끝나고 시작해야함(페이지 이동 후 시작 시)
								for(uint8_t i = 0; i< PAGE_MAX;i++)
								{
									if(current_states_lookup_table[i] == ON)
    1d92:	21 91       	ld	r18, Z+
    1d94:	21 30       	cpi	r18, 0x01	; 1
    1d96:	e9 f0       	breq	.+58     	; 0x1dd2 <_ZL4procPv+0x33e>
							{
								uint8_t flag = 0;
								mem4[START_BUTTON] = ON;
								mem4[CURRENT_STATE_ON] = ON; // 시작 등 ON
								//룩업 테이블을 먼저 확인 함. 한개라도 가동중이면 리턴함, 가동이 반드시 끝나고 시작해야함(페이지 이동 후 시작 시)
								for(uint8_t i = 0; i< PAGE_MAX;i++)
    1d98:	8e 16       	cp	r8, r30
    1d9a:	9f 06       	cpc	r9, r31
    1d9c:	d1 f7       	brne	.-12     	; 0x1d92 <_ZL4procPv+0x2fe>
										break;
									}
								}
								if(flag == 0)
								{
									current_states_lookup_table[mem4[CURRENT_PAGE]] = ON;
    1d9e:	2c 92       	st	X, r2
									mem4[CURRENT_RUN_NUMBER] = mem4[CURRENT_PAGE];
    1da0:	90 93 19 03 	sts	0x0319, r25	; 0x800319 <mem4+0x55>
    1da4:	80 93 18 03 	sts	0x0318, r24	; 0x800318 <mem4+0x54>
    1da8:	14 c0       	rjmp	.+40     	; 0x1dd2 <_ZL4procPv+0x33e>
								}
							}
						}
						if(func10.startingAddressLo == 39)
    1daa:	87 32       	cpi	r24, 0x27	; 39
    1dac:	91 f4       	brne	.+36     	; 0x1dd2 <_ZL4procPv+0x33e>
						{
						
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == ON)
    1dae:	e0 91 14 03 	lds	r30, 0x0314	; 0x800314 <mem4+0x50>
    1db2:	f0 91 15 03 	lds	r31, 0x0315	; 0x800315 <mem4+0x51>
    1db6:	e6 5c       	subi	r30, 0xC6	; 198
    1db8:	fc 4f       	sbci	r31, 0xFC	; 252
    1dba:	80 81       	ld	r24, Z
    1dbc:	81 30       	cpi	r24, 0x01	; 1
    1dbe:	49 f4       	brne	.+18     	; 0x1dd2 <_ZL4procPv+0x33e>
							{
								current_states_lookup_table[mem4[CURRENT_PAGE]] = 0;
    1dc0:	10 82       	st	Z, r1
								mem4[START_BUTTON] = OFF;
    1dc2:	70 92 11 03 	sts	0x0311, r7	; 0x800311 <mem4+0x4d>
    1dc6:	60 92 10 03 	sts	0x0310, r6	; 0x800310 <mem4+0x4c>
								mem4[CURRENT_STATE_ON] = 0;//시작 등  OFF
    1dca:	10 92 17 03 	sts	0x0317, r1	; 0x800317 <mem4+0x53>
    1dce:	10 92 16 03 	sts	0x0316, r1	; 0x800316 <mem4+0x52>
							}
						}
						ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1dd2:	6a e4       	ldi	r22, 0x4A	; 74
    1dd4:	73 e0       	ldi	r23, 0x03	; 3
    1dd6:	ce 01       	movw	r24, r28
    1dd8:	01 96       	adiw	r24, 0x01	; 1
    1dda:	0e 94 c3 02 	call	0x586	; 0x586 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
						sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    1dde:	48 e0       	ldi	r20, 0x08	; 8
    1de0:	50 e0       	ldi	r21, 0x00	; 0
    1de2:	6a e4       	ldi	r22, 0x4A	; 74
    1de4:	73 e0       	ldi	r23, 0x03	; 3
    1de6:	c8 01       	movw	r24, r16
    1de8:	0e 94 39 03 	call	0x672	; 0x672 <_ZN12SerialBuffer11SerialWriteEPKci>
    1dec:	80 e1       	ldi	r24, 0x10	; 16
    1dee:	d8 2e       	mov	r13, r24
    1df0:	13 c0       	rjmp	.+38     	; 0x1e18 <_ZL4procPv+0x384>
			}
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
		{
			vTaskDelay(10);
    1df2:	8a e0       	ldi	r24, 0x0A	; 10
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	0e 94 9b 18 	call	0x3136	; 0x3136 <vTaskDelay>
			chatter_flag = 0;
    1dfa:	10 92 aa 02 	sts	0x02AA, r1	; 0x8002aa <chatter_flag>
    1dfe:	96 ce       	rjmp	.-724    	; 0x1b2c <_ZL4procPv+0x98>
						#endif
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1e00:	f4 e0       	ldi	r31, 0x04	; 4
    1e02:	df 16       	cp	r13, r31
    1e04:	09 f4       	brne	.+2      	; 0x1e08 <_ZL4procPv+0x374>
    1e06:	dc ce       	rjmp	.-584    	; 0x1bc0 <_ZL4procPv+0x12c>
							read_Flag = 0;
					}

				}
			}
			else if(function_code == 0x05) //터치 버튼 
    1e08:	b5 e0       	ldi	r27, 0x05	; 5
    1e0a:	db 16       	cp	r13, r27
    1e0c:	09 f4       	brne	.+2      	; 0x1e10 <_ZL4procPv+0x37c>
    1e0e:	e4 ce       	rjmp	.-568    	; 0x1bd8 <_ZL4procPv+0x144>
						read_Flag = 0;
					}
	
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1e10:	b0 e1       	ldi	r27, 0x10	; 16
    1e12:	db 12       	cpse	r13, r27
    1e14:	dc ce       	rjmp	.-584    	; 0x1bce <_ZL4procPv+0x13a>
    1e16:	eb ce       	rjmp	.-554    	; 0x1bee <_ZL4procPv+0x15a>
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
							sb->SerialWrite((char*)&func04,sizeof(func04));
							read_Flag = 0;
    1e18:	c1 2c       	mov	r12, r1
    1e1a:	5e ce       	rjmp	.-836    	; 0x1ad8 <_ZL4procPv+0x44>

00001e1c <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    1e1c:	80 91 71 03 	lds	r24, 0x0371	; 0x800371 <DataStruct>
    1e20:	90 91 72 03 	lds	r25, 0x0372	; 0x800372 <DataStruct+0x1>
    1e24:	0e 94 17 03 	call	0x62e	; 0x62e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    1e28:	c5 9a       	sbi	0x18, 5	; 24
    1e2a:	08 95       	ret

00001e2c <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    1e2c:	80 91 73 03 	lds	r24, 0x0373	; 0x800373 <DataStruct+0x2>
    1e30:	90 91 74 03 	lds	r25, 0x0374	; 0x800374 <DataStruct+0x3>
    1e34:	0e 94 17 03 	call	0x62e	; 0x62e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    1e38:	c6 9a       	sbi	0x18, 6	; 24
    1e3a:	08 95       	ret

00001e3c <_Z16Count_Sensor_ISR8Dev_typej>:
{

}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,80,Set_Alarm);
    1e3c:	47 e8       	ldi	r20, 0x87	; 135
    1e3e:	5a e0       	ldi	r21, 0x0A	; 10
    1e40:	60 e5       	ldi	r22, 0x50	; 80
    1e42:	70 e0       	ldi	r23, 0x00	; 0
    1e44:	80 e0       	ldi	r24, 0x00	; 0
    1e46:	0c 94 d6 03 	jmp	0x7ac	; 0x7ac <Alarm_Open>

00001e4a <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    1e4a:	cf 93       	push	r28
    1e4c:	df 93       	push	r29
	dev = new Dev_Manager();
    1e4e:	84 e1       	ldi	r24, 0x14	; 20
    1e50:	90 e0       	ldi	r25, 0x00	; 0
    1e52:	0e 94 6e 04 	call	0x8dc	; 0x8dc <_ZN11Dev_ManagernwEj>
    1e56:	ec 01       	movw	r28, r24
    1e58:	0e 94 3c 04 	call	0x878	; 0x878 <_ZN11Dev_ManagerC1Ev>
    1e5c:	d0 93 7e 03 	sts	0x037E, r29	; 0x80037e <dev+0x1>
    1e60:	c0 93 7d 03 	sts	0x037D, r28	; 0x80037d <dev>
	#if USE_LCD
		lcd = new Char_LCD2004A();
	#endif
	#if USE_ADC
		adc = new Adc();
    1e64:	84 e0       	ldi	r24, 0x04	; 4
    1e66:	90 e0       	ldi	r25, 0x00	; 0
    1e68:	0e 94 c4 03 	call	0x788	; 0x788 <_ZN3AdcnwEj>
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	12 82       	std	Z+2, r1	; 0x02
    1e70:	13 82       	std	Z+3, r1	; 0x03
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Adc : public DeviceDriveInterFace
    1e72:	8b e0       	ldi	r24, 0x0B	; 11
    1e74:	91 e0       	ldi	r25, 0x01	; 1
    1e76:	91 83       	std	Z+1, r25	; 0x01
    1e78:	80 83       	st	Z, r24
    1e7a:	f0 93 7c 03 	sts	0x037C, r31	; 0x80037c <adc+0x1>
    1e7e:	e0 93 7b 03 	sts	0x037B, r30	; 0x80037b <adc>
		dev->Register_Dev(adc,_ADC);
    1e82:	44 e0       	ldi	r20, 0x04	; 4
    1e84:	bf 01       	movw	r22, r30
    1e86:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1e8a:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1e8e:	0e 94 66 04 	call	0x8cc	; 0x8cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	#endif
	dev->Register_Dev(new UartDriver,UART0);
    1e92:	88 e0       	ldi	r24, 0x08	; 8
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	0e 94 b2 06 	call	0xd64	; 0xd64 <_ZN10UartDrivernwEj>
    1e9a:	ec 01       	movw	r28, r24
    1e9c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_ZN10UartDriverC1Ev>
    1ea0:	40 e0       	ldi	r20, 0x00	; 0
    1ea2:	be 01       	movw	r22, r28
    1ea4:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1ea8:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1eac:	0e 94 66 04 	call	0x8cc	; 0x8cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    1eb0:	88 e0       	ldi	r24, 0x08	; 8
    1eb2:	90 e0       	ldi	r25, 0x00	; 0
    1eb4:	0e 94 08 06 	call	0xc10	; 0xc10 <_ZN11RS485DrivernwEj>
    1eb8:	ec 01       	movw	r28, r24
    1eba:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <_ZN11RS485DriverC1Ev>
    1ebe:	41 e0       	ldi	r20, 0x01	; 1
    1ec0:	be 01       	movw	r22, r28
    1ec2:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1ec6:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1eca:	0e 94 66 04 	call	0x8cc	; 0x8cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    1ece:	82 e0       	ldi	r24, 0x02	; 2
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	0e 94 d1 05 	call	0xba2	; 0xba2 <_ZN5TimernwEj>
    1ed6:	ec 01       	movw	r28, r24
    1ed8:	0e 94 cb 05 	call	0xb96	; 0xb96 <_ZN5TimerC1Ev>
    1edc:	42 e0       	ldi	r20, 0x02	; 2
    1ede:	be 01       	movw	r22, r28
    1ee0:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1ee4:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1ee8:	0e 94 66 04 	call	0x8cc	; 0x8cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    1eec:	82 e0       	ldi	r24, 0x02	; 2
    1eee:	90 e0       	ldi	r25, 0x00	; 0
    1ef0:	0e 94 3a 04 	call	0x874	; 0x874 <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    1ef4:	2b e1       	ldi	r18, 0x1B	; 27
    1ef6:	31 e0       	ldi	r19, 0x01	; 1
    1ef8:	fc 01       	movw	r30, r24
    1efa:	31 83       	std	Z+1, r19	; 0x01
    1efc:	20 83       	st	Z, r18
    1efe:	43 e0       	ldi	r20, 0x03	; 3
    1f00:	bc 01       	movw	r22, r24
    1f02:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f06:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f0a:	0e 94 66 04 	call	0x8cc	; 0x8cc <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	
	dev->Device_Init(UART0);
    1f0e:	60 e0       	ldi	r22, 0x00	; 0
    1f10:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f14:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f18:	0e 94 94 04 	call	0x928	; 0x928 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    1f1c:	61 e0       	ldi	r22, 0x01	; 1
    1f1e:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f22:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f26:	0e 94 94 04 	call	0x928	; 0x928 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    1f2a:	62 e0       	ldi	r22, 0x02	; 2
    1f2c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f30:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f34:	0e 94 94 04 	call	0x928	; 0x928 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    1f38:	63 e0       	ldi	r22, 0x03	; 3
    1f3a:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f3e:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f42:	0e 94 94 04 	call	0x928	; 0x928 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	#if USE_ADC
		dev->Device_Init(_ADC);
    1f46:	64 e0       	ldi	r22, 0x04	; 4
    1f48:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f4c:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f50:	0e 94 94 04 	call	0x928	; 0x928 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	#endif
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    1f54:	47 e5       	ldi	r20, 0x57	; 87
    1f56:	51 e0       	ldi	r21, 0x01	; 1
    1f58:	60 e0       	ldi	r22, 0x00	; 0
    1f5a:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f5e:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    1f62:	0e 94 82 04 	call	0x904	; 0x904 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1f66:	4d e7       	ldi	r20, 0x7D	; 125
    1f68:	51 e0       	ldi	r21, 0x01	; 1
    1f6a:	61 e0       	ldi	r22, 0x01	; 1
    1f6c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    1f70:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
}
    1f74:	df 91       	pop	r29
    1f76:	cf 91       	pop	r28
	dev->Device_Init(COUNT_SENSOR);
	#if USE_ADC
		dev->Device_Init(_ADC);
	#endif
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1f78:	0c 94 82 04 	jmp	0x904	; 0x904 <_ZN11Dev_Manager6WritesE8Dev_typePKc>

00001f7c <main>:
#if USE_ADC
	uint16_t Adc_channels[8] = {0};
	uint8_t Adc_check_flag[8] = {0};
#endif
int main( void )
{
    1f7c:	cf 92       	push	r12
    1f7e:	df 92       	push	r13
    1f80:	ef 92       	push	r14
    1f82:	ff 92       	push	r15
    1f84:	0f 93       	push	r16
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
	mem4[CURRENT_PAGE] = 0;//초기 페이지는 1 
    1f8a:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <mem4+0x51>
    1f8e:	10 92 14 03 	sts	0x0314, r1	; 0x800314 <mem4+0x50>
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    1f92:	80 e0       	ldi	r24, 0x00	; 0
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	0e 94 ae 1c 	call	0x395c	; 0x395c <eeprom_read_byte>
    1f9a:	d8 2e       	mov	r13, r24
    1f9c:	90 e0       	ldi	r25, 0x00	; 0
    1f9e:	90 93 05 03 	sts	0x0305, r25	; 0x800305 <mem4+0x41>
    1fa2:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	0e 94 ae 1c 	call	0x395c	; 0x395c <eeprom_read_byte>
    1fae:	d8 2f       	mov	r29, r24
    1fb0:	90 e0       	ldi	r25, 0x00	; 0
    1fb2:	90 93 07 03 	sts	0x0307, r25	; 0x800307 <mem4+0x43>
    1fb6:	80 93 06 03 	sts	0x0306, r24	; 0x800306 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    1fba:	82 e0       	ldi	r24, 0x02	; 2
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	0e 94 ae 1c 	call	0x395c	; 0x395c <eeprom_read_byte>
    1fc2:	c8 2f       	mov	r28, r24
    1fc4:	90 e0       	ldi	r25, 0x00	; 0
    1fc6:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <mem4+0x45>
    1fca:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    1fce:	83 e0       	ldi	r24, 0x03	; 3
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	0e 94 ae 1c 	call	0x395c	; 0x395c <eeprom_read_byte>
    1fd6:	28 2f       	mov	r18, r24
    1fd8:	30 e0       	ldi	r19, 0x00	; 0
    1fda:	30 93 0b 03 	sts	0x030B, r19	; 0x80030b <mem4+0x47>
    1fde:	20 93 0a 03 	sts	0x030A, r18	; 0x80030a <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    1fe2:	d0 92 ac 02 	sts	0x02AC, r13	; 0x8002ac <cmp_mem>
	cmp_mem[1] = mem4[IPV4_1];
    1fe6:	d0 93 ad 02 	sts	0x02AD, r29	; 0x8002ad <cmp_mem+0x1>
	cmp_mem[2] = mem4[IPV4_2];
    1fea:	c0 93 ae 02 	sts	0x02AE, r28	; 0x8002ae <cmp_mem+0x2>
	cmp_mem[3] = mem4[IPV4_3];
    1fee:	80 93 af 02 	sts	0x02AF, r24	; 0x8002af <cmp_mem+0x3>
int main( void )
{
	mem4[CURRENT_PAGE] = 0;//초기 페이지는 1 
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1ff2:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1ff4:	2a df       	rcall	.-428    	; 0x1e4a <_Z8Init_Devv>
    1ff6:	4e e0       	ldi	r20, 0x0E	; 14
    1ff8:	5f e0       	ldi	r21, 0x0F	; 15
    1ffa:	60 e0       	ldi	r22, 0x00	; 0
    1ffc:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    2000:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    2004:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    2008:	46 e1       	ldi	r20, 0x16	; 22
    200a:	5f e0       	ldi	r21, 0x0F	; 15
    200c:	61 e0       	ldi	r22, 0x01	; 1
    200e:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    2012:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    2016:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    201a:	4f e5       	ldi	r20, 0x5F	; 95
    201c:	5a e0       	ldi	r21, 0x0A	; 10
    201e:	62 e0       	ldi	r22, 0x02	; 2
    2020:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    2024:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    2028:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    202c:	4e e1       	ldi	r20, 0x1E	; 30
    202e:	5f e0       	ldi	r21, 0x0F	; 15
    2030:	63 e0       	ldi	r22, 0x03	; 3
    2032:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    2036:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    203a:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	#if USE_ADC
		dev->Open_Handle(_ADC,ADC_ISR);
    203e:	46 e8       	ldi	r20, 0x86	; 134
    2040:	5a e0       	ldi	r21, 0x0A	; 10
    2042:	64 e0       	ldi	r22, 0x04	; 4
    2044:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <dev>
    2048:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <dev+0x1>
    204c:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	#endif
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    2050:	88 e8       	ldi	r24, 0x88	; 136
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	0e 94 15 03 	call	0x62a	; 0x62a <_ZN12SerialBuffernwEj>
    2058:	6c 01       	movw	r12, r24
    205a:	60 91 7d 03 	lds	r22, 0x037D	; 0x80037d <dev>
    205e:	70 91 7e 03 	lds	r23, 0x037E	; 0x80037e <dev+0x1>
    2062:	40 e0       	ldi	r20, 0x00	; 0
    2064:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    2068:	c1 14       	cp	r12, r1
    206a:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    206c:	21 f4       	brne	.+8      	; 0x2076 <main+0xfa>
    206e:	81 e0       	ldi	r24, 0x01	; 1
    2070:	90 e0       	ldi	r25, 0x00	; 0
    2072:	0e 94 c7 1c 	call	0x398e	; 0x398e <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    2076:	88 e8       	ldi	r24, 0x88	; 136
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	0e 94 15 03 	call	0x62a	; 0x62a <_ZN12SerialBuffernwEj>
    207e:	ec 01       	movw	r28, r24
    2080:	60 91 7d 03 	lds	r22, 0x037D	; 0x80037d <dev>
    2084:	70 91 7e 03 	lds	r23, 0x037E	; 0x80037e <dev+0x1>
    2088:	41 e0       	ldi	r20, 0x01	; 1
    208a:	0e 94 ec 02 	call	0x5d8	; 0x5d8 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    208e:	20 97       	sbiw	r28, 0x00	; 0
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    2090:	71 f3       	breq	.-36     	; 0x206e <main+0xf2>
    2092:	d0 92 72 03 	sts	0x0372, r13	; 0x800372 <DataStruct+0x1>
    2096:	c0 92 71 03 	sts	0x0371, r12	; 0x800371 <DataStruct>
	DataStruct[RS485] = sb1;
    209a:	d0 93 74 03 	sts	0x0374, r29	; 0x800374 <DataStruct+0x3>
    209e:	c0 93 73 03 	sts	0x0373, r28	; 0x800373 <DataStruct+0x2>
		}
	}
	

		
	Alarm_Init(); //알람 초기화
    20a2:	0e 94 c6 03 	call	0x78c	; 0x78c <Alarm_Init>
	"Task1",      //테스크 이름
	300+MAX_ENUM,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    20a6:	78 94       	sei
    20a8:	e1 2c       	mov	r14, r1
    20aa:	f1 2c       	mov	r15, r1
    20ac:	02 e0       	ldi	r16, 0x02	; 2
    20ae:	96 01       	movw	r18, r12
    20b0:	45 e6       	ldi	r20, 0x65	; 101
    20b2:	51 e0       	ldi	r21, 0x01	; 1
    20b4:	64 ea       	ldi	r22, 0xA4	; 164
    20b6:	71 e0       	ldi	r23, 0x01	; 1
    20b8:	8a e4       	ldi	r24, 0x4A	; 74
    20ba:	9d e0       	ldi	r25, 0x0D	; 13
		"Task2",      //테스크 이름
		200,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    20bc:	0b d6       	rcall	.+3094   	; 0x2cd4 <xTaskCreate>
    20be:	9e 01       	movw	r18, r28
    20c0:	48 ec       	ldi	r20, 0xC8	; 200
    20c2:	50 e0       	ldi	r21, 0x00	; 0
    20c4:	6a ea       	ldi	r22, 0xAA	; 170
    20c6:	71 e0       	ldi	r23, 0x01	; 1
    20c8:	89 e6       	ldi	r24, 0x69	; 105
    20ca:	9c e0       	ldi	r25, 0x0C	; 12
				"Task3",      //테스크 이름
				650,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    20cc:	03 d6       	rcall	.+3078   	; 0x2cd4 <xTaskCreate>
    20ce:	20 e0       	ldi	r18, 0x00	; 0
    20d0:	30 e0       	ldi	r19, 0x00	; 0
    20d2:	4a e8       	ldi	r20, 0x8A	; 138
    20d4:	52 e0       	ldi	r21, 0x02	; 2
    20d6:	60 eb       	ldi	r22, 0xB0	; 176
    20d8:	71 e0       	ldi	r23, 0x01	; 1
    20da:	8f e8       	ldi	r24, 0x8F	; 143
    20dc:	9a e0       	ldi	r25, 0x0A	; 10
		"Task3",      //테스크 이름
		200,                   //스택의 크기
		NULL,       // 테스크 매개 변수
		2,                     //테스크 우선 순위0.
		NULL                   //태스크 핸들
		);
    20de:	fa d5       	rcall	.+3060   	; 0x2cd4 <xTaskCreate>
    20e0:	20 e0       	ldi	r18, 0x00	; 0
    20e2:	30 e0       	ldi	r19, 0x00	; 0
    20e4:	48 ec       	ldi	r20, 0xC8	; 200
    20e6:	50 e0       	ldi	r21, 0x00	; 0
    20e8:	60 eb       	ldi	r22, 0xB0	; 176
    20ea:	71 e0       	ldi	r23, 0x01	; 1
    20ec:	89 e2       	ldi	r24, 0x29	; 41
		#endif	

		
	
	vTaskStartScheduler();//스케줄러 실행 
    20ee:	91 e1       	ldi	r25, 0x11	; 17
    20f0:	f1 d5       	rcall	.+3042   	; 0x2cd4 <xTaskCreate>
	return 0;
}
    20f2:	e2 d6       	rcall	.+3524   	; 0x2eb8 <vTaskStartScheduler>
    20f4:	80 e0       	ldi	r24, 0x00	; 0
    20f6:	90 e0       	ldi	r25, 0x00	; 0
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	0f 91       	pop	r16
    20fe:	ff 90       	pop	r15
    2100:	ef 90       	pop	r14
    2102:	df 90       	pop	r13
    2104:	cf 90       	pop	r12
    2106:	08 95       	ret

00002108 <_Z9fnCalTempf>:
	100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
	110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
120};

float fnCalTemp(float lfOneVolt)
{
    2108:	4f 92       	push	r4
    210a:	5f 92       	push	r5
    210c:	6f 92       	push	r6
    210e:	7f 92       	push	r7
    2110:	8f 92       	push	r8
    2112:	9f 92       	push	r9
    2114:	af 92       	push	r10
    2116:	bf 92       	push	r11
    2118:	cf 92       	push	r12
    211a:	df 92       	push	r13
    211c:	ef 92       	push	r14
    211e:	ff 92       	push	r15
    2120:	0f 93       	push	r16
    2122:	1f 93       	push	r17
    2124:	cf 93       	push	r28
    2126:	df 93       	push	r29
    2128:	cd b7       	in	r28, 0x3d	; 61
    212a:	de b7       	in	r29, 0x3e	; 62
    212c:	28 97       	sbiw	r28, 0x08	; 8
    212e:	0f b6       	in	r0, 0x3f	; 63
    2130:	f8 94       	cli
    2132:	de bf       	out	0x3e, r29	; 62
    2134:	0f be       	out	0x3f, r0	; 63
    2136:	cd bf       	out	0x3d, r28	; 61
    2138:	6b 01       	movw	r12, r22
    213a:	7c 01       	movw	r14, r24
    213c:	0e ec       	ldi	r16, 0xCE	; 206
    213e:	11 e0       	ldi	r17, 0x01	; 1
	uint8_t i = 0;
	uint8_t dClass = 0;
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
    2140:	19 82       	std	Y+1, r1	; 0x01
	{
		if( lfOneVolt<pgm_read_float(&g_alfVolt[i]) )
    2142:	f8 01       	movw	r30, r16
    2144:	65 91       	lpm	r22, Z+
    2146:	75 91       	lpm	r23, Z+
    2148:	85 91       	lpm	r24, Z+
    214a:	94 91       	lpm	r25, Z
    214c:	a7 01       	movw	r20, r14
    214e:	96 01       	movw	r18, r12
    2150:	0e 94 fc 1b 	call	0x37f8	; 0x37f8 <__gesf2>
    2154:	18 16       	cp	r1, r24
    2156:	44 f0       	brlt	.+16     	; 0x2168 <_Z9fnCalTempf+0x60>
{
	uint8_t i = 0;
	uint8_t dClass = 0;
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
    2158:	29 81       	ldd	r18, Y+1	; 0x01
    215a:	2f 5f       	subi	r18, 0xFF	; 255
    215c:	29 83       	std	Y+1, r18	; 0x01
    215e:	0c 5f       	subi	r16, 0xFC	; 252
    2160:	1f 4f       	sbci	r17, 0xFF	; 255
    2162:	21 3a       	cpi	r18, 0xA1	; 161
    2164:	71 f7       	brne	.-36     	; 0x2142 <_Z9fnCalTempf+0x3a>
120};

float fnCalTemp(float lfOneVolt)
{
	uint8_t i = 0;
	uint8_t dClass = 0;
    2166:	19 82       	std	Y+1, r1	; 0x01
		{
			dClass = i;
			break;
		}
	}
	if (pgm_read_dword(&g_adTemp[dClass-1])<0 )
    2168:	89 80       	ldd	r8, Y+1	; 0x01
    216a:	a8 2d       	mov	r26, r8
    216c:	b0 e0       	ldi	r27, 0x00	; 0
    216e:	9d 01       	movw	r18, r26
    2170:	21 50       	subi	r18, 0x01	; 1
    2172:	31 09       	sbc	r19, r1
    2174:	f9 01       	movw	r30, r18
    2176:	ee 0f       	add	r30, r30
    2178:	ff 1f       	adc	r31, r31
    217a:	e4 57       	subi	r30, 0x74	; 116
    217c:	ff 4f       	sbci	r31, 0xFF	; 255
    217e:	45 91       	lpm	r20, Z+
    2180:	55 91       	lpm	r21, Z+
    2182:	65 91       	lpm	r22, Z+
    2184:	74 91       	lpm	r23, Z
		//정답지: 32~40 간략화           //1도   상위 고정값 - 측정된 값    /1도 구간에서 저항 변환량
		lfCalTemp = pgm_read_dword(&g_adTemp[dClass-1]) + (1 * ( (pgm_read_float(&g_alfVolt[dClass])-lfOneVolt)/(pgm_read_float(&g_alfVolt[dClass])-pgm_read_float(&g_alfVolt[dClass-1])) ));
	}
	else
	{
		lfCalTemp = pgm_read_dword(&g_adTemp[dClass]) - (1 * ( (pgm_read_float(&g_alfVolt[dClass])-lfOneVolt)/(pgm_read_float(&g_alfVolt[dClass])-pgm_read_float(&g_alfVolt[dClass-1])) ));
    2186:	fd 01       	movw	r30, r26
    2188:	ee 0f       	add	r30, r30
    218a:	ff 1f       	adc	r31, r31
    218c:	e4 57       	subi	r30, 0x74	; 116
    218e:	ff 4f       	sbci	r31, 0xFF	; 255
    2190:	65 91       	lpm	r22, Z+
    2192:	75 91       	lpm	r23, Z+
    2194:	85 91       	lpm	r24, Z+
    2196:	94 91       	lpm	r25, Z
    2198:	ad 01       	movw	r20, r26
    219a:	44 0f       	add	r20, r20
    219c:	55 1f       	adc	r21, r21
    219e:	44 0f       	add	r20, r20
    21a0:	55 1f       	adc	r21, r21
    21a2:	42 53       	subi	r20, 0x32	; 50
    21a4:	5e 4f       	sbci	r21, 0xFE	; 254
    21a6:	fa 01       	movw	r30, r20
    21a8:	45 90       	lpm	r4, Z+
    21aa:	55 90       	lpm	r5, Z+
    21ac:	65 90       	lpm	r6, Z+
    21ae:	74 90       	lpm	r7, Z
    21b0:	fa 01       	movw	r30, r20
    21b2:	85 90       	lpm	r8, Z+
    21b4:	95 90       	lpm	r9, Z+
    21b6:	a5 90       	lpm	r10, Z+
    21b8:	b4 90       	lpm	r11, Z
    21ba:	89 82       	std	Y+1, r8	; 0x01
    21bc:	9a 82       	std	Y+2, r9	; 0x02
    21be:	ab 82       	std	Y+3, r10	; 0x03
    21c0:	bc 82       	std	Y+4, r11	; 0x04
    21c2:	f9 01       	movw	r30, r18
    21c4:	ee 0f       	add	r30, r30
    21c6:	ff 1f       	adc	r31, r31
    21c8:	ee 0f       	add	r30, r30
    21ca:	ff 1f       	adc	r31, r31
    21cc:	e2 53       	subi	r30, 0x32	; 50
    21ce:	fe 4f       	sbci	r31, 0xFE	; 254
    21d0:	85 90       	lpm	r8, Z+
    21d2:	95 90       	lpm	r9, Z+
    21d4:	a5 90       	lpm	r10, Z+
    21d6:	b4 90       	lpm	r11, Z
    21d8:	8d 82       	std	Y+5, r8	; 0x05
    21da:	9e 82       	std	Y+6, r9	; 0x06
    21dc:	af 82       	std	Y+7, r10	; 0x07
    21de:	b8 86       	std	Y+8, r11	; 0x08
	}
	return lfCalTemp;
    21e0:	0e 94 4a 1b 	call	0x3694	; 0x3694 <__floatunsisf>
    21e4:	4b 01       	movw	r8, r22
    21e6:	5c 01       	movw	r10, r24
    21e8:	a7 01       	movw	r20, r14
    21ea:	96 01       	movw	r18, r12
    21ec:	c3 01       	movw	r24, r6
    21ee:	b2 01       	movw	r22, r4
    21f0:	0e 94 4c 1a 	call	0x3498	; 0x3498 <__subsf3>
    21f4:	6b 01       	movw	r12, r22
    21f6:	7c 01       	movw	r14, r24
    21f8:	2d 81       	ldd	r18, Y+5	; 0x05
    21fa:	3e 81       	ldd	r19, Y+6	; 0x06
    21fc:	4f 81       	ldd	r20, Y+7	; 0x07
    21fe:	58 85       	ldd	r21, Y+8	; 0x08
    2200:	69 81       	ldd	r22, Y+1	; 0x01
    2202:	7a 81       	ldd	r23, Y+2	; 0x02
    2204:	8b 81       	ldd	r24, Y+3	; 0x03
    2206:	9c 81       	ldd	r25, Y+4	; 0x04
    2208:	0e 94 4c 1a 	call	0x3498	; 0x3498 <__subsf3>
    220c:	9b 01       	movw	r18, r22
    220e:	ac 01       	movw	r20, r24
    2210:	c7 01       	movw	r24, r14
    2212:	b6 01       	movw	r22, r12
    2214:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__divsf3>
    2218:	9b 01       	movw	r18, r22
    221a:	ac 01       	movw	r20, r24
    221c:	c5 01       	movw	r24, r10
    221e:	b4 01       	movw	r22, r8
    2220:	0e 94 4c 1a 	call	0x3498	; 0x3498 <__subsf3>
}
    2224:	28 96       	adiw	r28, 0x08	; 8
    2226:	0f b6       	in	r0, 0x3f	; 63
    2228:	f8 94       	cli
    222a:	de bf       	out	0x3e, r29	; 62
    222c:	0f be       	out	0x3f, r0	; 63
    222e:	cd bf       	out	0x3d, r28	; 61
    2230:	df 91       	pop	r29
    2232:	cf 91       	pop	r28
    2234:	1f 91       	pop	r17
    2236:	0f 91       	pop	r16
    2238:	ff 90       	pop	r15
    223a:	ef 90       	pop	r14
    223c:	df 90       	pop	r13
    223e:	cf 90       	pop	r12
    2240:	bf 90       	pop	r11
    2242:	af 90       	pop	r10
    2244:	9f 90       	pop	r9
    2246:	8f 90       	pop	r8
    2248:	7f 90       	pop	r7
    224a:	6f 90       	pop	r6
    224c:	5f 90       	pop	r5
    224e:	4f 90       	pop	r4
    2250:	08 95       	ret

00002252 <_ZL5proc3Pv>:
		DFRobotHighTemperature PT100(3.300);
	#endif
	uint8_t cnt = 0;
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
    2252:	c0 e0       	ldi	r28, 0x00	; 0
{
	#if PT100
		DFRobotHighTemperature PT100(3.300);
	#endif
	uint8_t cnt = 0;
	uint8_t seq = 0;
    2254:	d0 e0       	ldi	r29, 0x00	; 0
	uint8_t cnt2 = 0;
	while(1)
	{
		if(mem4[TARGET_TEMP_SENSOR] == 1)
		{
			adc->Start_Device(seq % 3);
    2256:	53 e0       	ldi	r21, 0x03	; 3
    2258:	f5 2e       	mov	r15, r21
		#if USE_NTC
		if(cnt2 >= ADC_LOOP && mem4[TARGET_TEMP_SENSOR] == 1)
		{
			float vin = (Adc_channels[2] / ADC_LOOP )* 0.004887;
				//float vin = (Adc_channels[2] / ADC_LOOP )* 0.00323;
			float temp = fnCalTemp(vin);
    225a:	0e e1       	ldi	r16, 0x1E	; 30
    225c:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
	while(1)
	{
		if(mem4[TARGET_TEMP_SENSOR] == 1)
    225e:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <mem4+0x4a>
    2262:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <mem4+0x4b>
    2266:	01 97       	sbiw	r24, 0x01	; 1
    2268:	89 f4       	brne	.+34     	; 0x228c <_ZL5proc3Pv+0x3a>
		{
			adc->Start_Device(seq % 3);
    226a:	a0 91 7b 03 	lds	r26, 0x037B	; 0x80037b <adc>
    226e:	b0 91 7c 03 	lds	r27, 0x037C	; 0x80037c <adc+0x1>
    2272:	8d 2f       	mov	r24, r29
    2274:	6f 2d       	mov	r22, r15
    2276:	0e 94 63 1c 	call	0x38c6	; 0x38c6 <__udivmodqi4>
    227a:	ed 91       	ld	r30, X+
    227c:	fc 91       	ld	r31, X
    227e:	11 97       	sbiw	r26, 0x01	; 1
    2280:	02 84       	ldd	r0, Z+10	; 0x0a
    2282:	f3 85       	ldd	r31, Z+11	; 0x0b
    2284:	e0 2d       	mov	r30, r0
    2286:	69 2f       	mov	r22, r25
    2288:	cd 01       	movw	r24, r26
    228a:	09 95       	icall
		}
		uint8_t channel = ADMUX & 0x1f;
    228c:	e7 b0       	in	r14, 0x07	; 7
		vTaskDelay(10);
    228e:	8a e0       	ldi	r24, 0x0A	; 10
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	51 d7       	rcall	.+3746   	; 0x3136 <vTaskDelay>
		if(channel == 0)
    2294:	8e 2d       	mov	r24, r14
    2296:	8f 71       	andi	r24, 0x1F	; 31
    2298:	82 30       	cpi	r24, 0x02	; 2
    229a:	99 f4       	brne	.+38     	; 0x22c2 <_ZL5proc3Pv+0x70>
			#endif
		}
		else if(channel == 2)
		{
			#if USE_NTC
			uint16_t read = ADCL+((uint16_t)ADCH << 8);
    229c:	84 b1       	in	r24, 0x04	; 4
    229e:	95 b1       	in	r25, 0x05	; 5
			Adc_channels[channel] += read;
    22a0:	20 91 98 02 	lds	r18, 0x0298	; 0x800298 <Adc_channels+0x4>
    22a4:	30 91 99 02 	lds	r19, 0x0299	; 0x800299 <Adc_channels+0x5>
    22a8:	28 0f       	add	r18, r24
    22aa:	31 1d       	adc	r19, r1
    22ac:	89 2f       	mov	r24, r25
    22ae:	90 e0       	ldi	r25, 0x00	; 0
    22b0:	98 2f       	mov	r25, r24
    22b2:	88 27       	eor	r24, r24
    22b4:	82 0f       	add	r24, r18
    22b6:	93 1f       	adc	r25, r19
    22b8:	90 93 99 02 	sts	0x0299, r25	; 0x800299 <Adc_channels+0x5>
    22bc:	80 93 98 02 	sts	0x0298, r24	; 0x800298 <Adc_channels+0x4>
			cnt2++;
    22c0:	cf 5f       	subi	r28, 0xFF	; 255
			Adc_channels[1] = 0;
			cnt1 = 0;
		}
		#endif
		#if USE_NTC
		if(cnt2 >= ADC_LOOP && mem4[TARGET_TEMP_SENSOR] == 1)
    22c2:	ce 31       	cpi	r28, 0x1E	; 30
    22c4:	48 f1       	brcs	.+82     	; 0x2318 <_ZL5proc3Pv+0xc6>
    22c6:	80 91 0e 03 	lds	r24, 0x030E	; 0x80030e <mem4+0x4a>
    22ca:	90 91 0f 03 	lds	r25, 0x030F	; 0x80030f <mem4+0x4b>
    22ce:	01 97       	sbiw	r24, 0x01	; 1
    22d0:	19 f5       	brne	.+70     	; 0x2318 <_ZL5proc3Pv+0xc6>
		{
			float vin = (Adc_channels[2] / ADC_LOOP )* 0.004887;
				//float vin = (Adc_channels[2] / ADC_LOOP )* 0.00323;
			float temp = fnCalTemp(vin);
    22d2:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <Adc_channels+0x4>
    22d6:	90 91 99 02 	lds	r25, 0x0299	; 0x800299 <Adc_channels+0x5>
    22da:	b8 01       	movw	r22, r16
    22dc:	0e 94 6f 1c 	call	0x38de	; 0x38de <__udivmodhi4>
    22e0:	80 e0       	ldi	r24, 0x00	; 0
    22e2:	90 e0       	ldi	r25, 0x00	; 0
    22e4:	0e 94 4a 1b 	call	0x3694	; 0x3694 <__floatunsisf>
    22e8:	21 e2       	ldi	r18, 0x21	; 33
    22ea:	33 e2       	ldi	r19, 0x23	; 35
    22ec:	40 ea       	ldi	r20, 0xA0	; 160
    22ee:	5b e3       	ldi	r21, 0x3B	; 59
    22f0:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
    22f4:	09 df       	rcall	.-494    	; 0x2108 <_Z9fnCalTempf>
			mem4[TEMP] = temp * 10;
    22f6:	20 e0       	ldi	r18, 0x00	; 0
    22f8:	30 e0       	ldi	r19, 0x00	; 0
    22fa:	40 e2       	ldi	r20, 0x20	; 32
    22fc:	51 e4       	ldi	r21, 0x41	; 65
    22fe:	0e 94 00 1c 	call	0x3800	; 0x3800 <__mulsf3>
    2302:	0e 94 19 1b 	call	0x3632	; 0x3632 <__fixsfsi>
    2306:	70 93 c7 02 	sts	0x02C7, r23	; 0x8002c7 <mem4+0x3>
    230a:	60 93 c6 02 	sts	0x02C6, r22	; 0x8002c6 <mem4+0x2>
			Adc_channels[2] = 0;
    230e:	10 92 99 02 	sts	0x0299, r1	; 0x800299 <Adc_channels+0x5>
    2312:	10 92 98 02 	sts	0x0298, r1	; 0x800298 <Adc_channels+0x4>
			cnt2 = 0;
    2316:	c0 e0       	ldi	r28, 0x00	; 0
		}
		#endif
		seq++;
    2318:	df 5f       	subi	r29, 0xFF	; 255
	#endif
	uint8_t cnt = 0;
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
	while(1)
    231a:	a1 cf       	rjmp	.-190    	; 0x225e <_ZL5proc3Pv+0xc>

0000231c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2320:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    2322:	f2 d5       	rcall	.+3044   	; 0x2f08 <vTaskSuspendAll>
    2324:	80 91 80 03 	lds	r24, 0x0380	; 0x800380 <pucAlignedHeap.2069>
    2328:	90 91 81 03 	lds	r25, 0x0381	; 0x800381 <pucAlignedHeap.2069+0x1>
    232c:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    232e:	31 f4       	brne	.+12     	; 0x233c <pvPortMalloc+0x20>
    2330:	85 e8       	ldi	r24, 0x85	; 133
    2332:	93 e0       	ldi	r25, 0x03	; 3
    2334:	90 93 81 03 	sts	0x0381, r25	; 0x800381 <pucAlignedHeap.2069+0x1>
    2338:	80 93 80 03 	sts	0x0380, r24	; 0x800380 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    233c:	20 91 82 03 	lds	r18, 0x0382	; 0x800382 <xNextFreeByte>
    2340:	30 91 83 03 	lds	r19, 0x0383	; 0x800383 <xNextFreeByte+0x1>
    2344:	c9 01       	movw	r24, r18
    2346:	8c 0f       	add	r24, r28
    2348:	9d 1f       	adc	r25, r29
    234a:	87 3b       	cpi	r24, 0xB7	; 183
    234c:	4b e0       	ldi	r20, 0x0B	; 11
    234e:	94 07       	cpc	r25, r20
    2350:	70 f4       	brcc	.+28     	; 0x236e <pvPortMalloc+0x52>
    2352:	28 17       	cp	r18, r24
    2354:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2356:	58 f4       	brcc	.+22     	; 0x236e <pvPortMalloc+0x52>
    2358:	c0 91 80 03 	lds	r28, 0x0380	; 0x800380 <pucAlignedHeap.2069>
    235c:	d0 91 81 03 	lds	r29, 0x0381	; 0x800381 <pucAlignedHeap.2069+0x1>
    2360:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    2362:	d3 1f       	adc	r29, r19
    2364:	90 93 83 03 	sts	0x0383, r25	; 0x800383 <xNextFreeByte+0x1>
    2368:	80 93 82 03 	sts	0x0382, r24	; 0x800382 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    236c:	02 c0       	rjmp	.+4      	; 0x2372 <pvPortMalloc+0x56>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    236e:	c0 e0       	ldi	r28, 0x00	; 0
    2370:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    2372:	78 d6       	rcall	.+3312   	; 0x3064 <xTaskResumeAll>
    2374:	ce 01       	movw	r24, r28
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	08 95       	ret

0000237c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    237c:	08 95       	ret

0000237e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    237e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2380:	03 96       	adiw	r24, 0x03	; 3
    2382:	92 83       	std	Z+2, r25	; 0x02
    2384:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2386:	2f ef       	ldi	r18, 0xFF	; 255
    2388:	3f ef       	ldi	r19, 0xFF	; 255
    238a:	34 83       	std	Z+4, r19	; 0x04
    238c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    238e:	96 83       	std	Z+6, r25	; 0x06
    2390:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2392:	90 87       	std	Z+8, r25	; 0x08
    2394:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2396:	10 82       	st	Z, r1
    2398:	08 95       	ret

0000239a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    239a:	fc 01       	movw	r30, r24
    239c:	11 86       	std	Z+9, r1	; 0x09
    239e:	10 86       	std	Z+8, r1	; 0x08
    23a0:	08 95       	ret

000023a2 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    23a2:	cf 93       	push	r28
    23a4:	df 93       	push	r29
    23a6:	9c 01       	movw	r18, r24
    23a8:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    23aa:	dc 01       	movw	r26, r24
    23ac:	11 96       	adiw	r26, 0x01	; 1
    23ae:	cd 91       	ld	r28, X+
    23b0:	dc 91       	ld	r29, X
    23b2:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    23b4:	d3 83       	std	Z+3, r29	; 0x03
    23b6:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    23b8:	8c 81       	ldd	r24, Y+4	; 0x04
    23ba:	9d 81       	ldd	r25, Y+5	; 0x05
    23bc:	95 83       	std	Z+5, r25	; 0x05
    23be:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    23c0:	8c 81       	ldd	r24, Y+4	; 0x04
    23c2:	9d 81       	ldd	r25, Y+5	; 0x05
    23c4:	dc 01       	movw	r26, r24
    23c6:	13 96       	adiw	r26, 0x03	; 3
    23c8:	7c 93       	st	X, r23
    23ca:	6e 93       	st	-X, r22
    23cc:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    23ce:	7d 83       	std	Y+5, r23	; 0x05
    23d0:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    23d2:	31 87       	std	Z+9, r19	; 0x09
    23d4:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    23d6:	f9 01       	movw	r30, r18
    23d8:	80 81       	ld	r24, Z
    23da:	8f 5f       	subi	r24, 0xFF	; 255
    23dc:	80 83       	st	Z, r24
}
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	08 95       	ret

000023e4 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    23e4:	0f 93       	push	r16
    23e6:	1f 93       	push	r17
    23e8:	cf 93       	push	r28
    23ea:	df 93       	push	r29
    23ec:	8c 01       	movw	r16, r24
    23ee:	fb 01       	movw	r30, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    23f0:	80 81       	ld	r24, Z
    23f2:	91 81       	ldd	r25, Z+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    23f4:	8f 3f       	cpi	r24, 0xFF	; 255
    23f6:	2f ef       	ldi	r18, 0xFF	; 255
    23f8:	92 07       	cpc	r25, r18
    23fa:	21 f4       	brne	.+8      	; 0x2404 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    23fc:	e8 01       	movw	r28, r16
    23fe:	af 81       	ldd	r26, Y+7	; 0x07
    2400:	b8 85       	ldd	r27, Y+8	; 0x08
    2402:	0e c0       	rjmp	.+28     	; 0x2420 <vListInsert+0x3c>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2404:	d8 01       	movw	r26, r16
    2406:	13 96       	adiw	r26, 0x03	; 3
    2408:	12 96       	adiw	r26, 0x02	; 2
    240a:	2d 91       	ld	r18, X+
    240c:	3c 91       	ld	r19, X
    240e:	13 97       	sbiw	r26, 0x03	; 3
    2410:	e9 01       	movw	r28, r18
    2412:	48 81       	ld	r20, Y
    2414:	59 81       	ldd	r21, Y+1	; 0x01
    2416:	84 17       	cp	r24, r20
    2418:	95 07       	cpc	r25, r21
    241a:	10 f0       	brcs	.+4      	; 0x2420 <vListInsert+0x3c>
    241c:	d9 01       	movw	r26, r18
    241e:	f4 cf       	rjmp	.-24     	; 0x2408 <vListInsert+0x24>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2420:	12 96       	adiw	r26, 0x02	; 2
    2422:	8d 91       	ld	r24, X+
    2424:	9c 91       	ld	r25, X
    2426:	13 97       	sbiw	r26, 0x03	; 3
    2428:	93 83       	std	Z+3, r25	; 0x03
    242a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    242c:	ec 01       	movw	r28, r24
    242e:	fd 83       	std	Y+5, r31	; 0x05
    2430:	ec 83       	std	Y+4, r30	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2432:	b5 83       	std	Z+5, r27	; 0x05
    2434:	a4 83       	std	Z+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2436:	13 96       	adiw	r26, 0x03	; 3
    2438:	fc 93       	st	X, r31
    243a:	ee 93       	st	-X, r30
    243c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    243e:	11 87       	std	Z+9, r17	; 0x09
    2440:	00 87       	std	Z+8, r16	; 0x08

	( pxList->uxNumberOfItems )++;
    2442:	f8 01       	movw	r30, r16
    2444:	80 81       	ld	r24, Z
    2446:	8f 5f       	subi	r24, 0xFF	; 255
    2448:	80 83       	st	Z, r24
}
    244a:	df 91       	pop	r29
    244c:	cf 91       	pop	r28
    244e:	1f 91       	pop	r17
    2450:	0f 91       	pop	r16
    2452:	08 95       	ret

00002454 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2454:	cf 93       	push	r28
    2456:	df 93       	push	r29
    2458:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    245a:	a0 85       	ldd	r26, Z+8	; 0x08
    245c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    245e:	82 81       	ldd	r24, Z+2	; 0x02
    2460:	93 81       	ldd	r25, Z+3	; 0x03
    2462:	24 81       	ldd	r18, Z+4	; 0x04
    2464:	35 81       	ldd	r19, Z+5	; 0x05
    2466:	ec 01       	movw	r28, r24
    2468:	3d 83       	std	Y+5, r19	; 0x05
    246a:	2c 83       	std	Y+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    246c:	c4 81       	ldd	r28, Z+4	; 0x04
    246e:	d5 81       	ldd	r29, Z+5	; 0x05
    2470:	9b 83       	std	Y+3, r25	; 0x03
    2472:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2474:	11 96       	adiw	r26, 0x01	; 1
    2476:	8d 91       	ld	r24, X+
    2478:	9c 91       	ld	r25, X
    247a:	12 97       	sbiw	r26, 0x02	; 2
    247c:	e8 17       	cp	r30, r24
    247e:	f9 07       	cpc	r31, r25
    2480:	21 f4       	brne	.+8      	; 0x248a <uxListRemove+0x36>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2482:	12 96       	adiw	r26, 0x02	; 2
    2484:	dc 93       	st	X, r29
    2486:	ce 93       	st	-X, r28
    2488:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    248a:	11 86       	std	Z+9, r1	; 0x09
    248c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    248e:	8c 91       	ld	r24, X
    2490:	81 50       	subi	r24, 0x01	; 1
    2492:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2494:	df 91       	pop	r29
    2496:	cf 91       	pop	r28
    2498:	08 95       	ret

0000249a <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    249a:	31 e1       	ldi	r19, 0x11	; 17
    249c:	fc 01       	movw	r30, r24
    249e:	30 83       	st	Z, r19
    24a0:	31 97       	sbiw	r30, 0x01	; 1
    24a2:	22 e2       	ldi	r18, 0x22	; 34
    24a4:	20 83       	st	Z, r18
    24a6:	31 97       	sbiw	r30, 0x01	; 1
    24a8:	a3 e3       	ldi	r26, 0x33	; 51
    24aa:	a0 83       	st	Z, r26
    24ac:	31 97       	sbiw	r30, 0x01	; 1
    24ae:	60 83       	st	Z, r22
    24b0:	31 97       	sbiw	r30, 0x01	; 1
    24b2:	70 83       	st	Z, r23
    24b4:	31 97       	sbiw	r30, 0x01	; 1
    24b6:	10 82       	st	Z, r1
    24b8:	31 97       	sbiw	r30, 0x01	; 1
    24ba:	60 e8       	ldi	r22, 0x80	; 128
    24bc:	60 83       	st	Z, r22
    24be:	31 97       	sbiw	r30, 0x01	; 1
    24c0:	10 82       	st	Z, r1
    24c2:	31 97       	sbiw	r30, 0x01	; 1
    24c4:	62 e0       	ldi	r22, 0x02	; 2
    24c6:	60 83       	st	Z, r22
    24c8:	31 97       	sbiw	r30, 0x01	; 1
    24ca:	63 e0       	ldi	r22, 0x03	; 3
    24cc:	60 83       	st	Z, r22
    24ce:	31 97       	sbiw	r30, 0x01	; 1
    24d0:	64 e0       	ldi	r22, 0x04	; 4
    24d2:	60 83       	st	Z, r22
    24d4:	31 97       	sbiw	r30, 0x01	; 1
    24d6:	65 e0       	ldi	r22, 0x05	; 5
    24d8:	60 83       	st	Z, r22
    24da:	31 97       	sbiw	r30, 0x01	; 1
    24dc:	66 e0       	ldi	r22, 0x06	; 6
    24de:	60 83       	st	Z, r22
    24e0:	31 97       	sbiw	r30, 0x01	; 1
    24e2:	67 e0       	ldi	r22, 0x07	; 7
    24e4:	60 83       	st	Z, r22
    24e6:	31 97       	sbiw	r30, 0x01	; 1
    24e8:	68 e0       	ldi	r22, 0x08	; 8
    24ea:	60 83       	st	Z, r22
    24ec:	31 97       	sbiw	r30, 0x01	; 1
    24ee:	69 e0       	ldi	r22, 0x09	; 9
    24f0:	60 83       	st	Z, r22
    24f2:	31 97       	sbiw	r30, 0x01	; 1
    24f4:	60 e1       	ldi	r22, 0x10	; 16
    24f6:	60 83       	st	Z, r22
    24f8:	31 97       	sbiw	r30, 0x01	; 1
    24fa:	30 83       	st	Z, r19
    24fc:	31 97       	sbiw	r30, 0x01	; 1
    24fe:	32 e1       	ldi	r19, 0x12	; 18
    2500:	30 83       	st	Z, r19
    2502:	31 97       	sbiw	r30, 0x01	; 1
    2504:	33 e1       	ldi	r19, 0x13	; 19
    2506:	30 83       	st	Z, r19
    2508:	31 97       	sbiw	r30, 0x01	; 1
    250a:	34 e1       	ldi	r19, 0x14	; 20
    250c:	30 83       	st	Z, r19
    250e:	31 97       	sbiw	r30, 0x01	; 1
    2510:	35 e1       	ldi	r19, 0x15	; 21
    2512:	30 83       	st	Z, r19
    2514:	31 97       	sbiw	r30, 0x01	; 1
    2516:	36 e1       	ldi	r19, 0x16	; 22
    2518:	30 83       	st	Z, r19
    251a:	31 97       	sbiw	r30, 0x01	; 1
    251c:	37 e1       	ldi	r19, 0x17	; 23
    251e:	30 83       	st	Z, r19
    2520:	31 97       	sbiw	r30, 0x01	; 1
    2522:	38 e1       	ldi	r19, 0x18	; 24
    2524:	30 83       	st	Z, r19
    2526:	31 97       	sbiw	r30, 0x01	; 1
    2528:	39 e1       	ldi	r19, 0x19	; 25
    252a:	30 83       	st	Z, r19
    252c:	31 97       	sbiw	r30, 0x01	; 1
    252e:	30 e2       	ldi	r19, 0x20	; 32
    2530:	30 83       	st	Z, r19
    2532:	31 97       	sbiw	r30, 0x01	; 1
    2534:	31 e2       	ldi	r19, 0x21	; 33
    2536:	30 83       	st	Z, r19
    2538:	31 97       	sbiw	r30, 0x01	; 1
    253a:	20 83       	st	Z, r18
    253c:	31 97       	sbiw	r30, 0x01	; 1
    253e:	23 e2       	ldi	r18, 0x23	; 35
    2540:	20 83       	st	Z, r18
    2542:	31 97       	sbiw	r30, 0x01	; 1
    2544:	40 83       	st	Z, r20
    2546:	31 97       	sbiw	r30, 0x01	; 1
    2548:	50 83       	st	Z, r21
    254a:	31 97       	sbiw	r30, 0x01	; 1
    254c:	26 e2       	ldi	r18, 0x26	; 38
    254e:	20 83       	st	Z, r18
    2550:	31 97       	sbiw	r30, 0x01	; 1
    2552:	27 e2       	ldi	r18, 0x27	; 39
    2554:	20 83       	st	Z, r18
    2556:	31 97       	sbiw	r30, 0x01	; 1
    2558:	28 e2       	ldi	r18, 0x28	; 40
    255a:	20 83       	st	Z, r18
    255c:	31 97       	sbiw	r30, 0x01	; 1
    255e:	29 e2       	ldi	r18, 0x29	; 41
    2560:	20 83       	st	Z, r18
    2562:	31 97       	sbiw	r30, 0x01	; 1
    2564:	20 e3       	ldi	r18, 0x30	; 48
    2566:	20 83       	st	Z, r18
    2568:	31 97       	sbiw	r30, 0x01	; 1
    256a:	21 e3       	ldi	r18, 0x31	; 49
    256c:	20 83       	st	Z, r18
    256e:	86 97       	sbiw	r24, 0x26	; 38
    2570:	08 95       	ret

00002572 <xPortStartScheduler>:
    2572:	1b bc       	out	0x2b, r1	; 43
    2574:	89 ef       	ldi	r24, 0xF9	; 249
    2576:	8a bd       	out	0x2a, r24	; 42
    2578:	8b e0       	ldi	r24, 0x0B	; 11
    257a:	8e bd       	out	0x2e, r24	; 46
    257c:	87 b7       	in	r24, 0x37	; 55
    257e:	80 61       	ori	r24, 0x10	; 16
    2580:	87 bf       	out	0x37, r24	; 55
    2582:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2586:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    258a:	cd 91       	ld	r28, X+
    258c:	cd bf       	out	0x3d, r28	; 61
    258e:	dd 91       	ld	r29, X+
    2590:	de bf       	out	0x3e, r29	; 62
    2592:	ff 91       	pop	r31
    2594:	ef 91       	pop	r30
    2596:	df 91       	pop	r29
    2598:	cf 91       	pop	r28
    259a:	bf 91       	pop	r27
    259c:	af 91       	pop	r26
    259e:	9f 91       	pop	r25
    25a0:	8f 91       	pop	r24
    25a2:	7f 91       	pop	r23
    25a4:	6f 91       	pop	r22
    25a6:	5f 91       	pop	r21
    25a8:	4f 91       	pop	r20
    25aa:	3f 91       	pop	r19
    25ac:	2f 91       	pop	r18
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	ff 90       	pop	r15
    25b4:	ef 90       	pop	r14
    25b6:	df 90       	pop	r13
    25b8:	cf 90       	pop	r12
    25ba:	bf 90       	pop	r11
    25bc:	af 90       	pop	r10
    25be:	9f 90       	pop	r9
    25c0:	8f 90       	pop	r8
    25c2:	7f 90       	pop	r7
    25c4:	6f 90       	pop	r6
    25c6:	5f 90       	pop	r5
    25c8:	4f 90       	pop	r4
    25ca:	3f 90       	pop	r3
    25cc:	2f 90       	pop	r2
    25ce:	1f 90       	pop	r1
    25d0:	0f 90       	pop	r0
    25d2:	0f be       	out	0x3f, r0	; 63
    25d4:	0f 90       	pop	r0
    25d6:	08 95       	ret
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	08 95       	ret

000025dc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    25dc:	0f 92       	push	r0
    25de:	0f b6       	in	r0, 0x3f	; 63
    25e0:	f8 94       	cli
    25e2:	0f 92       	push	r0
    25e4:	1f 92       	push	r1
    25e6:	11 24       	eor	r1, r1
    25e8:	2f 92       	push	r2
    25ea:	3f 92       	push	r3
    25ec:	4f 92       	push	r4
    25ee:	5f 92       	push	r5
    25f0:	6f 92       	push	r6
    25f2:	7f 92       	push	r7
    25f4:	8f 92       	push	r8
    25f6:	9f 92       	push	r9
    25f8:	af 92       	push	r10
    25fa:	bf 92       	push	r11
    25fc:	cf 92       	push	r12
    25fe:	df 92       	push	r13
    2600:	ef 92       	push	r14
    2602:	ff 92       	push	r15
    2604:	0f 93       	push	r16
    2606:	1f 93       	push	r17
    2608:	2f 93       	push	r18
    260a:	3f 93       	push	r19
    260c:	4f 93       	push	r20
    260e:	5f 93       	push	r21
    2610:	6f 93       	push	r22
    2612:	7f 93       	push	r23
    2614:	8f 93       	push	r24
    2616:	9f 93       	push	r25
    2618:	af 93       	push	r26
    261a:	bf 93       	push	r27
    261c:	cf 93       	push	r28
    261e:	df 93       	push	r29
    2620:	ef 93       	push	r30
    2622:	ff 93       	push	r31
    2624:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2628:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    262c:	0d b6       	in	r0, 0x3d	; 61
    262e:	0d 92       	st	X+, r0
    2630:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    2632:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    2634:	bf d5       	rcall	.+2942   	; 0x31b4 <vTaskSwitchContext>
    2636:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    263a:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    263e:	cd 91       	ld	r28, X+
    2640:	cd bf       	out	0x3d, r28	; 61
    2642:	dd 91       	ld	r29, X+
    2644:	de bf       	out	0x3e, r29	; 62
    2646:	ff 91       	pop	r31
    2648:	ef 91       	pop	r30
    264a:	df 91       	pop	r29
    264c:	cf 91       	pop	r28
    264e:	bf 91       	pop	r27
    2650:	af 91       	pop	r26
    2652:	9f 91       	pop	r25
    2654:	8f 91       	pop	r24
    2656:	7f 91       	pop	r23
    2658:	6f 91       	pop	r22
    265a:	5f 91       	pop	r21
    265c:	4f 91       	pop	r20
    265e:	3f 91       	pop	r19
    2660:	2f 91       	pop	r18
    2662:	1f 91       	pop	r17
    2664:	0f 91       	pop	r16
    2666:	ff 90       	pop	r15
    2668:	ef 90       	pop	r14
    266a:	df 90       	pop	r13
    266c:	cf 90       	pop	r12
    266e:	bf 90       	pop	r11
    2670:	af 90       	pop	r10
    2672:	9f 90       	pop	r9
    2674:	8f 90       	pop	r8
    2676:	7f 90       	pop	r7
    2678:	6f 90       	pop	r6
    267a:	5f 90       	pop	r5
    267c:	4f 90       	pop	r4
    267e:	3f 90       	pop	r3
    2680:	2f 90       	pop	r2
    2682:	1f 90       	pop	r1
    2684:	0f 90       	pop	r0
    2686:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    2688:	0f 90       	pop	r0
    268a:	08 95       	ret

0000268c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    268c:	0f 92       	push	r0
    268e:	0f b6       	in	r0, 0x3f	; 63
    2690:	f8 94       	cli
    2692:	0f 92       	push	r0
    2694:	1f 92       	push	r1
    2696:	11 24       	eor	r1, r1
    2698:	2f 92       	push	r2
    269a:	3f 92       	push	r3
    269c:	4f 92       	push	r4
    269e:	5f 92       	push	r5
    26a0:	6f 92       	push	r6
    26a2:	7f 92       	push	r7
    26a4:	8f 92       	push	r8
    26a6:	9f 92       	push	r9
    26a8:	af 92       	push	r10
    26aa:	bf 92       	push	r11
    26ac:	cf 92       	push	r12
    26ae:	df 92       	push	r13
    26b0:	ef 92       	push	r14
    26b2:	ff 92       	push	r15
    26b4:	0f 93       	push	r16
    26b6:	1f 93       	push	r17
    26b8:	2f 93       	push	r18
    26ba:	3f 93       	push	r19
    26bc:	4f 93       	push	r20
    26be:	5f 93       	push	r21
    26c0:	6f 93       	push	r22
    26c2:	7f 93       	push	r23
    26c4:	8f 93       	push	r24
    26c6:	9f 93       	push	r25
    26c8:	af 93       	push	r26
    26ca:	bf 93       	push	r27
    26cc:	cf 93       	push	r28
    26ce:	df 93       	push	r29
    26d0:	ef 93       	push	r30
    26d2:	ff 93       	push	r31
    26d4:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    26d8:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    26dc:	0d b6       	in	r0, 0x3d	; 61
    26de:	0d 92       	st	X+, r0
    26e0:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    26e2:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    26e4:	17 d4       	rcall	.+2094   	; 0x2f14 <xTaskIncrementTick>
    26e6:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    26e8:	65 d5       	rcall	.+2762   	; 0x31b4 <vTaskSwitchContext>
    26ea:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    26ee:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    26f2:	cd 91       	ld	r28, X+
    26f4:	cd bf       	out	0x3d, r28	; 61
    26f6:	dd 91       	ld	r29, X+
    26f8:	de bf       	out	0x3e, r29	; 62
    26fa:	ff 91       	pop	r31
    26fc:	ef 91       	pop	r30
    26fe:	df 91       	pop	r29
    2700:	cf 91       	pop	r28
    2702:	bf 91       	pop	r27
    2704:	af 91       	pop	r26
    2706:	9f 91       	pop	r25
    2708:	8f 91       	pop	r24
    270a:	7f 91       	pop	r23
    270c:	6f 91       	pop	r22
    270e:	5f 91       	pop	r21
    2710:	4f 91       	pop	r20
    2712:	3f 91       	pop	r19
    2714:	2f 91       	pop	r18
    2716:	1f 91       	pop	r17
    2718:	0f 91       	pop	r16
    271a:	ff 90       	pop	r15
    271c:	ef 90       	pop	r14
    271e:	df 90       	pop	r13
    2720:	cf 90       	pop	r12
    2722:	bf 90       	pop	r11
    2724:	af 90       	pop	r10
    2726:	9f 90       	pop	r9
    2728:	8f 90       	pop	r8
    272a:	7f 90       	pop	r7
    272c:	6f 90       	pop	r6
    272e:	5f 90       	pop	r5
    2730:	4f 90       	pop	r4
    2732:	3f 90       	pop	r3
    2734:	2f 90       	pop	r2
    2736:	1f 90       	pop	r1
    2738:	0f 90       	pop	r0
    273a:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    273c:	0f 90       	pop	r0
    273e:	08 95       	ret

00002740 <__vector_12>:
    2740:	a5 df       	rcall	.-182    	; 0x268c <vPortYieldFromTick>
    2742:	18 95       	reti

00002744 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2744:	0f 93       	push	r16
    2746:	1f 93       	push	r17
    2748:	cf 93       	push	r28
    274a:	df 93       	push	r29
    274c:	ec 01       	movw	r28, r24
    274e:	04 2f       	mov	r16, r20
    2750:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2752:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2754:	41 11       	cpse	r20, r1
    2756:	0a c0       	rjmp	.+20     	; 0x276c <prvCopyDataToQueue+0x28>
    2758:	88 81       	ld	r24, Y
    275a:	99 81       	ldd	r25, Y+1	; 0x01
    275c:	89 2b       	or	r24, r25
    275e:	e1 f5       	brne	.+120    	; 0x27d8 <prvCopyDataToQueue+0x94>
    2760:	8a 81       	ldd	r24, Y+2	; 0x02
    2762:	9b 81       	ldd	r25, Y+3	; 0x03
    2764:	4e d6       	rcall	.+3228   	; 0x3402 <xTaskPriorityDisinherit>
    2766:	1b 82       	std	Y+3, r1	; 0x03
    2768:	1a 82       	std	Y+2, r1	; 0x02
    276a:	37 c0       	rjmp	.+110    	; 0x27da <prvCopyDataToQueue+0x96>
    276c:	50 e0       	ldi	r21, 0x00	; 0
    276e:	01 11       	cpse	r16, r1
    2770:	15 c0       	rjmp	.+42     	; 0x279c <prvCopyDataToQueue+0x58>
    2772:	8c 81       	ldd	r24, Y+4	; 0x04
    2774:	9d 81       	ldd	r25, Y+5	; 0x05
    2776:	0e 94 a5 1c 	call	0x394a	; 0x394a <memcpy>
    277a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    277c:	8c 81       	ldd	r24, Y+4	; 0x04
    277e:	9d 81       	ldd	r25, Y+5	; 0x05
    2780:	82 0f       	add	r24, r18
    2782:	91 1d       	adc	r25, r1
    2784:	9d 83       	std	Y+5, r25	; 0x05
    2786:	8c 83       	std	Y+4, r24	; 0x04
    2788:	2a 81       	ldd	r18, Y+2	; 0x02
    278a:	3b 81       	ldd	r19, Y+3	; 0x03
    278c:	82 17       	cp	r24, r18
    278e:	93 07       	cpc	r25, r19
    2790:	18 f1       	brcs	.+70     	; 0x27d8 <prvCopyDataToQueue+0x94>
    2792:	88 81       	ld	r24, Y
    2794:	99 81       	ldd	r25, Y+1	; 0x01
    2796:	9d 83       	std	Y+5, r25	; 0x05
    2798:	8c 83       	std	Y+4, r24	; 0x04
    279a:	1e c0       	rjmp	.+60     	; 0x27d8 <prvCopyDataToQueue+0x94>
    279c:	8e 81       	ldd	r24, Y+6	; 0x06
    279e:	9f 81       	ldd	r25, Y+7	; 0x07
    27a0:	0e 94 a5 1c 	call	0x394a	; 0x394a <memcpy>
    27a4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    27a6:	90 e0       	ldi	r25, 0x00	; 0
    27a8:	91 95       	neg	r25
    27aa:	81 95       	neg	r24
    27ac:	91 09       	sbc	r25, r1
    27ae:	2e 81       	ldd	r18, Y+6	; 0x06
    27b0:	3f 81       	ldd	r19, Y+7	; 0x07
    27b2:	28 0f       	add	r18, r24
    27b4:	39 1f       	adc	r19, r25
    27b6:	3f 83       	std	Y+7, r19	; 0x07
    27b8:	2e 83       	std	Y+6, r18	; 0x06
    27ba:	48 81       	ld	r20, Y
    27bc:	59 81       	ldd	r21, Y+1	; 0x01
    27be:	24 17       	cp	r18, r20
    27c0:	35 07       	cpc	r19, r21
    27c2:	30 f4       	brcc	.+12     	; 0x27d0 <prvCopyDataToQueue+0x8c>
    27c4:	2a 81       	ldd	r18, Y+2	; 0x02
    27c6:	3b 81       	ldd	r19, Y+3	; 0x03
    27c8:	82 0f       	add	r24, r18
    27ca:	93 1f       	adc	r25, r19
    27cc:	9f 83       	std	Y+7, r25	; 0x07
    27ce:	8e 83       	std	Y+6, r24	; 0x06
    27d0:	02 30       	cpi	r16, 0x02	; 2
    27d2:	11 f4       	brne	.+4      	; 0x27d8 <prvCopyDataToQueue+0x94>
    27d4:	11 11       	cpse	r17, r1
    27d6:	11 50       	subi	r17, 0x01	; 1
    27d8:	80 e0       	ldi	r24, 0x00	; 0
    27da:	1f 5f       	subi	r17, 0xFF	; 255
    27dc:	1a 8f       	std	Y+26, r17	; 0x1a
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	1f 91       	pop	r17
    27e4:	0f 91       	pop	r16
    27e6:	08 95       	ret

000027e8 <prvCopyDataFromQueue>:
    27e8:	fc 01       	movw	r30, r24
    27ea:	cb 01       	movw	r24, r22
    27ec:	44 8d       	ldd	r20, Z+28	; 0x1c
    27ee:	44 23       	and	r20, r20
    27f0:	a1 f0       	breq	.+40     	; 0x281a <prvCopyDataFromQueue+0x32>
    27f2:	50 e0       	ldi	r21, 0x00	; 0
    27f4:	26 81       	ldd	r18, Z+6	; 0x06
    27f6:	37 81       	ldd	r19, Z+7	; 0x07
    27f8:	24 0f       	add	r18, r20
    27fa:	35 1f       	adc	r19, r21
    27fc:	37 83       	std	Z+7, r19	; 0x07
    27fe:	26 83       	std	Z+6, r18	; 0x06
    2800:	62 81       	ldd	r22, Z+2	; 0x02
    2802:	73 81       	ldd	r23, Z+3	; 0x03
    2804:	26 17       	cp	r18, r22
    2806:	37 07       	cpc	r19, r23
    2808:	20 f0       	brcs	.+8      	; 0x2812 <prvCopyDataFromQueue+0x2a>
    280a:	20 81       	ld	r18, Z
    280c:	31 81       	ldd	r19, Z+1	; 0x01
    280e:	37 83       	std	Z+7, r19	; 0x07
    2810:	26 83       	std	Z+6, r18	; 0x06
    2812:	66 81       	ldd	r22, Z+6	; 0x06
    2814:	77 81       	ldd	r23, Z+7	; 0x07
    2816:	0c 94 a5 1c 	jmp	0x394a	; 0x394a <memcpy>
    281a:	08 95       	ret

0000281c <prvUnlockQueue>:
    281c:	ef 92       	push	r14
    281e:	ff 92       	push	r15
    2820:	1f 93       	push	r17
    2822:	cf 93       	push	r28
    2824:	df 93       	push	r29
    2826:	ec 01       	movw	r28, r24
    2828:	0f b6       	in	r0, 0x3f	; 63
    282a:	f8 94       	cli
    282c:	0f 92       	push	r0
    282e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2830:	7c 01       	movw	r14, r24
    2832:	81 e1       	ldi	r24, 0x11	; 17
    2834:	e8 0e       	add	r14, r24
    2836:	f1 1c       	adc	r15, r1
    2838:	11 16       	cp	r1, r17
    283a:	4c f4       	brge	.+18     	; 0x284e <prvUnlockQueue+0x32>
    283c:	89 89       	ldd	r24, Y+17	; 0x11
    283e:	88 23       	and	r24, r24
    2840:	31 f0       	breq	.+12     	; 0x284e <prvUnlockQueue+0x32>
    2842:	c7 01       	movw	r24, r14
    2844:	09 d5       	rcall	.+2578   	; 0x3258 <xTaskRemoveFromEventList>
    2846:	81 11       	cpse	r24, r1
    2848:	80 d5       	rcall	.+2816   	; 0x334a <vTaskMissedYield>
    284a:	11 50       	subi	r17, 0x01	; 1
    284c:	f5 cf       	rjmp	.-22     	; 0x2838 <prvUnlockQueue+0x1c>
    284e:	8f ef       	ldi	r24, 0xFF	; 255
    2850:	8e 8f       	std	Y+30, r24	; 0x1e
    2852:	0f 90       	pop	r0
    2854:	0f be       	out	0x3f, r0	; 63
    2856:	0f b6       	in	r0, 0x3f	; 63
    2858:	f8 94       	cli
    285a:	0f 92       	push	r0
    285c:	1d 8d       	ldd	r17, Y+29	; 0x1d
    285e:	7e 01       	movw	r14, r28
    2860:	88 e0       	ldi	r24, 0x08	; 8
    2862:	e8 0e       	add	r14, r24
    2864:	f1 1c       	adc	r15, r1
    2866:	11 16       	cp	r1, r17
    2868:	4c f4       	brge	.+18     	; 0x287c <prvUnlockQueue+0x60>
    286a:	88 85       	ldd	r24, Y+8	; 0x08
    286c:	88 23       	and	r24, r24
    286e:	31 f0       	breq	.+12     	; 0x287c <prvUnlockQueue+0x60>
    2870:	c7 01       	movw	r24, r14
    2872:	f2 d4       	rcall	.+2532   	; 0x3258 <xTaskRemoveFromEventList>
    2874:	81 11       	cpse	r24, r1
    2876:	69 d5       	rcall	.+2770   	; 0x334a <vTaskMissedYield>
    2878:	11 50       	subi	r17, 0x01	; 1
    287a:	f5 cf       	rjmp	.-22     	; 0x2866 <prvUnlockQueue+0x4a>
    287c:	8f ef       	ldi	r24, 0xFF	; 255
    287e:	8d 8f       	std	Y+29, r24	; 0x1d
    2880:	0f 90       	pop	r0
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	df 91       	pop	r29
    2886:	cf 91       	pop	r28
    2888:	1f 91       	pop	r17
    288a:	ff 90       	pop	r15
    288c:	ef 90       	pop	r14
    288e:	08 95       	ret

00002890 <xQueueGenericReset>:
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	ec 01       	movw	r28, r24
    2896:	0f b6       	in	r0, 0x3f	; 63
    2898:	f8 94       	cli
    289a:	0f 92       	push	r0
    289c:	28 81       	ld	r18, Y
    289e:	39 81       	ldd	r19, Y+1	; 0x01
    28a0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    28a2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    28a4:	94 9f       	mul	r25, r20
    28a6:	c0 01       	movw	r24, r0
    28a8:	11 24       	eor	r1, r1
    28aa:	f9 01       	movw	r30, r18
    28ac:	e8 0f       	add	r30, r24
    28ae:	f9 1f       	adc	r31, r25
    28b0:	fb 83       	std	Y+3, r31	; 0x03
    28b2:	ea 83       	std	Y+2, r30	; 0x02
    28b4:	1a 8e       	std	Y+26, r1	; 0x1a
    28b6:	3d 83       	std	Y+5, r19	; 0x05
    28b8:	2c 83       	std	Y+4, r18	; 0x04
    28ba:	84 1b       	sub	r24, r20
    28bc:	91 09       	sbc	r25, r1
    28be:	82 0f       	add	r24, r18
    28c0:	93 1f       	adc	r25, r19
    28c2:	9f 83       	std	Y+7, r25	; 0x07
    28c4:	8e 83       	std	Y+6, r24	; 0x06
    28c6:	8f ef       	ldi	r24, 0xFF	; 255
    28c8:	8d 8f       	std	Y+29, r24	; 0x1d
    28ca:	8e 8f       	std	Y+30, r24	; 0x1e
    28cc:	61 11       	cpse	r22, r1
    28ce:	0a c0       	rjmp	.+20     	; 0x28e4 <xQueueGenericReset+0x54>
    28d0:	88 85       	ldd	r24, Y+8	; 0x08
    28d2:	88 23       	and	r24, r24
    28d4:	69 f0       	breq	.+26     	; 0x28f0 <xQueueGenericReset+0x60>
    28d6:	ce 01       	movw	r24, r28
    28d8:	08 96       	adiw	r24, 0x08	; 8
    28da:	be d4       	rcall	.+2428   	; 0x3258 <xTaskRemoveFromEventList>
    28dc:	88 23       	and	r24, r24
    28de:	41 f0       	breq	.+16     	; 0x28f0 <xQueueGenericReset+0x60>
    28e0:	7d de       	rcall	.-774    	; 0x25dc <vPortYield>
    28e2:	06 c0       	rjmp	.+12     	; 0x28f0 <xQueueGenericReset+0x60>
    28e4:	ce 01       	movw	r24, r28
    28e6:	08 96       	adiw	r24, 0x08	; 8
    28e8:	4a dd       	rcall	.-1388   	; 0x237e <vListInitialise>
    28ea:	ce 01       	movw	r24, r28
    28ec:	41 96       	adiw	r24, 0x11	; 17
    28ee:	47 dd       	rcall	.-1394   	; 0x237e <vListInitialise>
    28f0:	0f 90       	pop	r0
    28f2:	0f be       	out	0x3f, r0	; 63
    28f4:	81 e0       	ldi	r24, 0x01	; 1
    28f6:	df 91       	pop	r29
    28f8:	cf 91       	pop	r28
    28fa:	08 95       	ret

000028fc <xQueueGenericCreate>:
    28fc:	0f 93       	push	r16
    28fe:	1f 93       	push	r17
    2900:	cf 93       	push	r28
    2902:	df 93       	push	r29
    2904:	08 2f       	mov	r16, r24
    2906:	16 2f       	mov	r17, r22
    2908:	66 23       	and	r22, r22
    290a:	21 f0       	breq	.+8      	; 0x2914 <xQueueGenericCreate+0x18>
    290c:	86 9f       	mul	r24, r22
    290e:	c0 01       	movw	r24, r0
    2910:	11 24       	eor	r1, r1
    2912:	02 c0       	rjmp	.+4      	; 0x2918 <xQueueGenericCreate+0x1c>
    2914:	80 e0       	ldi	r24, 0x00	; 0
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	4f 96       	adiw	r24, 0x1f	; 31
    291a:	00 dd       	rcall	.-1536   	; 0x231c <pvPortMalloc>
    291c:	ec 01       	movw	r28, r24
    291e:	00 97       	sbiw	r24, 0x00	; 0
    2920:	69 f0       	breq	.+26     	; 0x293c <xQueueGenericCreate+0x40>
    2922:	11 11       	cpse	r17, r1
    2924:	03 c0       	rjmp	.+6      	; 0x292c <xQueueGenericCreate+0x30>
    2926:	99 83       	std	Y+1, r25	; 0x01
    2928:	88 83       	st	Y, r24
    292a:	03 c0       	rjmp	.+6      	; 0x2932 <xQueueGenericCreate+0x36>
    292c:	4f 96       	adiw	r24, 0x1f	; 31
    292e:	99 83       	std	Y+1, r25	; 0x01
    2930:	88 83       	st	Y, r24
    2932:	0b 8f       	std	Y+27, r16	; 0x1b
    2934:	1c 8f       	std	Y+28, r17	; 0x1c
    2936:	61 e0       	ldi	r22, 0x01	; 1
    2938:	ce 01       	movw	r24, r28
    293a:	aa df       	rcall	.-172    	; 0x2890 <xQueueGenericReset>
    293c:	ce 01       	movw	r24, r28
    293e:	df 91       	pop	r29
    2940:	cf 91       	pop	r28
    2942:	1f 91       	pop	r17
    2944:	0f 91       	pop	r16
    2946:	08 95       	ret

00002948 <xQueueGenericSend>:
    2948:	af 92       	push	r10
    294a:	bf 92       	push	r11
    294c:	cf 92       	push	r12
    294e:	df 92       	push	r13
    2950:	ff 92       	push	r15
    2952:	0f 93       	push	r16
    2954:	1f 93       	push	r17
    2956:	cf 93       	push	r28
    2958:	df 93       	push	r29
    295a:	00 d0       	rcall	.+0      	; 0x295c <xQueueGenericSend+0x14>
    295c:	00 d0       	rcall	.+0      	; 0x295e <xQueueGenericSend+0x16>
    295e:	1f 92       	push	r1
    2960:	cd b7       	in	r28, 0x3d	; 61
    2962:	de b7       	in	r29, 0x3e	; 62
    2964:	8c 01       	movw	r16, r24
    2966:	6b 01       	movw	r12, r22
    2968:	5d 83       	std	Y+5, r21	; 0x05
    296a:	4c 83       	std	Y+4, r20	; 0x04
    296c:	f2 2e       	mov	r15, r18
    296e:	80 e0       	ldi	r24, 0x00	; 0
    2970:	58 01       	movw	r10, r16
    2972:	98 e0       	ldi	r25, 0x08	; 8
    2974:	a9 0e       	add	r10, r25
    2976:	b1 1c       	adc	r11, r1
    2978:	0f b6       	in	r0, 0x3f	; 63
    297a:	f8 94       	cli
    297c:	0f 92       	push	r0
    297e:	f8 01       	movw	r30, r16
    2980:	22 8d       	ldd	r18, Z+26	; 0x1a
    2982:	93 8d       	ldd	r25, Z+27	; 0x1b
    2984:	29 17       	cp	r18, r25
    2986:	18 f0       	brcs	.+6      	; 0x298e <xQueueGenericSend+0x46>
    2988:	f2 e0       	ldi	r31, 0x02	; 2
    298a:	ff 12       	cpse	r15, r31
    298c:	11 c0       	rjmp	.+34     	; 0x29b0 <xQueueGenericSend+0x68>
    298e:	4f 2d       	mov	r20, r15
    2990:	b6 01       	movw	r22, r12
    2992:	c8 01       	movw	r24, r16
    2994:	d7 de       	rcall	.-594    	; 0x2744 <prvCopyDataToQueue>
    2996:	f8 01       	movw	r30, r16
    2998:	91 89       	ldd	r25, Z+17	; 0x11
    299a:	99 23       	and	r25, r25
    299c:	19 f0       	breq	.+6      	; 0x29a4 <xQueueGenericSend+0x5c>
    299e:	c8 01       	movw	r24, r16
    29a0:	41 96       	adiw	r24, 0x11	; 17
    29a2:	5a d4       	rcall	.+2228   	; 0x3258 <xTaskRemoveFromEventList>
    29a4:	81 11       	cpse	r24, r1
    29a6:	1a de       	rcall	.-972    	; 0x25dc <vPortYield>
    29a8:	0f 90       	pop	r0
    29aa:	0f be       	out	0x3f, r0	; 63
    29ac:	81 e0       	ldi	r24, 0x01	; 1
    29ae:	45 c0       	rjmp	.+138    	; 0x2a3a <xQueueGenericSend+0xf2>
    29b0:	2c 81       	ldd	r18, Y+4	; 0x04
    29b2:	3d 81       	ldd	r19, Y+5	; 0x05
    29b4:	23 2b       	or	r18, r19
    29b6:	19 f4       	brne	.+6      	; 0x29be <xQueueGenericSend+0x76>
    29b8:	0f 90       	pop	r0
    29ba:	0f be       	out	0x3f, r0	; 63
    29bc:	3d c0       	rjmp	.+122    	; 0x2a38 <xQueueGenericSend+0xf0>
    29be:	81 11       	cpse	r24, r1
    29c0:	03 c0       	rjmp	.+6      	; 0x29c8 <xQueueGenericSend+0x80>
    29c2:	ce 01       	movw	r24, r28
    29c4:	01 96       	adiw	r24, 0x01	; 1
    29c6:	85 d4       	rcall	.+2314   	; 0x32d2 <vTaskSetTimeOutState>
    29c8:	0f 90       	pop	r0
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	9d d2       	rcall	.+1338   	; 0x2f08 <vTaskSuspendAll>
    29ce:	0f b6       	in	r0, 0x3f	; 63
    29d0:	f8 94       	cli
    29d2:	0f 92       	push	r0
    29d4:	f8 01       	movw	r30, r16
    29d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    29d8:	8f 3f       	cpi	r24, 0xFF	; 255
    29da:	09 f4       	brne	.+2      	; 0x29de <xQueueGenericSend+0x96>
    29dc:	15 8e       	std	Z+29, r1	; 0x1d
    29de:	f8 01       	movw	r30, r16
    29e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    29e2:	8f 3f       	cpi	r24, 0xFF	; 255
    29e4:	09 f4       	brne	.+2      	; 0x29e8 <xQueueGenericSend+0xa0>
    29e6:	16 8e       	std	Z+30, r1	; 0x1e
    29e8:	0f 90       	pop	r0
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	be 01       	movw	r22, r28
    29ee:	6c 5f       	subi	r22, 0xFC	; 252
    29f0:	7f 4f       	sbci	r23, 0xFF	; 255
    29f2:	ce 01       	movw	r24, r28
    29f4:	01 96       	adiw	r24, 0x01	; 1
    29f6:	78 d4       	rcall	.+2288   	; 0x32e8 <xTaskCheckForTimeOut>
    29f8:	81 11       	cpse	r24, r1
    29fa:	1b c0       	rjmp	.+54     	; 0x2a32 <xQueueGenericSend+0xea>
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	0f 92       	push	r0
    2a02:	f8 01       	movw	r30, r16
    2a04:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a06:	0f 90       	pop	r0
    2a08:	0f be       	out	0x3f, r0	; 63
    2a0a:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a0c:	98 13       	cpse	r25, r24
    2a0e:	0d c0       	rjmp	.+26     	; 0x2a2a <xQueueGenericSend+0xe2>
    2a10:	6c 81       	ldd	r22, Y+4	; 0x04
    2a12:	7d 81       	ldd	r23, Y+5	; 0x05
    2a14:	c5 01       	movw	r24, r10
    2a16:	11 d4       	rcall	.+2082   	; 0x323a <vTaskPlaceOnEventList>
    2a18:	c8 01       	movw	r24, r16
    2a1a:	00 df       	rcall	.-512    	; 0x281c <prvUnlockQueue>
    2a1c:	23 d3       	rcall	.+1606   	; 0x3064 <xTaskResumeAll>
    2a1e:	88 23       	and	r24, r24
    2a20:	11 f0       	breq	.+4      	; 0x2a26 <xQueueGenericSend+0xde>
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	a9 cf       	rjmp	.-174    	; 0x2978 <xQueueGenericSend+0x30>
    2a26:	da dd       	rcall	.-1100   	; 0x25dc <vPortYield>
    2a28:	fc cf       	rjmp	.-8      	; 0x2a22 <xQueueGenericSend+0xda>
    2a2a:	c8 01       	movw	r24, r16
    2a2c:	f7 de       	rcall	.-530    	; 0x281c <prvUnlockQueue>
    2a2e:	1a d3       	rcall	.+1588   	; 0x3064 <xTaskResumeAll>
    2a30:	f8 cf       	rjmp	.-16     	; 0x2a22 <xQueueGenericSend+0xda>
    2a32:	c8 01       	movw	r24, r16
    2a34:	f3 de       	rcall	.-538    	; 0x281c <prvUnlockQueue>
    2a36:	16 d3       	rcall	.+1580   	; 0x3064 <xTaskResumeAll>
    2a38:	80 e0       	ldi	r24, 0x00	; 0
    2a3a:	0f 90       	pop	r0
    2a3c:	0f 90       	pop	r0
    2a3e:	0f 90       	pop	r0
    2a40:	0f 90       	pop	r0
    2a42:	0f 90       	pop	r0
    2a44:	df 91       	pop	r29
    2a46:	cf 91       	pop	r28
    2a48:	1f 91       	pop	r17
    2a4a:	0f 91       	pop	r16
    2a4c:	ff 90       	pop	r15
    2a4e:	df 90       	pop	r13
    2a50:	cf 90       	pop	r12
    2a52:	bf 90       	pop	r11
    2a54:	af 90       	pop	r10
    2a56:	08 95       	ret

00002a58 <xQueueCreateMutex>:
    2a58:	cf 93       	push	r28
    2a5a:	df 93       	push	r29
    2a5c:	48 2f       	mov	r20, r24
    2a5e:	60 e0       	ldi	r22, 0x00	; 0
    2a60:	81 e0       	ldi	r24, 0x01	; 1
    2a62:	4c df       	rcall	.-360    	; 0x28fc <xQueueGenericCreate>
    2a64:	ec 01       	movw	r28, r24
    2a66:	00 97       	sbiw	r24, 0x00	; 0
    2a68:	59 f0       	breq	.+22     	; 0x2a80 <xQueueCreateMutex+0x28>
    2a6a:	1b 82       	std	Y+3, r1	; 0x03
    2a6c:	1a 82       	std	Y+2, r1	; 0x02
    2a6e:	19 82       	std	Y+1, r1	; 0x01
    2a70:	18 82       	st	Y, r1
    2a72:	1e 82       	std	Y+6, r1	; 0x06
    2a74:	20 e0       	ldi	r18, 0x00	; 0
    2a76:	40 e0       	ldi	r20, 0x00	; 0
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	60 e0       	ldi	r22, 0x00	; 0
    2a7c:	70 e0       	ldi	r23, 0x00	; 0
    2a7e:	64 df       	rcall	.-312    	; 0x2948 <xQueueGenericSend>
    2a80:	ce 01       	movw	r24, r28
    2a82:	df 91       	pop	r29
    2a84:	cf 91       	pop	r28
    2a86:	08 95       	ret

00002a88 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2a88:	af 92       	push	r10
    2a8a:	bf 92       	push	r11
    2a8c:	cf 92       	push	r12
    2a8e:	df 92       	push	r13
    2a90:	ef 92       	push	r14
    2a92:	ff 92       	push	r15
    2a94:	0f 93       	push	r16
    2a96:	1f 93       	push	r17
    2a98:	cf 93       	push	r28
    2a9a:	df 93       	push	r29
    2a9c:	00 d0       	rcall	.+0      	; 0x2a9e <xQueueGenericReceive+0x16>
    2a9e:	00 d0       	rcall	.+0      	; 0x2aa0 <xQueueGenericReceive+0x18>
    2aa0:	1f 92       	push	r1
    2aa2:	cd b7       	in	r28, 0x3d	; 61
    2aa4:	de b7       	in	r29, 0x3e	; 62
    2aa6:	8c 01       	movw	r16, r24
    2aa8:	6b 01       	movw	r12, r22
    2aaa:	5d 83       	std	Y+5, r21	; 0x05
    2aac:	4c 83       	std	Y+4, r20	; 0x04
    2aae:	e2 2e       	mov	r14, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2ab0:	80 e0       	ldi	r24, 0x00	; 0
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2ab2:	58 01       	movw	r10, r16
    2ab4:	91 e1       	ldi	r25, 0x11	; 17
    2ab6:	a9 0e       	add	r10, r25
    2ab8:	b1 1c       	adc	r11, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2aba:	0f b6       	in	r0, 0x3f	; 63
    2abc:	f8 94       	cli
    2abe:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2ac0:	f8 01       	movw	r30, r16
    2ac2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2ac4:	ff 20       	and	r15, r15
    2ac6:	51 f1       	breq	.+84     	; 0x2b1c <xQueueGenericReceive+0x94>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2ac8:	a6 80       	ldd	r10, Z+6	; 0x06
    2aca:	b7 80       	ldd	r11, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2acc:	b6 01       	movw	r22, r12
    2ace:	c8 01       	movw	r24, r16
    2ad0:	8b de       	rcall	.-746    	; 0x27e8 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2ad2:	e1 10       	cpse	r14, r1
    2ad4:	16 c0       	rjmp	.+44     	; 0x2b02 <xQueueGenericReceive+0x7a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2ad6:	fa 94       	dec	r15
    2ad8:	f8 01       	movw	r30, r16
    2ada:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2adc:	80 81       	ld	r24, Z
    2ade:	91 81       	ldd	r25, Z+1	; 0x01
    2ae0:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2ae2:	21 f4       	brne	.+8      	; 0x2aec <xQueueGenericReceive+0x64>
    2ae4:	c7 d4       	rcall	.+2446   	; 0x3474 <pvTaskIncrementMutexHeldCount>
    2ae6:	f8 01       	movw	r30, r16
    2ae8:	93 83       	std	Z+3, r25	; 0x03
    2aea:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2aec:	f8 01       	movw	r30, r16
    2aee:	80 85       	ldd	r24, Z+8	; 0x08
    2af0:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2af2:	81 f0       	breq	.+32     	; 0x2b14 <xQueueGenericReceive+0x8c>
    2af4:	c8 01       	movw	r24, r16
    2af6:	08 96       	adiw	r24, 0x08	; 8
    2af8:	af d3       	rcall	.+1886   	; 0x3258 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2afa:	88 23       	and	r24, r24
    2afc:	59 f0       	breq	.+22     	; 0x2b14 <xQueueGenericReceive+0x8c>
    2afe:	6e dd       	rcall	.-1316   	; 0x25dc <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2b00:	09 c0       	rjmp	.+18     	; 0x2b14 <xQueueGenericReceive+0x8c>
    2b02:	f8 01       	movw	r30, r16
    2b04:	b7 82       	std	Z+7, r11	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2b06:	a6 82       	std	Z+6, r10	; 0x06
    2b08:	81 89       	ldd	r24, Z+17	; 0x11
    2b0a:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b0c:	19 f0       	breq	.+6      	; 0x2b14 <xQueueGenericReceive+0x8c>
    2b0e:	c8 01       	movw	r24, r16
    2b10:	41 96       	adiw	r24, 0x11	; 17
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2b12:	f2 cf       	rjmp	.-28     	; 0x2af8 <xQueueGenericReceive+0x70>
    2b14:	0f 90       	pop	r0
				return pdPASS;
    2b16:	0f be       	out	0x3f, r0	; 63
    2b18:	81 e0       	ldi	r24, 0x01	; 1
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2b1a:	59 c0       	rjmp	.+178    	; 0x2bce <xQueueGenericReceive+0x146>
    2b1c:	2c 81       	ldd	r18, Y+4	; 0x04
    2b1e:	3d 81       	ldd	r19, Y+5	; 0x05
    2b20:	23 2b       	or	r18, r19
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2b22:	21 f4       	brne	.+8      	; 0x2b2c <xQueueGenericReceive+0xa4>
    2b24:	0f 90       	pop	r0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2b26:	0f be       	out	0x3f, r0	; 63
				}
				else if( xEntryTimeSet == pdFALSE )
    2b28:	80 e0       	ldi	r24, 0x00	; 0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2b2a:	51 c0       	rjmp	.+162    	; 0x2bce <xQueueGenericReceive+0x146>
    2b2c:	81 11       	cpse	r24, r1
    2b2e:	03 c0       	rjmp	.+6      	; 0x2b36 <xQueueGenericReceive+0xae>
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2b30:	ce 01       	movw	r24, r28
    2b32:	01 96       	adiw	r24, 0x01	; 1

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2b34:	ce d3       	rcall	.+1948   	; 0x32d2 <vTaskSetTimeOutState>
    2b36:	0f 90       	pop	r0
		prvLockQueue( pxQueue );
    2b38:	0f be       	out	0x3f, r0	; 63
    2b3a:	e6 d1       	rcall	.+972    	; 0x2f08 <vTaskSuspendAll>
    2b3c:	0f b6       	in	r0, 0x3f	; 63
    2b3e:	f8 94       	cli
    2b40:	0f 92       	push	r0
    2b42:	f8 01       	movw	r30, r16
    2b44:	85 8d       	ldd	r24, Z+29	; 0x1d
    2b46:	8f 3f       	cpi	r24, 0xFF	; 255
    2b48:	09 f4       	brne	.+2      	; 0x2b4c <xQueueGenericReceive+0xc4>
    2b4a:	15 8e       	std	Z+29, r1	; 0x1d
    2b4c:	f8 01       	movw	r30, r16
    2b4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b50:	8f 3f       	cpi	r24, 0xFF	; 255
    2b52:	09 f4       	brne	.+2      	; 0x2b56 <xQueueGenericReceive+0xce>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2b54:	16 8e       	std	Z+30, r1	; 0x1e
    2b56:	0f 90       	pop	r0
    2b58:	0f be       	out	0x3f, r0	; 63
    2b5a:	be 01       	movw	r22, r28
    2b5c:	6c 5f       	subi	r22, 0xFC	; 252
    2b5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b60:	ce 01       	movw	r24, r28
    2b62:	01 96       	adiw	r24, 0x01	; 1
    2b64:	c1 d3       	rcall	.+1922   	; 0x32e8 <xTaskCheckForTimeOut>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2b66:	81 11       	cpse	r24, r1
    2b68:	26 c0       	rjmp	.+76     	; 0x2bb6 <xQueueGenericReceive+0x12e>
    2b6a:	0f b6       	in	r0, 0x3f	; 63
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2b6c:	f8 94       	cli
    2b6e:	0f 92       	push	r0
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2b70:	f8 01       	movw	r30, r16
    2b72:	82 8d       	ldd	r24, Z+26	; 0x1a
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2b74:	0f 90       	pop	r0
    2b76:	0f be       	out	0x3f, r0	; 63
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2b78:	81 11       	cpse	r24, r1
    2b7a:	19 c0       	rjmp	.+50     	; 0x2bae <xQueueGenericReceive+0x126>
    2b7c:	80 81       	ld	r24, Z
					{
						taskENTER_CRITICAL();
    2b7e:	91 81       	ldd	r25, Z+1	; 0x01
    2b80:	89 2b       	or	r24, r25
    2b82:	41 f4       	brne	.+16     	; 0x2b94 <xQueueGenericReceive+0x10c>
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2b84:	0f b6       	in	r0, 0x3f	; 63
						}
						taskEXIT_CRITICAL();
    2b86:	f8 94       	cli
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2b88:	0f 92       	push	r0
    2b8a:	82 81       	ldd	r24, Z+2	; 0x02
    2b8c:	93 81       	ldd	r25, Z+3	; 0x03
    2b8e:	e1 d3       	rcall	.+1986   	; 0x3352 <vTaskPriorityInherit>
				prvUnlockQueue( pxQueue );
    2b90:	0f 90       	pop	r0
				if( xTaskResumeAll() == pdFALSE )
    2b92:	0f be       	out	0x3f, r0	; 63
    2b94:	6c 81       	ldd	r22, Y+4	; 0x04
    2b96:	7d 81       	ldd	r23, Y+5	; 0x05
    2b98:	c5 01       	movw	r24, r10
				{
					portYIELD_WITHIN_API();
    2b9a:	4f d3       	rcall	.+1694   	; 0x323a <vTaskPlaceOnEventList>
    2b9c:	c8 01       	movw	r24, r16
    2b9e:	3e de       	rcall	.-900    	; 0x281c <prvUnlockQueue>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2ba0:	61 d2       	rcall	.+1218   	; 0x3064 <xTaskResumeAll>
    2ba2:	88 23       	and	r24, r24
    2ba4:	11 f0       	breq	.+4      	; 0x2baa <xQueueGenericReceive+0x122>
				( void ) xTaskResumeAll();
    2ba6:	81 e0       	ldi	r24, 0x01	; 1
    2ba8:	88 cf       	rjmp	.-240    	; 0x2aba <xQueueGenericReceive+0x32>
    2baa:	18 dd       	rcall	.-1488   	; 0x25dc <vPortYield>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2bac:	fc cf       	rjmp	.-8      	; 0x2ba6 <xQueueGenericReceive+0x11e>
    2bae:	c8 01       	movw	r24, r16
    2bb0:	35 de       	rcall	.-918    	; 0x281c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2bb2:	58 d2       	rcall	.+1200   	; 0x3064 <xTaskResumeAll>
    2bb4:	f8 cf       	rjmp	.-16     	; 0x2ba6 <xQueueGenericReceive+0x11e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2bb6:	c8 01       	movw	r24, r16
    2bb8:	31 de       	rcall	.-926    	; 0x281c <prvUnlockQueue>
    2bba:	54 d2       	rcall	.+1192   	; 0x3064 <xTaskResumeAll>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2bbc:	0f b6       	in	r0, 0x3f	; 63
    2bbe:	f8 94       	cli
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2bc0:	0f 92       	push	r0
    2bc2:	f8 01       	movw	r30, r16
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2bc4:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bc6:	0f 90       	pop	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    2bc8:	0f be       	out	0x3f, r0	; 63
    2bca:	81 11       	cpse	r24, r1
    2bcc:	ec cf       	rjmp	.-40     	; 0x2ba6 <xQueueGenericReceive+0x11e>
    2bce:	0f 90       	pop	r0
    2bd0:	0f 90       	pop	r0
    2bd2:	0f 90       	pop	r0
    2bd4:	0f 90       	pop	r0
    2bd6:	0f 90       	pop	r0
    2bd8:	df 91       	pop	r29
    2bda:	cf 91       	pop	r28
    2bdc:	1f 91       	pop	r17
    2bde:	0f 91       	pop	r16
    2be0:	ff 90       	pop	r15
    2be2:	ef 90       	pop	r14
    2be4:	df 90       	pop	r13
    2be6:	cf 90       	pop	r12
    2be8:	bf 90       	pop	r11
    2bea:	af 90       	pop	r10
    2bec:	08 95       	ret

00002bee <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    2bee:	e0 91 68 0f 	lds	r30, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2bf2:	f0 91 69 0f 	lds	r31, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2bf6:	80 81       	ld	r24, Z
    2bf8:	81 11       	cpse	r24, r1
    2bfa:	03 c0       	rjmp	.+6      	; 0x2c02 <prvResetNextTaskUnblockTime+0x14>
    2bfc:	8f ef       	ldi	r24, 0xFF	; 255
    2bfe:	9f ef       	ldi	r25, 0xFF	; 255
    2c00:	0c c0       	rjmp	.+24     	; 0x2c1a <prvResetNextTaskUnblockTime+0x2c>
    2c02:	e0 91 68 0f 	lds	r30, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2c06:	f0 91 69 0f 	lds	r31, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2c0a:	05 80       	ldd	r0, Z+5	; 0x05
    2c0c:	f6 81       	ldd	r31, Z+6	; 0x06
    2c0e:	e0 2d       	mov	r30, r0
    2c10:	06 80       	ldd	r0, Z+6	; 0x06
    2c12:	f7 81       	ldd	r31, Z+7	; 0x07
    2c14:	e0 2d       	mov	r30, r0
    2c16:	82 81       	ldd	r24, Z+2	; 0x02
    2c18:	93 81       	ldd	r25, Z+3	; 0x03
    2c1a:	90 93 40 0f 	sts	0x0F40, r25	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2c1e:	80 93 3f 0f 	sts	0x0F3F, r24	; 0x800f3f <xNextTaskUnblockTime>
    2c22:	08 95       	ret

00002c24 <prvAddCurrentTaskToDelayedList>:
    2c24:	ff 92       	push	r15
    2c26:	0f 93       	push	r16
    2c28:	1f 93       	push	r17
    2c2a:	cf 93       	push	r28
    2c2c:	df 93       	push	r29
    2c2e:	ec 01       	movw	r28, r24
    2c30:	f6 2e       	mov	r15, r22
    2c32:	00 91 47 0f 	lds	r16, 0x0F47	; 0x800f47 <xTickCount>
    2c36:	10 91 48 0f 	lds	r17, 0x0F48	; 0x800f48 <xTickCount+0x1>
    2c3a:	80 91 a0 0f 	lds	r24, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2c3e:	90 91 a1 0f 	lds	r25, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2c42:	02 96       	adiw	r24, 0x02	; 2
    2c44:	07 dc       	rcall	.-2034   	; 0x2454 <uxListRemove>
    2c46:	cf 3f       	cpi	r28, 0xFF	; 255
    2c48:	8f ef       	ldi	r24, 0xFF	; 255
    2c4a:	d8 07       	cpc	r29, r24
    2c4c:	81 f4       	brne	.+32     	; 0x2c6e <prvAddCurrentTaskToDelayedList+0x4a>
    2c4e:	ff 20       	and	r15, r15
    2c50:	71 f0       	breq	.+28     	; 0x2c6e <prvAddCurrentTaskToDelayedList+0x4a>
    2c52:	60 91 a0 0f 	lds	r22, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2c56:	70 91 a1 0f 	lds	r23, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2c5a:	6e 5f       	subi	r22, 0xFE	; 254
    2c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    2c5e:	8a e4       	ldi	r24, 0x4A	; 74
    2c60:	9f e0       	ldi	r25, 0x0F	; 15
    2c62:	df 91       	pop	r29
    2c64:	cf 91       	pop	r28
    2c66:	1f 91       	pop	r17
    2c68:	0f 91       	pop	r16
    2c6a:	ff 90       	pop	r15
    2c6c:	9a cb       	rjmp	.-2252   	; 0x23a2 <vListInsertEnd>
    2c6e:	c0 0f       	add	r28, r16
    2c70:	d1 1f       	adc	r29, r17
    2c72:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2c76:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2c7a:	d3 83       	std	Z+3, r29	; 0x03
    2c7c:	c2 83       	std	Z+2, r28	; 0x02
    2c7e:	60 91 a0 0f 	lds	r22, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2c82:	70 91 a1 0f 	lds	r23, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2c86:	c0 17       	cp	r28, r16
    2c88:	d1 07       	cpc	r29, r17
    2c8a:	60 f4       	brcc	.+24     	; 0x2ca4 <prvAddCurrentTaskToDelayedList+0x80>
    2c8c:	80 91 66 0f 	lds	r24, 0x0F66	; 0x800f66 <pxOverflowDelayedTaskList>
    2c90:	90 91 67 0f 	lds	r25, 0x0F67	; 0x800f67 <pxOverflowDelayedTaskList+0x1>
    2c94:	6e 5f       	subi	r22, 0xFE	; 254
    2c96:	7f 4f       	sbci	r23, 0xFF	; 255
    2c98:	df 91       	pop	r29
    2c9a:	cf 91       	pop	r28
    2c9c:	1f 91       	pop	r17
    2c9e:	0f 91       	pop	r16
    2ca0:	ff 90       	pop	r15
    2ca2:	a0 cb       	rjmp	.-2240   	; 0x23e4 <vListInsert>
    2ca4:	80 91 68 0f 	lds	r24, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2ca8:	90 91 69 0f 	lds	r25, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2cac:	6e 5f       	subi	r22, 0xFE	; 254
    2cae:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb0:	99 db       	rcall	.-2254   	; 0x23e4 <vListInsert>
    2cb2:	80 91 3f 0f 	lds	r24, 0x0F3F	; 0x800f3f <xNextTaskUnblockTime>
    2cb6:	90 91 40 0f 	lds	r25, 0x0F40	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2cba:	c8 17       	cp	r28, r24
    2cbc:	d9 07       	cpc	r29, r25
    2cbe:	20 f4       	brcc	.+8      	; 0x2cc8 <prvAddCurrentTaskToDelayedList+0xa4>
    2cc0:	d0 93 40 0f 	sts	0x0F40, r29	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2cc4:	c0 93 3f 0f 	sts	0x0F3F, r28	; 0x800f3f <xNextTaskUnblockTime>
    2cc8:	df 91       	pop	r29
    2cca:	cf 91       	pop	r28
    2ccc:	1f 91       	pop	r17
    2cce:	0f 91       	pop	r16
    2cd0:	ff 90       	pop	r15
    2cd2:	08 95       	ret

00002cd4 <xTaskCreate>:
    2cd4:	3f 92       	push	r3
    2cd6:	4f 92       	push	r4
    2cd8:	5f 92       	push	r5
    2cda:	6f 92       	push	r6
    2cdc:	7f 92       	push	r7
    2cde:	8f 92       	push	r8
    2ce0:	9f 92       	push	r9
    2ce2:	af 92       	push	r10
    2ce4:	bf 92       	push	r11
    2ce6:	cf 92       	push	r12
    2ce8:	df 92       	push	r13
    2cea:	ef 92       	push	r14
    2cec:	ff 92       	push	r15
    2cee:	0f 93       	push	r16
    2cf0:	1f 93       	push	r17
    2cf2:	cf 93       	push	r28
    2cf4:	df 93       	push	r29
    2cf6:	4c 01       	movw	r8, r24
    2cf8:	16 2f       	mov	r17, r22
    2cfa:	37 2e       	mov	r3, r23
    2cfc:	6a 01       	movw	r12, r20
    2cfe:	59 01       	movw	r10, r18
    2d00:	ca 01       	movw	r24, r20
    2d02:	0c db       	rcall	.-2536   	; 0x231c <pvPortMalloc>
    2d04:	2c 01       	movw	r4, r24
    2d06:	89 2b       	or	r24, r25
    2d08:	09 f4       	brne	.+2      	; 0x2d0c <xTaskCreate+0x38>
    2d0a:	c3 c0       	rjmp	.+390    	; 0x2e92 <xTaskCreate+0x1be>
    2d0c:	88 e2       	ldi	r24, 0x28	; 40
    2d0e:	90 e0       	ldi	r25, 0x00	; 0
    2d10:	05 db       	rcall	.-2550   	; 0x231c <pvPortMalloc>
    2d12:	ec 01       	movw	r28, r24
    2d14:	89 2b       	or	r24, r25
    2d16:	79 f0       	breq	.+30     	; 0x2d36 <xTaskCreate+0x62>
    2d18:	58 8e       	std	Y+24, r5	; 0x18
    2d1a:	4f 8a       	std	Y+23, r4	; 0x17
    2d1c:	c6 01       	movw	r24, r12
    2d1e:	01 97       	sbiw	r24, 0x01	; 1
    2d20:	32 01       	movw	r6, r4
    2d22:	68 0e       	add	r6, r24
    2d24:	79 1e       	adc	r7, r25
    2d26:	be 01       	movw	r22, r28
    2d28:	67 5e       	subi	r22, 0xE7	; 231
    2d2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d2c:	e1 2f       	mov	r30, r17
    2d2e:	f3 2d       	mov	r31, r3
    2d30:	cf 01       	movw	r24, r30
    2d32:	08 96       	adiw	r24, 0x08	; 8
    2d34:	06 c0       	rjmp	.+12     	; 0x2d42 <xTaskCreate+0x6e>
    2d36:	c2 01       	movw	r24, r4
    2d38:	21 db       	rcall	.-2494   	; 0x237c <vPortFree>
    2d3a:	ab c0       	rjmp	.+342    	; 0x2e92 <xTaskCreate+0x1be>
    2d3c:	e8 17       	cp	r30, r24
    2d3e:	f9 07       	cpc	r31, r25
    2d40:	49 f0       	breq	.+18     	; 0x2d54 <xTaskCreate+0x80>
    2d42:	9f 01       	movw	r18, r30
    2d44:	41 91       	ld	r20, Z+
    2d46:	db 01       	movw	r26, r22
    2d48:	4d 93       	st	X+, r20
    2d4a:	bd 01       	movw	r22, r26
    2d4c:	d9 01       	movw	r26, r18
    2d4e:	2c 91       	ld	r18, X
    2d50:	21 11       	cpse	r18, r1
    2d52:	f4 cf       	rjmp	.-24     	; 0x2d3c <xTaskCreate+0x68>
    2d54:	18 a2       	std	Y+32, r1	; 0x20
    2d56:	04 30       	cpi	r16, 0x04	; 4
    2d58:	08 f0       	brcs	.+2      	; 0x2d5c <xTaskCreate+0x88>
    2d5a:	03 e0       	ldi	r16, 0x03	; 3
    2d5c:	0e 8b       	std	Y+22, r16	; 0x16
    2d5e:	09 a3       	std	Y+33, r16	; 0x21
    2d60:	1a a2       	std	Y+34, r1	; 0x22
    2d62:	6e 01       	movw	r12, r28
    2d64:	b2 e0       	ldi	r27, 0x02	; 2
    2d66:	cb 0e       	add	r12, r27
    2d68:	d1 1c       	adc	r13, r1
    2d6a:	c6 01       	movw	r24, r12
    2d6c:	16 db       	rcall	.-2516   	; 0x239a <vListInitialiseItem>
    2d6e:	ce 01       	movw	r24, r28
    2d70:	0c 96       	adiw	r24, 0x0c	; 12
    2d72:	13 db       	rcall	.-2522   	; 0x239a <vListInitialiseItem>
    2d74:	d9 87       	std	Y+9, r29	; 0x09
    2d76:	c8 87       	std	Y+8, r28	; 0x08
    2d78:	84 e0       	ldi	r24, 0x04	; 4
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	80 1b       	sub	r24, r16
    2d7e:	91 09       	sbc	r25, r1
    2d80:	9d 87       	std	Y+13, r25	; 0x0d
    2d82:	8c 87       	std	Y+12, r24	; 0x0c
    2d84:	db 8b       	std	Y+19, r29	; 0x13
    2d86:	ca 8b       	std	Y+18, r28	; 0x12
    2d88:	1b a2       	std	Y+35, r1	; 0x23
    2d8a:	1c a2       	std	Y+36, r1	; 0x24
    2d8c:	1d a2       	std	Y+37, r1	; 0x25
    2d8e:	1e a2       	std	Y+38, r1	; 0x26
    2d90:	1f a2       	std	Y+39, r1	; 0x27
    2d92:	a5 01       	movw	r20, r10
    2d94:	b4 01       	movw	r22, r8
    2d96:	c3 01       	movw	r24, r6
    2d98:	80 db       	rcall	.-2304   	; 0x249a <pxPortInitialiseStack>
    2d9a:	99 83       	std	Y+1, r25	; 0x01
    2d9c:	88 83       	st	Y, r24
    2d9e:	e1 14       	cp	r14, r1
    2da0:	f1 04       	cpc	r15, r1
    2da2:	19 f0       	breq	.+6      	; 0x2daa <xTaskCreate+0xd6>
    2da4:	f7 01       	movw	r30, r14
    2da6:	d1 83       	std	Z+1, r29	; 0x01
    2da8:	c0 83       	st	Z, r28
    2daa:	0f b6       	in	r0, 0x3f	; 63
    2dac:	f8 94       	cli
    2dae:	0f 92       	push	r0
    2db0:	80 91 49 0f 	lds	r24, 0x0F49	; 0x800f49 <uxCurrentNumberOfTasks>
    2db4:	8f 5f       	subi	r24, 0xFF	; 255
    2db6:	80 93 49 0f 	sts	0x0F49, r24	; 0x800f49 <uxCurrentNumberOfTasks>
    2dba:	80 91 a0 0f 	lds	r24, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2dbe:	90 91 a1 0f 	lds	r25, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2dc2:	89 2b       	or	r24, r25
    2dc4:	89 f5       	brne	.+98     	; 0x2e28 <xTaskCreate+0x154>
    2dc6:	d0 93 a1 0f 	sts	0x0FA1, r29	; 0x800fa1 <pxCurrentTCB+0x1>
    2dca:	c0 93 a0 0f 	sts	0x0FA0, r28	; 0x800fa0 <pxCurrentTCB>
    2dce:	80 91 49 0f 	lds	r24, 0x0F49	; 0x800f49 <uxCurrentNumberOfTasks>
    2dd2:	81 30       	cpi	r24, 0x01	; 1
    2dd4:	09 f0       	breq	.+2      	; 0x2dd8 <xTaskCreate+0x104>
    2dd6:	38 c0       	rjmp	.+112    	; 0x2e48 <xTaskCreate+0x174>
    2dd8:	8c e7       	ldi	r24, 0x7C	; 124
    2dda:	9f e0       	ldi	r25, 0x0F	; 15
    2ddc:	d0 da       	rcall	.-2656   	; 0x237e <vListInitialise>
    2dde:	85 e8       	ldi	r24, 0x85	; 133
    2de0:	9f e0       	ldi	r25, 0x0F	; 15
    2de2:	cd da       	rcall	.-2662   	; 0x237e <vListInitialise>
    2de4:	8e e8       	ldi	r24, 0x8E	; 142
    2de6:	9f e0       	ldi	r25, 0x0F	; 15
    2de8:	ca da       	rcall	.-2668   	; 0x237e <vListInitialise>
    2dea:	87 e9       	ldi	r24, 0x97	; 151
    2dec:	9f e0       	ldi	r25, 0x0F	; 15
    2dee:	c7 da       	rcall	.-2674   	; 0x237e <vListInitialise>
    2df0:	83 e7       	ldi	r24, 0x73	; 115
    2df2:	9f e0       	ldi	r25, 0x0F	; 15
    2df4:	c4 da       	rcall	.-2680   	; 0x237e <vListInitialise>
    2df6:	8a e6       	ldi	r24, 0x6A	; 106
    2df8:	9f e0       	ldi	r25, 0x0F	; 15
    2dfa:	c1 da       	rcall	.-2686   	; 0x237e <vListInitialise>
    2dfc:	8d e5       	ldi	r24, 0x5D	; 93
    2dfe:	9f e0       	ldi	r25, 0x0F	; 15
    2e00:	be da       	rcall	.-2692   	; 0x237e <vListInitialise>
    2e02:	84 e5       	ldi	r24, 0x54	; 84
    2e04:	9f e0       	ldi	r25, 0x0F	; 15
    2e06:	bb da       	rcall	.-2698   	; 0x237e <vListInitialise>
    2e08:	8a e4       	ldi	r24, 0x4A	; 74
    2e0a:	9f e0       	ldi	r25, 0x0F	; 15
    2e0c:	b8 da       	rcall	.-2704   	; 0x237e <vListInitialise>
    2e0e:	83 e7       	ldi	r24, 0x73	; 115
    2e10:	9f e0       	ldi	r25, 0x0F	; 15
    2e12:	90 93 69 0f 	sts	0x0F69, r25	; 0x800f69 <pxDelayedTaskList+0x1>
    2e16:	80 93 68 0f 	sts	0x0F68, r24	; 0x800f68 <pxDelayedTaskList>
    2e1a:	8a e6       	ldi	r24, 0x6A	; 106
    2e1c:	9f e0       	ldi	r25, 0x0F	; 15
    2e1e:	90 93 67 0f 	sts	0x0F67, r25	; 0x800f67 <pxOverflowDelayedTaskList+0x1>
    2e22:	80 93 66 0f 	sts	0x0F66, r24	; 0x800f66 <pxOverflowDelayedTaskList>
    2e26:	10 c0       	rjmp	.+32     	; 0x2e48 <xTaskCreate+0x174>
    2e28:	80 91 45 0f 	lds	r24, 0x0F45	; 0x800f45 <xSchedulerRunning>
    2e2c:	81 11       	cpse	r24, r1
    2e2e:	0c c0       	rjmp	.+24     	; 0x2e48 <xTaskCreate+0x174>
    2e30:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2e34:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2e38:	96 89       	ldd	r25, Z+22	; 0x16
    2e3a:	8e 89       	ldd	r24, Y+22	; 0x16
    2e3c:	89 17       	cp	r24, r25
    2e3e:	20 f0       	brcs	.+8      	; 0x2e48 <xTaskCreate+0x174>
    2e40:	d0 93 a1 0f 	sts	0x0FA1, r29	; 0x800fa1 <pxCurrentTCB+0x1>
    2e44:	c0 93 a0 0f 	sts	0x0FA0, r28	; 0x800fa0 <pxCurrentTCB>
    2e48:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxTaskNumber>
    2e4c:	8f 5f       	subi	r24, 0xFF	; 255
    2e4e:	80 93 41 0f 	sts	0x0F41, r24	; 0x800f41 <uxTaskNumber>
    2e52:	8e 89       	ldd	r24, Y+22	; 0x16
    2e54:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    2e58:	98 17       	cp	r25, r24
    2e5a:	10 f4       	brcc	.+4      	; 0x2e60 <xTaskCreate+0x18c>
    2e5c:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    2e60:	f9 e0       	ldi	r31, 0x09	; 9
    2e62:	8f 9f       	mul	r24, r31
    2e64:	c0 01       	movw	r24, r0
    2e66:	11 24       	eor	r1, r1
    2e68:	b6 01       	movw	r22, r12
    2e6a:	84 58       	subi	r24, 0x84	; 132
    2e6c:	90 4f       	sbci	r25, 0xF0	; 240
    2e6e:	99 da       	rcall	.-2766   	; 0x23a2 <vListInsertEnd>
    2e70:	0f 90       	pop	r0
    2e72:	0f be       	out	0x3f, r0	; 63
    2e74:	80 91 45 0f 	lds	r24, 0x0F45	; 0x800f45 <xSchedulerRunning>
    2e78:	88 23       	and	r24, r24
    2e7a:	49 f0       	breq	.+18     	; 0x2e8e <xTaskCreate+0x1ba>
    2e7c:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    2e80:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    2e84:	96 89       	ldd	r25, Z+22	; 0x16
    2e86:	8e 89       	ldd	r24, Y+22	; 0x16
    2e88:	98 17       	cp	r25, r24
    2e8a:	08 f4       	brcc	.+2      	; 0x2e8e <xTaskCreate+0x1ba>
    2e8c:	a7 db       	rcall	.-2226   	; 0x25dc <vPortYield>
    2e8e:	81 e0       	ldi	r24, 0x01	; 1
    2e90:	01 c0       	rjmp	.+2      	; 0x2e94 <xTaskCreate+0x1c0>
    2e92:	8f ef       	ldi	r24, 0xFF	; 255
    2e94:	df 91       	pop	r29
    2e96:	cf 91       	pop	r28
    2e98:	1f 91       	pop	r17
    2e9a:	0f 91       	pop	r16
    2e9c:	ff 90       	pop	r15
    2e9e:	ef 90       	pop	r14
    2ea0:	df 90       	pop	r13
    2ea2:	cf 90       	pop	r12
    2ea4:	bf 90       	pop	r11
    2ea6:	af 90       	pop	r10
    2ea8:	9f 90       	pop	r9
    2eaa:	8f 90       	pop	r8
    2eac:	7f 90       	pop	r7
    2eae:	6f 90       	pop	r6
    2eb0:	5f 90       	pop	r5
    2eb2:	4f 90       	pop	r4
    2eb4:	3f 90       	pop	r3
    2eb6:	08 95       	ret

00002eb8 <vTaskStartScheduler>:
    2eb8:	ef 92       	push	r14
    2eba:	ff 92       	push	r15
    2ebc:	0f 93       	push	r16
    2ebe:	8d e3       	ldi	r24, 0x3D	; 61
    2ec0:	e8 2e       	mov	r14, r24
    2ec2:	8f e0       	ldi	r24, 0x0F	; 15
    2ec4:	f8 2e       	mov	r15, r24
    2ec6:	00 e0       	ldi	r16, 0x00	; 0
    2ec8:	20 e0       	ldi	r18, 0x00	; 0
    2eca:	30 e0       	ldi	r19, 0x00	; 0
    2ecc:	45 e5       	ldi	r20, 0x55	; 85
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	66 eb       	ldi	r22, 0xB6	; 182
    2ed2:	71 e0       	ldi	r23, 0x01	; 1
    2ed4:	8c ea       	ldi	r24, 0xAC	; 172
    2ed6:	98 e1       	ldi	r25, 0x18	; 24
    2ed8:	fd de       	rcall	.-518    	; 0x2cd4 <xTaskCreate>
    2eda:	81 30       	cpi	r24, 0x01	; 1
    2edc:	89 f4       	brne	.+34     	; 0x2f00 <vTaskStartScheduler+0x48>
    2ede:	f8 94       	cli
    2ee0:	2f ef       	ldi	r18, 0xFF	; 255
    2ee2:	3f ef       	ldi	r19, 0xFF	; 255
    2ee4:	30 93 40 0f 	sts	0x0F40, r19	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2ee8:	20 93 3f 0f 	sts	0x0F3F, r18	; 0x800f3f <xNextTaskUnblockTime>
    2eec:	80 93 45 0f 	sts	0x0F45, r24	; 0x800f45 <xSchedulerRunning>
    2ef0:	10 92 48 0f 	sts	0x0F48, r1	; 0x800f48 <xTickCount+0x1>
    2ef4:	10 92 47 0f 	sts	0x0F47, r1	; 0x800f47 <xTickCount>
    2ef8:	0f 91       	pop	r16
    2efa:	ff 90       	pop	r15
    2efc:	ef 90       	pop	r14
    2efe:	39 cb       	rjmp	.-2446   	; 0x2572 <xPortStartScheduler>
    2f00:	0f 91       	pop	r16
    2f02:	ff 90       	pop	r15
    2f04:	ef 90       	pop	r14
    2f06:	08 95       	ret

00002f08 <vTaskSuspendAll>:
    2f08:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    2f0c:	8f 5f       	subi	r24, 0xFF	; 255
    2f0e:	80 93 3c 0f 	sts	0x0F3C, r24	; 0x800f3c <uxSchedulerSuspended>
    2f12:	08 95       	ret

00002f14 <xTaskIncrementTick>:
    2f14:	cf 92       	push	r12
    2f16:	df 92       	push	r13
    2f18:	ef 92       	push	r14
    2f1a:	ff 92       	push	r15
    2f1c:	0f 93       	push	r16
    2f1e:	1f 93       	push	r17
    2f20:	cf 93       	push	r28
    2f22:	df 93       	push	r29
    2f24:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    2f28:	81 11       	cpse	r24, r1
    2f2a:	88 c0       	rjmp	.+272    	; 0x303c <xTaskIncrementTick+0x128>
    2f2c:	00 91 47 0f 	lds	r16, 0x0F47	; 0x800f47 <xTickCount>
    2f30:	10 91 48 0f 	lds	r17, 0x0F48	; 0x800f48 <xTickCount+0x1>
    2f34:	0f 5f       	subi	r16, 0xFF	; 255
    2f36:	1f 4f       	sbci	r17, 0xFF	; 255
    2f38:	10 93 48 0f 	sts	0x0F48, r17	; 0x800f48 <xTickCount+0x1>
    2f3c:	00 93 47 0f 	sts	0x0F47, r16	; 0x800f47 <xTickCount>
    2f40:	01 15       	cp	r16, r1
    2f42:	11 05       	cpc	r17, r1
    2f44:	b1 f4       	brne	.+44     	; 0x2f72 <xTaskIncrementTick+0x5e>
    2f46:	80 91 68 0f 	lds	r24, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2f4a:	90 91 69 0f 	lds	r25, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2f4e:	20 91 66 0f 	lds	r18, 0x0F66	; 0x800f66 <pxOverflowDelayedTaskList>
    2f52:	30 91 67 0f 	lds	r19, 0x0F67	; 0x800f67 <pxOverflowDelayedTaskList+0x1>
    2f56:	30 93 69 0f 	sts	0x0F69, r19	; 0x800f69 <pxDelayedTaskList+0x1>
    2f5a:	20 93 68 0f 	sts	0x0F68, r18	; 0x800f68 <pxDelayedTaskList>
    2f5e:	90 93 67 0f 	sts	0x0F67, r25	; 0x800f67 <pxOverflowDelayedTaskList+0x1>
    2f62:	80 93 66 0f 	sts	0x0F66, r24	; 0x800f66 <pxOverflowDelayedTaskList>
    2f66:	80 91 42 0f 	lds	r24, 0x0F42	; 0x800f42 <xNumOfOverflows>
    2f6a:	8f 5f       	subi	r24, 0xFF	; 255
    2f6c:	80 93 42 0f 	sts	0x0F42, r24	; 0x800f42 <xNumOfOverflows>
    2f70:	3e de       	rcall	.-900    	; 0x2bee <prvResetNextTaskUnblockTime>
    2f72:	80 91 3f 0f 	lds	r24, 0x0F3F	; 0x800f3f <xNextTaskUnblockTime>
    2f76:	90 91 40 0f 	lds	r25, 0x0F40	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2f7a:	c0 e0       	ldi	r28, 0x00	; 0
    2f7c:	08 17       	cp	r16, r24
    2f7e:	19 07       	cpc	r17, r25
    2f80:	08 f4       	brcc	.+2      	; 0x2f84 <xTaskIncrementTick+0x70>
    2f82:	4c c0       	rjmp	.+152    	; 0x301c <xTaskIncrementTick+0x108>
    2f84:	d9 e0       	ldi	r29, 0x09	; 9
    2f86:	e0 91 68 0f 	lds	r30, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2f8a:	f0 91 69 0f 	lds	r31, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2f8e:	80 81       	ld	r24, Z
    2f90:	81 11       	cpse	r24, r1
    2f92:	03 c0       	rjmp	.+6      	; 0x2f9a <xTaskIncrementTick+0x86>
    2f94:	8f ef       	ldi	r24, 0xFF	; 255
    2f96:	9f ef       	ldi	r25, 0xFF	; 255
    2f98:	11 c0       	rjmp	.+34     	; 0x2fbc <xTaskIncrementTick+0xa8>
    2f9a:	e0 91 68 0f 	lds	r30, 0x0F68	; 0x800f68 <pxDelayedTaskList>
    2f9e:	f0 91 69 0f 	lds	r31, 0x0F69	; 0x800f69 <pxDelayedTaskList+0x1>
    2fa2:	05 80       	ldd	r0, Z+5	; 0x05
    2fa4:	f6 81       	ldd	r31, Z+6	; 0x06
    2fa6:	e0 2d       	mov	r30, r0
    2fa8:	e6 80       	ldd	r14, Z+6	; 0x06
    2faa:	f7 80       	ldd	r15, Z+7	; 0x07
    2fac:	d7 01       	movw	r26, r14
    2fae:	12 96       	adiw	r26, 0x02	; 2
    2fb0:	8d 91       	ld	r24, X+
    2fb2:	9c 91       	ld	r25, X
    2fb4:	13 97       	sbiw	r26, 0x03	; 3
    2fb6:	08 17       	cp	r16, r24
    2fb8:	19 07       	cpc	r17, r25
    2fba:	28 f4       	brcc	.+10     	; 0x2fc6 <xTaskIncrementTick+0xb2>
    2fbc:	90 93 40 0f 	sts	0x0F40, r25	; 0x800f40 <xNextTaskUnblockTime+0x1>
    2fc0:	80 93 3f 0f 	sts	0x0F3F, r24	; 0x800f3f <xNextTaskUnblockTime>
    2fc4:	2b c0       	rjmp	.+86     	; 0x301c <xTaskIncrementTick+0x108>
    2fc6:	67 01       	movw	r12, r14
    2fc8:	b2 e0       	ldi	r27, 0x02	; 2
    2fca:	cb 0e       	add	r12, r27
    2fcc:	d1 1c       	adc	r13, r1
    2fce:	c6 01       	movw	r24, r12
    2fd0:	41 da       	rcall	.-2942   	; 0x2454 <uxListRemove>
    2fd2:	f7 01       	movw	r30, r14
    2fd4:	84 89       	ldd	r24, Z+20	; 0x14
    2fd6:	95 89       	ldd	r25, Z+21	; 0x15
    2fd8:	89 2b       	or	r24, r25
    2fda:	19 f0       	breq	.+6      	; 0x2fe2 <xTaskIncrementTick+0xce>
    2fdc:	c7 01       	movw	r24, r14
    2fde:	0c 96       	adiw	r24, 0x0c	; 12
    2fe0:	39 da       	rcall	.-2958   	; 0x2454 <uxListRemove>
    2fe2:	d7 01       	movw	r26, r14
    2fe4:	56 96       	adiw	r26, 0x16	; 22
    2fe6:	8c 91       	ld	r24, X
    2fe8:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    2fec:	98 17       	cp	r25, r24
    2fee:	10 f4       	brcc	.+4      	; 0x2ff4 <xTaskIncrementTick+0xe0>
    2ff0:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    2ff4:	d8 9f       	mul	r29, r24
    2ff6:	c0 01       	movw	r24, r0
    2ff8:	11 24       	eor	r1, r1
    2ffa:	b6 01       	movw	r22, r12
    2ffc:	84 58       	subi	r24, 0x84	; 132
    2ffe:	90 4f       	sbci	r25, 0xF0	; 240
    3000:	d0 d9       	rcall	.-3168   	; 0x23a2 <vListInsertEnd>
    3002:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3006:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    300a:	d7 01       	movw	r26, r14
    300c:	56 96       	adiw	r26, 0x16	; 22
    300e:	9c 91       	ld	r25, X
    3010:	86 89       	ldd	r24, Z+22	; 0x16
    3012:	98 17       	cp	r25, r24
    3014:	08 f4       	brcc	.+2      	; 0x3018 <xTaskIncrementTick+0x104>
    3016:	b7 cf       	rjmp	.-146    	; 0x2f86 <xTaskIncrementTick+0x72>
    3018:	c1 e0       	ldi	r28, 0x01	; 1
    301a:	b5 cf       	rjmp	.-150    	; 0x2f86 <xTaskIncrementTick+0x72>
    301c:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3020:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    3024:	e6 89       	ldd	r30, Z+22	; 0x16
    3026:	b9 e0       	ldi	r27, 0x09	; 9
    3028:	eb 9f       	mul	r30, r27
    302a:	f0 01       	movw	r30, r0
    302c:	11 24       	eor	r1, r1
    302e:	e4 58       	subi	r30, 0x84	; 132
    3030:	f0 4f       	sbci	r31, 0xF0	; 240
    3032:	80 81       	ld	r24, Z
    3034:	82 30       	cpi	r24, 0x02	; 2
    3036:	40 f0       	brcs	.+16     	; 0x3048 <xTaskIncrementTick+0x134>
    3038:	c1 e0       	ldi	r28, 0x01	; 1
    303a:	06 c0       	rjmp	.+12     	; 0x3048 <xTaskIncrementTick+0x134>
    303c:	80 91 44 0f 	lds	r24, 0x0F44	; 0x800f44 <uxPendedTicks>
    3040:	8f 5f       	subi	r24, 0xFF	; 255
    3042:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <uxPendedTicks>
    3046:	c0 e0       	ldi	r28, 0x00	; 0
    3048:	80 91 43 0f 	lds	r24, 0x0F43	; 0x800f43 <xYieldPending>
    304c:	81 11       	cpse	r24, r1
    304e:	c1 e0       	ldi	r28, 0x01	; 1
    3050:	8c 2f       	mov	r24, r28
    3052:	df 91       	pop	r29
    3054:	cf 91       	pop	r28
    3056:	1f 91       	pop	r17
    3058:	0f 91       	pop	r16
    305a:	ff 90       	pop	r15
    305c:	ef 90       	pop	r14
    305e:	df 90       	pop	r13
    3060:	cf 90       	pop	r12
    3062:	08 95       	ret

00003064 <xTaskResumeAll>:
    3064:	ef 92       	push	r14
    3066:	ff 92       	push	r15
    3068:	0f 93       	push	r16
    306a:	1f 93       	push	r17
    306c:	cf 93       	push	r28
    306e:	df 93       	push	r29
    3070:	0f b6       	in	r0, 0x3f	; 63
    3072:	f8 94       	cli
    3074:	0f 92       	push	r0
    3076:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    307a:	81 50       	subi	r24, 0x01	; 1
    307c:	80 93 3c 0f 	sts	0x0F3C, r24	; 0x800f3c <uxSchedulerSuspended>
    3080:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    3084:	88 23       	and	r24, r24
    3086:	11 f0       	breq	.+4      	; 0x308c <xTaskResumeAll+0x28>
    3088:	80 e0       	ldi	r24, 0x00	; 0
    308a:	4c c0       	rjmp	.+152    	; 0x3124 <xTaskResumeAll+0xc0>
    308c:	80 91 49 0f 	lds	r24, 0x0F49	; 0x800f49 <uxCurrentNumberOfTasks>
    3090:	88 23       	and	r24, r24
    3092:	d1 f3       	breq	.-12     	; 0x3088 <xTaskResumeAll+0x24>
    3094:	c0 e0       	ldi	r28, 0x00	; 0
    3096:	d0 e0       	ldi	r29, 0x00	; 0
    3098:	89 e0       	ldi	r24, 0x09	; 9
    309a:	f8 2e       	mov	r15, r24
    309c:	ee 24       	eor	r14, r14
    309e:	e3 94       	inc	r14
    30a0:	80 91 5d 0f 	lds	r24, 0x0F5D	; 0x800f5d <xPendingReadyList>
    30a4:	88 23       	and	r24, r24
    30a6:	39 f1       	breq	.+78     	; 0x30f6 <xTaskResumeAll+0x92>
    30a8:	e0 91 62 0f 	lds	r30, 0x0F62	; 0x800f62 <xPendingReadyList+0x5>
    30ac:	f0 91 63 0f 	lds	r31, 0x0F63	; 0x800f63 <xPendingReadyList+0x6>
    30b0:	c6 81       	ldd	r28, Z+6	; 0x06
    30b2:	d7 81       	ldd	r29, Z+7	; 0x07
    30b4:	ce 01       	movw	r24, r28
    30b6:	0c 96       	adiw	r24, 0x0c	; 12
    30b8:	cd d9       	rcall	.-3174   	; 0x2454 <uxListRemove>
    30ba:	8e 01       	movw	r16, r28
    30bc:	0e 5f       	subi	r16, 0xFE	; 254
    30be:	1f 4f       	sbci	r17, 0xFF	; 255
    30c0:	c8 01       	movw	r24, r16
    30c2:	c8 d9       	rcall	.-3184   	; 0x2454 <uxListRemove>
    30c4:	8e 89       	ldd	r24, Y+22	; 0x16
    30c6:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    30ca:	98 17       	cp	r25, r24
    30cc:	10 f4       	brcc	.+4      	; 0x30d2 <xTaskResumeAll+0x6e>
    30ce:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    30d2:	f8 9e       	mul	r15, r24
    30d4:	c0 01       	movw	r24, r0
    30d6:	11 24       	eor	r1, r1
    30d8:	b8 01       	movw	r22, r16
    30da:	84 58       	subi	r24, 0x84	; 132
    30dc:	90 4f       	sbci	r25, 0xF0	; 240
    30de:	61 d9       	rcall	.-3390   	; 0x23a2 <vListInsertEnd>
    30e0:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    30e4:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    30e8:	9e 89       	ldd	r25, Y+22	; 0x16
    30ea:	86 89       	ldd	r24, Z+22	; 0x16
    30ec:	98 17       	cp	r25, r24
    30ee:	c0 f2       	brcs	.-80     	; 0x30a0 <xTaskResumeAll+0x3c>
    30f0:	e0 92 43 0f 	sts	0x0F43, r14	; 0x800f43 <xYieldPending>
    30f4:	d5 cf       	rjmp	.-86     	; 0x30a0 <xTaskResumeAll+0x3c>
    30f6:	cd 2b       	or	r28, r29
    30f8:	09 f0       	breq	.+2      	; 0x30fc <xTaskResumeAll+0x98>
    30fa:	79 dd       	rcall	.-1294   	; 0x2bee <prvResetNextTaskUnblockTime>
    30fc:	c0 91 44 0f 	lds	r28, 0x0F44	; 0x800f44 <uxPendedTicks>
    3100:	cc 23       	and	r28, r28
    3102:	49 f0       	breq	.+18     	; 0x3116 <xTaskResumeAll+0xb2>
    3104:	d1 e0       	ldi	r29, 0x01	; 1
    3106:	06 df       	rcall	.-500    	; 0x2f14 <xTaskIncrementTick>
    3108:	81 11       	cpse	r24, r1
    310a:	d0 93 43 0f 	sts	0x0F43, r29	; 0x800f43 <xYieldPending>
    310e:	c1 50       	subi	r28, 0x01	; 1
    3110:	d1 f7       	brne	.-12     	; 0x3106 <xTaskResumeAll+0xa2>
    3112:	10 92 44 0f 	sts	0x0F44, r1	; 0x800f44 <uxPendedTicks>
    3116:	80 91 43 0f 	lds	r24, 0x0F43	; 0x800f43 <xYieldPending>
    311a:	88 23       	and	r24, r24
    311c:	09 f4       	brne	.+2      	; 0x3120 <xTaskResumeAll+0xbc>
    311e:	b4 cf       	rjmp	.-152    	; 0x3088 <xTaskResumeAll+0x24>
    3120:	5d da       	rcall	.-2886   	; 0x25dc <vPortYield>
    3122:	81 e0       	ldi	r24, 0x01	; 1
    3124:	0f 90       	pop	r0
    3126:	0f be       	out	0x3f, r0	; 63
    3128:	df 91       	pop	r29
    312a:	cf 91       	pop	r28
    312c:	1f 91       	pop	r17
    312e:	0f 91       	pop	r16
    3130:	ff 90       	pop	r15
    3132:	ef 90       	pop	r14
    3134:	08 95       	ret

00003136 <vTaskDelay>:
    3136:	cf 93       	push	r28
    3138:	df 93       	push	r29
    313a:	ec 01       	movw	r28, r24
    313c:	89 2b       	or	r24, r25
    313e:	11 f4       	brne	.+4      	; 0x3144 <vTaskDelay+0xe>
    3140:	4d da       	rcall	.-2918   	; 0x25dc <vPortYield>
    3142:	07 c0       	rjmp	.+14     	; 0x3152 <vTaskDelay+0x1c>
    3144:	e1 de       	rcall	.-574    	; 0x2f08 <vTaskSuspendAll>
    3146:	60 e0       	ldi	r22, 0x00	; 0
    3148:	ce 01       	movw	r24, r28
    314a:	6c dd       	rcall	.-1320   	; 0x2c24 <prvAddCurrentTaskToDelayedList>
    314c:	8b df       	rcall	.-234    	; 0x3064 <xTaskResumeAll>
    314e:	88 23       	and	r24, r24
    3150:	b9 f3       	breq	.-18     	; 0x3140 <vTaskDelay+0xa>
    3152:	df 91       	pop	r29
    3154:	cf 91       	pop	r28
    3156:	08 95       	ret

00003158 <prvIdleTask>:
    3158:	80 91 53 0f 	lds	r24, 0x0F53	; 0x800f53 <uxDeletedTasksWaitingCleanUp>
    315c:	88 23       	and	r24, r24
    315e:	21 f1       	breq	.+72     	; 0x31a8 <prvIdleTask+0x50>
    3160:	d3 de       	rcall	.-602    	; 0x2f08 <vTaskSuspendAll>
    3162:	c0 91 54 0f 	lds	r28, 0x0F54	; 0x800f54 <xTasksWaitingTermination>
    3166:	7e df       	rcall	.-260    	; 0x3064 <xTaskResumeAll>
    3168:	cc 23       	and	r28, r28
    316a:	b1 f3       	breq	.-20     	; 0x3158 <prvIdleTask>
    316c:	0f b6       	in	r0, 0x3f	; 63
    316e:	f8 94       	cli
    3170:	0f 92       	push	r0
    3172:	e0 91 59 0f 	lds	r30, 0x0F59	; 0x800f59 <xTasksWaitingTermination+0x5>
    3176:	f0 91 5a 0f 	lds	r31, 0x0F5A	; 0x800f5a <xTasksWaitingTermination+0x6>
    317a:	c6 81       	ldd	r28, Z+6	; 0x06
    317c:	d7 81       	ldd	r29, Z+7	; 0x07
    317e:	ce 01       	movw	r24, r28
    3180:	02 96       	adiw	r24, 0x02	; 2
    3182:	68 d9       	rcall	.-3376   	; 0x2454 <uxListRemove>
    3184:	80 91 49 0f 	lds	r24, 0x0F49	; 0x800f49 <uxCurrentNumberOfTasks>
    3188:	81 50       	subi	r24, 0x01	; 1
    318a:	80 93 49 0f 	sts	0x0F49, r24	; 0x800f49 <uxCurrentNumberOfTasks>
    318e:	80 91 53 0f 	lds	r24, 0x0F53	; 0x800f53 <uxDeletedTasksWaitingCleanUp>
    3192:	81 50       	subi	r24, 0x01	; 1
    3194:	80 93 53 0f 	sts	0x0F53, r24	; 0x800f53 <uxDeletedTasksWaitingCleanUp>
    3198:	0f 90       	pop	r0
    319a:	0f be       	out	0x3f, r0	; 63
    319c:	8f 89       	ldd	r24, Y+23	; 0x17
    319e:	98 8d       	ldd	r25, Y+24	; 0x18
    31a0:	ed d8       	rcall	.-3622   	; 0x237c <vPortFree>
    31a2:	ce 01       	movw	r24, r28
    31a4:	eb d8       	rcall	.-3626   	; 0x237c <vPortFree>
    31a6:	d8 cf       	rjmp	.-80     	; 0x3158 <prvIdleTask>
    31a8:	80 91 7c 0f 	lds	r24, 0x0F7C	; 0x800f7c <pxReadyTasksLists>
    31ac:	82 30       	cpi	r24, 0x02	; 2
    31ae:	a0 f2       	brcs	.-88     	; 0x3158 <prvIdleTask>
    31b0:	15 da       	rcall	.-3030   	; 0x25dc <vPortYield>
    31b2:	d2 cf       	rjmp	.-92     	; 0x3158 <prvIdleTask>

000031b4 <vTaskSwitchContext>:
    31b4:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    31b8:	88 23       	and	r24, r24
    31ba:	21 f0       	breq	.+8      	; 0x31c4 <vTaskSwitchContext+0x10>
    31bc:	81 e0       	ldi	r24, 0x01	; 1
    31be:	80 93 43 0f 	sts	0x0F43, r24	; 0x800f43 <xYieldPending>
    31c2:	08 95       	ret
    31c4:	10 92 43 0f 	sts	0x0F43, r1	; 0x800f43 <xYieldPending>
    31c8:	80 91 46 0f 	lds	r24, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    31cc:	69 e0       	ldi	r22, 0x09	; 9
    31ce:	48 2f       	mov	r20, r24
    31d0:	50 e0       	ldi	r21, 0x00	; 0
    31d2:	64 9f       	mul	r22, r20
    31d4:	90 01       	movw	r18, r0
    31d6:	65 9f       	mul	r22, r21
    31d8:	30 0d       	add	r19, r0
    31da:	11 24       	eor	r1, r1
    31dc:	f9 01       	movw	r30, r18
    31de:	e4 58       	subi	r30, 0x84	; 132
    31e0:	f0 4f       	sbci	r31, 0xF0	; 240
    31e2:	90 81       	ld	r25, Z
    31e4:	91 11       	cpse	r25, r1
    31e6:	02 c0       	rjmp	.+4      	; 0x31ec <vTaskSwitchContext+0x38>
    31e8:	81 50       	subi	r24, 0x01	; 1
    31ea:	f1 cf       	rjmp	.-30     	; 0x31ce <vTaskSwitchContext+0x1a>
    31ec:	a1 81       	ldd	r26, Z+1	; 0x01
    31ee:	b2 81       	ldd	r27, Z+2	; 0x02
    31f0:	12 96       	adiw	r26, 0x02	; 2
    31f2:	0d 90       	ld	r0, X+
    31f4:	bc 91       	ld	r27, X
    31f6:	a0 2d       	mov	r26, r0
    31f8:	b2 83       	std	Z+2, r27	; 0x02
    31fa:	a1 83       	std	Z+1, r26	; 0x01
    31fc:	21 58       	subi	r18, 0x81	; 129
    31fe:	30 4f       	sbci	r19, 0xF0	; 240
    3200:	a2 17       	cp	r26, r18
    3202:	b3 07       	cpc	r27, r19
    3204:	31 f4       	brne	.+12     	; 0x3212 <vTaskSwitchContext+0x5e>
    3206:	12 96       	adiw	r26, 0x02	; 2
    3208:	2d 91       	ld	r18, X+
    320a:	3c 91       	ld	r19, X
    320c:	13 97       	sbiw	r26, 0x03	; 3
    320e:	32 83       	std	Z+2, r19	; 0x02
    3210:	21 83       	std	Z+1, r18	; 0x01
    3212:	99 e0       	ldi	r25, 0x09	; 9
    3214:	94 9f       	mul	r25, r20
    3216:	f0 01       	movw	r30, r0
    3218:	95 9f       	mul	r25, r21
    321a:	f0 0d       	add	r31, r0
    321c:	11 24       	eor	r1, r1
    321e:	e4 58       	subi	r30, 0x84	; 132
    3220:	f0 4f       	sbci	r31, 0xF0	; 240
    3222:	01 80       	ldd	r0, Z+1	; 0x01
    3224:	f2 81       	ldd	r31, Z+2	; 0x02
    3226:	e0 2d       	mov	r30, r0
    3228:	26 81       	ldd	r18, Z+6	; 0x06
    322a:	37 81       	ldd	r19, Z+7	; 0x07
    322c:	30 93 a1 0f 	sts	0x0FA1, r19	; 0x800fa1 <pxCurrentTCB+0x1>
    3230:	20 93 a0 0f 	sts	0x0FA0, r18	; 0x800fa0 <pxCurrentTCB>
    3234:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    3238:	08 95       	ret

0000323a <vTaskPlaceOnEventList>:
    323a:	cf 93       	push	r28
    323c:	df 93       	push	r29
    323e:	eb 01       	movw	r28, r22
    3240:	60 91 a0 0f 	lds	r22, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3244:	70 91 a1 0f 	lds	r23, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    3248:	64 5f       	subi	r22, 0xF4	; 244
    324a:	7f 4f       	sbci	r23, 0xFF	; 255
    324c:	cb d8       	rcall	.-3690   	; 0x23e4 <vListInsert>
    324e:	61 e0       	ldi	r22, 0x01	; 1
    3250:	ce 01       	movw	r24, r28
    3252:	df 91       	pop	r29
    3254:	cf 91       	pop	r28
    3256:	e6 cc       	rjmp	.-1588   	; 0x2c24 <prvAddCurrentTaskToDelayedList>

00003258 <xTaskRemoveFromEventList>:
    3258:	0f 93       	push	r16
    325a:	1f 93       	push	r17
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
    3260:	dc 01       	movw	r26, r24
    3262:	15 96       	adiw	r26, 0x05	; 5
    3264:	ed 91       	ld	r30, X+
    3266:	fc 91       	ld	r31, X
    3268:	16 97       	sbiw	r26, 0x06	; 6
    326a:	c6 81       	ldd	r28, Z+6	; 0x06
    326c:	d7 81       	ldd	r29, Z+7	; 0x07
    326e:	8e 01       	movw	r16, r28
    3270:	04 5f       	subi	r16, 0xF4	; 244
    3272:	1f 4f       	sbci	r17, 0xFF	; 255
    3274:	c8 01       	movw	r24, r16
    3276:	ee d8       	rcall	.-3620   	; 0x2454 <uxListRemove>
    3278:	80 91 3c 0f 	lds	r24, 0x0F3C	; 0x800f3c <uxSchedulerSuspended>
    327c:	81 11       	cpse	r24, r1
    327e:	13 c0       	rjmp	.+38     	; 0x32a6 <xTaskRemoveFromEventList+0x4e>
    3280:	0a 50       	subi	r16, 0x0A	; 10
    3282:	11 09       	sbc	r17, r1
    3284:	c8 01       	movw	r24, r16
    3286:	e6 d8       	rcall	.-3636   	; 0x2454 <uxListRemove>
    3288:	8e 89       	ldd	r24, Y+22	; 0x16
    328a:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    328e:	98 17       	cp	r25, r24
    3290:	10 f4       	brcc	.+4      	; 0x3296 <xTaskRemoveFromEventList+0x3e>
    3292:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    3296:	b9 e0       	ldi	r27, 0x09	; 9
    3298:	8b 9f       	mul	r24, r27
    329a:	c0 01       	movw	r24, r0
    329c:	11 24       	eor	r1, r1
    329e:	b8 01       	movw	r22, r16
    32a0:	84 58       	subi	r24, 0x84	; 132
    32a2:	90 4f       	sbci	r25, 0xF0	; 240
    32a4:	03 c0       	rjmp	.+6      	; 0x32ac <xTaskRemoveFromEventList+0x54>
    32a6:	b8 01       	movw	r22, r16
    32a8:	8d e5       	ldi	r24, 0x5D	; 93
    32aa:	9f e0       	ldi	r25, 0x0F	; 15
    32ac:	7a d8       	rcall	.-3852   	; 0x23a2 <vListInsertEnd>
    32ae:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    32b2:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    32b6:	9e 89       	ldd	r25, Y+22	; 0x16
    32b8:	86 89       	ldd	r24, Z+22	; 0x16
    32ba:	89 17       	cp	r24, r25
    32bc:	20 f4       	brcc	.+8      	; 0x32c6 <xTaskRemoveFromEventList+0x6e>
    32be:	81 e0       	ldi	r24, 0x01	; 1
    32c0:	80 93 43 0f 	sts	0x0F43, r24	; 0x800f43 <xYieldPending>
    32c4:	01 c0       	rjmp	.+2      	; 0x32c8 <xTaskRemoveFromEventList+0x70>
    32c6:	80 e0       	ldi	r24, 0x00	; 0
    32c8:	df 91       	pop	r29
    32ca:	cf 91       	pop	r28
    32cc:	1f 91       	pop	r17
    32ce:	0f 91       	pop	r16
    32d0:	08 95       	ret

000032d2 <vTaskSetTimeOutState>:
    32d2:	20 91 42 0f 	lds	r18, 0x0F42	; 0x800f42 <xNumOfOverflows>
    32d6:	fc 01       	movw	r30, r24
    32d8:	20 83       	st	Z, r18
    32da:	20 91 47 0f 	lds	r18, 0x0F47	; 0x800f47 <xTickCount>
    32de:	30 91 48 0f 	lds	r19, 0x0F48	; 0x800f48 <xTickCount+0x1>
    32e2:	32 83       	std	Z+2, r19	; 0x02
    32e4:	21 83       	std	Z+1, r18	; 0x01
    32e6:	08 95       	ret

000032e8 <xTaskCheckForTimeOut>:
    32e8:	cf 93       	push	r28
    32ea:	df 93       	push	r29
    32ec:	0f b6       	in	r0, 0x3f	; 63
    32ee:	f8 94       	cli
    32f0:	0f 92       	push	r0
    32f2:	e0 91 47 0f 	lds	r30, 0x0F47	; 0x800f47 <xTickCount>
    32f6:	f0 91 48 0f 	lds	r31, 0x0F48	; 0x800f48 <xTickCount+0x1>
    32fa:	db 01       	movw	r26, r22
    32fc:	2d 91       	ld	r18, X+
    32fe:	3c 91       	ld	r19, X
    3300:	2f 3f       	cpi	r18, 0xFF	; 255
    3302:	bf ef       	ldi	r27, 0xFF	; 255
    3304:	3b 07       	cpc	r19, r27
    3306:	c9 f0       	breq	.+50     	; 0x333a <xTaskCheckForTimeOut+0x52>
    3308:	a0 91 42 0f 	lds	r26, 0x0F42	; 0x800f42 <xNumOfOverflows>
    330c:	ec 01       	movw	r28, r24
    330e:	b8 81       	ld	r27, Y
    3310:	49 81       	ldd	r20, Y+1	; 0x01
    3312:	5a 81       	ldd	r21, Y+2	; 0x02
    3314:	ba 17       	cp	r27, r26
    3316:	19 f0       	breq	.+6      	; 0x331e <xTaskCheckForTimeOut+0x36>
    3318:	e4 17       	cp	r30, r20
    331a:	f5 07       	cpc	r31, r21
    331c:	80 f4       	brcc	.+32     	; 0x333e <xTaskCheckForTimeOut+0x56>
    331e:	df 01       	movw	r26, r30
    3320:	a4 1b       	sub	r26, r20
    3322:	b5 0b       	sbc	r27, r21
    3324:	a2 17       	cp	r26, r18
    3326:	b3 07       	cpc	r27, r19
    3328:	50 f4       	brcc	.+20     	; 0x333e <xTaskCheckForTimeOut+0x56>
    332a:	db 01       	movw	r26, r22
    332c:	4e 1b       	sub	r20, r30
    332e:	5f 0b       	sbc	r21, r31
    3330:	24 0f       	add	r18, r20
    3332:	35 1f       	adc	r19, r21
    3334:	2d 93       	st	X+, r18
    3336:	3c 93       	st	X, r19
    3338:	cc df       	rcall	.-104    	; 0x32d2 <vTaskSetTimeOutState>
    333a:	80 e0       	ldi	r24, 0x00	; 0
    333c:	01 c0       	rjmp	.+2      	; 0x3340 <xTaskCheckForTimeOut+0x58>
    333e:	81 e0       	ldi	r24, 0x01	; 1
    3340:	0f 90       	pop	r0
    3342:	0f be       	out	0x3f, r0	; 63
    3344:	df 91       	pop	r29
    3346:	cf 91       	pop	r28
    3348:	08 95       	ret

0000334a <vTaskMissedYield>:
    334a:	81 e0       	ldi	r24, 0x01	; 1
    334c:	80 93 43 0f 	sts	0x0F43, r24	; 0x800f43 <xYieldPending>
    3350:	08 95       	ret

00003352 <vTaskPriorityInherit>:
    3352:	0f 93       	push	r16
    3354:	1f 93       	push	r17
    3356:	cf 93       	push	r28
    3358:	df 93       	push	r29
    335a:	fc 01       	movw	r30, r24
    335c:	89 2b       	or	r24, r25
    335e:	09 f4       	brne	.+2      	; 0x3362 <vTaskPriorityInherit+0x10>
    3360:	4b c0       	rjmp	.+150    	; 0x33f8 <vTaskPriorityInherit+0xa6>
    3362:	86 89       	ldd	r24, Z+22	; 0x16
    3364:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3368:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    336c:	56 96       	adiw	r26, 0x16	; 22
    336e:	9c 91       	ld	r25, X
    3370:	89 17       	cp	r24, r25
    3372:	08 f0       	brcs	.+2      	; 0x3376 <vTaskPriorityInherit+0x24>
    3374:	41 c0       	rjmp	.+130    	; 0x33f8 <vTaskPriorityInherit+0xa6>
    3376:	24 85       	ldd	r18, Z+12	; 0x0c
    3378:	35 85       	ldd	r19, Z+13	; 0x0d
    337a:	37 fd       	sbrc	r19, 7
    337c:	0c c0       	rjmp	.+24     	; 0x3396 <vTaskPriorityInherit+0x44>
    337e:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3382:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    3386:	56 96       	adiw	r26, 0x16	; 22
    3388:	9c 91       	ld	r25, X
    338a:	24 e0       	ldi	r18, 0x04	; 4
    338c:	30 e0       	ldi	r19, 0x00	; 0
    338e:	29 1b       	sub	r18, r25
    3390:	31 09       	sbc	r19, r1
    3392:	35 87       	std	Z+13, r19	; 0x0d
    3394:	24 87       	std	Z+12, r18	; 0x0c
    3396:	29 e0       	ldi	r18, 0x09	; 9
    3398:	82 9f       	mul	r24, r18
    339a:	c0 01       	movw	r24, r0
    339c:	11 24       	eor	r1, r1
    339e:	84 58       	subi	r24, 0x84	; 132
    33a0:	90 4f       	sbci	r25, 0xF0	; 240
    33a2:	22 85       	ldd	r18, Z+10	; 0x0a
    33a4:	33 85       	ldd	r19, Z+11	; 0x0b
    33a6:	28 17       	cp	r18, r24
    33a8:	39 07       	cpc	r19, r25
    33aa:	f9 f4       	brne	.+62     	; 0x33ea <vTaskPriorityInherit+0x98>
    33ac:	8f 01       	movw	r16, r30
    33ae:	ef 01       	movw	r28, r30
    33b0:	22 96       	adiw	r28, 0x02	; 2
    33b2:	ce 01       	movw	r24, r28
    33b4:	4f d8       	rcall	.-3938   	; 0x2454 <uxListRemove>
    33b6:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    33ba:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    33be:	86 89       	ldd	r24, Z+22	; 0x16
    33c0:	f8 01       	movw	r30, r16
    33c2:	86 8b       	std	Z+22, r24	; 0x16
    33c4:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    33c8:	98 17       	cp	r25, r24
    33ca:	10 f4       	brcc	.+4      	; 0x33d0 <vTaskPriorityInherit+0x7e>
    33cc:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    33d0:	f9 e0       	ldi	r31, 0x09	; 9
    33d2:	8f 9f       	mul	r24, r31
    33d4:	c0 01       	movw	r24, r0
    33d6:	11 24       	eor	r1, r1
    33d8:	be 01       	movw	r22, r28
    33da:	84 58       	subi	r24, 0x84	; 132
    33dc:	90 4f       	sbci	r25, 0xF0	; 240
    33de:	df 91       	pop	r29
    33e0:	cf 91       	pop	r28
    33e2:	1f 91       	pop	r17
    33e4:	0f 91       	pop	r16
    33e6:	0c 94 d1 11 	jmp	0x23a2	; 0x23a2 <vListInsertEnd>
    33ea:	a0 91 a0 0f 	lds	r26, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    33ee:	b0 91 a1 0f 	lds	r27, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    33f2:	56 96       	adiw	r26, 0x16	; 22
    33f4:	8c 91       	ld	r24, X
    33f6:	86 8b       	std	Z+22, r24	; 0x16
    33f8:	df 91       	pop	r29
    33fa:	cf 91       	pop	r28
    33fc:	1f 91       	pop	r17
    33fe:	0f 91       	pop	r16
    3400:	08 95       	ret

00003402 <xTaskPriorityDisinherit>:
    3402:	0f 93       	push	r16
    3404:	1f 93       	push	r17
    3406:	cf 93       	push	r28
    3408:	df 93       	push	r29
    340a:	fc 01       	movw	r30, r24
    340c:	89 2b       	or	r24, r25
    340e:	11 f4       	brne	.+4      	; 0x3414 <xTaskPriorityDisinherit+0x12>
    3410:	80 e0       	ldi	r24, 0x00	; 0
    3412:	2b c0       	rjmp	.+86     	; 0x346a <xTaskPriorityDisinherit+0x68>
    3414:	82 a1       	ldd	r24, Z+34	; 0x22
    3416:	81 50       	subi	r24, 0x01	; 1
    3418:	82 a3       	std	Z+34, r24	; 0x22
    341a:	26 89       	ldd	r18, Z+22	; 0x16
    341c:	91 a1       	ldd	r25, Z+33	; 0x21
    341e:	29 17       	cp	r18, r25
    3420:	b9 f3       	breq	.-18     	; 0x3410 <xTaskPriorityDisinherit+0xe>
    3422:	81 11       	cpse	r24, r1
    3424:	f5 cf       	rjmp	.-22     	; 0x3410 <xTaskPriorityDisinherit+0xe>
    3426:	ef 01       	movw	r28, r30
    3428:	8f 01       	movw	r16, r30
    342a:	0e 5f       	subi	r16, 0xFE	; 254
    342c:	1f 4f       	sbci	r17, 0xFF	; 255
    342e:	c8 01       	movw	r24, r16
    3430:	11 d8       	rcall	.-4062   	; 0x2454 <uxListRemove>
    3432:	89 a1       	ldd	r24, Y+33	; 0x21
    3434:	8e 8b       	std	Y+22, r24	; 0x16
    3436:	48 2f       	mov	r20, r24
    3438:	50 e0       	ldi	r21, 0x00	; 0
    343a:	24 e0       	ldi	r18, 0x04	; 4
    343c:	30 e0       	ldi	r19, 0x00	; 0
    343e:	24 1b       	sub	r18, r20
    3440:	35 0b       	sbc	r19, r21
    3442:	3d 87       	std	Y+13, r19	; 0x0d
    3444:	2c 87       	std	Y+12, r18	; 0x0c
    3446:	90 91 46 0f 	lds	r25, 0x0F46	; 0x800f46 <uxTopReadyPriority>
    344a:	98 17       	cp	r25, r24
    344c:	10 f4       	brcc	.+4      	; 0x3452 <xTaskPriorityDisinherit+0x50>
    344e:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTopReadyPriority>
    3452:	29 e0       	ldi	r18, 0x09	; 9
    3454:	24 9f       	mul	r18, r20
    3456:	c0 01       	movw	r24, r0
    3458:	25 9f       	mul	r18, r21
    345a:	90 0d       	add	r25, r0
    345c:	11 24       	eor	r1, r1
    345e:	b8 01       	movw	r22, r16
    3460:	84 58       	subi	r24, 0x84	; 132
    3462:	90 4f       	sbci	r25, 0xF0	; 240
    3464:	0e 94 d1 11 	call	0x23a2	; 0x23a2 <vListInsertEnd>
    3468:	81 e0       	ldi	r24, 0x01	; 1
    346a:	df 91       	pop	r29
    346c:	cf 91       	pop	r28
    346e:	1f 91       	pop	r17
    3470:	0f 91       	pop	r16
    3472:	08 95       	ret

00003474 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3474:	80 91 a0 0f 	lds	r24, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3478:	90 91 a1 0f 	lds	r25, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    347c:	89 2b       	or	r24, r25
    347e:	39 f0       	breq	.+14     	; 0x348e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    3480:	e0 91 a0 0f 	lds	r30, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3484:	f0 91 a1 0f 	lds	r31, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
    3488:	82 a1       	ldd	r24, Z+34	; 0x22
    348a:	8f 5f       	subi	r24, 0xFF	; 255
    348c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    348e:	80 91 a0 0f 	lds	r24, 0x0FA0	; 0x800fa0 <pxCurrentTCB>
    3492:	90 91 a1 0f 	lds	r25, 0x0FA1	; 0x800fa1 <pxCurrentTCB+0x1>
	}
    3496:	08 95       	ret

00003498 <__subsf3>:
    3498:	50 58       	subi	r21, 0x80	; 128

0000349a <__addsf3>:
    349a:	bb 27       	eor	r27, r27
    349c:	aa 27       	eor	r26, r26
    349e:	0e d0       	rcall	.+28     	; 0x34bc <__addsf3x>
    34a0:	71 c1       	rjmp	.+738    	; 0x3784 <__fp_round>
    34a2:	62 d1       	rcall	.+708    	; 0x3768 <__fp_pscA>
    34a4:	30 f0       	brcs	.+12     	; 0x34b2 <__addsf3+0x18>
    34a6:	67 d1       	rcall	.+718    	; 0x3776 <__fp_pscB>
    34a8:	20 f0       	brcs	.+8      	; 0x34b2 <__addsf3+0x18>
    34aa:	31 f4       	brne	.+12     	; 0x34b8 <__addsf3+0x1e>
    34ac:	9f 3f       	cpi	r25, 0xFF	; 255
    34ae:	11 f4       	brne	.+4      	; 0x34b4 <__addsf3+0x1a>
    34b0:	1e f4       	brtc	.+6      	; 0x34b8 <__addsf3+0x1e>
    34b2:	57 c1       	rjmp	.+686    	; 0x3762 <__fp_nan>
    34b4:	0e f4       	brtc	.+2      	; 0x34b8 <__addsf3+0x1e>
    34b6:	e0 95       	com	r30
    34b8:	e7 fb       	bst	r30, 7
    34ba:	4d c1       	rjmp	.+666    	; 0x3756 <__fp_inf>

000034bc <__addsf3x>:
    34bc:	e9 2f       	mov	r30, r25
    34be:	73 d1       	rcall	.+742    	; 0x37a6 <__fp_split3>
    34c0:	80 f3       	brcs	.-32     	; 0x34a2 <__addsf3+0x8>
    34c2:	ba 17       	cp	r27, r26
    34c4:	62 07       	cpc	r22, r18
    34c6:	73 07       	cpc	r23, r19
    34c8:	84 07       	cpc	r24, r20
    34ca:	95 07       	cpc	r25, r21
    34cc:	18 f0       	brcs	.+6      	; 0x34d4 <__addsf3x+0x18>
    34ce:	71 f4       	brne	.+28     	; 0x34ec <__addsf3x+0x30>
    34d0:	9e f5       	brtc	.+102    	; 0x3538 <__addsf3x+0x7c>
    34d2:	8b c1       	rjmp	.+790    	; 0x37ea <__fp_zero>
    34d4:	0e f4       	brtc	.+2      	; 0x34d8 <__addsf3x+0x1c>
    34d6:	e0 95       	com	r30
    34d8:	0b 2e       	mov	r0, r27
    34da:	ba 2f       	mov	r27, r26
    34dc:	a0 2d       	mov	r26, r0
    34de:	0b 01       	movw	r0, r22
    34e0:	b9 01       	movw	r22, r18
    34e2:	90 01       	movw	r18, r0
    34e4:	0c 01       	movw	r0, r24
    34e6:	ca 01       	movw	r24, r20
    34e8:	a0 01       	movw	r20, r0
    34ea:	11 24       	eor	r1, r1
    34ec:	ff 27       	eor	r31, r31
    34ee:	59 1b       	sub	r21, r25
    34f0:	99 f0       	breq	.+38     	; 0x3518 <__addsf3x+0x5c>
    34f2:	59 3f       	cpi	r21, 0xF9	; 249
    34f4:	50 f4       	brcc	.+20     	; 0x350a <__addsf3x+0x4e>
    34f6:	50 3e       	cpi	r21, 0xE0	; 224
    34f8:	68 f1       	brcs	.+90     	; 0x3554 <__addsf3x+0x98>
    34fa:	1a 16       	cp	r1, r26
    34fc:	f0 40       	sbci	r31, 0x00	; 0
    34fe:	a2 2f       	mov	r26, r18
    3500:	23 2f       	mov	r18, r19
    3502:	34 2f       	mov	r19, r20
    3504:	44 27       	eor	r20, r20
    3506:	58 5f       	subi	r21, 0xF8	; 248
    3508:	f3 cf       	rjmp	.-26     	; 0x34f0 <__addsf3x+0x34>
    350a:	46 95       	lsr	r20
    350c:	37 95       	ror	r19
    350e:	27 95       	ror	r18
    3510:	a7 95       	ror	r26
    3512:	f0 40       	sbci	r31, 0x00	; 0
    3514:	53 95       	inc	r21
    3516:	c9 f7       	brne	.-14     	; 0x350a <__addsf3x+0x4e>
    3518:	7e f4       	brtc	.+30     	; 0x3538 <__addsf3x+0x7c>
    351a:	1f 16       	cp	r1, r31
    351c:	ba 0b       	sbc	r27, r26
    351e:	62 0b       	sbc	r22, r18
    3520:	73 0b       	sbc	r23, r19
    3522:	84 0b       	sbc	r24, r20
    3524:	ba f0       	brmi	.+46     	; 0x3554 <__addsf3x+0x98>
    3526:	91 50       	subi	r25, 0x01	; 1
    3528:	a1 f0       	breq	.+40     	; 0x3552 <__addsf3x+0x96>
    352a:	ff 0f       	add	r31, r31
    352c:	bb 1f       	adc	r27, r27
    352e:	66 1f       	adc	r22, r22
    3530:	77 1f       	adc	r23, r23
    3532:	88 1f       	adc	r24, r24
    3534:	c2 f7       	brpl	.-16     	; 0x3526 <__addsf3x+0x6a>
    3536:	0e c0       	rjmp	.+28     	; 0x3554 <__addsf3x+0x98>
    3538:	ba 0f       	add	r27, r26
    353a:	62 1f       	adc	r22, r18
    353c:	73 1f       	adc	r23, r19
    353e:	84 1f       	adc	r24, r20
    3540:	48 f4       	brcc	.+18     	; 0x3554 <__addsf3x+0x98>
    3542:	87 95       	ror	r24
    3544:	77 95       	ror	r23
    3546:	67 95       	ror	r22
    3548:	b7 95       	ror	r27
    354a:	f7 95       	ror	r31
    354c:	9e 3f       	cpi	r25, 0xFE	; 254
    354e:	08 f0       	brcs	.+2      	; 0x3552 <__addsf3x+0x96>
    3550:	b3 cf       	rjmp	.-154    	; 0x34b8 <__addsf3+0x1e>
    3552:	93 95       	inc	r25
    3554:	88 0f       	add	r24, r24
    3556:	08 f0       	brcs	.+2      	; 0x355a <__addsf3x+0x9e>
    3558:	99 27       	eor	r25, r25
    355a:	ee 0f       	add	r30, r30
    355c:	97 95       	ror	r25
    355e:	87 95       	ror	r24
    3560:	08 95       	ret

00003562 <__divsf3>:
    3562:	0c d0       	rcall	.+24     	; 0x357c <__divsf3x>
    3564:	0f c1       	rjmp	.+542    	; 0x3784 <__fp_round>
    3566:	07 d1       	rcall	.+526    	; 0x3776 <__fp_pscB>
    3568:	40 f0       	brcs	.+16     	; 0x357a <__divsf3+0x18>
    356a:	fe d0       	rcall	.+508    	; 0x3768 <__fp_pscA>
    356c:	30 f0       	brcs	.+12     	; 0x357a <__divsf3+0x18>
    356e:	21 f4       	brne	.+8      	; 0x3578 <__divsf3+0x16>
    3570:	5f 3f       	cpi	r21, 0xFF	; 255
    3572:	19 f0       	breq	.+6      	; 0x357a <__divsf3+0x18>
    3574:	f0 c0       	rjmp	.+480    	; 0x3756 <__fp_inf>
    3576:	51 11       	cpse	r21, r1
    3578:	39 c1       	rjmp	.+626    	; 0x37ec <__fp_szero>
    357a:	f3 c0       	rjmp	.+486    	; 0x3762 <__fp_nan>

0000357c <__divsf3x>:
    357c:	14 d1       	rcall	.+552    	; 0x37a6 <__fp_split3>
    357e:	98 f3       	brcs	.-26     	; 0x3566 <__divsf3+0x4>

00003580 <__divsf3_pse>:
    3580:	99 23       	and	r25, r25
    3582:	c9 f3       	breq	.-14     	; 0x3576 <__divsf3+0x14>
    3584:	55 23       	and	r21, r21
    3586:	b1 f3       	breq	.-20     	; 0x3574 <__divsf3+0x12>
    3588:	95 1b       	sub	r25, r21
    358a:	55 0b       	sbc	r21, r21
    358c:	bb 27       	eor	r27, r27
    358e:	aa 27       	eor	r26, r26
    3590:	62 17       	cp	r22, r18
    3592:	73 07       	cpc	r23, r19
    3594:	84 07       	cpc	r24, r20
    3596:	38 f0       	brcs	.+14     	; 0x35a6 <__divsf3_pse+0x26>
    3598:	9f 5f       	subi	r25, 0xFF	; 255
    359a:	5f 4f       	sbci	r21, 0xFF	; 255
    359c:	22 0f       	add	r18, r18
    359e:	33 1f       	adc	r19, r19
    35a0:	44 1f       	adc	r20, r20
    35a2:	aa 1f       	adc	r26, r26
    35a4:	a9 f3       	breq	.-22     	; 0x3590 <__divsf3_pse+0x10>
    35a6:	33 d0       	rcall	.+102    	; 0x360e <__divsf3_pse+0x8e>
    35a8:	0e 2e       	mov	r0, r30
    35aa:	3a f0       	brmi	.+14     	; 0x35ba <__divsf3_pse+0x3a>
    35ac:	e0 e8       	ldi	r30, 0x80	; 128
    35ae:	30 d0       	rcall	.+96     	; 0x3610 <__divsf3_pse+0x90>
    35b0:	91 50       	subi	r25, 0x01	; 1
    35b2:	50 40       	sbci	r21, 0x00	; 0
    35b4:	e6 95       	lsr	r30
    35b6:	00 1c       	adc	r0, r0
    35b8:	ca f7       	brpl	.-14     	; 0x35ac <__divsf3_pse+0x2c>
    35ba:	29 d0       	rcall	.+82     	; 0x360e <__divsf3_pse+0x8e>
    35bc:	fe 2f       	mov	r31, r30
    35be:	27 d0       	rcall	.+78     	; 0x360e <__divsf3_pse+0x8e>
    35c0:	66 0f       	add	r22, r22
    35c2:	77 1f       	adc	r23, r23
    35c4:	88 1f       	adc	r24, r24
    35c6:	bb 1f       	adc	r27, r27
    35c8:	26 17       	cp	r18, r22
    35ca:	37 07       	cpc	r19, r23
    35cc:	48 07       	cpc	r20, r24
    35ce:	ab 07       	cpc	r26, r27
    35d0:	b0 e8       	ldi	r27, 0x80	; 128
    35d2:	09 f0       	breq	.+2      	; 0x35d6 <__divsf3_pse+0x56>
    35d4:	bb 0b       	sbc	r27, r27
    35d6:	80 2d       	mov	r24, r0
    35d8:	bf 01       	movw	r22, r30
    35da:	ff 27       	eor	r31, r31
    35dc:	93 58       	subi	r25, 0x83	; 131
    35de:	5f 4f       	sbci	r21, 0xFF	; 255
    35e0:	2a f0       	brmi	.+10     	; 0x35ec <__divsf3_pse+0x6c>
    35e2:	9e 3f       	cpi	r25, 0xFE	; 254
    35e4:	51 05       	cpc	r21, r1
    35e6:	68 f0       	brcs	.+26     	; 0x3602 <__divsf3_pse+0x82>
    35e8:	b6 c0       	rjmp	.+364    	; 0x3756 <__fp_inf>
    35ea:	00 c1       	rjmp	.+512    	; 0x37ec <__fp_szero>
    35ec:	5f 3f       	cpi	r21, 0xFF	; 255
    35ee:	ec f3       	brlt	.-6      	; 0x35ea <__divsf3_pse+0x6a>
    35f0:	98 3e       	cpi	r25, 0xE8	; 232
    35f2:	dc f3       	brlt	.-10     	; 0x35ea <__divsf3_pse+0x6a>
    35f4:	86 95       	lsr	r24
    35f6:	77 95       	ror	r23
    35f8:	67 95       	ror	r22
    35fa:	b7 95       	ror	r27
    35fc:	f7 95       	ror	r31
    35fe:	9f 5f       	subi	r25, 0xFF	; 255
    3600:	c9 f7       	brne	.-14     	; 0x35f4 <__divsf3_pse+0x74>
    3602:	88 0f       	add	r24, r24
    3604:	91 1d       	adc	r25, r1
    3606:	96 95       	lsr	r25
    3608:	87 95       	ror	r24
    360a:	97 f9       	bld	r25, 7
    360c:	08 95       	ret
    360e:	e1 e0       	ldi	r30, 0x01	; 1
    3610:	66 0f       	add	r22, r22
    3612:	77 1f       	adc	r23, r23
    3614:	88 1f       	adc	r24, r24
    3616:	bb 1f       	adc	r27, r27
    3618:	62 17       	cp	r22, r18
    361a:	73 07       	cpc	r23, r19
    361c:	84 07       	cpc	r24, r20
    361e:	ba 07       	cpc	r27, r26
    3620:	20 f0       	brcs	.+8      	; 0x362a <__divsf3_pse+0xaa>
    3622:	62 1b       	sub	r22, r18
    3624:	73 0b       	sbc	r23, r19
    3626:	84 0b       	sbc	r24, r20
    3628:	ba 0b       	sbc	r27, r26
    362a:	ee 1f       	adc	r30, r30
    362c:	88 f7       	brcc	.-30     	; 0x3610 <__divsf3_pse+0x90>
    362e:	e0 95       	com	r30
    3630:	08 95       	ret

00003632 <__fixsfsi>:
    3632:	04 d0       	rcall	.+8      	; 0x363c <__fixunssfsi>
    3634:	68 94       	set
    3636:	b1 11       	cpse	r27, r1
    3638:	d9 c0       	rjmp	.+434    	; 0x37ec <__fp_szero>
    363a:	08 95       	ret

0000363c <__fixunssfsi>:
    363c:	bc d0       	rcall	.+376    	; 0x37b6 <__fp_splitA>
    363e:	88 f0       	brcs	.+34     	; 0x3662 <__fixunssfsi+0x26>
    3640:	9f 57       	subi	r25, 0x7F	; 127
    3642:	90 f0       	brcs	.+36     	; 0x3668 <__fixunssfsi+0x2c>
    3644:	b9 2f       	mov	r27, r25
    3646:	99 27       	eor	r25, r25
    3648:	b7 51       	subi	r27, 0x17	; 23
    364a:	a0 f0       	brcs	.+40     	; 0x3674 <__fixunssfsi+0x38>
    364c:	d1 f0       	breq	.+52     	; 0x3682 <__fixunssfsi+0x46>
    364e:	66 0f       	add	r22, r22
    3650:	77 1f       	adc	r23, r23
    3652:	88 1f       	adc	r24, r24
    3654:	99 1f       	adc	r25, r25
    3656:	1a f0       	brmi	.+6      	; 0x365e <__fixunssfsi+0x22>
    3658:	ba 95       	dec	r27
    365a:	c9 f7       	brne	.-14     	; 0x364e <__fixunssfsi+0x12>
    365c:	12 c0       	rjmp	.+36     	; 0x3682 <__fixunssfsi+0x46>
    365e:	b1 30       	cpi	r27, 0x01	; 1
    3660:	81 f0       	breq	.+32     	; 0x3682 <__fixunssfsi+0x46>
    3662:	c3 d0       	rcall	.+390    	; 0x37ea <__fp_zero>
    3664:	b1 e0       	ldi	r27, 0x01	; 1
    3666:	08 95       	ret
    3668:	c0 c0       	rjmp	.+384    	; 0x37ea <__fp_zero>
    366a:	67 2f       	mov	r22, r23
    366c:	78 2f       	mov	r23, r24
    366e:	88 27       	eor	r24, r24
    3670:	b8 5f       	subi	r27, 0xF8	; 248
    3672:	39 f0       	breq	.+14     	; 0x3682 <__fixunssfsi+0x46>
    3674:	b9 3f       	cpi	r27, 0xF9	; 249
    3676:	cc f3       	brlt	.-14     	; 0x366a <__fixunssfsi+0x2e>
    3678:	86 95       	lsr	r24
    367a:	77 95       	ror	r23
    367c:	67 95       	ror	r22
    367e:	b3 95       	inc	r27
    3680:	d9 f7       	brne	.-10     	; 0x3678 <__fixunssfsi+0x3c>
    3682:	3e f4       	brtc	.+14     	; 0x3692 <__fixunssfsi+0x56>
    3684:	90 95       	com	r25
    3686:	80 95       	com	r24
    3688:	70 95       	com	r23
    368a:	61 95       	neg	r22
    368c:	7f 4f       	sbci	r23, 0xFF	; 255
    368e:	8f 4f       	sbci	r24, 0xFF	; 255
    3690:	9f 4f       	sbci	r25, 0xFF	; 255
    3692:	08 95       	ret

00003694 <__floatunsisf>:
    3694:	e8 94       	clt
    3696:	09 c0       	rjmp	.+18     	; 0x36aa <__floatsisf+0x12>

00003698 <__floatsisf>:
    3698:	97 fb       	bst	r25, 7
    369a:	3e f4       	brtc	.+14     	; 0x36aa <__floatsisf+0x12>
    369c:	90 95       	com	r25
    369e:	80 95       	com	r24
    36a0:	70 95       	com	r23
    36a2:	61 95       	neg	r22
    36a4:	7f 4f       	sbci	r23, 0xFF	; 255
    36a6:	8f 4f       	sbci	r24, 0xFF	; 255
    36a8:	9f 4f       	sbci	r25, 0xFF	; 255
    36aa:	99 23       	and	r25, r25
    36ac:	a9 f0       	breq	.+42     	; 0x36d8 <__floatsisf+0x40>
    36ae:	f9 2f       	mov	r31, r25
    36b0:	96 e9       	ldi	r25, 0x96	; 150
    36b2:	bb 27       	eor	r27, r27
    36b4:	93 95       	inc	r25
    36b6:	f6 95       	lsr	r31
    36b8:	87 95       	ror	r24
    36ba:	77 95       	ror	r23
    36bc:	67 95       	ror	r22
    36be:	b7 95       	ror	r27
    36c0:	f1 11       	cpse	r31, r1
    36c2:	f8 cf       	rjmp	.-16     	; 0x36b4 <__floatsisf+0x1c>
    36c4:	fa f4       	brpl	.+62     	; 0x3704 <__floatsisf+0x6c>
    36c6:	bb 0f       	add	r27, r27
    36c8:	11 f4       	brne	.+4      	; 0x36ce <__floatsisf+0x36>
    36ca:	60 ff       	sbrs	r22, 0
    36cc:	1b c0       	rjmp	.+54     	; 0x3704 <__floatsisf+0x6c>
    36ce:	6f 5f       	subi	r22, 0xFF	; 255
    36d0:	7f 4f       	sbci	r23, 0xFF	; 255
    36d2:	8f 4f       	sbci	r24, 0xFF	; 255
    36d4:	9f 4f       	sbci	r25, 0xFF	; 255
    36d6:	16 c0       	rjmp	.+44     	; 0x3704 <__floatsisf+0x6c>
    36d8:	88 23       	and	r24, r24
    36da:	11 f0       	breq	.+4      	; 0x36e0 <__floatsisf+0x48>
    36dc:	96 e9       	ldi	r25, 0x96	; 150
    36de:	11 c0       	rjmp	.+34     	; 0x3702 <__floatsisf+0x6a>
    36e0:	77 23       	and	r23, r23
    36e2:	21 f0       	breq	.+8      	; 0x36ec <__floatsisf+0x54>
    36e4:	9e e8       	ldi	r25, 0x8E	; 142
    36e6:	87 2f       	mov	r24, r23
    36e8:	76 2f       	mov	r23, r22
    36ea:	05 c0       	rjmp	.+10     	; 0x36f6 <__floatsisf+0x5e>
    36ec:	66 23       	and	r22, r22
    36ee:	71 f0       	breq	.+28     	; 0x370c <__floatsisf+0x74>
    36f0:	96 e8       	ldi	r25, 0x86	; 134
    36f2:	86 2f       	mov	r24, r22
    36f4:	70 e0       	ldi	r23, 0x00	; 0
    36f6:	60 e0       	ldi	r22, 0x00	; 0
    36f8:	2a f0       	brmi	.+10     	; 0x3704 <__floatsisf+0x6c>
    36fa:	9a 95       	dec	r25
    36fc:	66 0f       	add	r22, r22
    36fe:	77 1f       	adc	r23, r23
    3700:	88 1f       	adc	r24, r24
    3702:	da f7       	brpl	.-10     	; 0x36fa <__floatsisf+0x62>
    3704:	88 0f       	add	r24, r24
    3706:	96 95       	lsr	r25
    3708:	87 95       	ror	r24
    370a:	97 f9       	bld	r25, 7
    370c:	08 95       	ret

0000370e <__fp_cmp>:
    370e:	99 0f       	add	r25, r25
    3710:	00 08       	sbc	r0, r0
    3712:	55 0f       	add	r21, r21
    3714:	aa 0b       	sbc	r26, r26
    3716:	e0 e8       	ldi	r30, 0x80	; 128
    3718:	fe ef       	ldi	r31, 0xFE	; 254
    371a:	16 16       	cp	r1, r22
    371c:	17 06       	cpc	r1, r23
    371e:	e8 07       	cpc	r30, r24
    3720:	f9 07       	cpc	r31, r25
    3722:	c0 f0       	brcs	.+48     	; 0x3754 <__fp_cmp+0x46>
    3724:	12 16       	cp	r1, r18
    3726:	13 06       	cpc	r1, r19
    3728:	e4 07       	cpc	r30, r20
    372a:	f5 07       	cpc	r31, r21
    372c:	98 f0       	brcs	.+38     	; 0x3754 <__fp_cmp+0x46>
    372e:	62 1b       	sub	r22, r18
    3730:	73 0b       	sbc	r23, r19
    3732:	84 0b       	sbc	r24, r20
    3734:	95 0b       	sbc	r25, r21
    3736:	39 f4       	brne	.+14     	; 0x3746 <__fp_cmp+0x38>
    3738:	0a 26       	eor	r0, r26
    373a:	61 f0       	breq	.+24     	; 0x3754 <__fp_cmp+0x46>
    373c:	23 2b       	or	r18, r19
    373e:	24 2b       	or	r18, r20
    3740:	25 2b       	or	r18, r21
    3742:	21 f4       	brne	.+8      	; 0x374c <__fp_cmp+0x3e>
    3744:	08 95       	ret
    3746:	0a 26       	eor	r0, r26
    3748:	09 f4       	brne	.+2      	; 0x374c <__fp_cmp+0x3e>
    374a:	a1 40       	sbci	r26, 0x01	; 1
    374c:	a6 95       	lsr	r26
    374e:	8f ef       	ldi	r24, 0xFF	; 255
    3750:	81 1d       	adc	r24, r1
    3752:	81 1d       	adc	r24, r1
    3754:	08 95       	ret

00003756 <__fp_inf>:
    3756:	97 f9       	bld	r25, 7
    3758:	9f 67       	ori	r25, 0x7F	; 127
    375a:	80 e8       	ldi	r24, 0x80	; 128
    375c:	70 e0       	ldi	r23, 0x00	; 0
    375e:	60 e0       	ldi	r22, 0x00	; 0
    3760:	08 95       	ret

00003762 <__fp_nan>:
    3762:	9f ef       	ldi	r25, 0xFF	; 255
    3764:	80 ec       	ldi	r24, 0xC0	; 192
    3766:	08 95       	ret

00003768 <__fp_pscA>:
    3768:	00 24       	eor	r0, r0
    376a:	0a 94       	dec	r0
    376c:	16 16       	cp	r1, r22
    376e:	17 06       	cpc	r1, r23
    3770:	18 06       	cpc	r1, r24
    3772:	09 06       	cpc	r0, r25
    3774:	08 95       	ret

00003776 <__fp_pscB>:
    3776:	00 24       	eor	r0, r0
    3778:	0a 94       	dec	r0
    377a:	12 16       	cp	r1, r18
    377c:	13 06       	cpc	r1, r19
    377e:	14 06       	cpc	r1, r20
    3780:	05 06       	cpc	r0, r21
    3782:	08 95       	ret

00003784 <__fp_round>:
    3784:	09 2e       	mov	r0, r25
    3786:	03 94       	inc	r0
    3788:	00 0c       	add	r0, r0
    378a:	11 f4       	brne	.+4      	; 0x3790 <__fp_round+0xc>
    378c:	88 23       	and	r24, r24
    378e:	52 f0       	brmi	.+20     	; 0x37a4 <__fp_round+0x20>
    3790:	bb 0f       	add	r27, r27
    3792:	40 f4       	brcc	.+16     	; 0x37a4 <__fp_round+0x20>
    3794:	bf 2b       	or	r27, r31
    3796:	11 f4       	brne	.+4      	; 0x379c <__fp_round+0x18>
    3798:	60 ff       	sbrs	r22, 0
    379a:	04 c0       	rjmp	.+8      	; 0x37a4 <__fp_round+0x20>
    379c:	6f 5f       	subi	r22, 0xFF	; 255
    379e:	7f 4f       	sbci	r23, 0xFF	; 255
    37a0:	8f 4f       	sbci	r24, 0xFF	; 255
    37a2:	9f 4f       	sbci	r25, 0xFF	; 255
    37a4:	08 95       	ret

000037a6 <__fp_split3>:
    37a6:	57 fd       	sbrc	r21, 7
    37a8:	90 58       	subi	r25, 0x80	; 128
    37aa:	44 0f       	add	r20, r20
    37ac:	55 1f       	adc	r21, r21
    37ae:	59 f0       	breq	.+22     	; 0x37c6 <__fp_splitA+0x10>
    37b0:	5f 3f       	cpi	r21, 0xFF	; 255
    37b2:	71 f0       	breq	.+28     	; 0x37d0 <__fp_splitA+0x1a>
    37b4:	47 95       	ror	r20

000037b6 <__fp_splitA>:
    37b6:	88 0f       	add	r24, r24
    37b8:	97 fb       	bst	r25, 7
    37ba:	99 1f       	adc	r25, r25
    37bc:	61 f0       	breq	.+24     	; 0x37d6 <__fp_splitA+0x20>
    37be:	9f 3f       	cpi	r25, 0xFF	; 255
    37c0:	79 f0       	breq	.+30     	; 0x37e0 <__fp_splitA+0x2a>
    37c2:	87 95       	ror	r24
    37c4:	08 95       	ret
    37c6:	12 16       	cp	r1, r18
    37c8:	13 06       	cpc	r1, r19
    37ca:	14 06       	cpc	r1, r20
    37cc:	55 1f       	adc	r21, r21
    37ce:	f2 cf       	rjmp	.-28     	; 0x37b4 <__fp_split3+0xe>
    37d0:	46 95       	lsr	r20
    37d2:	f1 df       	rcall	.-30     	; 0x37b6 <__fp_splitA>
    37d4:	08 c0       	rjmp	.+16     	; 0x37e6 <__fp_splitA+0x30>
    37d6:	16 16       	cp	r1, r22
    37d8:	17 06       	cpc	r1, r23
    37da:	18 06       	cpc	r1, r24
    37dc:	99 1f       	adc	r25, r25
    37de:	f1 cf       	rjmp	.-30     	; 0x37c2 <__fp_splitA+0xc>
    37e0:	86 95       	lsr	r24
    37e2:	71 05       	cpc	r23, r1
    37e4:	61 05       	cpc	r22, r1
    37e6:	08 94       	sec
    37e8:	08 95       	ret

000037ea <__fp_zero>:
    37ea:	e8 94       	clt

000037ec <__fp_szero>:
    37ec:	bb 27       	eor	r27, r27
    37ee:	66 27       	eor	r22, r22
    37f0:	77 27       	eor	r23, r23
    37f2:	cb 01       	movw	r24, r22
    37f4:	97 f9       	bld	r25, 7
    37f6:	08 95       	ret

000037f8 <__gesf2>:
    37f8:	8a df       	rcall	.-236    	; 0x370e <__fp_cmp>
    37fa:	08 f4       	brcc	.+2      	; 0x37fe <__gesf2+0x6>
    37fc:	8f ef       	ldi	r24, 0xFF	; 255
    37fe:	08 95       	ret

00003800 <__mulsf3>:
    3800:	0b d0       	rcall	.+22     	; 0x3818 <__mulsf3x>
    3802:	c0 cf       	rjmp	.-128    	; 0x3784 <__fp_round>
    3804:	b1 df       	rcall	.-158    	; 0x3768 <__fp_pscA>
    3806:	28 f0       	brcs	.+10     	; 0x3812 <__mulsf3+0x12>
    3808:	b6 df       	rcall	.-148    	; 0x3776 <__fp_pscB>
    380a:	18 f0       	brcs	.+6      	; 0x3812 <__mulsf3+0x12>
    380c:	95 23       	and	r25, r21
    380e:	09 f0       	breq	.+2      	; 0x3812 <__mulsf3+0x12>
    3810:	a2 cf       	rjmp	.-188    	; 0x3756 <__fp_inf>
    3812:	a7 cf       	rjmp	.-178    	; 0x3762 <__fp_nan>
    3814:	11 24       	eor	r1, r1
    3816:	ea cf       	rjmp	.-44     	; 0x37ec <__fp_szero>

00003818 <__mulsf3x>:
    3818:	c6 df       	rcall	.-116    	; 0x37a6 <__fp_split3>
    381a:	a0 f3       	brcs	.-24     	; 0x3804 <__mulsf3+0x4>

0000381c <__mulsf3_pse>:
    381c:	95 9f       	mul	r25, r21
    381e:	d1 f3       	breq	.-12     	; 0x3814 <__mulsf3+0x14>
    3820:	95 0f       	add	r25, r21
    3822:	50 e0       	ldi	r21, 0x00	; 0
    3824:	55 1f       	adc	r21, r21
    3826:	62 9f       	mul	r22, r18
    3828:	f0 01       	movw	r30, r0
    382a:	72 9f       	mul	r23, r18
    382c:	bb 27       	eor	r27, r27
    382e:	f0 0d       	add	r31, r0
    3830:	b1 1d       	adc	r27, r1
    3832:	63 9f       	mul	r22, r19
    3834:	aa 27       	eor	r26, r26
    3836:	f0 0d       	add	r31, r0
    3838:	b1 1d       	adc	r27, r1
    383a:	aa 1f       	adc	r26, r26
    383c:	64 9f       	mul	r22, r20
    383e:	66 27       	eor	r22, r22
    3840:	b0 0d       	add	r27, r0
    3842:	a1 1d       	adc	r26, r1
    3844:	66 1f       	adc	r22, r22
    3846:	82 9f       	mul	r24, r18
    3848:	22 27       	eor	r18, r18
    384a:	b0 0d       	add	r27, r0
    384c:	a1 1d       	adc	r26, r1
    384e:	62 1f       	adc	r22, r18
    3850:	73 9f       	mul	r23, r19
    3852:	b0 0d       	add	r27, r0
    3854:	a1 1d       	adc	r26, r1
    3856:	62 1f       	adc	r22, r18
    3858:	83 9f       	mul	r24, r19
    385a:	a0 0d       	add	r26, r0
    385c:	61 1d       	adc	r22, r1
    385e:	22 1f       	adc	r18, r18
    3860:	74 9f       	mul	r23, r20
    3862:	33 27       	eor	r19, r19
    3864:	a0 0d       	add	r26, r0
    3866:	61 1d       	adc	r22, r1
    3868:	23 1f       	adc	r18, r19
    386a:	84 9f       	mul	r24, r20
    386c:	60 0d       	add	r22, r0
    386e:	21 1d       	adc	r18, r1
    3870:	82 2f       	mov	r24, r18
    3872:	76 2f       	mov	r23, r22
    3874:	6a 2f       	mov	r22, r26
    3876:	11 24       	eor	r1, r1
    3878:	9f 57       	subi	r25, 0x7F	; 127
    387a:	50 40       	sbci	r21, 0x00	; 0
    387c:	8a f0       	brmi	.+34     	; 0x38a0 <__mulsf3_pse+0x84>
    387e:	e1 f0       	breq	.+56     	; 0x38b8 <__mulsf3_pse+0x9c>
    3880:	88 23       	and	r24, r24
    3882:	4a f0       	brmi	.+18     	; 0x3896 <__mulsf3_pse+0x7a>
    3884:	ee 0f       	add	r30, r30
    3886:	ff 1f       	adc	r31, r31
    3888:	bb 1f       	adc	r27, r27
    388a:	66 1f       	adc	r22, r22
    388c:	77 1f       	adc	r23, r23
    388e:	88 1f       	adc	r24, r24
    3890:	91 50       	subi	r25, 0x01	; 1
    3892:	50 40       	sbci	r21, 0x00	; 0
    3894:	a9 f7       	brne	.-22     	; 0x3880 <__mulsf3_pse+0x64>
    3896:	9e 3f       	cpi	r25, 0xFE	; 254
    3898:	51 05       	cpc	r21, r1
    389a:	70 f0       	brcs	.+28     	; 0x38b8 <__mulsf3_pse+0x9c>
    389c:	5c cf       	rjmp	.-328    	; 0x3756 <__fp_inf>
    389e:	a6 cf       	rjmp	.-180    	; 0x37ec <__fp_szero>
    38a0:	5f 3f       	cpi	r21, 0xFF	; 255
    38a2:	ec f3       	brlt	.-6      	; 0x389e <__mulsf3_pse+0x82>
    38a4:	98 3e       	cpi	r25, 0xE8	; 232
    38a6:	dc f3       	brlt	.-10     	; 0x389e <__mulsf3_pse+0x82>
    38a8:	86 95       	lsr	r24
    38aa:	77 95       	ror	r23
    38ac:	67 95       	ror	r22
    38ae:	b7 95       	ror	r27
    38b0:	f7 95       	ror	r31
    38b2:	e7 95       	ror	r30
    38b4:	9f 5f       	subi	r25, 0xFF	; 255
    38b6:	c1 f7       	brne	.-16     	; 0x38a8 <__mulsf3_pse+0x8c>
    38b8:	fe 2b       	or	r31, r30
    38ba:	88 0f       	add	r24, r24
    38bc:	91 1d       	adc	r25, r1
    38be:	96 95       	lsr	r25
    38c0:	87 95       	ror	r24
    38c2:	97 f9       	bld	r25, 7
    38c4:	08 95       	ret

000038c6 <__udivmodqi4>:
    38c6:	99 1b       	sub	r25, r25
    38c8:	79 e0       	ldi	r23, 0x09	; 9
    38ca:	04 c0       	rjmp	.+8      	; 0x38d4 <__udivmodqi4_ep>

000038cc <__udivmodqi4_loop>:
    38cc:	99 1f       	adc	r25, r25
    38ce:	96 17       	cp	r25, r22
    38d0:	08 f0       	brcs	.+2      	; 0x38d4 <__udivmodqi4_ep>
    38d2:	96 1b       	sub	r25, r22

000038d4 <__udivmodqi4_ep>:
    38d4:	88 1f       	adc	r24, r24
    38d6:	7a 95       	dec	r23
    38d8:	c9 f7       	brne	.-14     	; 0x38cc <__udivmodqi4_loop>
    38da:	80 95       	com	r24
    38dc:	08 95       	ret

000038de <__udivmodhi4>:
    38de:	aa 1b       	sub	r26, r26
    38e0:	bb 1b       	sub	r27, r27
    38e2:	51 e1       	ldi	r21, 0x11	; 17
    38e4:	07 c0       	rjmp	.+14     	; 0x38f4 <__udivmodhi4_ep>

000038e6 <__udivmodhi4_loop>:
    38e6:	aa 1f       	adc	r26, r26
    38e8:	bb 1f       	adc	r27, r27
    38ea:	a6 17       	cp	r26, r22
    38ec:	b7 07       	cpc	r27, r23
    38ee:	10 f0       	brcs	.+4      	; 0x38f4 <__udivmodhi4_ep>
    38f0:	a6 1b       	sub	r26, r22
    38f2:	b7 0b       	sbc	r27, r23

000038f4 <__udivmodhi4_ep>:
    38f4:	88 1f       	adc	r24, r24
    38f6:	99 1f       	adc	r25, r25
    38f8:	5a 95       	dec	r21
    38fa:	a9 f7       	brne	.-22     	; 0x38e6 <__udivmodhi4_loop>
    38fc:	80 95       	com	r24
    38fe:	90 95       	com	r25
    3900:	bc 01       	movw	r22, r24
    3902:	cd 01       	movw	r24, r26
    3904:	08 95       	ret

00003906 <__udivmodsi4>:
    3906:	a1 e2       	ldi	r26, 0x21	; 33
    3908:	1a 2e       	mov	r1, r26
    390a:	aa 1b       	sub	r26, r26
    390c:	bb 1b       	sub	r27, r27
    390e:	fd 01       	movw	r30, r26
    3910:	0d c0       	rjmp	.+26     	; 0x392c <__udivmodsi4_ep>

00003912 <__udivmodsi4_loop>:
    3912:	aa 1f       	adc	r26, r26
    3914:	bb 1f       	adc	r27, r27
    3916:	ee 1f       	adc	r30, r30
    3918:	ff 1f       	adc	r31, r31
    391a:	a2 17       	cp	r26, r18
    391c:	b3 07       	cpc	r27, r19
    391e:	e4 07       	cpc	r30, r20
    3920:	f5 07       	cpc	r31, r21
    3922:	20 f0       	brcs	.+8      	; 0x392c <__udivmodsi4_ep>
    3924:	a2 1b       	sub	r26, r18
    3926:	b3 0b       	sbc	r27, r19
    3928:	e4 0b       	sbc	r30, r20
    392a:	f5 0b       	sbc	r31, r21

0000392c <__udivmodsi4_ep>:
    392c:	66 1f       	adc	r22, r22
    392e:	77 1f       	adc	r23, r23
    3930:	88 1f       	adc	r24, r24
    3932:	99 1f       	adc	r25, r25
    3934:	1a 94       	dec	r1
    3936:	69 f7       	brne	.-38     	; 0x3912 <__udivmodsi4_loop>
    3938:	60 95       	com	r22
    393a:	70 95       	com	r23
    393c:	80 95       	com	r24
    393e:	90 95       	com	r25
    3940:	9b 01       	movw	r18, r22
    3942:	ac 01       	movw	r20, r24
    3944:	bd 01       	movw	r22, r26
    3946:	cf 01       	movw	r24, r30
    3948:	08 95       	ret

0000394a <memcpy>:
    394a:	fb 01       	movw	r30, r22
    394c:	dc 01       	movw	r26, r24
    394e:	02 c0       	rjmp	.+4      	; 0x3954 <memcpy+0xa>
    3950:	01 90       	ld	r0, Z+
    3952:	0d 92       	st	X+, r0
    3954:	41 50       	subi	r20, 0x01	; 1
    3956:	50 40       	sbci	r21, 0x00	; 0
    3958:	d8 f7       	brcc	.-10     	; 0x3950 <memcpy+0x6>
    395a:	08 95       	ret

0000395c <eeprom_read_byte>:
    395c:	e1 99       	sbic	0x1c, 1	; 28
    395e:	fe cf       	rjmp	.-4      	; 0x395c <eeprom_read_byte>
    3960:	9f bb       	out	0x1f, r25	; 31
    3962:	8e bb       	out	0x1e, r24	; 30
    3964:	e0 9a       	sbi	0x1c, 0	; 28
    3966:	99 27       	eor	r25, r25
    3968:	8d b3       	in	r24, 0x1d	; 29
    396a:	08 95       	ret

0000396c <eeprom_update_byte>:
    396c:	26 2f       	mov	r18, r22

0000396e <eeprom_update_r18>:
    396e:	e1 99       	sbic	0x1c, 1	; 28
    3970:	fe cf       	rjmp	.-4      	; 0x396e <eeprom_update_r18>
    3972:	9f bb       	out	0x1f, r25	; 31
    3974:	8e bb       	out	0x1e, r24	; 30
    3976:	e0 9a       	sbi	0x1c, 0	; 28
    3978:	01 97       	sbiw	r24, 0x01	; 1
    397a:	0d b2       	in	r0, 0x1d	; 29
    397c:	02 16       	cp	r0, r18
    397e:	31 f0       	breq	.+12     	; 0x398c <eeprom_update_r18+0x1e>
    3980:	2d bb       	out	0x1d, r18	; 29
    3982:	0f b6       	in	r0, 0x3f	; 63
    3984:	f8 94       	cli
    3986:	e2 9a       	sbi	0x1c, 2	; 28
    3988:	e1 9a       	sbi	0x1c, 1	; 28
    398a:	0f be       	out	0x3f, r0	; 63
    398c:	08 95       	ret

0000398e <_exit>:
    398e:	f8 94       	cli

00003990 <__stop_program>:
    3990:	ff cf       	rjmp	.-2      	; 0x3990 <__stop_program>
