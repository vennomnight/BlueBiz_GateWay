
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000bc  00800100  000045e2  00004676  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000045e2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000deb  008001bc  008001bc  00004732  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00004732  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004764  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000ab8  00000000  00000000  000047a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000e0e4  00000000  00000000  00005260  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00003a50  00000000  00000000  00013344  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005dfd  00000000  00000000  00016d94  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001ce4  00000000  00000000  0001cb94  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003cda  00000000  00000000  0001e878  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000092cf  00000000  00000000  00022552  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000b18  00000000  00000000  0002b821  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	48 c5       	rjmp	.+2704   	; 0xa92 <__ctors_end>
       2:	00 00       	nop
       4:	0c 94 c9 09 	jmp	0x1392	; 0x1392 <__vector_1>
       8:	63 c5       	rjmp	.+2758   	; 0xad0 <__bad_interrupt>
       a:	00 00       	nop
       c:	61 c5       	rjmp	.+2754   	; 0xad0 <__bad_interrupt>
       e:	00 00       	nop
      10:	5f c5       	rjmp	.+2750   	; 0xad0 <__bad_interrupt>
      12:	00 00       	nop
      14:	5d c5       	rjmp	.+2746   	; 0xad0 <__bad_interrupt>
      16:	00 00       	nop
      18:	5b c5       	rjmp	.+2742   	; 0xad0 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	59 c5       	rjmp	.+2738   	; 0xad0 <__bad_interrupt>
      1e:	00 00       	nop
      20:	57 c5       	rjmp	.+2734   	; 0xad0 <__bad_interrupt>
      22:	00 00       	nop
      24:	0c 94 d1 0a 	jmp	0x15a2	; 0x15a2 <__vector_9>
      28:	53 c5       	rjmp	.+2726   	; 0xad0 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	51 c5       	rjmp	.+2722   	; 0xad0 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 2a 19 	jmp	0x3254	; 0x3254 <__vector_12>
      34:	4d c5       	rjmp	.+2714   	; 0xad0 <__bad_interrupt>
      36:	00 00       	nop
      38:	4b c5       	rjmp	.+2710   	; 0xad0 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	0c 94 3f 08 	jmp	0x107e	; 0x107e <__vector_15>
      40:	47 c5       	rjmp	.+2702   	; 0xad0 <__bad_interrupt>
      42:	00 00       	nop
      44:	45 c5       	rjmp	.+2698   	; 0xad0 <__bad_interrupt>
      46:	00 00       	nop
      48:	0c 94 38 09 	jmp	0x1270	; 0x1270 <__vector_18>
      4c:	41 c5       	rjmp	.+2690   	; 0xad0 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3f c5       	rjmp	.+2686   	; 0xad0 <__bad_interrupt>
      52:	00 00       	nop
      54:	0c 94 f9 09 	jmp	0x13f2	; 0x13f2 <__vector_21>
      58:	3b c5       	rjmp	.+2678   	; 0xad0 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	39 c5       	rjmp	.+2674   	; 0xad0 <__bad_interrupt>
      5e:	00 00       	nop
      60:	37 c5       	rjmp	.+2670   	; 0xad0 <__bad_interrupt>
      62:	00 00       	nop
      64:	35 c5       	rjmp	.+2666   	; 0xad0 <__bad_interrupt>
      66:	00 00       	nop
      68:	33 c5       	rjmp	.+2662   	; 0xad0 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	31 c5       	rjmp	.+2658   	; 0xad0 <__bad_interrupt>
      6e:	00 00       	nop
      70:	0c 94 99 09 	jmp	0x1332	; 0x1332 <__vector_28>
      74:	2d c5       	rjmp	.+2650   	; 0xad0 <__bad_interrupt>
      76:	00 00       	nop
      78:	0c 94 68 09 	jmp	0x12d0	; 0x12d0 <__vector_30>
      7c:	29 c5       	rjmp	.+2642   	; 0xad0 <__bad_interrupt>
      7e:	00 00       	nop
      80:	27 c5       	rjmp	.+2638   	; 0xad0 <__bad_interrupt>
      82:	00 00       	nop
      84:	25 c5       	rjmp	.+2634   	; 0xad0 <__bad_interrupt>
      86:	00 00       	nop
      88:	23 c5       	rjmp	.+2630   	; 0xad0 <__bad_interrupt>
	...

0000008c <__trampolines_end>:
      8c:	00 00       	nop
      8e:	c8 42       	sbci	r28, 0x28	; 40
      90:	ae c7       	rjmp	.+3932   	; 0xfee <_ZN22DFRobotHighTemperature15readTemperatureEj+0x16e>
      92:	c8 42       	sbci	r28, 0x28	; 40
      94:	5c 8f       	std	Y+28, r21	; 0x1c
      96:	c9 42       	sbci	r28, 0x29	; 41
      98:	0a 57       	subi	r16, 0x7A	; 122
      9a:	ca 42       	sbci	r28, 0x2A	; 42
      9c:	b8 1e       	adc	r11, r24
      9e:	cb 42       	sbci	r28, 0x2B	; 43
      a0:	66 e6       	ldi	r22, 0x66	; 102
      a2:	cb 42       	sbci	r28, 0x2B	; 43
      a4:	14 ae       	std	Z+60, r1	; 0x3c
      a6:	cc 42       	sbci	r28, 0x2C	; 44
      a8:	c3 75       	andi	r28, 0x53	; 83
      aa:	cd 42       	sbci	r28, 0x2D	; 45
      ac:	71 3d       	cpi	r23, 0xD1	; 209
      ae:	ce 42       	sbci	r28, 0x2E	; 46
      b0:	1f 05       	cpc	r17, r15
      b2:	cf 42       	sbci	r28, 0x2F	; 47
      b4:	cd cc       	rjmp	.-1638   	; 0xfffffa50 <__eeprom_end+0xff7efa50>
      b6:	cf 42       	sbci	r28, 0x2F	; 47
      b8:	7b 94       	des	7
      ba:	d0 42       	sbci	r29, 0x20	; 32
      bc:	29 5c       	subi	r18, 0xC9	; 201
      be:	d1 42       	sbci	r29, 0x21	; 33
      c0:	d7 23       	and	r29, r23
      c2:	d2 42       	sbci	r29, 0x22	; 34
      c4:	85 eb       	ldi	r24, 0xB5	; 181
      c6:	d2 42       	sbci	r29, 0x22	; 34
      c8:	33 b3       	in	r19, 0x13	; 19
      ca:	d3 42       	sbci	r29, 0x23	; 35
      cc:	e1 7a       	andi	r30, 0xA1	; 161
      ce:	d4 42       	sbci	r29, 0x24	; 36
      d0:	8f 42       	sbci	r24, 0x2F	; 47
      d2:	d5 42       	sbci	r29, 0x25	; 37
      d4:	3d 0a       	sbc	r3, r29
      d6:	d6 42       	sbci	r29, 0x26	; 38
      d8:	cd cc       	rjmp	.-1638   	; 0xfffffa74 <__eeprom_end+0xff7efa74>
      da:	d6 42       	sbci	r29, 0x26	; 38
      dc:	7b 94       	des	7
      de:	d7 42       	sbci	r29, 0x27	; 39
      e0:	29 5c       	subi	r18, 0xC9	; 201
      e2:	d8 42       	sbci	r29, 0x28	; 40
      e4:	d7 23       	and	r29, r23
      e6:	d9 42       	sbci	r29, 0x29	; 41
      e8:	85 eb       	ldi	r24, 0xB5	; 181
      ea:	d9 42       	sbci	r29, 0x29	; 41
      ec:	33 b3       	in	r19, 0x13	; 19
      ee:	da 42       	sbci	r29, 0x2A	; 42
      f0:	c3 75       	andi	r28, 0x53	; 83
      f2:	db 42       	sbci	r29, 0x2B	; 43
      f4:	71 3d       	cpi	r23, 0xD1	; 209
      f6:	dc 42       	sbci	r29, 0x2C	; 44
      f8:	1f 05       	cpc	r17, r15
      fa:	dd 42       	sbci	r29, 0x2D	; 45
      fc:	cd cc       	rjmp	.-1638   	; 0xfffffa98 <__eeprom_end+0xff7efa98>
      fe:	dd 42       	sbci	r29, 0x2D	; 45
     100:	7b 94       	des	7
     102:	de 42       	sbci	r29, 0x2E	; 46
     104:	0a 57       	subi	r16, 0x7A	; 122
     106:	df 42       	sbci	r29, 0x2F	; 47
     108:	b8 1e       	adc	r11, r24
     10a:	e0 42       	sbci	r30, 0x20	; 32
     10c:	66 e6       	ldi	r22, 0x66	; 102
     10e:	e0 42       	sbci	r30, 0x20	; 32
     110:	f6 a8       	ldd	r15, Z+54	; 0x36
     112:	e1 42       	sbci	r30, 0x21	; 33
     114:	a4 70       	andi	r26, 0x04	; 4
     116:	e2 42       	sbci	r30, 0x22	; 34
     118:	52 38       	cpi	r21, 0x82	; 130
     11a:	e3 42       	sbci	r30, 0x23	; 35
     11c:	00 00       	nop
     11e:	e4 42       	sbci	r30, 0x24	; 36
     120:	8f c2       	rjmp	.+1310   	; 0x640 <__LOCK_REGION_LENGTH__+0x240>
     122:	e4 42       	sbci	r30, 0x24	; 36
     124:	3d 8a       	std	Y+21, r3	; 0x15
     126:	e5 42       	sbci	r30, 0x25	; 37
     128:	cd 4c       	sbci	r28, 0xCD	; 205
     12a:	e6 42       	sbci	r30, 0x26	; 38
     12c:	7b 14       	cp	r7, r11
     12e:	e7 42       	sbci	r30, 0x27	; 39
     130:	29 dc       	rcall	.-1966   	; 0xfffff984 <__eeprom_end+0xff7ef984>
     132:	e7 42       	sbci	r30, 0x27	; 39
     134:	b8 9e       	mul	r11, r24
     136:	e8 42       	sbci	r30, 0x28	; 40
     138:	66 66       	ori	r22, 0x66	; 102
     13a:	e9 42       	sbci	r30, 0x29	; 41
     13c:	f6 28       	or	r15, r6
     13e:	ea 42       	sbci	r30, 0x2A	; 42
     140:	a4 f0       	brlt	.+40     	; 0x16a <__trampolines_end+0xde>
     142:	ea 42       	sbci	r30, 0x2A	; 42
     144:	52 b8       	out	0x02, r5	; 2
     146:	eb 42       	sbci	r30, 0x2B	; 43
     148:	e1 7a       	andi	r30, 0xA1	; 161
     14a:	ec 42       	sbci	r30, 0x2C	; 44
     14c:	8f 42       	sbci	r24, 0x2F	; 47
     14e:	ed 42       	sbci	r30, 0x2D	; 45
     150:	1f 05       	cpc	r17, r15
     152:	ee 42       	sbci	r30, 0x2E	; 46
     154:	cd cc       	rjmp	.-1638   	; 0xfffffaf0 <__eeprom_end+0xff7efaf0>
     156:	ee 42       	sbci	r30, 0x2E	; 46
     158:	5c 8f       	std	Y+28, r21	; 0x1c
     15a:	ef 42       	sbci	r30, 0x2F	; 47
     15c:	0a 57       	subi	r16, 0x7A	; 122
     15e:	f0 42       	sbci	r31, 0x20	; 32
     160:	9a 19       	sub	r25, r10
     162:	f1 42       	sbci	r31, 0x21	; 33
     164:	48 e1       	ldi	r20, 0x18	; 24
     166:	f1 42       	sbci	r31, 0x21	; 33
     168:	d7 a3       	std	Z+39, r29	; 0x27
     16a:	f2 42       	sbci	r31, 0x22	; 34
     16c:	85 6b       	ori	r24, 0xB5	; 181
     16e:	f3 42       	sbci	r31, 0x23	; 35
     170:	14 2e       	mov	r1, r20
     172:	f4 42       	sbci	r31, 0x24	; 36
     174:	a4 f0       	brlt	.+40     	; 0x19e <__trampolines_end+0x112>
     176:	f4 42       	sbci	r31, 0x24	; 36
     178:	52 b8       	out	0x02, r5	; 2
     17a:	f5 42       	sbci	r31, 0x25	; 37
     17c:	e1 7a       	andi	r30, 0xA1	; 161
     17e:	f6 42       	sbci	r31, 0x26	; 38
     180:	8f 42       	sbci	r24, 0x2F	; 47
     182:	f7 42       	sbci	r31, 0x27	; 39
     184:	1f 05       	cpc	r17, r15
     186:	f8 42       	sbci	r31, 0x28	; 40
     188:	ae c7       	rjmp	.+3932   	; 0x10e6 <__vector_15+0x68>
     18a:	f8 42       	sbci	r31, 0x28	; 40
     18c:	5c 8f       	std	Y+28, r21	; 0x1c
     18e:	f9 42       	sbci	r31, 0x29	; 41
     190:	ec 51       	subi	r30, 0x1C	; 28
     192:	fa 42       	sbci	r31, 0x2A	; 42
     194:	7b 14       	cp	r7, r11
     196:	fb 42       	sbci	r31, 0x2B	; 43
     198:	29 dc       	rcall	.-1966   	; 0xfffff9ec <__eeprom_end+0xff7ef9ec>
     19a:	fb 42       	sbci	r31, 0x2B	; 43
     19c:	b8 9e       	mul	r11, r24
     19e:	fc 42       	sbci	r31, 0x2C	; 44
     1a0:	48 61       	ori	r20, 0x18	; 24
     1a2:	fd 42       	sbci	r31, 0x2D	; 45
     1a4:	f6 28       	or	r15, r6
     1a6:	fe 42       	sbci	r31, 0x2E	; 46
     1a8:	85 eb       	ldi	r24, 0xB5	; 181
     1aa:	fe 42       	sbci	r31, 0x2E	; 46
     1ac:	14 ae       	std	Z+60, r1	; 0x3c
     1ae:	ff 42       	sbci	r31, 0x2F	; 47
     1b0:	52 38       	cpi	r21, 0x82	; 130
     1b2:	00 43       	sbci	r16, 0x30	; 48
     1b4:	29 9c       	mul	r2, r9
     1b6:	00 43       	sbci	r16, 0x30	; 48
     1b8:	71 fd       	sbrc	r23, 1
     1ba:	00 43       	sbci	r16, 0x30	; 48
     1bc:	b8 5e       	subi	r27, 0xE8	; 232
     1be:	01 43       	sbci	r16, 0x31	; 49
     1c0:	00 c0       	rjmp	.+0      	; 0x1c2 <__trampolines_end+0x136>
     1c2:	01 43       	sbci	r16, 0x31	; 49
     1c4:	48 21       	and	r20, r8
     1c6:	02 43       	sbci	r16, 0x32	; 50
     1c8:	1f 85       	ldd	r17, Y+15	; 0x0f
     1ca:	02 43       	sbci	r16, 0x32	; 50
     1cc:	66 e6       	ldi	r22, 0x66	; 102
     1ce:	02 43       	sbci	r16, 0x32	; 50
     1d0:	ae 47       	sbci	r26, 0x7E	; 126
     1d2:	03 43       	sbci	r16, 0x33	; 51
     1d4:	f6 a8       	ldd	r15, Z+54	; 0x36
     1d6:	03 43       	sbci	r16, 0x33	; 51
     1d8:	3d 0a       	sbc	r3, r29
     1da:	04 43       	sbci	r16, 0x34	; 52
     1dc:	85 6b       	ori	r24, 0xB5	; 181
     1de:	04 43       	sbci	r16, 0x34	; 52
     1e0:	cd cc       	rjmp	.-1638   	; 0xfffffb7c <__eeprom_end+0xff7efb7c>
     1e2:	04 43       	sbci	r16, 0x34	; 52
     1e4:	14 2e       	mov	r1, r20
     1e6:	05 43       	sbci	r16, 0x35	; 53
     1e8:	ec 91       	ld	r30, X
     1ea:	05 43       	sbci	r16, 0x35	; 53
     1ec:	33 f3       	brvs	.-52     	; 0x1ba <__trampolines_end+0x12e>
     1ee:	05 43       	sbci	r16, 0x35	; 53
     1f0:	7b 54       	subi	r23, 0x4B	; 75
     1f2:	06 43       	sbci	r16, 0x36	; 54
     1f4:	c3 b5       	in	r28, 0x23	; 35
     1f6:	06 43       	sbci	r16, 0x36	; 54
     1f8:	0a 17       	cp	r16, r26
     1fa:	07 43       	sbci	r16, 0x37	; 55
     1fc:	52 78       	andi	r21, 0x82	; 130
     1fe:	07 43       	sbci	r16, 0x37	; 55
     200:	9a d9       	rcall	.-3276   	; 0xfffff536 <__eeprom_end+0xff7ef536>
     202:	07 43       	sbci	r16, 0x37	; 55
     204:	e1 3a       	cpi	r30, 0xA1	; 161
     206:	08 43       	sbci	r16, 0x38	; 56
     208:	29 9c       	mul	r2, r9
     20a:	08 43       	sbci	r16, 0x38	; 56
     20c:	71 fd       	sbrc	r23, 1
     20e:	08 43       	sbci	r16, 0x38	; 56
     210:	b8 5e       	subi	r27, 0xE8	; 232
     212:	09 43       	sbci	r16, 0x39	; 57
     214:	00 c0       	rjmp	.+0      	; 0x216 <__trampolines_end+0x18a>
     216:	09 43       	sbci	r16, 0x39	; 57
     218:	48 21       	and	r20, r8
     21a:	0a 43       	sbci	r16, 0x3A	; 58
     21c:	8f 82       	std	Y+7, r8	; 0x07
     21e:	0a 43       	sbci	r16, 0x3A	; 58
     220:	48 e1       	ldi	r20, 0x18	; 24
     222:	0a 43       	sbci	r16, 0x3A	; 58
     224:	8f 42       	sbci	r24, 0x2F	; 47
     226:	0b 43       	sbci	r16, 0x3B	; 59
     228:	d7 a3       	std	Z+39, r29	; 0x27
     22a:	0b 43       	sbci	r16, 0x3B	; 59
     22c:	1f 05       	cpc	r17, r15
     22e:	0c 43       	sbci	r16, 0x3C	; 60
     230:	66 66       	ori	r22, 0x66	; 102
     232:	0c 43       	sbci	r16, 0x3C	; 60
     234:	ae c7       	rjmp	.+3932   	; 0x1192 <_ZN11Dev_Manager11getInstanceEv+0x26>
     236:	0c 43       	sbci	r16, 0x3C	; 60
     238:	f6 28       	or	r15, r6
     23a:	0d 43       	sbci	r16, 0x3D	; 61
     23c:	3d 8a       	std	Y+21, r3	; 0x15
     23e:	0d 43       	sbci	r16, 0x3D	; 61
     240:	f6 e8       	ldi	r31, 0x86	; 134
     242:	0d 43       	sbci	r16, 0x3D	; 61
     244:	3d 4a       	sbci	r19, 0xAD	; 173
     246:	0e 43       	sbci	r16, 0x3E	; 62
     248:	85 ab       	std	Z+53, r24	; 0x35
     24a:	0e 43       	sbci	r16, 0x3E	; 62
     24c:	cd 0c       	add	r12, r13
     24e:	0f 43       	sbci	r16, 0x3F	; 63
     250:	14 6e       	ori	r17, 0xE4	; 228
     252:	0f 43       	sbci	r16, 0x3F	; 63
     254:	cd cc       	rjmp	.-1638   	; 0xfffffbf0 <__eeprom_end+0xff7efbf0>
     256:	0f 43       	sbci	r16, 0x3F	; 63
     258:	14 2e       	mov	r1, r20
     25a:	10 43       	sbci	r17, 0x30	; 48
     25c:	5c 8f       	std	Y+28, r21	; 0x1c
     25e:	10 43       	sbci	r17, 0x30	; 48
     260:	a4 f0       	brlt	.+40     	; 0x28a <__trampolines_end+0x1fe>
     262:	10 43       	sbci	r17, 0x30	; 48
     264:	5c 4f       	sbci	r21, 0xFC	; 252
     266:	11 43       	sbci	r17, 0x31	; 49
     268:	a4 b0       	in	r10, 0x04	; 4
     26a:	11 43       	sbci	r17, 0x31	; 49
     26c:	ec 11       	cpse	r30, r12
     26e:	12 43       	sbci	r17, 0x32	; 50
     270:	a4 70       	andi	r26, 0x04	; 4
     272:	12 43       	sbci	r17, 0x32	; 50
     274:	ec d1       	rcall	.+984    	; 0x64e <__LOCK_REGION_LENGTH__+0x24e>
     276:	12 43       	sbci	r17, 0x32	; 50
     278:	33 33       	cpi	r19, 0x33	; 51
     27a:	13 43       	sbci	r17, 0x33	; 51
     27c:	ec 91       	ld	r30, X
     27e:	13 43       	sbci	r17, 0x33	; 51
     280:	33 f3       	brvs	.-52     	; 0x24e <__trampolines_end+0x1c2>
     282:	13 43       	sbci	r17, 0x33	; 51
     284:	7b 54       	subi	r23, 0x4B	; 75
     286:	14 43       	sbci	r17, 0x34	; 52
     288:	33 b3       	in	r19, 0x13	; 19
     28a:	14 43       	sbci	r17, 0x34	; 52
     28c:	7b 14       	cp	r7, r11
     28e:	15 43       	sbci	r17, 0x35	; 53
     290:	c3 75       	andi	r28, 0x53	; 83
     292:	15 43       	sbci	r17, 0x35	; 53
     294:	7b d4       	rcall	.+2294   	; 0xb8c <_Z13GetFucc10DataPcP17GetFunctionCode10Pi+0xe>
     296:	15 43       	sbci	r17, 0x35	; 53
     298:	c3 35       	cpi	r28, 0x53	; 83
     29a:	16 43       	sbci	r17, 0x36	; 54
     29c:	7b 94       	des	7
     29e:	16 43       	sbci	r17, 0x36	; 54
     2a0:	c3 f5       	brvc	.+112    	; 0x312 <__trampolines_end+0x286>
     2a2:	16 43       	sbci	r17, 0x36	; 54
     2a4:	7b 54       	subi	r23, 0x4B	; 75
     2a6:	17 43       	sbci	r17, 0x37	; 55
     2a8:	c3 b5       	in	r28, 0x23	; 35
     2aa:	17 43       	sbci	r17, 0x37	; 55
     2ac:	7b 14       	cp	r7, r11
     2ae:	18 43       	sbci	r17, 0x38	; 56
     2b0:	c3 75       	andi	r28, 0x53	; 83
     2b2:	18 43       	sbci	r17, 0x38	; 56
     2b4:	7b d4       	rcall	.+2294   	; 0xbac <_Z13GetFucc10DataPcP17GetFunctionCode10Pi+0x2e>
     2b6:	18 43       	sbci	r17, 0x38	; 56
     2b8:	c3 35       	cpi	r28, 0x53	; 83
     2ba:	19 43       	sbci	r17, 0x39	; 57
     2bc:	7b 94       	des	7
     2be:	19 43       	sbci	r17, 0x39	; 57
     2c0:	c3 f5       	brvc	.+112    	; 0x332 <__trampolines_end+0x2a6>
     2c2:	19 43       	sbci	r17, 0x39	; 57
     2c4:	7b 54       	subi	r23, 0x4B	; 75
     2c6:	1a 43       	sbci	r17, 0x3A	; 58
     2c8:	c3 b5       	in	r28, 0x23	; 35
     2ca:	1a 43       	sbci	r17, 0x3A	; 58
     2cc:	7b 14       	cp	r7, r11
     2ce:	1b 43       	sbci	r17, 0x3B	; 59
     2d0:	c3 75       	andi	r28, 0x53	; 83
     2d2:	1b 43       	sbci	r17, 0x3B	; 59
     2d4:	7b d4       	rcall	.+2294   	; 0xbcc <_Z13GetFucc10DataPcP17GetFunctionCode10Pi+0x4e>
     2d6:	1b 43       	sbci	r17, 0x3B	; 59
     2d8:	33 33       	cpi	r19, 0x33	; 51
     2da:	1c 43       	sbci	r17, 0x3C	; 60
     2dc:	7b 94       	des	7
     2de:	1c 43       	sbci	r17, 0x3C	; 60
     2e0:	33 f3       	brvs	.-52     	; 0x2ae <__trampolines_end+0x222>
     2e2:	1c 43       	sbci	r17, 0x3C	; 60
     2e4:	7b 54       	subi	r23, 0x4B	; 75
     2e6:	1d 43       	sbci	r17, 0x3D	; 61
     2e8:	33 b3       	in	r19, 0x13	; 19
     2ea:	1d 43       	sbci	r17, 0x3D	; 61
     2ec:	ec 11       	cpse	r30, r12
     2ee:	1e 43       	sbci	r17, 0x3E	; 62
     2f0:	33 73       	andi	r19, 0x33	; 51
     2f2:	1e 43       	sbci	r17, 0x3E	; 62
     2f4:	ec d1       	rcall	.+984    	; 0x6ce <_ZL8g_adTemp+0x2>
     2f6:	1e 43       	sbci	r17, 0x3E	; 62
     2f8:	a4 30       	cpi	r26, 0x04	; 4
     2fa:	1f 43       	sbci	r17, 0x3F	; 63
     2fc:	5c 8f       	std	Y+28, r21	; 0x1c
     2fe:	1f 43       	sbci	r17, 0x3F	; 63
     300:	a4 f0       	brlt	.+40     	; 0x32a <__trampolines_end+0x29e>
     302:	1f 43       	sbci	r17, 0x3F	; 63
     304:	5c 4f       	sbci	r21, 0xFC	; 252
     306:	20 43       	sbci	r18, 0x30	; 48
     308:	14 ae       	std	Z+60, r1	; 0x3c
     30a:	20 43       	sbci	r18, 0x30	; 48
     30c:	cd 0c       	add	r12, r13
     30e:	21 43       	sbci	r18, 0x31	; 49
     310:	14 6e       	ori	r17, 0xE4	; 228
     312:	21 43       	sbci	r18, 0x31	; 49
     314:	cd cc       	rjmp	.-1638   	; 0xfffffcb0 <__eeprom_end+0xff7efcb0>
     316:	21 43       	sbci	r18, 0x31	; 49
     318:	85 2b       	or	r24, r21
     31a:	22 43       	sbci	r18, 0x32	; 50
     31c:	3d 8a       	std	Y+21, r3	; 0x15
     31e:	22 43       	sbci	r18, 0x32	; 50
     320:	f6 e8       	ldi	r31, 0x86	; 134
     322:	22 43       	sbci	r18, 0x32	; 50
     324:	3d 4a       	sbci	r19, 0xAD	; 173
     326:	23 43       	sbci	r18, 0x33	; 51
     328:	f6 a8       	ldd	r15, Z+54	; 0x36
     32a:	23 43       	sbci	r18, 0x33	; 51
     32c:	ae 07       	cpc	r26, r30
     32e:	24 43       	sbci	r18, 0x34	; 52
     330:	66 66       	ori	r22, 0x66	; 102
     332:	24 43       	sbci	r18, 0x34	; 52
     334:	1f c5       	rjmp	.+2622   	; 0xd74 <_ZN12SerialBuffer10SerialReadEv+0x3e>
     336:	24 43       	sbci	r18, 0x34	; 52
     338:	d7 23       	and	r29, r23
     33a:	25 43       	sbci	r18, 0x35	; 53
     33c:	8f 82       	std	Y+7, r8	; 0x07
     33e:	25 43       	sbci	r18, 0x35	; 53
     340:	d7 e3       	ldi	r29, 0x37	; 55
     342:	25 43       	sbci	r18, 0x35	; 53
     344:	8f 42       	sbci	r24, 0x2F	; 47
     346:	26 43       	sbci	r18, 0x36	; 54
     348:	48 a1       	ldd	r20, Y+32	; 0x20
     34a:	26 43       	sbci	r18, 0x36	; 54
     34c:	00 00       	nop
     34e:	27 43       	sbci	r18, 0x37	; 55
     350:	b8 5e       	subi	r27, 0xE8	; 232
     352:	27 43       	sbci	r18, 0x37	; 55
     354:	71 bd       	out	0x21, r23	; 33
     356:	27 43       	sbci	r18, 0x37	; 55
     358:	29 1c       	adc	r2, r9
     35a:	28 43       	sbci	r18, 0x38	; 56
     35c:	e1 7a       	andi	r30, 0xA1	; 161
     35e:	28 43       	sbci	r18, 0x38	; 56
     360:	9a d9       	rcall	.-3276   	; 0xfffff696 <__eeprom_end+0xff7ef696>
     362:	28 43       	sbci	r18, 0x38	; 56
     364:	52 38       	cpi	r21, 0x82	; 130
     366:	29 43       	sbci	r18, 0x39	; 57
     368:	0a 97       	sbiw	r24, 0x0a	; 10
     36a:	29 43       	sbci	r18, 0x39	; 57
     36c:	c3 f5       	brvc	.+112    	; 0x3de <__trampolines_end+0x352>
     36e:	29 43       	sbci	r18, 0x39	; 57
     370:	7b 54       	subi	r23, 0x4B	; 75
     372:	2a 43       	sbci	r18, 0x3A	; 58
     374:	33 b3       	in	r19, 0x13	; 19
     376:	2a 43       	sbci	r18, 0x3A	; 58
     378:	ec 11       	cpse	r30, r12
     37a:	2b 43       	sbci	r18, 0x3B	; 59
     37c:	14 6e       	ori	r17, 0xE4	; 228
     37e:	2b 43       	sbci	r18, 0x3B	; 59
     380:	cd cc       	rjmp	.-1638   	; 0xfffffd1c <__eeprom_end+0xff7efd1c>
     382:	2b 43       	sbci	r18, 0x3B	; 59
     384:	85 2b       	or	r24, r21
     386:	2c 43       	sbci	r18, 0x3C	; 60
     388:	3d 8a       	std	Y+21, r3	; 0x15
     38a:	2c 43       	sbci	r18, 0x3C	; 60
     38c:	f6 e8       	ldi	r31, 0x86	; 134
     38e:	2c 43       	sbci	r18, 0x3C	; 60
     390:	ae 47       	sbci	r26, 0x7E	; 126
     392:	2d 43       	sbci	r18, 0x3D	; 61
     394:	66 a6       	std	Z+46, r6	; 0x2e
     396:	2d 43       	sbci	r18, 0x3D	; 61
     398:	1f 05       	cpc	r17, r15
     39a:	2e 43       	sbci	r18, 0x3E	; 62
     39c:	48 61       	ori	r20, 0x18	; 24
     39e:	2e 43       	sbci	r18, 0x3E	; 62
     3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <__trampolines_end+0x316>
     3a2:	2e 43       	sbci	r18, 0x3E	; 62
     3a4:	b8 1e       	adc	r11, r24
     3a6:	2f 43       	sbci	r18, 0x3F	; 63
     3a8:	71 7d       	andi	r23, 0xD1	; 209
     3aa:	2f 43       	sbci	r18, 0x3F	; 63
     3ac:	29 dc       	rcall	.-1966   	; 0xfffffc00 <__eeprom_end+0xff7efc00>
     3ae:	2f 43       	sbci	r18, 0x3F	; 63
     3b0:	52 38       	cpi	r21, 0x82	; 130
     3b2:	30 43       	sbci	r19, 0x30	; 48
     3b4:	0a 97       	sbiw	r24, 0x0a	; 10
     3b6:	30 43       	sbci	r19, 0x30	; 48
     3b8:	c3 f5       	brvc	.+112    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     3ba:	30 43       	sbci	r19, 0x30	; 48
     3bc:	7b 54       	subi	r23, 0x4B	; 75
     3be:	31 43       	sbci	r19, 0x31	; 49
     3c0:	a4 b0       	in	r10, 0x04	; 4
     3c2:	31 43       	sbci	r19, 0x31	; 49
     3c4:	5c 0f       	add	r21, r28
     3c6:	32 43       	sbci	r19, 0x32	; 50
     3c8:	14 6e       	ori	r17, 0xE4	; 228
     3ca:	32 43       	sbci	r19, 0x32	; 50
     3cc:	3d ca       	rjmp	.-2950   	; 0xfffff848 <__eeprom_end+0xff7ef848>
     3ce:	32 43       	sbci	r19, 0x32	; 50
     3d0:	f6 28       	or	r15, r6
     3d2:	33 43       	sbci	r19, 0x33	; 51
     3d4:	ae 87       	std	Y+14, r26	; 0x0e
     3d6:	33 43       	sbci	r19, 0x33	; 51
     3d8:	d7 e3       	ldi	r29, 0x37	; 55
     3da:	33 43       	sbci	r19, 0x33	; 51
     3dc:	8f 42       	sbci	r24, 0x2F	; 47
     3de:	34 43       	sbci	r19, 0x34	; 52
     3e0:	48 a1       	ldd	r20, Y+32	; 0x20
     3e2:	34 43       	sbci	r19, 0x34	; 52
     3e4:	71 fd       	sbrc	r23, 1
     3e6:	34 43       	sbci	r19, 0x34	; 52
     3e8:	29 5c       	subi	r18, 0xC9	; 201
     3ea:	35 43       	sbci	r19, 0x35	; 53
     3ec:	52 b8       	out	0x02, r5	; 2
     3ee:	35 43       	sbci	r19, 0x35	; 53
     3f0:	0a 17       	cp	r16, r26
     3f2:	36 43       	sbci	r19, 0x36	; 54
     3f4:	c3 75       	andi	r28, 0x53	; 83
     3f6:	36 43       	sbci	r19, 0x36	; 54
     3f8:	ec d1       	rcall	.+984    	; 0x7d2 <_ZL8g_adTemp+0x106>
     3fa:	36 43       	sbci	r19, 0x36	; 54
     3fc:	a4 30       	cpi	r26, 0x04	; 4
     3fe:	37 43       	sbci	r19, 0x37	; 55
     400:	cd 8c       	ldd	r12, Y+29	; 0x1d
     402:	37 43       	sbci	r19, 0x37	; 55
     404:	85 eb       	ldi	r24, 0xB5	; 181
     406:	37 43       	sbci	r19, 0x37	; 55
     408:	ae 47       	sbci	r26, 0x7E	; 126
     40a:	38 43       	sbci	r19, 0x38	; 56
     40c:	66 a6       	std	Z+46, r6	; 0x2e
     40e:	38 43       	sbci	r19, 0x38	; 56
     410:	8f 02       	muls	r24, r31
     412:	39 43       	sbci	r19, 0x39	; 57
     414:	48 61       	ori	r20, 0x18	; 24
     416:	39 43       	sbci	r19, 0x39	; 57
     418:	71 bd       	out	0x21, r23	; 33
     41a:	39 43       	sbci	r19, 0x39	; 57
     41c:	29 1c       	adc	r2, r9
     41e:	3a 43       	sbci	r19, 0x3A	; 58
     420:	52 78       	andi	r21, 0x82	; 130
     422:	3a 43       	sbci	r19, 0x3A	; 58
     424:	0a d7       	rcall	.+3604   	; 0x123a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x10>
     426:	3a 43       	sbci	r19, 0x3A	; 58
     428:	33 33       	cpi	r19, 0x33	; 51
     42a:	3b 43       	sbci	r19, 0x3B	; 59
     42c:	5c 8f       	std	Y+28, r21	; 0x1c
     42e:	3b 43       	sbci	r19, 0x3B	; 59
     430:	14 ee       	ldi	r17, 0xE4	; 228
     432:	3b 43       	sbci	r19, 0x3B	; 59
     434:	3d 4a       	sbci	r19, 0xAD	; 173
     436:	3c 43       	sbci	r19, 0x3C	; 60
     438:	f6 a8       	ldd	r15, Z+54	; 0x36
     43a:	3c 43       	sbci	r19, 0x3C	; 60
     43c:	1f 05       	cpc	r17, r15
     43e:	3d 43       	sbci	r19, 0x3D	; 61
     440:	48 61       	ori	r20, 0x18	; 24
     442:	3d 43       	sbci	r19, 0x3D	; 61
     444:	00 c0       	rjmp	.+0      	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     446:	3d 43       	sbci	r19, 0x3D	; 61
     448:	29 1c       	adc	r2, r9
     44a:	3e 43       	sbci	r19, 0x3E	; 62
     44c:	52 78       	andi	r21, 0x82	; 130
     44e:	3e 43       	sbci	r19, 0x3E	; 62
     450:	0a d7       	rcall	.+3604   	; 0x1266 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type+0x8>
     452:	3e 43       	sbci	r19, 0x3E	; 62
     454:	33 33       	cpi	r19, 0x33	; 51
     456:	3f 43       	sbci	r19, 0x3F	; 63
     458:	5c 8f       	std	Y+28, r21	; 0x1c
     45a:	3f 43       	sbci	r19, 0x3F	; 63
     45c:	85 eb       	ldi	r24, 0xB5	; 181
     45e:	3f 43       	sbci	r19, 0x3F	; 63
     460:	3d 4a       	sbci	r19, 0xAD	; 173
     462:	40 43       	sbci	r20, 0x30	; 48
     464:	66 a6       	std	Z+46, r6	; 0x2e
     466:	40 43       	sbci	r20, 0x30	; 48
     468:	8f 02       	muls	r24, r31
     46a:	41 43       	sbci	r20, 0x31	; 49
     46c:	b8 5e       	subi	r27, 0xE8	; 232
     46e:	41 43       	sbci	r20, 0x31	; 49
     470:	71 bd       	out	0x21, r23	; 33
     472:	41 43       	sbci	r20, 0x31	; 49
     474:	9a 19       	sub	r25, r10
     476:	42 43       	sbci	r20, 0x32	; 50
     478:	c3 75       	andi	r28, 0x53	; 83
     47a:	42 43       	sbci	r20, 0x32	; 50
     47c:	ec d1       	rcall	.+984    	; 0x856 <_ZL9g_alfVolt+0x48>
     47e:	42 43       	sbci	r20, 0x32	; 50
     480:	14 2e       	mov	r1, r20
     482:	43 43       	sbci	r20, 0x33	; 51
     484:	cd 8c       	ldd	r12, Y+29	; 0x1d
     486:	43 43       	sbci	r20, 0x33	; 51
     488:	f6 e8       	ldi	r31, 0x86	; 134
     48a:	43 43       	sbci	r20, 0x33	; 51
     48c:	1f 45       	sbci	r17, 0x5F	; 95
     48e:	44 43       	sbci	r20, 0x34	; 52
     490:	48 a1       	ldd	r20, Y+32	; 0x20
     492:	44 43       	sbci	r20, 0x34	; 52
     494:	71 fd       	sbrc	r23, 1
     496:	44 43       	sbci	r20, 0x34	; 52
     498:	9a 59       	subi	r25, 0x9A	; 154
     49a:	45 43       	sbci	r20, 0x35	; 53
     49c:	c3 b5       	in	r28, 0x23	; 35
     49e:	45 43       	sbci	r20, 0x35	; 53
     4a0:	ec 11       	cpse	r30, r12
     4a2:	46 43       	sbci	r20, 0x36	; 54
     4a4:	14 6e       	ori	r17, 0xE4	; 228
     4a6:	46 43       	sbci	r20, 0x36	; 54
     4a8:	3d ca       	rjmp	.-2950   	; 0xfffff924 <__eeprom_end+0xff7ef924>
     4aa:	46 43       	sbci	r20, 0x36	; 54
     4ac:	66 26       	eor	r6, r22
     4ae:	47 43       	sbci	r20, 0x37	; 55
     4b0:	8f 82       	std	Y+7, r8	; 0x07
     4b2:	47 43       	sbci	r20, 0x37	; 55
     4b4:	b8 de       	rcall	.-656    	; 0x226 <__trampolines_end+0x19a>
     4b6:	47 43       	sbci	r20, 0x37	; 55
     4b8:	e1 3a       	cpi	r30, 0xA1	; 161
     4ba:	48 43       	sbci	r20, 0x38	; 56
     4bc:	0a 97       	sbiw	r24, 0x0a	; 10
     4be:	48 43       	sbci	r20, 0x38	; 56
     4c0:	33 f3       	brvs	.-52     	; 0x48e <__LOCK_REGION_LENGTH__+0x8e>
     4c2:	48 43       	sbci	r20, 0x38	; 56
     4c4:	5c 4f       	sbci	r21, 0xFC	; 252
     4c6:	49 43       	sbci	r20, 0x39	; 57
     4c8:	85 ab       	std	Z+53, r24	; 0x35
     4ca:	49 43       	sbci	r20, 0x39	; 57
     4cc:	ae 07       	cpc	r26, r30
     4ce:	4a 43       	sbci	r20, 0x3A	; 58
     4d0:	d7 63       	ori	r29, 0x37	; 55
     4d2:	4a 43       	sbci	r20, 0x3A	; 58
     4d4:	00 c0       	rjmp	.+0      	; 0x4d6 <__LOCK_REGION_LENGTH__+0xd6>
     4d6:	4a 43       	sbci	r20, 0x3A	; 58
     4d8:	29 1c       	adc	r2, r9
     4da:	4b 43       	sbci	r20, 0x3B	; 59
     4dc:	52 78       	andi	r21, 0x82	; 130
     4de:	4b 43       	sbci	r20, 0x3B	; 59
     4e0:	7b d4       	rcall	.+2294   	; 0xdd8 <_ZN22DFRobotHighTemperature4compEfi+0x12>
     4e2:	4b 43       	sbci	r20, 0x3B	; 59
     4e4:	a4 30       	cpi	r26, 0x04	; 4
     4e6:	4c 43       	sbci	r20, 0x3C	; 60
     4e8:	cd 8c       	ldd	r12, Y+29	; 0x1d
     4ea:	4c 43       	sbci	r20, 0x3C	; 60
     4ec:	66 e6       	ldi	r22, 0x66	; 102
     4ee:	4c 43       	sbci	r20, 0x3C	; 60
     4f0:	8f 42       	sbci	r24, 0x2F	; 47
     4f2:	4d 43       	sbci	r20, 0x3D	; 61
     4f4:	b8 9e       	mul	r11, r24
     4f6:	4d 43       	sbci	r20, 0x3D	; 61
     4f8:	e1 fa       	bst	r14, 1
     4fa:	4d 43       	sbci	r20, 0x3D	; 61
     4fc:	0a 57       	subi	r16, 0x7A	; 122
     4fe:	4e 43       	sbci	r20, 0x3E	; 62
     500:	33 b3       	in	r19, 0x13	; 19
     502:	4e 43       	sbci	r20, 0x3E	; 62
     504:	cd 0c       	add	r12, r13
     506:	4f 43       	sbci	r20, 0x3F	; 63
     508:	f6 68       	ori	r31, 0x86	; 134
     50a:	4f 43       	sbci	r20, 0x3F	; 63
     50c:	1f c5       	rjmp	.+2622   	; 0xf4c <_ZN22DFRobotHighTemperature15readTemperatureEj+0xcc>
     50e:	4f 43       	sbci	r20, 0x3F	; 63
     510:	48 21       	and	r20, r8
     512:	50 43       	sbci	r21, 0x30	; 48
     514:	e1 7a       	andi	r30, 0xA1	; 161
     516:	50 43       	sbci	r21, 0x30	; 48
     518:	0a d7       	rcall	.+3604   	; 0x132e <__vector_30+0x5e>
     51a:	50 43       	sbci	r21, 0x30	; 48
     51c:	33 33       	cpi	r19, 0x33	; 51
     51e:	51 43       	sbci	r21, 0x31	; 49
     520:	5c 8f       	std	Y+28, r21	; 0x1c
     522:	51 43       	sbci	r21, 0x31	; 49
     524:	f6 e8       	ldi	r31, 0x86	; 134
     526:	51 43       	sbci	r21, 0x31	; 49
     528:	1f 45       	sbci	r17, 0x5F	; 95
     52a:	52 43       	sbci	r21, 0x32	; 50
     52c:	48 a1       	ldd	r20, Y+32	; 0x20
     52e:	52 43       	sbci	r21, 0x32	; 50
     530:	e1 fa       	bst	r14, 1
     532:	52 43       	sbci	r21, 0x32	; 50
     534:	0a 57       	subi	r16, 0x7A	; 122
     536:	53 43       	sbci	r21, 0x33	; 51
     538:	33 b3       	in	r19, 0x13	; 19
     53a:	53 43       	sbci	r21, 0x33	; 51
     53c:	cd 0c       	add	r12, r13
     53e:	54 43       	sbci	r21, 0x34	; 52
     540:	f6 68       	ori	r31, 0x86	; 134
     542:	54 43       	sbci	r21, 0x34	; 52
     544:	8f c2       	rjmp	.+1310   	; 0xa64 <_ZL9g_alfVolt+0x256>
     546:	54 43       	sbci	r21, 0x34	; 52
     548:	b8 1e       	adc	r11, r24
     54a:	55 43       	sbci	r21, 0x35	; 53
     54c:	e1 7a       	andi	r30, 0xA1	; 161
     54e:	55 43       	sbci	r21, 0x35	; 53
     550:	7b d4       	rcall	.+2294   	; 0xe48 <_ZN22DFRobotHighTemperature4compEfi+0x82>
     552:	55 43       	sbci	r21, 0x35	; 53
     554:	a4 30       	cpi	r26, 0x04	; 4
     556:	56 43       	sbci	r21, 0x36	; 54
     558:	3d 8a       	std	Y+21, r3	; 0x15
     55a:	56 43       	sbci	r21, 0x36	; 54
     55c:	66 e6       	ldi	r22, 0x66	; 102
     55e:	56 43       	sbci	r21, 0x36	; 54
     560:	00 40       	sbci	r16, 0x00	; 0
     562:	57 43       	sbci	r21, 0x37	; 55
     564:	29 9c       	mul	r2, r9
     566:	57 43       	sbci	r21, 0x37	; 55
     568:	c3 f5       	brvc	.+112    	; 0x5da <__LOCK_REGION_LENGTH__+0x1da>
     56a:	57 43       	sbci	r21, 0x37	; 55
     56c:	ec 51       	subi	r30, 0x1C	; 28
     56e:	58 43       	sbci	r21, 0x38	; 56
     570:	85 ab       	std	Z+53, r24	; 0x35
     572:	58 43       	sbci	r21, 0x38	; 56
     574:	ae 07       	cpc	r26, r30
     576:	59 43       	sbci	r21, 0x39	; 57
     578:	48 61       	ori	r20, 0x18	; 24
     57a:	59 43       	sbci	r21, 0x39	; 57
     57c:	71 bd       	out	0x21, r23	; 33
     57e:	59 43       	sbci	r21, 0x39	; 57
     580:	0a 17       	cp	r16, r26
     582:	5a 43       	sbci	r21, 0x3A	; 58
     584:	a4 70       	andi	r26, 0x04	; 4
     586:	5a 43       	sbci	r21, 0x3A	; 58
     588:	cd cc       	rjmp	.-1638   	; 0xffffff24 <__eeprom_end+0xff7eff24>
     58a:	5a 43       	sbci	r21, 0x3A	; 58
     58c:	66 26       	eor	r6, r22
     58e:	5b 43       	sbci	r21, 0x3B	; 59
     590:	8f 82       	std	Y+7, r8	; 0x07
     592:	5b 43       	sbci	r21, 0x3B	; 59
     594:	29 dc       	rcall	.-1966   	; 0xfffffde8 <__eeprom_end+0xff7efde8>
     596:	5b 43       	sbci	r21, 0x3B	; 59
     598:	c3 35       	cpi	r28, 0x53	; 83
     59a:	5c 43       	sbci	r21, 0x3C	; 60
     59c:	ec 91       	ld	r30, X
     59e:	5c 43       	sbci	r21, 0x3C	; 60
     5a0:	85 eb       	ldi	r24, 0xB5	; 181
     5a2:	5c 43       	sbci	r21, 0x3C	; 60
     5a4:	1f 45       	sbci	r17, 0x5F	; 95
     5a6:	5d 43       	sbci	r21, 0x3D	; 61
     5a8:	48 a1       	ldd	r20, Y+32	; 0x20
     5aa:	5d 43       	sbci	r21, 0x3D	; 61
     5ac:	e1 fa       	bst	r14, 1
     5ae:	5d 43       	sbci	r21, 0x3D	; 61
     5b0:	7b 54       	subi	r23, 0x4B	; 75
     5b2:	5e 43       	sbci	r21, 0x3E	; 62
     5b4:	14 ae       	std	Z+60, r1	; 0x3c
     5b6:	5e 43       	sbci	r21, 0x3E	; 62
     5b8:	3d 0a       	sbc	r3, r29
     5ba:	5f 43       	sbci	r21, 0x3F	; 63
     5bc:	d7 63       	ori	r29, 0x37	; 55
     5be:	5f 43       	sbci	r21, 0x3F	; 63
     5c0:	71 bd       	out	0x21, r23	; 33
     5c2:	5f 43       	sbci	r21, 0x3F	; 63
     5c4:	0a 17       	cp	r16, r26
     5c6:	60 43       	sbci	r22, 0x30	; 48
     5c8:	33 73       	andi	r19, 0x33	; 51
     5ca:	60 43       	sbci	r22, 0x30	; 48
     5cc:	cd cc       	rjmp	.-1638   	; 0xffffff68 <__eeprom_end+0xff7eff68>
     5ce:	60 43       	sbci	r22, 0x30	; 48
     5d0:	66 26       	eor	r6, r22
     5d2:	61 43       	sbci	r22, 0x31	; 49
     5d4:	00 80       	ld	r0, Z
     5d6:	61 43       	sbci	r22, 0x31	; 49
     5d8:	9a d9       	rcall	.-3276   	; 0xfffff90e <__eeprom_end+0xff7ef90e>
     5da:	61 43       	sbci	r22, 0x31	; 49
     5dc:	c3 35       	cpi	r28, 0x53	; 83
     5de:	62 43       	sbci	r22, 0x32	; 50
     5e0:	5c 8f       	std	Y+28, r21	; 0x1c
     5e2:	62 43       	sbci	r22, 0x32	; 50
     5e4:	f6 e8       	ldi	r31, 0x86	; 134
     5e6:	62 43       	sbci	r22, 0x32	; 50
     5e8:	8f 42       	sbci	r24, 0x2F	; 47
     5ea:	63 43       	sbci	r22, 0x33	; 51
     5ec:	29 9c       	mul	r2, r9
     5ee:	63 43       	sbci	r22, 0x33	; 51
     5f0:	c3 f5       	brvc	.+112    	; 0x662 <__LOCK_REGION_LENGTH__+0x262>
     5f2:	63 43       	sbci	r22, 0x33	; 51
     5f4:	5c 4f       	sbci	r21, 0xFC	; 252
     5f6:	64 43       	sbci	r22, 0x34	; 52
     5f8:	f6 a8       	ldd	r15, Z+54	; 0x36
     5fa:	64 43       	sbci	r22, 0x34	; 52
     5fc:	1f 05       	cpc	r17, r15
     5fe:	65 43       	sbci	r22, 0x35	; 53
     600:	b8 5e       	subi	r27, 0xE8	; 232
     602:	65 43       	sbci	r22, 0x35	; 53
     604:	52 b8       	out	0x02, r5	; 2
     606:	65 43       	sbci	r22, 0x35	; 53
     608:	ec 11       	cpse	r30, r12
     60a:	66 43       	sbci	r22, 0x36	; 54
     60c:	85 6b       	ori	r24, 0xB5	; 181
     60e:	66 43       	sbci	r22, 0x36	; 54
     610:	1f c5       	rjmp	.+2622   	; 0x1050 <Alarm_Start+0x6>
     612:	66 43       	sbci	r22, 0x36	; 54
     614:	b8 1e       	adc	r11, r24
     616:	67 43       	sbci	r22, 0x37	; 55
     618:	52 78       	andi	r21, 0x82	; 130
     61a:	67 43       	sbci	r22, 0x37	; 55
     61c:	ec d1       	rcall	.+984    	; 0x9f6 <_ZL9g_alfVolt+0x1e8>
     61e:	67 43       	sbci	r22, 0x37	; 55
     620:	85 2b       	or	r24, r21
     622:	68 43       	sbci	r22, 0x38	; 56
     624:	1f 85       	ldd	r17, Y+15	; 0x0f
     626:	68 43       	sbci	r22, 0x38	; 56
     628:	b8 de       	rcall	.-656    	; 0x39a <__trampolines_end+0x30e>
     62a:	68 43       	sbci	r22, 0x38	; 56
     62c:	c3 35       	cpi	r28, 0x53	; 83
     62e:	69 43       	sbci	r22, 0x39	; 57
     630:	5c 8f       	std	Y+28, r21	; 0x1c
     632:	69 43       	sbci	r22, 0x39	; 57
     634:	f6 e8       	ldi	r31, 0x86	; 134
     636:	69 43       	sbci	r22, 0x39	; 57
     638:	8f 42       	sbci	r24, 0x2F	; 47
     63a:	6a 43       	sbci	r22, 0x3A	; 58
     63c:	29 9c       	mul	r2, r9
     63e:	6a 43       	sbci	r22, 0x3A	; 58
     640:	c3 f5       	brvc	.+112    	; 0x6b2 <__LOCK_REGION_LENGTH__+0x2b2>
     642:	6a 43       	sbci	r22, 0x3A	; 58
     644:	5c 4f       	sbci	r21, 0xFC	; 252
     646:	6b 43       	sbci	r22, 0x3B	; 59
     648:	f6 a8       	ldd	r15, Z+54	; 0x36
     64a:	6b 43       	sbci	r22, 0x3B	; 59
     64c:	00 00       	nop
     64e:	6c 43       	sbci	r22, 0x3C	; 60
     650:	9a 59       	subi	r25, 0x9A	; 154
     652:	6c 43       	sbci	r22, 0x3C	; 60
     654:	33 b3       	in	r19, 0x13	; 19
     656:	6c 43       	sbci	r22, 0x3C	; 60
     658:	cd 0c       	add	r12, r13
     65a:	6d 43       	sbci	r22, 0x3D	; 61
     65c:	66 66       	ori	r22, 0x66	; 102
     65e:	6d 43       	sbci	r22, 0x3D	; 61
     660:	71 bd       	out	0x21, r23	; 33
     662:	6d 43       	sbci	r22, 0x3D	; 61
     664:	0a 17       	cp	r16, r26
     666:	6e 43       	sbci	r22, 0x3E	; 62
     668:	a4 70       	andi	r26, 0x04	; 4
     66a:	6e 43       	sbci	r22, 0x3E	; 62
     66c:	3d ca       	rjmp	.-2950   	; 0xfffffae8 <__eeprom_end+0xff7efae8>
     66e:	6e 43       	sbci	r22, 0x3E	; 62
     670:	48 21       	and	r20, r8
     672:	6f 43       	sbci	r22, 0x3F	; 63
     674:	e1 7a       	andi	r30, 0xA1	; 161
     676:	6f 43       	sbci	r22, 0x3F	; 63
     678:	7b d4       	rcall	.+2294   	; 0xf70 <_ZN22DFRobotHighTemperature15readTemperatureEj+0xf0>
     67a:	6f 43       	sbci	r22, 0x3F	; 63
     67c:	14 2e       	mov	r1, r20
     67e:	70 43       	sbci	r23, 0x30	; 48
     680:	1f 85       	ldd	r17, Y+15	; 0x0f
     682:	70 43       	sbci	r23, 0x30	; 48
     684:	b8 de       	rcall	.-656    	; 0x3f6 <__trampolines_end+0x36a>
     686:	70 43       	sbci	r23, 0x30	; 48
     688:	52 38       	cpi	r21, 0x82	; 130
     68a:	71 43       	sbci	r23, 0x31	; 49
     68c:	5c 8f       	std	Y+28, r21	; 0x1c
     68e:	71 43       	sbci	r23, 0x31	; 49
     690:	f6 e8       	ldi	r31, 0x86	; 134
     692:	71 43       	sbci	r23, 0x31	; 49
     694:	8f 42       	sbci	r24, 0x2F	; 47
     696:	72 43       	sbci	r23, 0x32	; 50
     698:	9a 99       	sbic	0x13, 2	; 19
     69a:	72 43       	sbci	r23, 0x32	; 50
     69c:	33 f3       	brvs	.-52     	; 0x66a <__LOCK_REGION_LENGTH__+0x26a>
     69e:	72 43       	sbci	r23, 0x32	; 50
     6a0:	3d 4a       	sbci	r19, 0xAD	; 173
     6a2:	73 43       	sbci	r23, 0x33	; 51
     6a4:	d7 a3       	std	Z+39, r29	; 0x27
     6a6:	73 43       	sbci	r23, 0x33	; 51
     6a8:	71 fd       	sbrc	r23, 1
     6aa:	73 43       	sbci	r23, 0x33	; 51
     6ac:	7b 54       	subi	r23, 0x4B	; 75
     6ae:	74 43       	sbci	r23, 0x34	; 52
     6b0:	14 ae       	std	Z+60, r1	; 0x3c
     6b2:	74 43       	sbci	r23, 0x34	; 52
     6b4:	1f 05       	cpc	r17, r15
     6b6:	75 43       	sbci	r23, 0x35	; 53
     6b8:	b8 5e       	subi	r27, 0xE8	; 232
     6ba:	75 43       	sbci	r23, 0x35	; 53
     6bc:	c3 b5       	in	r28, 0x23	; 35
     6be:	75 43       	sbci	r23, 0x35	; 53
     6c0:	5c 0f       	add	r21, r28
     6c2:	76 43       	sbci	r23, 0x36	; 54
     6c4:	66 66       	ori	r22, 0x66	; 102
     6c6:	76 43       	sbci	r23, 0x36	; 54
     6c8:	00 c0       	rjmp	.+0      	; 0x6ca <__LOCK_REGION_LENGTH__+0x2ca>
     6ca:	76 43       	sbci	r23, 0x36	; 54

000006cc <_ZL8g_adTemp>:
     6cc:	d8 ff d9 ff da ff db ff dc ff dd ff de ff df ff     ................
     6dc:	e0 ff e1 ff e2 ff e3 ff e4 ff e5 ff e6 ff e7 ff     ................
     6ec:	e8 ff e9 ff ea ff eb ff ec ff ed ff ee ff ef ff     ................
     6fc:	f0 ff f1 ff f2 ff f3 ff f4 ff f5 ff f6 ff f7 ff     ................
     70c:	f8 ff f9 ff fa ff fb ff fc ff fd ff fe ff ff ff     ................
     71c:	00 00 01 00 02 00 03 00 04 00 05 00 06 00 07 00     ................
     72c:	08 00 09 00 0a 00 0b 00 0c 00 0d 00 0e 00 0f 00     ................
     73c:	10 00 11 00 12 00 13 00 14 00 15 00 16 00 17 00     ................
     74c:	18 00 19 00 1a 00 1b 00 1c 00 1d 00 1e 00 1f 00     ................
     75c:	20 00 21 00 22 00 23 00 24 00 25 00 26 00 27 00      .!.".#.$.%.&.'.
     76c:	28 00 29 00 2a 00 2b 00 2c 00 2d 00 2e 00 2f 00     (.).*.+.,.-.../.
     77c:	30 00 31 00 32 00 33 00 34 00 35 00 36 00 37 00     0.1.2.3.4.5.6.7.
     78c:	38 00 39 00 3a 00 3b 00 3c 00 3d 00 3e 00 3f 00     8.9.:.;.<.=.>.?.
     79c:	40 00 41 00 42 00 43 00 44 00 45 00 46 00 47 00     @.A.B.C.D.E.F.G.
     7ac:	48 00 49 00 4a 00 4b 00 4c 00 4d 00 4e 00 4f 00     H.I.J.K.L.M.N.O.
     7bc:	50 00 51 00 52 00 53 00 54 00 55 00 56 00 57 00     P.Q.R.S.T.U.V.W.
     7cc:	58 00 59 00 5a 00 5b 00 5c 00 5d 00 5e 00 5f 00     X.Y.Z.[.\.].^._.
     7dc:	60 00 61 00 62 00 63 00 64 00 65 00 66 00 67 00     `.a.b.c.d.e.f.g.
     7ec:	68 00 69 00 6a 00 6b 00 6c 00 6d 00 6e 00 6f 00     h.i.j.k.l.m.n.o.
     7fc:	70 00 71 00 72 00 73 00 74 00 75 00 76 00 77 00     p.q.r.s.t.u.v.w.
     80c:	78 00                                               x.

0000080e <_ZL9g_alfVolt>:
     80e:	a1 84 89 3e cd 92 90 3e 60 ea 97 3e 97 90 9f 3e     ...>...>`..>...>
     81e:	73 85 a7 3e 92 cb af 3e 95 65 b8 3e ca 54 c1 3e     s..>...>.e.>.T.>
     82e:	80 9a ca 3e 09 38 d4 3e 51 31 de 3e 59 86 e8 3e     ...>.8.>Q1.>Y..>
     83e:	c1 39 f3 3e 88 4b fe 3e 7f de 04 3f 08 c9 0a 3f     .9.>.K.>...?...?
     84e:	11 e4 10 3f 90 31 17 3f 85 b1 1d 3f f1 63 24 3f     ...?.1.?...?.c$?
     85e:	7b 49 2b 3f 24 62 32 3f 92 ae 39 3f c7 2e 41 3f     {I+?$b2?..9?..A?
     86e:	19 e2 48 3f 32 c9 50 3f c1 e2 58 3f 16 30 61 3f     ..H?2.P?..X?.0a?
     87e:	3a af 69 3f 2d 60 72 3f ee 42 7b 3f 17 2b 82 3f     :.i?-`r?.B{?.+.?
     88e:	a3 cc 86 3f c6 85 8b 3f da 55 90 3f 36 3c 95 3f     ...?...?.U.?6<.?
     89e:	32 38 9a 3f cf 49 9f 3f 69 6f a4 3f 00 a9 a9 3f     28.?.I.?io.?...?
     8ae:	99 f5 ae 3f e3 53 b4 3f df c3 b9 3f e9 43 bf 3f     ...?.S.?...?.C.?
     8be:	07 d3 c4 3f e3 70 ca 3f da 1b d0 3f 46 d3 d5 3f     ...?.p.?...?F..?
     8ce:	d5 95 db 3f 8d 62 e1 3f 71 38 e7 3f 33 16 ed 3f     ...?.b.?q8.?3..?
     8de:	83 fa f2 3f b8 e4 f8 3f 84 d3 fe 3f cc 62 02 40     ...?...?...?.b.@
     8ee:	fb 5c 05 40 a8 57 08 40 7e 52 0b 40 ad 4c 0e 40     .\.@.W.@~R.@.L.@
     8fe:	b7 45 11 40 1d 3d 14 40 61 32 17 40 dd 24 1a 40     .E.@.=.@a2.@.$.@
     90e:	3c 14 1d 40 00 00 20 40 82 e7 22 40 97 ca 25 40     <..@.. @.."@..%@
     91e:	6d a8 28 40 dc 80 2b 40 8f 53 2e 40 de 1f 31 40     m.(@..+@.S.@..1@
     92e:	9f e5 33 40 7f a4 36 40 ff 5b 39 40 f6 0b 3c 40     ..3@..6@.[9@..<@
     93e:	e5 b3 3e 40 ce 53 41 40 85 eb 43 40 63 7a 46 40     ..>@.SA@..C@czF@
     94e:	93 00 49 40 bf 7d 4b 40 bf f1 4d 40 92 5c 50 40     ..I@.}K@..M@.\P@
     95e:	e4 bd 52 40 8c 15 55 40 b2 63 57 40 2f a8 59 40     ..R@..U@.cW@/.Y@
     96e:	d6 e2 5b 40 a9 13 5e 40 a8 3a 60 40 d1 57 62 40     ..[@..^@.:`@.Wb@
     97e:	fd 6a 64 40 54 74 66 40 00 74 68 40 ad 69 6a 40     .jd@Ttf@.th@.ij@
     98e:	b0 55 6c 40 df 37 6e 40 8c 10 70 40 8f df 71 40     .Ul@.7n@..p@..q@
     99e:	12 a5 73 40 3d 61 75 40 12 14 77 40 ba bd 78 40     ..s@=au@..w@..x@
     9ae:	0b 5e 7a 40 ae f5 7b 40 23 84 7d 40 13 0a 7f 40     .^z@..{@#.}@...@
     9be:	96 43 80 40 f4 fd 80 40 0f b4 81 40 27 66 82 40     .C.@...@...@'f.@
     9ce:	12 14 83 40 0e be 83 40 1b 64 84 40 4f 06 85 40     ...@...@.d.@O..@
     9de:	d3 a4 85 40 7d 3f 86 40 a1 d6 86 40 2b 6a 87 40     ...@}?.@...@+j.@
     9ee:	2f fa 87 40 c2 86 88 40 0e 10 89 40 ff 95 89 40     /..@...@...@...@
     9fe:	d2 18 8a 40 5f 98 8a 40 f9 14 8b 40 75 8e 8b 40     ...@_..@...@u..@
     a0e:	14 05 8c 40 c0 78 8c 40 a3 e9 8c 40 d1 57 8d 40     ...@.x.@...@.W.@
     a1e:	4c c3 8d 40 28 2c 8e 40 64 92 8e 40 2b f6 8e 40     L..@(,.@d..@+..@
     a2e:	93 57 8f 40 85 b6 8f 40 2b 13 90 40 87 6d 90 40     .W.@...@+..@.m.@
     a3e:	ac c5 90 40 b0 1b 91 40 93 6f 91 40 6a c1 91 40     ...@...@.o.@j..@
     a4e:	49 11 92 40 1c 5f 92 40 22 ab 92 40 45 f5 92 40     I..@._.@"..@E..@
     a5e:	86 3d 93 40 0e 84 93 40 f3 c8 93 40 0b 0c 94 40     .=.@...@...@...@
     a6e:	94 4d 94 40 7a 8d 94 40 e6 cb 94 40 c4 08 95 40     .M.@z..@...@...@
     a7e:	28 44 95 40 13 7e 95 40 ae b6 95 40 d0 ed 95 40     (D.@.~.@...@...@
     a8e:	b8 23 96 40                                         .#.@

00000a92 <__ctors_end>:
     a92:	11 24       	eor	r1, r1
     a94:	1f be       	out	0x3f, r1	; 63
     a96:	cf ef       	ldi	r28, 0xFF	; 255
     a98:	d0 e1       	ldi	r29, 0x10	; 16
     a9a:	de bf       	out	0x3e, r29	; 62
     a9c:	cd bf       	out	0x3d, r28	; 61

00000a9e <__do_copy_data>:
     a9e:	11 e0       	ldi	r17, 0x01	; 1
     aa0:	a0 e0       	ldi	r26, 0x00	; 0
     aa2:	b1 e0       	ldi	r27, 0x01	; 1
     aa4:	e2 ee       	ldi	r30, 0xE2	; 226
     aa6:	f5 e4       	ldi	r31, 0x45	; 69
     aa8:	00 e0       	ldi	r16, 0x00	; 0
     aaa:	0b bf       	out	0x3b, r16	; 59
     aac:	02 c0       	rjmp	.+4      	; 0xab2 <__do_copy_data+0x14>
     aae:	07 90       	elpm	r0, Z+
     ab0:	0d 92       	st	X+, r0
     ab2:	ac 3b       	cpi	r26, 0xBC	; 188
     ab4:	b1 07       	cpc	r27, r17
     ab6:	d9 f7       	brne	.-10     	; 0xaae <__do_copy_data+0x10>

00000ab8 <__do_clear_bss>:
     ab8:	2f e0       	ldi	r18, 0x0F	; 15
     aba:	ac eb       	ldi	r26, 0xBC	; 188
     abc:	b1 e0       	ldi	r27, 0x01	; 1
     abe:	01 c0       	rjmp	.+2      	; 0xac2 <.do_clear_bss_start>

00000ac0 <.do_clear_bss_loop>:
     ac0:	1d 92       	st	X+, r1

00000ac2 <.do_clear_bss_start>:
     ac2:	a7 3a       	cpi	r26, 0xA7	; 167
     ac4:	b2 07       	cpc	r27, r18
     ac6:	e1 f7       	brne	.-8      	; 0xac0 <.do_clear_bss_loop>
     ac8:	0e 94 a8 14 	call	0x2950	; 0x2950 <main>
     acc:	0c 94 ef 22 	jmp	0x45de	; 0x45de <_exit>

00000ad0 <__bad_interrupt>:
     ad0:	97 ca       	rjmp	.-2770   	; 0x0 <__vectors>

00000ad2 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
     ad2:	fc 01       	movw	r30, r24
     ad4:	68 0f       	add	r22, r24
     ad6:	79 1f       	adc	r23, r25
     ad8:	8f ef       	ldi	r24, 0xFF	; 255
     ada:	9f ef       	ldi	r25, 0xFF	; 255
     adc:	e6 17       	cp	r30, r22
     ade:	f7 07       	cpc	r31, r23
     ae0:	99 f0       	breq	.+38     	; 0xb08 <_Z5CRC16Phi+0x36>
     ae2:	21 91       	ld	r18, Z+
     ae4:	82 27       	eor	r24, r18
     ae6:	28 e0       	ldi	r18, 0x08	; 8
     ae8:	30 e0       	ldi	r19, 0x00	; 0
     aea:	ac 01       	movw	r20, r24
     aec:	41 70       	andi	r20, 0x01	; 1
     aee:	55 27       	eor	r21, r21
     af0:	96 95       	lsr	r25
     af2:	87 95       	ror	r24
     af4:	45 2b       	or	r20, r21
     af6:	21 f0       	breq	.+8      	; 0xb00 <_Z5CRC16Phi+0x2e>
     af8:	41 e0       	ldi	r20, 0x01	; 1
     afa:	84 27       	eor	r24, r20
     afc:	40 ea       	ldi	r20, 0xA0	; 160
     afe:	94 27       	eor	r25, r20
     b00:	21 50       	subi	r18, 0x01	; 1
     b02:	31 09       	sbc	r19, r1
     b04:	91 f7       	brne	.-28     	; 0xaea <_Z5CRC16Phi+0x18>
     b06:	ea cf       	rjmp	.-44     	; 0xadc <_Z5CRC16Phi+0xa>
     b08:	08 95       	ret

00000b0a <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     b0a:	cf 93       	push	r28
     b0c:	df 93       	push	r29
     b0e:	dc 01       	movw	r26, r24
     b10:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     b12:	8c 91       	ld	r24, X
     b14:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     b16:	11 96       	adiw	r26, 0x01	; 1
     b18:	8c 91       	ld	r24, X
     b1a:	11 97       	sbiw	r26, 0x01	; 1
     b1c:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     b1e:	13 96       	adiw	r26, 0x03	; 3
     b20:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     b22:	92 e0       	ldi	r25, 0x02	; 2
     b24:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     b26:	e8 2f       	mov	r30, r24
     b28:	f0 e0       	ldi	r31, 0x00	; 0
     b2a:	ee 0f       	add	r30, r30
     b2c:	ff 1f       	adc	r31, r31
     b2e:	e4 0f       	add	r30, r20
     b30:	f5 1f       	adc	r31, r21
     b32:	81 81       	ldd	r24, Z+1	; 0x01
     b34:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     b36:	80 81       	ld	r24, Z
     b38:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     b3a:	65 e0       	ldi	r22, 0x05	; 5
     b3c:	70 e0       	ldi	r23, 0x00	; 0
     b3e:	ce 01       	movw	r24, r28
     b40:	c8 df       	rcall	.-112    	; 0xad2 <_Z5CRC16Phi>
	function04->CRC = crc16;
     b42:	9e 83       	std	Y+6, r25	; 0x06
     b44:	8d 83       	std	Y+5, r24	; 0x05
}
     b46:	df 91       	pop	r29
     b48:	cf 91       	pop	r28
     b4a:	08 95       	ret

00000b4c <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     b4c:	cf 93       	push	r28
     b4e:	df 93       	push	r29
     b50:	fc 01       	movw	r30, r24
     b52:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     b54:	80 81       	ld	r24, Z
     b56:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     b58:	81 81       	ldd	r24, Z+1	; 0x01
     b5a:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     b5c:	82 81       	ldd	r24, Z+2	; 0x02
     b5e:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     b60:	83 81       	ldd	r24, Z+3	; 0x03
     b62:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     b64:	84 81       	ldd	r24, Z+4	; 0x04
     b66:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     b68:	85 81       	ldd	r24, Z+5	; 0x05
     b6a:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     b6c:	66 e0       	ldi	r22, 0x06	; 6
     b6e:	70 e0       	ldi	r23, 0x00	; 0
     b70:	ce 01       	movw	r24, r28
     b72:	af df       	rcall	.-162    	; 0xad2 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     b74:	9f 83       	std	Y+7, r25	; 0x07
     b76:	8e 83       	std	Y+6, r24	; 0x06
}
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	08 95       	ret

00000b7e <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     b7e:	cf 93       	push	r28
     b80:	df 93       	push	r29
     b82:	fc 01       	movw	r30, r24
     b84:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     b86:	80 81       	ld	r24, Z
     b88:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     b8a:	81 81       	ldd	r24, Z+1	; 0x01
     b8c:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     b8e:	82 81       	ldd	r24, Z+2	; 0x02
     b90:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     b92:	83 81       	ldd	r24, Z+3	; 0x03
     b94:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     b96:	94 81       	ldd	r25, Z+4	; 0x04
     b98:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     b9a:	95 81       	ldd	r25, Z+5	; 0x05
     b9c:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     b9e:	96 81       	ldd	r25, Z+6	; 0x06
     ba0:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     ba2:	27 81       	ldd	r18, Z+7	; 0x07
     ba4:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     ba6:	90 85       	ldd	r25, Z+8	; 0x08
     ba8:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     baa:	e8 2f       	mov	r30, r24
     bac:	f0 e0       	ldi	r31, 0x00	; 0
     bae:	ee 0f       	add	r30, r30
     bb0:	ff 1f       	adc	r31, r31
     bb2:	e4 0f       	add	r30, r20
     bb4:	f5 1f       	adc	r31, r21
     bb6:	89 2f       	mov	r24, r25
     bb8:	90 e0       	ldi	r25, 0x00	; 0
     bba:	92 2b       	or	r25, r18
     bbc:	91 83       	std	Z+1, r25	; 0x01
     bbe:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     bc0:	69 e0       	ldi	r22, 0x09	; 9
     bc2:	70 e0       	ldi	r23, 0x00	; 0
     bc4:	ce 01       	movw	r24, r28
     bc6:	85 df       	rcall	.-246    	; 0xad2 <_Z5CRC16Phi>
	function10->CRC = crc16;
     bc8:	9a 87       	std	Y+10, r25	; 0x0a
     bca:	89 87       	std	Y+9, r24	; 0x09
}
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	08 95       	ret

00000bd2 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     bd2:	cf 93       	push	r28
     bd4:	df 93       	push	r29
     bd6:	fc 01       	movw	r30, r24
     bd8:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     bda:	80 81       	ld	r24, Z
     bdc:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     bde:	81 81       	ldd	r24, Z+1	; 0x01
     be0:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     be2:	82 81       	ldd	r24, Z+2	; 0x02
     be4:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     be6:	83 81       	ldd	r24, Z+3	; 0x03
     be8:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     bea:	84 81       	ldd	r24, Z+4	; 0x04
     bec:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     bee:	85 81       	ldd	r24, Z+5	; 0x05
     bf0:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     bf2:	66 e0       	ldi	r22, 0x06	; 6
     bf4:	70 e0       	ldi	r23, 0x00	; 0
     bf6:	ce 01       	movw	r24, r28
     bf8:	6c df       	rcall	.-296    	; 0xad2 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     bfa:	9f 83       	std	Y+7, r25	; 0x07
     bfc:	8e 83       	std	Y+6, r24	; 0x06
}
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
     c02:	08 95       	ret

00000c04 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     c04:	cf 93       	push	r28
     c06:	df 93       	push	r29
     c08:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     c0a:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     c0c:	81 e8       	ldi	r24, 0x81	; 129
     c0e:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     c10:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     c12:	63 e0       	ldi	r22, 0x03	; 3
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	ce 01       	movw	r24, r28
     c18:	5c df       	rcall	.-328    	; 0xad2 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     c1a:	9c 83       	std	Y+4, r25	; 0x04
     c1c:	8b 83       	std	Y+3, r24	; 0x03
}
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	08 95       	ret

00000c24 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     c24:	1f 93       	push	r17
     c26:	cf 93       	push	r28
     c28:	df 93       	push	r29
     c2a:	ec 01       	movw	r28, r24
     c2c:	cb 01       	movw	r24, r22
     c2e:	14 2f       	mov	r17, r20
     c30:	fe 01       	movw	r30, r28
     c32:	ea 57       	subi	r30, 0x7A	; 122
     c34:	ff 4f       	sbci	r31, 0xFF	; 255
     c36:	71 83       	std	Z+1, r23	; 0x01
     c38:	60 83       	st	Z, r22
     c3a:	64 2f       	mov	r22, r20
     c3c:	03 d3       	rcall	.+1542   	; 0x1244 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     c3e:	88 23       	and	r24, r24
     c40:	71 f0       	breq	.+28     	; 0xc5e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     c42:	fe 01       	movw	r30, r28
     c44:	eb 57       	subi	r30, 0x7B	; 123
     c46:	ff 4f       	sbci	r31, 0xFF	; 255
     c48:	10 83       	st	Z, r17
     c4a:	31 97       	sbiw	r30, 0x01	; 1
     c4c:	10 82       	st	Z, r1
     c4e:	34 97       	sbiw	r30, 0x04	; 4
     c50:	11 82       	std	Z+1, r1	; 0x01
     c52:	10 82       	st	Z, r1
     c54:	ce 57       	subi	r28, 0x7E	; 126
     c56:	df 4f       	sbci	r29, 0xFF	; 255
     c58:	19 82       	std	Y+1, r1	; 0x01
     c5a:	18 82       	st	Y, r1
     c5c:	04 c0       	rjmp	.+8      	; 0xc66 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     c5e:	ca 57       	subi	r28, 0x7A	; 122
     c60:	df 4f       	sbci	r29, 0xFF	; 255
     c62:	19 82       	std	Y+1, r1	; 0x01
     c64:	18 82       	st	Y, r1
     c66:	df 91       	pop	r29
     c68:	cf 91       	pop	r28
     c6a:	1f 91       	pop	r17
     c6c:	08 95       	ret

00000c6e <_ZN12SerialBuffernwEj>:
     c6e:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
     c72:	08 95       	ret

00000c74 <_ZN12SerialBuffer11SerialstoreEc>:
     c74:	fc 01       	movw	r30, r24
     c76:	e0 58       	subi	r30, 0x80	; 128
     c78:	ff 4f       	sbci	r31, 0xFF	; 255
     c7a:	20 81       	ld	r18, Z
     c7c:	2f 5f       	subi	r18, 0xFF	; 255
     c7e:	2f 77       	andi	r18, 0x7F	; 127
     c80:	19 f4       	brne	.+6      	; 0xc88 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     c82:	11 82       	std	Z+1, r1	; 0x01
     c84:	10 82       	st	Z, r1
     c86:	21 e0       	ldi	r18, 0x01	; 1
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	fc 01       	movw	r30, r24
     c8c:	ee 57       	subi	r30, 0x7E	; 126
     c8e:	ff 4f       	sbci	r31, 0xFF	; 255
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	24 17       	cp	r18, r20
     c96:	35 07       	cpc	r19, r21
     c98:	89 f0       	breq	.+34     	; 0xcbc <_ZN12SerialBuffer11SerialstoreEc+0x48>
     c9a:	dc 01       	movw	r26, r24
     c9c:	a0 58       	subi	r26, 0x80	; 128
     c9e:	bf 4f       	sbci	r27, 0xFF	; 255
     ca0:	ed 91       	ld	r30, X+
     ca2:	fc 91       	ld	r31, X
     ca4:	11 97       	sbiw	r26, 0x01	; 1
     ca6:	e8 0f       	add	r30, r24
     ca8:	f9 1f       	adc	r31, r25
     caa:	61 83       	std	Z+1, r22	; 0x01
     cac:	2d 93       	st	X+, r18
     cae:	3c 93       	st	X, r19
     cb0:	fc 01       	movw	r30, r24
     cb2:	ec 57       	subi	r30, 0x7C	; 124
     cb4:	ff 4f       	sbci	r31, 0xFF	; 255
     cb6:	80 81       	ld	r24, Z
     cb8:	8f 5f       	subi	r24, 0xFF	; 255
     cba:	80 83       	st	Z, r24
     cbc:	08 95       	ret

00000cbe <_ZN12SerialBuffer11SerialWriteEPKci>:
     cbe:	af 92       	push	r10
     cc0:	bf 92       	push	r11
     cc2:	cf 92       	push	r12
     cc4:	df 92       	push	r13
     cc6:	ef 92       	push	r14
     cc8:	ff 92       	push	r15
     cca:	0f 93       	push	r16
     ccc:	1f 93       	push	r17
     cce:	cf 93       	push	r28
     cd0:	8c 01       	movw	r16, r24
     cd2:	6b 01       	movw	r12, r22
     cd4:	7a 01       	movw	r14, r20
     cd6:	dc 01       	movw	r26, r24
     cd8:	ab 57       	subi	r26, 0x7B	; 123
     cda:	bf 4f       	sbci	r27, 0xFF	; 255
     cdc:	fc 01       	movw	r30, r24
     cde:	ea 57       	subi	r30, 0x7A	; 122
     ce0:	ff 4f       	sbci	r31, 0xFF	; 255
     ce2:	6c 91       	ld	r22, X
     ce4:	80 81       	ld	r24, Z
     ce6:	91 81       	ldd	r25, Z+1	; 0x01
     ce8:	ba d2       	rcall	.+1396   	; 0x125e <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     cea:	89 2b       	or	r24, r25
     cec:	d1 f0       	breq	.+52     	; 0xd22 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     cee:	1e 14       	cp	r1, r14
     cf0:	1f 04       	cpc	r1, r15
     cf2:	bc f4       	brge	.+46     	; 0xd22 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     cf4:	c0 e0       	ldi	r28, 0x00	; 0
     cf6:	58 01       	movw	r10, r16
     cf8:	85 e8       	ldi	r24, 0x85	; 133
     cfa:	a8 0e       	add	r10, r24
     cfc:	b1 1c       	adc	r11, r1
     cfe:	0a 57       	subi	r16, 0x7A	; 122
     d00:	1f 4f       	sbci	r17, 0xFF	; 255
     d02:	f6 01       	movw	r30, r12
     d04:	ec 0f       	add	r30, r28
     d06:	f1 1d       	adc	r31, r1
     d08:	40 81       	ld	r20, Z
     d0a:	f5 01       	movw	r30, r10
     d0c:	60 81       	ld	r22, Z
     d0e:	f8 01       	movw	r30, r16
     d10:	80 81       	ld	r24, Z
     d12:	91 81       	ldd	r25, Z+1	; 0x01
     d14:	50 d2       	rcall	.+1184   	; 0x11b6 <_ZN11Dev_Manager5WriteE8Dev_typec>
     d16:	cf 5f       	subi	r28, 0xFF	; 255
     d18:	2c 2f       	mov	r18, r28
     d1a:	30 e0       	ldi	r19, 0x00	; 0
     d1c:	2e 15       	cp	r18, r14
     d1e:	3f 05       	cpc	r19, r15
     d20:	84 f3       	brlt	.-32     	; 0xd02 <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     d22:	cf 91       	pop	r28
     d24:	1f 91       	pop	r17
     d26:	0f 91       	pop	r16
     d28:	ff 90       	pop	r15
     d2a:	ef 90       	pop	r14
     d2c:	df 90       	pop	r13
     d2e:	cf 90       	pop	r12
     d30:	bf 90       	pop	r11
     d32:	af 90       	pop	r10
     d34:	08 95       	ret

00000d36 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     d36:	fc 01       	movw	r30, r24
     d38:	ee 57       	subi	r30, 0x7E	; 126
     d3a:	ff 4f       	sbci	r31, 0xFF	; 255
     d3c:	20 81       	ld	r18, Z
     d3e:	31 81       	ldd	r19, Z+1	; 0x01
     d40:	32 97       	sbiw	r30, 0x02	; 2
     d42:	40 81       	ld	r20, Z
     d44:	51 81       	ldd	r21, Z+1	; 0x01
     d46:	42 17       	cp	r20, r18
     d48:	53 07       	cpc	r21, r19
     d4a:	e9 f0       	breq	.+58     	; 0xd86 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     d4c:	2f 5f       	subi	r18, 0xFF	; 255
     d4e:	3f 4f       	sbci	r19, 0xFF	; 255
     d50:	fc 01       	movw	r30, r24
     d52:	e2 0f       	add	r30, r18
     d54:	f3 1f       	adc	r31, r19
     d56:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     d58:	2f 77       	andi	r18, 0x7F	; 127
     d5a:	33 27       	eor	r19, r19
     d5c:	fc 01       	movw	r30, r24
     d5e:	ee 57       	subi	r30, 0x7E	; 126
     d60:	ff 4f       	sbci	r31, 0xFF	; 255
     d62:	31 83       	std	Z+1, r19	; 0x01
     d64:	20 83       	st	Z, r18
		if (ib.tail == num)
     d66:	32 96       	adiw	r30, 0x02	; 2
     d68:	60 81       	ld	r22, Z
     d6a:	70 e0       	ldi	r23, 0x00	; 0
     d6c:	26 17       	cp	r18, r22
     d6e:	37 07       	cpc	r19, r23
     d70:	61 f4       	brne	.+24     	; 0xd8a <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     d72:	32 97       	sbiw	r30, 0x02	; 2
     d74:	11 82       	std	Z+1, r1	; 0x01
     d76:	10 82       	st	Z, r1
			ib.head = 0;
     d78:	32 97       	sbiw	r30, 0x02	; 2
     d7a:	11 82       	std	Z+1, r1	; 0x01
     d7c:	10 82       	st	Z, r1
			num = 0;
     d7e:	34 96       	adiw	r30, 0x04	; 4
     d80:	10 82       	st	Z, r1
		}
		return data;
     d82:	84 2f       	mov	r24, r20
     d84:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     d86:	8f ef       	ldi	r24, 0xFF	; 255
     d88:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     d8a:	84 2f       	mov	r24, r20
	}
}
     d8c:	08 95       	ret

00000d8e <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     d8e:	dc 01       	movw	r26, r24
     d90:	a0 58       	subi	r26, 0x80	; 128
     d92:	bf 4f       	sbci	r27, 0xFF	; 255
     d94:	fc 01       	movw	r30, r24
     d96:	ee 57       	subi	r30, 0x7E	; 126
     d98:	ff 4f       	sbci	r31, 0xFF	; 255
     d9a:	8c 91       	ld	r24, X
     d9c:	90 81       	ld	r25, Z
     d9e:	89 1b       	sub	r24, r25
}
     da0:	8f 77       	andi	r24, 0x7F	; 127
     da2:	08 95       	ret

00000da4 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     da4:	fc 01       	movw	r30, r24
     da6:	ee 57       	subi	r30, 0x7E	; 126
     da8:	ff 4f       	sbci	r31, 0xFF	; 255
     daa:	11 82       	std	Z+1, r1	; 0x01
     dac:	10 82       	st	Z, r1
	ib.head = 0;
     dae:	32 97       	sbiw	r30, 0x02	; 2
     db0:	11 82       	std	Z+1, r1	; 0x01
     db2:	10 82       	st	Z, r1
	num = 0;
     db4:	34 96       	adiw	r30, 0x04	; 4
     db6:	10 82       	st	Z, r1
     db8:	08 95       	ret

00000dba <_ZN22DFRobotHighTemperatureC1Ef>:
DFRobotHighTemperature::DFRobotHighTemperature(float v)  //Constructor
{
	_voltageRef = v;
}

DFRobotHighTemperature::~DFRobotHighTemperature()		//Destructor
     dba:	fc 01       	movw	r30, r24
     dbc:	40 83       	st	Z, r20
     dbe:	51 83       	std	Z+1, r21	; 0x01
     dc0:	62 83       	std	Z+2, r22	; 0x02
     dc2:	73 83       	std	Z+3, r23	; 0x03
     dc4:	08 95       	ret

00000dc6 <_ZN22DFRobotHighTemperature4compEfi>:
            mid = front + (end - front) / 2;
        }
    return mid;
}
int DFRobotHighTemperature::comp(float pt, int i) //Which number is closer on the two adjacent numbers.
{
     dc6:	4f 92       	push	r4
     dc8:	5f 92       	push	r5
     dca:	6f 92       	push	r6
     dcc:	7f 92       	push	r7
     dce:	8f 92       	push	r8
     dd0:	9f 92       	push	r9
     dd2:	af 92       	push	r10
     dd4:	bf 92       	push	r11
     dd6:	cf 92       	push	r12
     dd8:	df 92       	push	r13
     dda:	ef 92       	push	r14
     ddc:	ff 92       	push	r15
     dde:	0f 93       	push	r16
     de0:	1f 93       	push	r17
     de2:	cf 93       	push	r28
     de4:	df 93       	push	r29
     de6:	cb 01       	movw	r24, r22
     de8:	ba 01       	movw	r22, r20
     dea:	e9 01       	movw	r28, r18
    if ((pt - pgm_read_float(&PT100Tab[i])) > (pgm_read_float(&PT100Tab[i + 1]) - pgm_read_float(&PT100Tab[i])) / 2 )
     dec:	22 0f       	add	r18, r18
     dee:	33 1f       	adc	r19, r19
     df0:	22 0f       	add	r18, r18
     df2:	33 1f       	adc	r19, r19
     df4:	d9 01       	movw	r26, r18
     df6:	a4 57       	subi	r26, 0x74	; 116
     df8:	bf 4f       	sbci	r27, 0xFF	; 255
     dfa:	fd 01       	movw	r30, r26
     dfc:	25 91       	lpm	r18, Z+
     dfe:	35 91       	lpm	r19, Z+
     e00:	45 91       	lpm	r20, Z+
     e02:	54 91       	lpm	r21, Z
     e04:	8e 01       	movw	r16, r28
     e06:	0f 5f       	subi	r16, 0xFF	; 255
     e08:	1f 4f       	sbci	r17, 0xFF	; 255
     e0a:	f8 01       	movw	r30, r16
     e0c:	ee 0f       	add	r30, r30
     e0e:	ff 1f       	adc	r31, r31
     e10:	ee 0f       	add	r30, r30
     e12:	ff 1f       	adc	r31, r31
     e14:	e4 57       	subi	r30, 0x74	; 116
     e16:	ff 4f       	sbci	r31, 0xFF	; 255
     e18:	85 90       	lpm	r8, Z+
     e1a:	95 90       	lpm	r9, Z+
     e1c:	a5 90       	lpm	r10, Z+
     e1e:	b4 90       	lpm	r11, Z
     e20:	fd 01       	movw	r30, r26
     e22:	45 90       	lpm	r4, Z+
     e24:	55 90       	lpm	r5, Z+
     e26:	65 90       	lpm	r6, Z+
     e28:	74 90       	lpm	r7, Z
     e2a:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
     e2e:	6b 01       	movw	r12, r22
     e30:	7c 01       	movw	r14, r24
     e32:	a3 01       	movw	r20, r6
     e34:	92 01       	movw	r18, r4
     e36:	c5 01       	movw	r24, r10
     e38:	b4 01       	movw	r22, r8
     e3a:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
     e3e:	20 e0       	ldi	r18, 0x00	; 0
     e40:	30 e0       	ldi	r19, 0x00	; 0
     e42:	40 e0       	ldi	r20, 0x00	; 0
     e44:	5f e3       	ldi	r21, 0x3F	; 63
     e46:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
     e4a:	9b 01       	movw	r18, r22
     e4c:	ac 01       	movw	r20, r24
     e4e:	c7 01       	movw	r24, r14
     e50:	b6 01       	movw	r22, r12
     e52:	0e 94 35 22 	call	0x446a	; 0x446a <__gesf2>
     e56:	18 16       	cp	r1, r24
     e58:	0c f0       	brlt	.+2      	; 0xe5c <_ZN22DFRobotHighTemperature4compEfi+0x96>
        return i + 1;
    else
        return i;
     e5a:	8e 01       	movw	r16, r28
}
     e5c:	c8 01       	movw	r24, r16
     e5e:	df 91       	pop	r29
     e60:	cf 91       	pop	r28
     e62:	1f 91       	pop	r17
     e64:	0f 91       	pop	r16
     e66:	ff 90       	pop	r15
     e68:	ef 90       	pop	r14
     e6a:	df 90       	pop	r13
     e6c:	cf 90       	pop	r12
     e6e:	bf 90       	pop	r11
     e70:	af 90       	pop	r10
     e72:	9f 90       	pop	r9
     e74:	8f 90       	pop	r8
     e76:	7f 90       	pop	r7
     e78:	6f 90       	pop	r6
     e7a:	5f 90       	pop	r5
     e7c:	4f 90       	pop	r4
     e7e:	08 95       	ret

00000e80 <_ZN22DFRobotHighTemperature15readTemperatureEj>:
DFRobotHighTemperature::~DFRobotHighTemperature()		//Destructor
{
	
}
int DFRobotHighTemperature::readTemperature(unsigned int sensorValue)     //Get temperature
{
     e80:	4f 92       	push	r4
     e82:	5f 92       	push	r5
     e84:	6f 92       	push	r6
     e86:	7f 92       	push	r7
     e88:	af 92       	push	r10
     e8a:	bf 92       	push	r11
     e8c:	cf 92       	push	r12
     e8e:	df 92       	push	r13
     e90:	ef 92       	push	r14
     e92:	ff 92       	push	r15
     e94:	0f 93       	push	r16
     e96:	1f 93       	push	r17
     e98:	cf 93       	push	r28
     e9a:	df 93       	push	r29
     e9c:	5c 01       	movw	r10, r24
    float voltage = 0,res = 0;
    voltage = sensorValue * 0.0048828125;//_voltageRef / 1024.0;  //If your microcontroller are a 12 bit ADC, you should be change 1024 to 4096
     e9e:	80 e0       	ldi	r24, 0x00	; 0
     ea0:	90 e0       	ldi	r25, 0x00	; 0
     ea2:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
     ea6:	20 e0       	ldi	r18, 0x00	; 0
     ea8:	30 e0       	ldi	r19, 0x00	; 0
     eaa:	40 ea       	ldi	r20, 0xA0	; 160
     eac:	5b e3       	ldi	r21, 0x3B	; 59
     eae:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
     eb2:	6b 01       	movw	r12, r22
     eb4:	7c 01       	movw	r14, r24
	//If you have a DS18B20 on hand, you can make a more accurate calibration.
	//change 220.9 to 210.9 or 230.9,and you need change 2.209 to 2.109 or 2.309 at the same time to accurate calibration.
	res =  (1800 * voltage + 220.9 * 18) / (2.209 * 18 - voltage);
     eb6:	20 e0       	ldi	r18, 0x00	; 0
     eb8:	30 e0       	ldi	r19, 0x00	; 0
     eba:	41 ee       	ldi	r20, 0xE1	; 225
     ebc:	54 e4       	ldi	r21, 0x44	; 68
     ebe:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
     ec2:	23 e3       	ldi	r18, 0x33	; 51
     ec4:	33 e8       	ldi	r19, 0x83	; 131
     ec6:	48 e7       	ldi	r20, 0x78	; 120
     ec8:	55 e4       	ldi	r21, 0x45	; 69
     eca:	0e 94 82 20 	call	0x4104	; 0x4104 <__addsf3>
     ece:	2b 01       	movw	r4, r22
     ed0:	3c 01       	movw	r6, r24
     ed2:	a7 01       	movw	r20, r14
     ed4:	96 01       	movw	r18, r12
     ed6:	6a e4       	ldi	r22, 0x4A	; 74
     ed8:	7c e0       	ldi	r23, 0x0C	; 12
     eda:	8f e1       	ldi	r24, 0x1F	; 31
     edc:	92 e4       	ldi	r25, 0x42	; 66
     ede:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
     ee2:	9b 01       	movw	r18, r22
     ee4:	ac 01       	movw	r20, r24
     ee6:	c3 01       	movw	r24, r6
     ee8:	b2 01       	movw	r22, r4
     eea:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <__divsf3>
     eee:	2b 01       	movw	r4, r22
     ef0:	3c 01       	movw	r6, r24
	//res =  (1800 * voltage + 235.9 * 18) / (2.359 * 18 - voltage);
	//searched by the halving method
    int front = 0, end = 0, mid = 0;
    front = 0;
    end = 399;
    mid = (front + end) / 2;
     ef2:	c7 ec       	ldi	r28, 0xC7	; 199
     ef4:	d0 e0       	ldi	r29, 0x00	; 0
	res =  (1800 * voltage + 220.9 * 18) / (2.209 * 18 - voltage);
	//res =  (1800 * voltage + 235.9 * 18) / (2.359 * 18 - voltage);
	//searched by the halving method
    int front = 0, end = 0, mid = 0;
    front = 0;
    end = 399;
     ef6:	0f 2e       	mov	r0, r31
     ef8:	ff e8       	ldi	r31, 0x8F	; 143
     efa:	cf 2e       	mov	r12, r31
     efc:	dd 24       	eor	r13, r13
     efe:	d3 94       	inc	r13
     f00:	f0 2d       	mov	r31, r0
	//change 220.9 to 210.9 or 230.9,and you need change 2.209 to 2.109 or 2.309 at the same time to accurate calibration.
	res =  (1800 * voltage + 220.9 * 18) / (2.209 * 18 - voltage);
	//res =  (1800 * voltage + 235.9 * 18) / (2.359 * 18 - voltage);
	//searched by the halving method
    int front = 0, end = 0, mid = 0;
    front = 0;
     f02:	e1 2c       	mov	r14, r1
     f04:	f1 2c       	mov	r15, r1
    end = 399;
    mid = (front + end) / 2;
    while (front < end && pgm_read_float(&PT100Tab[mid]) != res)  
     f06:	8e 01       	movw	r16, r28
     f08:	00 0f       	add	r16, r16
     f0a:	11 1f       	adc	r17, r17
     f0c:	00 0f       	add	r16, r16
     f0e:	11 1f       	adc	r17, r17
     f10:	04 57       	subi	r16, 0x74	; 116
     f12:	1f 4f       	sbci	r17, 0xFF	; 255
     f14:	f8 01       	movw	r30, r16
     f16:	25 91       	lpm	r18, Z+
     f18:	35 91       	lpm	r19, Z+
     f1a:	45 91       	lpm	r20, Z+
     f1c:	54 91       	lpm	r21, Z
     f1e:	c3 01       	movw	r24, r6
     f20:	b2 01       	movw	r22, r4
     f22:	0e 94 e6 20 	call	0x41cc	; 0x41cc <__cmpsf2>
     f26:	81 11       	cpse	r24, r1
     f28:	50 c0       	rjmp	.+160    	; 0xfca <_ZN22DFRobotHighTemperature15readTemperatureEj+0x14a>
     f2a:	5c c0       	rjmp	.+184    	; 0xfe4 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x164>
        {
            if (pgm_read_float(&PT100Tab[mid]) < res)
                if (pgm_read_float(&PT100Tab[mid + 1]) < res)
     f2c:	7e 01       	movw	r14, r28
     f2e:	8f ef       	ldi	r24, 0xFF	; 255
     f30:	e8 1a       	sub	r14, r24
     f32:	f8 0a       	sbc	r15, r24
     f34:	f7 01       	movw	r30, r14
     f36:	ee 0f       	add	r30, r30
     f38:	ff 1f       	adc	r31, r31
     f3a:	ee 0f       	add	r30, r30
     f3c:	ff 1f       	adc	r31, r31
     f3e:	e4 57       	subi	r30, 0x74	; 116
     f40:	ff 4f       	sbci	r31, 0xFF	; 255
     f42:	25 91       	lpm	r18, Z+
     f44:	35 91       	lpm	r19, Z+
     f46:	45 91       	lpm	r20, Z+
     f48:	54 91       	lpm	r21, Z
     f4a:	c3 01       	movw	r24, r6
     f4c:	b2 01       	movw	r22, r4
     f4e:	0e 94 35 22 	call	0x446a	; 0x446a <__gesf2>
     f52:	18 16       	cp	r1, r24
     f54:	34 f0       	brlt	.+12     	; 0xf62 <_ZN22DFRobotHighTemperature15readTemperatureEj+0xe2>
                    front = mid + 1;
                else
                    {
                        mid = comp(res, mid);
     f56:	9e 01       	movw	r18, r28
     f58:	b3 01       	movw	r22, r6
     f5a:	a2 01       	movw	r20, r4
     f5c:	c5 01       	movw	r24, r10
     f5e:	33 df       	rcall	.-410    	; 0xdc6 <_ZN22DFRobotHighTemperature4compEfi>
                        return mid;
     f60:	43 c0       	rjmp	.+134    	; 0xfe8 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x168>
                    }
            if (pgm_read_float(&PT100Tab[mid]) > res)
     f62:	f8 01       	movw	r30, r16
     f64:	25 91       	lpm	r18, Z+
     f66:	35 91       	lpm	r19, Z+
     f68:	45 91       	lpm	r20, Z+
     f6a:	54 91       	lpm	r21, Z
     f6c:	c3 01       	movw	r24, r6
     f6e:	b2 01       	movw	r22, r4
     f70:	0e 94 e6 20 	call	0x41cc	; 0x41cc <__cmpsf2>
     f74:	88 23       	and	r24, r24
     f76:	dc f4       	brge	.+54     	; 0xfae <_ZN22DFRobotHighTemperature15readTemperatureEj+0x12e>
                if (pgm_read_float(&PT100Tab[mid - 1]) > res)
     f78:	6e 01       	movw	r12, r28
     f7a:	81 e0       	ldi	r24, 0x01	; 1
     f7c:	c8 1a       	sub	r12, r24
     f7e:	d1 08       	sbc	r13, r1
     f80:	f6 01       	movw	r30, r12
     f82:	ee 0f       	add	r30, r30
     f84:	ff 1f       	adc	r31, r31
     f86:	ee 0f       	add	r30, r30
     f88:	ff 1f       	adc	r31, r31
     f8a:	e4 57       	subi	r30, 0x74	; 116
     f8c:	ff 4f       	sbci	r31, 0xFF	; 255
     f8e:	25 91       	lpm	r18, Z+
     f90:	35 91       	lpm	r19, Z+
     f92:	45 91       	lpm	r20, Z+
     f94:	54 91       	lpm	r21, Z
     f96:	c3 01       	movw	r24, r6
     f98:	b2 01       	movw	r22, r4
     f9a:	0e 94 e6 20 	call	0x41cc	; 0x41cc <__cmpsf2>
     f9e:	88 23       	and	r24, r24
     fa0:	34 f0       	brlt	.+12     	; 0xfae <_ZN22DFRobotHighTemperature15readTemperatureEj+0x12e>
                    end = mid - 1;
                else
                    {
                        mid = comp(res, mid - 1);
     fa2:	96 01       	movw	r18, r12
     fa4:	b3 01       	movw	r22, r6
     fa6:	a2 01       	movw	r20, r4
     fa8:	c5 01       	movw	r24, r10
     faa:	0d df       	rcall	.-486    	; 0xdc6 <_ZN22DFRobotHighTemperature4compEfi>
                        return mid;
     fac:	1d c0       	rjmp	.+58     	; 0xfe8 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x168>
                    }
            mid = front + (end - front) / 2;
     fae:	c6 01       	movw	r24, r12
     fb0:	8e 19       	sub	r24, r14
     fb2:	9f 09       	sbc	r25, r15
     fb4:	ec 01       	movw	r28, r24
     fb6:	0a f4       	brpl	.+2      	; 0xfba <_ZN22DFRobotHighTemperature15readTemperatureEj+0x13a>
     fb8:	21 96       	adiw	r28, 0x01	; 1
     fba:	d5 95       	asr	r29
     fbc:	c7 95       	ror	r28
     fbe:	ce 0d       	add	r28, r14
     fc0:	df 1d       	adc	r29, r15
	//searched by the halving method
    int front = 0, end = 0, mid = 0;
    front = 0;
    end = 399;
    mid = (front + end) / 2;
    while (front < end && pgm_read_float(&PT100Tab[mid]) != res)  
     fc2:	ec 14       	cp	r14, r12
     fc4:	fd 04       	cpc	r15, r13
     fc6:	74 f4       	brge	.+28     	; 0xfe4 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x164>
     fc8:	9e cf       	rjmp	.-196    	; 0xf06 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x86>
        {
            if (pgm_read_float(&PT100Tab[mid]) < res)
     fca:	f8 01       	movw	r30, r16
     fcc:	25 91       	lpm	r18, Z+
     fce:	35 91       	lpm	r19, Z+
     fd0:	45 91       	lpm	r20, Z+
     fd2:	54 91       	lpm	r21, Z
     fd4:	c3 01       	movw	r24, r6
     fd6:	b2 01       	movw	r22, r4
     fd8:	0e 94 35 22 	call	0x446a	; 0x446a <__gesf2>
     fdc:	18 16       	cp	r1, r24
     fde:	0c f4       	brge	.+2      	; 0xfe2 <_ZN22DFRobotHighTemperature15readTemperatureEj+0x162>
     fe0:	a5 cf       	rjmp	.-182    	; 0xf2c <_ZN22DFRobotHighTemperature15readTemperatureEj+0xac>
     fe2:	bf cf       	rjmp	.-130    	; 0xf62 <_ZN22DFRobotHighTemperature15readTemperatureEj+0xe2>
                if (pgm_read_float(&PT100Tab[mid - 1]) > res)
                    end = mid - 1;
                else
                    {
                        mid = comp(res, mid - 1);
                        return mid;
     fe4:	8c 2f       	mov	r24, r28
     fe6:	9d 2f       	mov	r25, r29
                    }
            mid = front + (end - front) / 2;
        }
    return mid;
}
     fe8:	df 91       	pop	r29
     fea:	cf 91       	pop	r28
     fec:	1f 91       	pop	r17
     fee:	0f 91       	pop	r16
     ff0:	ff 90       	pop	r15
     ff2:	ef 90       	pop	r14
     ff4:	df 90       	pop	r13
     ff6:	cf 90       	pop	r12
     ff8:	bf 90       	pop	r11
     ffa:	af 90       	pop	r10
     ffc:	7f 90       	pop	r7
     ffe:	6f 90       	pop	r6
    1000:	5f 90       	pop	r5
    1002:	4f 90       	pop	r4
    1004:	08 95       	ret

00001006 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
	virtual void Device_Writes(const char* data){}
    1006:	08 95       	ret

00001008 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
    1008:	08 95       	ret

0000100a <_ZN20DeviceDriveInterFace11Stop_DeviceEv>:
	virtual void Stop_Device(void){}
    100a:	08 95       	ret

0000100c <_ZN3Adc11Device_InitEv>:
{
	return channel_inf;
}
void Adc::Read_Set()
{
	read_flag = 0;
    100c:	80 e4       	ldi	r24, 0x40	; 64
    100e:	87 b9       	out	0x07, r24	; 7
    1010:	87 e8       	ldi	r24, 0x87	; 135
    1012:	86 b9       	out	0x06, r24	; 6
    1014:	08 95       	ret

00001016 <_ZN3Adc12Start_DeviceEh>:
    1016:	36 99       	sbic	0x06, 6	; 6
    1018:	fe cf       	rjmp	.-4      	; 0x1016 <_ZN3Adc12Start_DeviceEh>
    101a:	87 b1       	in	r24, 0x07	; 7
    101c:	80 7e       	andi	r24, 0xE0	; 224
    101e:	68 2b       	or	r22, r24
    1020:	67 b9       	out	0x07, r22	; 7
    1022:	36 9a       	sbi	0x06, 6	; 6
    1024:	08 95       	ret

00001026 <_ZNK3Adc11Device_ReadEv>:
    1026:	fc 01       	movw	r30, r24
    1028:	82 81       	ldd	r24, Z+2	; 0x02
    102a:	08 95       	ret

0000102c <_ZN3AdcnwEj>:
}
void* Adc::operator new(size_t size)
{
	return malloc(size);
    102c:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
}
    1030:	08 95       	ret

00001032 <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
    1032:	8c e0       	ldi	r24, 0x0C	; 12
    1034:	83 bf       	out	0x33, r24	; 51
    1036:	8c e7       	ldi	r24, 0x7C	; 124
    1038:	81 bf       	out	0x31, r24	; 49
    103a:	87 b7       	in	r24, 0x37	; 55
    103c:	82 60       	ori	r24, 0x02	; 2
    103e:	87 bf       	out	0x37, r24	; 55
    1040:	08 95       	ret

00001042 <Alarm_Stop>:
    1042:	87 b7       	in	r24, 0x37	; 55
    1044:	8d 7f       	andi	r24, 0xFD	; 253
    1046:	87 bf       	out	0x37, r24	; 55
    1048:	08 95       	ret

0000104a <Alarm_Start>:
    104a:	87 b7       	in	r24, 0x37	; 55
    104c:	82 60       	ori	r24, 0x02	; 2
    104e:	87 bf       	out	0x37, r24	; 55
    1050:	08 95       	ret

00001052 <Alarm_Open>:
    1052:	90 e0       	ldi	r25, 0x00	; 0
    1054:	fc 01       	movw	r30, r24
    1056:	ee 0f       	add	r30, r30
    1058:	ff 1f       	adc	r31, r31
    105a:	df 01       	movw	r26, r30
    105c:	a8 0f       	add	r26, r24
    105e:	b9 1f       	adc	r27, r25
    1060:	aa 0f       	add	r26, r26
    1062:	bb 1f       	adc	r27, r27
    1064:	a4 54       	subi	r26, 0x44	; 68
    1066:	be 4f       	sbci	r27, 0xFE	; 254
    1068:	11 96       	adiw	r26, 0x01	; 1
    106a:	7c 93       	st	X, r23
    106c:	6e 93       	st	-X, r22
    106e:	13 96       	adiw	r26, 0x03	; 3
    1070:	1c 92       	st	X, r1
    1072:	1e 92       	st	-X, r1
    1074:	12 97       	sbiw	r26, 0x02	; 2
    1076:	fd 01       	movw	r30, r26
    1078:	55 83       	std	Z+5, r21	; 0x05
    107a:	44 83       	std	Z+4, r20	; 0x04
    107c:	08 95       	ret

0000107e <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
    107e:	1f 92       	push	r1
    1080:	0f 92       	push	r0
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	0f 92       	push	r0
    1086:	11 24       	eor	r1, r1
    1088:	0b b6       	in	r0, 0x3b	; 59
    108a:	0f 92       	push	r0
    108c:	ef 92       	push	r14
    108e:	ff 92       	push	r15
    1090:	0f 93       	push	r16
    1092:	1f 93       	push	r17
    1094:	2f 93       	push	r18
    1096:	3f 93       	push	r19
    1098:	4f 93       	push	r20
    109a:	5f 93       	push	r21
    109c:	6f 93       	push	r22
    109e:	7f 93       	push	r23
    10a0:	8f 93       	push	r24
    10a2:	9f 93       	push	r25
    10a4:	af 93       	push	r26
    10a6:	bf 93       	push	r27
    10a8:	cf 93       	push	r28
    10aa:	df 93       	push	r29
    10ac:	ef 93       	push	r30
    10ae:	ff 93       	push	r31
    10b0:	cc eb       	ldi	r28, 0xBC	; 188
    10b2:	d1 e0       	ldi	r29, 0x01	; 1
    10b4:	0f 2e       	mov	r0, r31
    10b6:	fa ed       	ldi	r31, 0xDA	; 218
    10b8:	ef 2e       	mov	r14, r31
    10ba:	f1 e0       	ldi	r31, 0x01	; 1
    10bc:	ff 2e       	mov	r15, r31
    10be:	f0 2d       	mov	r31, r0
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
    10c0:	ec 81       	ldd	r30, Y+4	; 0x04
    10c2:	fd 81       	ldd	r31, Y+5	; 0x05
    10c4:	30 97       	sbiw	r30, 0x00	; 0
    10c6:	79 f0       	breq	.+30     	; 0x10e6 <__vector_15+0x68>
		{
			AlarmTable[i].Time++;
    10c8:	8a 81       	ldd	r24, Y+2	; 0x02
    10ca:	9b 81       	ldd	r25, Y+3	; 0x03
    10cc:	01 96       	adiw	r24, 0x01	; 1
    10ce:	9b 83       	std	Y+3, r25	; 0x03
    10d0:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
    10d2:	28 81       	ld	r18, Y
    10d4:	39 81       	ldd	r19, Y+1	; 0x01
    10d6:	82 17       	cp	r24, r18
    10d8:	93 07       	cpc	r25, r19
    10da:	29 f4       	brne	.+10     	; 0x10e6 <__vector_15+0x68>
			{
				AlarmTable[i].Time = 0;
    10dc:	1b 82       	std	Y+3, r1	; 0x03
    10de:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
    10e0:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
    10e2:	1d 82       	std	Y+5, r1	; 0x05
    10e4:	1c 82       	std	Y+4, r1	; 0x04
    10e6:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
    10e8:	ce 15       	cp	r28, r14
    10ea:	df 05       	cpc	r29, r15
    10ec:	49 f7       	brne	.-46     	; 0x10c0 <__vector_15+0x42>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
    10ee:	ff 91       	pop	r31
    10f0:	ef 91       	pop	r30
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	bf 91       	pop	r27
    10f8:	af 91       	pop	r26
    10fa:	9f 91       	pop	r25
    10fc:	8f 91       	pop	r24
    10fe:	7f 91       	pop	r23
    1100:	6f 91       	pop	r22
    1102:	5f 91       	pop	r21
    1104:	4f 91       	pop	r20
    1106:	3f 91       	pop	r19
    1108:	2f 91       	pop	r18
    110a:	1f 91       	pop	r17
    110c:	0f 91       	pop	r16
    110e:	ff 90       	pop	r15
    1110:	ef 90       	pop	r14
    1112:	0f 90       	pop	r0
    1114:	0b be       	out	0x3b, r0	; 59
    1116:	0f 90       	pop	r0
    1118:	0f be       	out	0x3f, r0	; 63
    111a:	0f 90       	pop	r0
    111c:	1f 90       	pop	r1
    111e:	18 95       	reti

00001120 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
    1120:	80 e0       	ldi	r24, 0x00	; 0
    1122:	08 95       	ret

00001124 <_ZN20DeviceDriveInterFace12Start_DeviceEh>:
	virtual void Device_Writes(const char* data){}
	virtual void Device_Write(char data){}
	virtual void Stop_Device(void){}
	virtual void Start_Device(unsigned char){}
    1124:	08 95       	ret

00001126 <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
    1126:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
    1128:	8f ef       	ldi	r24, 0xFF	; 255
    112a:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
    112c:	ea e6       	ldi	r30, 0x6A	; 106
    112e:	f0 e0       	ldi	r31, 0x00	; 0
    1130:	80 81       	ld	r24, Z
    1132:	82 60       	ori	r24, 0x02	; 2
    1134:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
    1136:	80 81       	ld	r24, Z
    1138:	8e 7f       	andi	r24, 0xFE	; 254
    113a:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
    113c:	89 b7       	in	r24, 0x39	; 57
    113e:	81 60       	ori	r24, 0x01	; 1
    1140:	89 bf       	out	0x39, r24	; 57
    1142:	08 95       	ret

00001144 <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
    1144:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
}
    1148:	08 95       	ret

0000114a <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
    114a:	2a e0       	ldi	r18, 0x0A	; 10
    114c:	dc 01       	movw	r26, r24
    114e:	e2 2f       	mov	r30, r18
    1150:	1d 92       	st	X+, r1
    1152:	ea 95       	dec	r30
    1154:	e9 f7       	brne	.-6      	; 0x1150 <_ZN11Dev_ManagerC1Ev+0x6>
    1156:	fc 01       	movw	r30, r24
    1158:	3a 96       	adiw	r30, 0x0a	; 10
    115a:	df 01       	movw	r26, r30
    115c:	1d 92       	st	X+, r1
    115e:	2a 95       	dec	r18
    1160:	e9 f7       	brne	.-6      	; 0x115c <_ZN11Dev_ManagerC1Ev+0x12>
    1162:	90 93 db 01 	sts	0x01DB, r25	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
    1166:	80 93 da 01 	sts	0x01DA, r24	; 0x8001da <_ZN11Dev_Manager4instE>
    116a:	08 95       	ret

0000116c <_ZN11Dev_Manager11getInstanceEv>:
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <_ZN11Dev_Manager4instE>
    1174:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
    1178:	89 2b       	or	r24, r25
    117a:	51 f4       	brne	.+20     	; 0x1190 <_ZN11Dev_Manager11getInstanceEv+0x24>
    117c:	84 e1       	ldi	r24, 0x14	; 20
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	0e 94 19 17 	call	0x2e32	; 0x2e32 <pvPortMalloc>
    1184:	ec 01       	movw	r28, r24
    1186:	e1 df       	rcall	.-62     	; 0x114a <_ZN11Dev_ManagerC1Ev>
    1188:	d0 93 db 01 	sts	0x01DB, r29	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
    118c:	c0 93 da 01 	sts	0x01DA, r28	; 0x8001da <_ZN11Dev_Manager4instE>
    1190:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <_ZN11Dev_Manager4instE>
    1194:	90 91 db 01 	lds	r25, 0x01DB	; 0x8001db <_ZN11Dev_Manager4instE+0x1>
    1198:	df 91       	pop	r29
    119a:	cf 91       	pop	r28
    119c:	08 95       	ret

0000119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
    119e:	50 e0       	ldi	r21, 0x00	; 0
    11a0:	44 0f       	add	r20, r20
    11a2:	55 1f       	adc	r21, r21
    11a4:	84 0f       	add	r24, r20
    11a6:	95 1f       	adc	r25, r21
    11a8:	fc 01       	movw	r30, r24
    11aa:	71 83       	std	Z+1, r23	; 0x01
    11ac:	60 83       	st	Z, r22
    11ae:	08 95       	ret

000011b0 <_ZN11Dev_ManagernwEj>:
    11b0:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
    11b4:	08 95       	ret

000011b6 <_ZN11Dev_Manager5WriteE8Dev_typec>:
    11b6:	26 2f       	mov	r18, r22
    11b8:	30 e0       	ldi	r19, 0x00	; 0
    11ba:	22 0f       	add	r18, r18
    11bc:	33 1f       	adc	r19, r19
    11be:	82 0f       	add	r24, r18
    11c0:	93 1f       	adc	r25, r19
    11c2:	dc 01       	movw	r26, r24
    11c4:	8d 91       	ld	r24, X+
    11c6:	9c 91       	ld	r25, X
    11c8:	00 97       	sbiw	r24, 0x00	; 0
    11ca:	41 f0       	breq	.+16     	; 0x11dc <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
    11cc:	64 2f       	mov	r22, r20
    11ce:	dc 01       	movw	r26, r24
    11d0:	ed 91       	ld	r30, X+
    11d2:	fc 91       	ld	r31, X
    11d4:	06 80       	ldd	r0, Z+6	; 0x06
    11d6:	f7 81       	ldd	r31, Z+7	; 0x07
    11d8:	e0 2d       	mov	r30, r0
    11da:	09 95       	icall
    11dc:	08 95       	ret

000011de <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
    11de:	26 2f       	mov	r18, r22
    11e0:	30 e0       	ldi	r19, 0x00	; 0
    11e2:	22 0f       	add	r18, r18
    11e4:	33 1f       	adc	r19, r19
    11e6:	82 0f       	add	r24, r18
    11e8:	93 1f       	adc	r25, r19
    11ea:	dc 01       	movw	r26, r24
    11ec:	8d 91       	ld	r24, X+
    11ee:	9c 91       	ld	r25, X
    11f0:	00 97       	sbiw	r24, 0x00	; 0
    11f2:	41 f0       	breq	.+16     	; 0x1204 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
    11f4:	ba 01       	movw	r22, r20
    11f6:	dc 01       	movw	r26, r24
    11f8:	ed 91       	ld	r30, X+
    11fa:	fc 91       	ld	r31, X
    11fc:	04 80       	ldd	r0, Z+4	; 0x04
    11fe:	f5 81       	ldd	r31, Z+5	; 0x05
    1200:	e0 2d       	mov	r30, r0
    1202:	09 95       	icall
    1204:	08 95       	ret

00001206 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
    1206:	70 e0       	ldi	r23, 0x00	; 0
    1208:	66 0f       	add	r22, r22
    120a:	77 1f       	adc	r23, r23
    120c:	86 0f       	add	r24, r22
    120e:	97 1f       	adc	r25, r23
    1210:	dc 01       	movw	r26, r24
    1212:	8d 91       	ld	r24, X+
    1214:	9c 91       	ld	r25, X
    1216:	00 97       	sbiw	r24, 0x00	; 0
    1218:	39 f0       	breq	.+14     	; 0x1228 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
    121a:	dc 01       	movw	r26, r24
    121c:	ed 91       	ld	r30, X+
    121e:	fc 91       	ld	r31, X
    1220:	01 90       	ld	r0, Z+
    1222:	f0 81       	ld	r31, Z
    1224:	e0 2d       	mov	r30, r0
    1226:	09 95       	icall
    1228:	08 95       	ret

0000122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
    122a:	e6 2f       	mov	r30, r22
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	e8 0f       	add	r30, r24
    1234:	f9 1f       	adc	r31, r25
    1236:	80 81       	ld	r24, Z
    1238:	91 81       	ldd	r25, Z+1	; 0x01
    123a:	89 2b       	or	r24, r25
    123c:	11 f0       	breq	.+4      	; 0x1242 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
    123e:	53 87       	std	Z+11, r21	; 0x0b
    1240:	42 87       	std	Z+10, r20	; 0x0a
    1242:	08 95       	ret

00001244 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
    1244:	70 e0       	ldi	r23, 0x00	; 0
    1246:	66 0f       	add	r22, r22
    1248:	77 1f       	adc	r23, r23
    124a:	fc 01       	movw	r30, r24
    124c:	e6 0f       	add	r30, r22
    124e:	f7 1f       	adc	r31, r23
    1250:	81 e0       	ldi	r24, 0x01	; 1
    1252:	20 81       	ld	r18, Z
    1254:	31 81       	ldd	r19, Z+1	; 0x01
    1256:	23 2b       	or	r18, r19
    1258:	09 f4       	brne	.+2      	; 0x125c <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
    125a:	80 e0       	ldi	r24, 0x00	; 0
    125c:	08 95       	ret

0000125e <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* const Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
    125e:	70 e0       	ldi	r23, 0x00	; 0
    1260:	66 0f       	add	r22, r22
    1262:	77 1f       	adc	r23, r23
    1264:	86 0f       	add	r24, r22
    1266:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
    1268:	fc 01       	movw	r30, r24
    126a:	80 81       	ld	r24, Z
    126c:	91 81       	ldd	r25, Z+1	; 0x01
    126e:	08 95       	ret

00001270 <__vector_18>:
ISR(USART0_RX_vect)
{
    1270:	1f 92       	push	r1
    1272:	0f 92       	push	r0
    1274:	0f b6       	in	r0, 0x3f	; 63
    1276:	0f 92       	push	r0
    1278:	11 24       	eor	r1, r1
    127a:	0b b6       	in	r0, 0x3b	; 59
    127c:	0f 92       	push	r0
    127e:	2f 93       	push	r18
    1280:	3f 93       	push	r19
    1282:	4f 93       	push	r20
    1284:	5f 93       	push	r21
    1286:	6f 93       	push	r22
    1288:	7f 93       	push	r23
    128a:	8f 93       	push	r24
    128c:	9f 93       	push	r25
    128e:	af 93       	push	r26
    1290:	bf 93       	push	r27
    1292:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
    1294:	ff 93       	push	r31
    1296:	6a df       	rcall	.-300    	; 0x116c <_ZN11Dev_Manager11getInstanceEv>
    1298:	6c b1       	in	r22, 0x0c	; 12
    129a:	70 e0       	ldi	r23, 0x00	; 0
    129c:	dc 01       	movw	r26, r24
    129e:	1a 96       	adiw	r26, 0x0a	; 10
    12a0:	ed 91       	ld	r30, X+
    12a2:	fc 91       	ld	r31, X
    12a4:	1b 97       	sbiw	r26, 0x0b	; 11
    12a6:	80 e0       	ldi	r24, 0x00	; 0
}
    12a8:	09 95       	icall
    12aa:	ff 91       	pop	r31
    12ac:	ef 91       	pop	r30
    12ae:	bf 91       	pop	r27
    12b0:	af 91       	pop	r26
    12b2:	9f 91       	pop	r25
    12b4:	8f 91       	pop	r24
    12b6:	7f 91       	pop	r23
    12b8:	6f 91       	pop	r22
    12ba:	5f 91       	pop	r21
    12bc:	4f 91       	pop	r20
    12be:	3f 91       	pop	r19
    12c0:	2f 91       	pop	r18
    12c2:	0f 90       	pop	r0
    12c4:	0b be       	out	0x3b, r0	; 59
    12c6:	0f 90       	pop	r0
    12c8:	0f be       	out	0x3f, r0	; 63
    12ca:	0f 90       	pop	r0
    12cc:	1f 90       	pop	r1
    12ce:	18 95       	reti

000012d0 <__vector_30>:
ISR(USART1_RX_vect)
{
    12d0:	1f 92       	push	r1
    12d2:	0f 92       	push	r0
    12d4:	0f b6       	in	r0, 0x3f	; 63
    12d6:	0f 92       	push	r0
    12d8:	11 24       	eor	r1, r1
    12da:	0b b6       	in	r0, 0x3b	; 59
    12dc:	0f 92       	push	r0
    12de:	2f 93       	push	r18
    12e0:	3f 93       	push	r19
    12e2:	4f 93       	push	r20
    12e4:	5f 93       	push	r21
    12e6:	6f 93       	push	r22
    12e8:	7f 93       	push	r23
    12ea:	8f 93       	push	r24
    12ec:	9f 93       	push	r25
    12ee:	af 93       	push	r26
    12f0:	bf 93       	push	r27
    12f2:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
    12f4:	ff 93       	push	r31
    12f6:	3a df       	rcall	.-396    	; 0x116c <_ZN11Dev_Manager11getInstanceEv>
    12f8:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
    12fc:	70 e0       	ldi	r23, 0x00	; 0
    12fe:	dc 01       	movw	r26, r24
    1300:	1c 96       	adiw	r26, 0x0c	; 12
    1302:	ed 91       	ld	r30, X+
    1304:	fc 91       	ld	r31, X
    1306:	1d 97       	sbiw	r26, 0x0d	; 13
    1308:	81 e0       	ldi	r24, 0x01	; 1
}
    130a:	09 95       	icall
    130c:	ff 91       	pop	r31
    130e:	ef 91       	pop	r30
    1310:	bf 91       	pop	r27
    1312:	af 91       	pop	r26
    1314:	9f 91       	pop	r25
    1316:	8f 91       	pop	r24
    1318:	7f 91       	pop	r23
    131a:	6f 91       	pop	r22
    131c:	5f 91       	pop	r21
    131e:	4f 91       	pop	r20
    1320:	3f 91       	pop	r19
    1322:	2f 91       	pop	r18
    1324:	0f 90       	pop	r0
    1326:	0b be       	out	0x3b, r0	; 59
    1328:	0f 90       	pop	r0
    132a:	0f be       	out	0x3f, r0	; 63
    132c:	0f 90       	pop	r0
    132e:	1f 90       	pop	r1
    1330:	18 95       	reti

00001332 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
    1332:	1f 92       	push	r1
    1334:	0f 92       	push	r0
    1336:	0f b6       	in	r0, 0x3f	; 63
    1338:	0f 92       	push	r0
    133a:	11 24       	eor	r1, r1
    133c:	0b b6       	in	r0, 0x3b	; 59
    133e:	0f 92       	push	r0
    1340:	2f 93       	push	r18
    1342:	3f 93       	push	r19
    1344:	4f 93       	push	r20
    1346:	5f 93       	push	r21
    1348:	6f 93       	push	r22
    134a:	7f 93       	push	r23
    134c:	8f 93       	push	r24
    134e:	9f 93       	push	r25
    1350:	af 93       	push	r26
    1352:	bf 93       	push	r27
    1354:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
    1356:	ff 93       	push	r31
    1358:	09 df       	rcall	.-494    	; 0x116c <_ZN11Dev_Manager11getInstanceEv>
    135a:	dc 01       	movw	r26, r24
    135c:	1e 96       	adiw	r26, 0x0e	; 14
    135e:	ed 91       	ld	r30, X+
    1360:	fc 91       	ld	r31, X
    1362:	1f 97       	sbiw	r26, 0x0f	; 15
    1364:	60 e0       	ldi	r22, 0x00	; 0
    1366:	70 e0       	ldi	r23, 0x00	; 0
    1368:	82 e0       	ldi	r24, 0x02	; 2
}
    136a:	09 95       	icall
    136c:	ff 91       	pop	r31
    136e:	ef 91       	pop	r30
    1370:	bf 91       	pop	r27
    1372:	af 91       	pop	r26
    1374:	9f 91       	pop	r25
    1376:	8f 91       	pop	r24
    1378:	7f 91       	pop	r23
    137a:	6f 91       	pop	r22
    137c:	5f 91       	pop	r21
    137e:	4f 91       	pop	r20
    1380:	3f 91       	pop	r19
    1382:	2f 91       	pop	r18
    1384:	0f 90       	pop	r0
    1386:	0b be       	out	0x3b, r0	; 59
    1388:	0f 90       	pop	r0
    138a:	0f be       	out	0x3f, r0	; 63
    138c:	0f 90       	pop	r0
    138e:	1f 90       	pop	r1
    1390:	18 95       	reti

00001392 <__vector_1>:
ISR(INT0_vect)
{
    1392:	1f 92       	push	r1
    1394:	0f 92       	push	r0
    1396:	0f b6       	in	r0, 0x3f	; 63
    1398:	0f 92       	push	r0
    139a:	11 24       	eor	r1, r1
    139c:	0b b6       	in	r0, 0x3b	; 59
    139e:	0f 92       	push	r0
    13a0:	2f 93       	push	r18
    13a2:	3f 93       	push	r19
    13a4:	4f 93       	push	r20
    13a6:	5f 93       	push	r21
    13a8:	6f 93       	push	r22
    13aa:	7f 93       	push	r23
    13ac:	8f 93       	push	r24
    13ae:	9f 93       	push	r25
    13b0:	af 93       	push	r26
    13b2:	bf 93       	push	r27
    13b4:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
    13b6:	ff 93       	push	r31
    13b8:	d9 de       	rcall	.-590    	; 0x116c <_ZN11Dev_Manager11getInstanceEv>
    13ba:	dc 01       	movw	r26, r24
    13bc:	50 96       	adiw	r26, 0x10	; 16
    13be:	ed 91       	ld	r30, X+
    13c0:	fc 91       	ld	r31, X
    13c2:	51 97       	sbiw	r26, 0x11	; 17
    13c4:	60 e0       	ldi	r22, 0x00	; 0
    13c6:	70 e0       	ldi	r23, 0x00	; 0
    13c8:	83 e0       	ldi	r24, 0x03	; 3
}
    13ca:	09 95       	icall
    13cc:	ff 91       	pop	r31
    13ce:	ef 91       	pop	r30
    13d0:	bf 91       	pop	r27
    13d2:	af 91       	pop	r26
    13d4:	9f 91       	pop	r25
    13d6:	8f 91       	pop	r24
    13d8:	7f 91       	pop	r23
    13da:	6f 91       	pop	r22
    13dc:	5f 91       	pop	r21
    13de:	4f 91       	pop	r20
    13e0:	3f 91       	pop	r19
    13e2:	2f 91       	pop	r18
    13e4:	0f 90       	pop	r0
    13e6:	0b be       	out	0x3b, r0	; 59
    13e8:	0f 90       	pop	r0
    13ea:	0f be       	out	0x3f, r0	; 63
    13ec:	0f 90       	pop	r0
    13ee:	1f 90       	pop	r1
    13f0:	18 95       	reti

000013f2 <__vector_21>:
ISR(ADC_vect)
{	
    13f2:	1f 92       	push	r1
    13f4:	0f 92       	push	r0
    13f6:	0f b6       	in	r0, 0x3f	; 63
    13f8:	0f 92       	push	r0
    13fa:	11 24       	eor	r1, r1
    13fc:	0b b6       	in	r0, 0x3b	; 59
    13fe:	0f 92       	push	r0
    1400:	2f 93       	push	r18
    1402:	3f 93       	push	r19
    1404:	4f 93       	push	r20
    1406:	5f 93       	push	r21
    1408:	6f 93       	push	r22
    140a:	7f 93       	push	r23
    140c:	8f 93       	push	r24
    140e:	9f 93       	push	r25
    1410:	af 93       	push	r26
    1412:	bf 93       	push	r27
    1414:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[_ADC](_ADC,ADCL+((uint16_t)ADCH << 8));
    1416:	ff 93       	push	r31
    1418:	a9 de       	rcall	.-686    	; 0x116c <_ZN11Dev_Manager11getInstanceEv>
    141a:	24 b1       	in	r18, 0x04	; 4
    141c:	65 b1       	in	r22, 0x05	; 5
    141e:	70 e0       	ldi	r23, 0x00	; 0
    1420:	76 2f       	mov	r23, r22
    1422:	66 27       	eor	r22, r22
    1424:	62 0f       	add	r22, r18
    1426:	71 1d       	adc	r23, r1
    1428:	dc 01       	movw	r26, r24
    142a:	52 96       	adiw	r26, 0x12	; 18
    142c:	ed 91       	ld	r30, X+
    142e:	fc 91       	ld	r31, X
    1430:	53 97       	sbiw	r26, 0x13	; 19
    1432:	84 e0       	ldi	r24, 0x04	; 4
}
    1434:	09 95       	icall
    1436:	ff 91       	pop	r31
    1438:	ef 91       	pop	r30
    143a:	bf 91       	pop	r27
    143c:	af 91       	pop	r26
    143e:	9f 91       	pop	r25
    1440:	8f 91       	pop	r24
    1442:	7f 91       	pop	r23
    1444:	6f 91       	pop	r22
    1446:	5f 91       	pop	r21
    1448:	4f 91       	pop	r20
    144a:	3f 91       	pop	r19
    144c:	2f 91       	pop	r18
    144e:	0f 90       	pop	r0
    1450:	0b be       	out	0x3b, r0	; 59
    1452:	0f 90       	pop	r0
    1454:	0f be       	out	0x3f, r0	; 63
    1456:	0f 90       	pop	r0
    1458:	1f 90       	pop	r1
    145a:	18 95       	reti

0000145c <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
    145c:	80 e4       	ldi	r24, 0x40	; 64
    145e:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
    1462:	84 e0       	ldi	r24, 0x04	; 4
    1464:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
    1468:	88 e0       	ldi	r24, 0x08	; 8
    146a:	9d e3       	ldi	r25, 0x3D	; 61
    146c:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
    1470:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
    1474:	82 e0       	ldi	r24, 0x02	; 2
    1476:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
    147a:	08 95       	ret

0000147c <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
    147c:	2b e2       	ldi	r18, 0x2B	; 43
    147e:	31 e0       	ldi	r19, 0x01	; 1
    1480:	fc 01       	movw	r30, r24
    1482:	31 83       	std	Z+1, r19	; 0x01
    1484:	20 83       	st	Z, r18
    1486:	08 95       	ret

00001488 <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
    1488:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
}
    148c:	08 95       	ret

0000148e <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	ec 01       	movw	r28, r24
    1494:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
    1498:	88 e9       	ldi	r24, 0x98	; 152
    149a:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
    149e:	86 e0       	ldi	r24, 0x06	; 6
    14a0:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
    14a4:	be 01       	movw	r22, r28
    14a6:	6e 5f       	subi	r22, 0xFE	; 254
    14a8:	7f 4f       	sbci	r23, 0xFF	; 255
    14aa:	ce 01       	movw	r24, r28
    14ac:	19 d1       	rcall	.+562    	; 0x16e0 <_ZN4Ubbr10Ubbr_ValueERKj>
    14ae:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
    14b2:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <xQueueCreateMutex>
    14bc:	9f 83       	std	Y+7, r25	; 0x07
    14be:	8e 83       	std	Y+6, r24	; 0x06
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <xQueueCreateMutex>
    14c6:	9d 83       	std	Y+5, r25	; 0x05
    14c8:	8c 83       	std	Y+4, r24	; 0x04
    14ca:	df 91       	pop	r29
    14cc:	cf 91       	pop	r28
    14ce:	08 95       	ret

000014d0 <_ZN11RS485DriverC1Ev>:
    14d0:	2b e3       	ldi	r18, 0x3B	; 59
    14d2:	31 e0       	ldi	r19, 0x01	; 1
    14d4:	fc 01       	movw	r30, r24
    14d6:	31 83       	std	Z+1, r19	; 0x01
    14d8:	20 83       	st	Z, r18
    14da:	20 e8       	ldi	r18, 0x80	; 128
    14dc:	35 e2       	ldi	r19, 0x25	; 37
    14de:	33 83       	std	Z+3, r19	; 0x03
    14e0:	22 83       	std	Z+2, r18	; 0x02
    14e2:	20 91 dc 01 	lds	r18, 0x01DC	; 0x8001dc <_ZN11RS485Driver4instE>
    14e6:	30 91 dd 01 	lds	r19, 0x01DD	; 0x8001dd <_ZN11RS485Driver4instE+0x1>
    14ea:	23 2b       	or	r18, r19
    14ec:	21 f4       	brne	.+8      	; 0x14f6 <_ZN11RS485DriverC1Ev+0x26>
    14ee:	90 93 dd 01 	sts	0x01DD, r25	; 0x8001dd <_ZN11RS485Driver4instE+0x1>
    14f2:	80 93 dc 01 	sts	0x01DC, r24	; 0x8001dc <_ZN11RS485Driver4instE>
    14f6:	08 95       	ret

000014f8 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
    14f8:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
}
    14fc:	08 95       	ret

000014fe <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
    14fe:	1f 93       	push	r17
    1500:	cf 93       	push	r28
    1502:	df 93       	push	r29
    1504:	ec 01       	movw	r28, r24
    1506:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
    1508:	20 e0       	ldi	r18, 0x00	; 0
    150a:	44 e6       	ldi	r20, 0x64	; 100
    150c:	50 e0       	ldi	r21, 0x00	; 0
    150e:	60 e0       	ldi	r22, 0x00	; 0
    1510:	70 e0       	ldi	r23, 0x00	; 0
    1512:	8c 81       	ldd	r24, Y+4	; 0x04
    1514:	9d 81       	ldd	r25, Y+5	; 0x05
    1516:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <xQueueGenericReceive>
    151a:	81 30       	cpi	r24, 0x01	; 1
    151c:	81 f4       	brne	.+32     	; 0x153e <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
    151e:	eb e9       	ldi	r30, 0x9B	; 155
    1520:	f0 e0       	ldi	r31, 0x00	; 0
    1522:	80 81       	ld	r24, Z
    1524:	85 ff       	sbrs	r24, 5
    1526:	fd cf       	rjmp	.-6      	; 0x1522 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
    1528:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
    152c:	20 e0       	ldi	r18, 0x00	; 0
    152e:	40 e0       	ldi	r20, 0x00	; 0
    1530:	50 e0       	ldi	r21, 0x00	; 0
    1532:	60 e0       	ldi	r22, 0x00	; 0
    1534:	70 e0       	ldi	r23, 0x00	; 0
    1536:	8c 81       	ldd	r24, Y+4	; 0x04
    1538:	9d 81       	ldd	r25, Y+5	; 0x05
    153a:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <xQueueGenericSend>
	}
}
    153e:	df 91       	pop	r29
    1540:	cf 91       	pop	r28
    1542:	1f 91       	pop	r17
    1544:	08 95       	ret

00001546 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
    1546:	db cf       	rjmp	.-74     	; 0x14fe <_ZN11RS485Driver12UART_PutcharEc>
    1548:	08 95       	ret

0000154a <_ZN11RS485Driver14UART_PutStringEPKc>:
    154a:	0f 93       	push	r16
    154c:	1f 93       	push	r17
    154e:	cf 93       	push	r28
    1550:	df 93       	push	r29
    1552:	8c 01       	movw	r16, r24
    1554:	eb 01       	movw	r28, r22
    1556:	20 e0       	ldi	r18, 0x00	; 0
    1558:	44 e6       	ldi	r20, 0x64	; 100
    155a:	50 e0       	ldi	r21, 0x00	; 0
    155c:	60 e0       	ldi	r22, 0x00	; 0
    155e:	70 e0       	ldi	r23, 0x00	; 0
    1560:	fc 01       	movw	r30, r24
    1562:	86 81       	ldd	r24, Z+6	; 0x06
    1564:	97 81       	ldd	r25, Z+7	; 0x07
    1566:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <xQueueGenericReceive>
    156a:	81 30       	cpi	r24, 0x01	; 1
    156c:	99 f4       	brne	.+38     	; 0x1594 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
    156e:	68 81       	ld	r22, Y
    1570:	66 23       	and	r22, r22
    1572:	31 f0       	breq	.+12     	; 0x1580 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
    1574:	21 96       	adiw	r28, 0x01	; 1
    1576:	c8 01       	movw	r24, r16
    1578:	c2 df       	rcall	.-124    	; 0x14fe <_ZN11RS485Driver12UART_PutcharEc>
    157a:	69 91       	ld	r22, Y+
    157c:	61 11       	cpse	r22, r1
    157e:	fb cf       	rjmp	.-10     	; 0x1576 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
    1580:	20 e0       	ldi	r18, 0x00	; 0
    1582:	40 e0       	ldi	r20, 0x00	; 0
    1584:	50 e0       	ldi	r21, 0x00	; 0
    1586:	60 e0       	ldi	r22, 0x00	; 0
    1588:	70 e0       	ldi	r23, 0x00	; 0
    158a:	f8 01       	movw	r30, r16
    158c:	86 81       	ldd	r24, Z+6	; 0x06
    158e:	97 81       	ldd	r25, Z+7	; 0x07
    1590:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <xQueueGenericSend>
    1594:	df 91       	pop	r29
    1596:	cf 91       	pop	r28
    1598:	1f 91       	pop	r17
    159a:	0f 91       	pop	r16
    159c:	08 95       	ret

0000159e <_ZN11RS485Driver13Device_WritesEPKc>:
    159e:	d5 cf       	rjmp	.-86     	; 0x154a <_ZN11RS485Driver14UART_PutStringEPKc>
    15a0:	08 95       	ret

000015a2 <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
    15a2:	1f 92       	push	r1
    15a4:	0f 92       	push	r0
    15a6:	0f b6       	in	r0, 0x3f	; 63
    15a8:	0f 92       	push	r0
    15aa:	11 24       	eor	r1, r1
    15ac:	0b b6       	in	r0, 0x3b	; 59
    15ae:	0f 92       	push	r0
    15b0:	8f 93       	push	r24
    15b2:	9f 93       	push	r25
    15b4:	ef 93       	push	r30
    15b6:	ff 93       	push	r31
	mem4[3]++;
    15b8:	e4 ec       	ldi	r30, 0xC4	; 196
    15ba:	f2 e0       	ldi	r31, 0x02	; 2
    15bc:	86 81       	ldd	r24, Z+6	; 0x06
    15be:	97 81       	ldd	r25, Z+7	; 0x07
    15c0:	01 96       	adiw	r24, 0x01	; 1
    15c2:	97 83       	std	Z+7, r25	; 0x07
    15c4:	86 83       	std	Z+6, r24	; 0x06
}
    15c6:	ff 91       	pop	r31
    15c8:	ef 91       	pop	r30
    15ca:	9f 91       	pop	r25
    15cc:	8f 91       	pop	r24
    15ce:	0f 90       	pop	r0
    15d0:	0b be       	out	0x3b, r0	; 59
    15d2:	0f 90       	pop	r0
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	0f 90       	pop	r0
    15d8:	1f 90       	pop	r1
    15da:	18 95       	reti

000015dc <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
    15dc:	cf 93       	push	r28
    15de:	df 93       	push	r29
    15e0:	ec 01       	movw	r28, r24
    15e2:	88 e9       	ldi	r24, 0x98	; 152
    15e4:	8a b9       	out	0x0a, r24	; 10
    15e6:	86 e0       	ldi	r24, 0x06	; 6
    15e8:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
    15ec:	be 01       	movw	r22, r28
    15ee:	6e 5f       	subi	r22, 0xFE	; 254
    15f0:	7f 4f       	sbci	r23, 0xFF	; 255
    15f2:	ce 01       	movw	r24, r28
    15f4:	75 d0       	rcall	.+234    	; 0x16e0 <_ZN4Ubbr10Ubbr_ValueERKj>
    15f6:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
    15fa:	99 b9       	out	0x09, r25	; 9
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <xQueueCreateMutex>
    1602:	9f 83       	std	Y+7, r25	; 0x07
    1604:	8e 83       	std	Y+6, r24	; 0x06
    1606:	81 e0       	ldi	r24, 0x01	; 1
    1608:	0e 94 e2 1a 	call	0x35c4	; 0x35c4 <xQueueCreateMutex>
    160c:	9d 83       	std	Y+5, r25	; 0x05
    160e:	8c 83       	std	Y+4, r24	; 0x04
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	08 95       	ret

00001616 <_ZN10UartDriverC1Ev>:
    1616:	2b e4       	ldi	r18, 0x4B	; 75
    1618:	31 e0       	ldi	r19, 0x01	; 1
    161a:	fc 01       	movw	r30, r24
    161c:	31 83       	std	Z+1, r19	; 0x01
    161e:	20 83       	st	Z, r18
    1620:	20 e0       	ldi	r18, 0x00	; 0
    1622:	36 e9       	ldi	r19, 0x96	; 150
    1624:	33 83       	std	Z+3, r19	; 0x03
    1626:	22 83       	std	Z+2, r18	; 0x02
    1628:	20 91 de 01 	lds	r18, 0x01DE	; 0x8001de <_ZN10UartDriver4instE>
    162c:	30 91 df 01 	lds	r19, 0x01DF	; 0x8001df <_ZN10UartDriver4instE+0x1>
    1630:	23 2b       	or	r18, r19
    1632:	21 f4       	brne	.+8      	; 0x163c <_ZN10UartDriverC1Ev+0x26>
    1634:	90 93 df 01 	sts	0x01DF, r25	; 0x8001df <_ZN10UartDriver4instE+0x1>
    1638:	80 93 de 01 	sts	0x01DE, r24	; 0x8001de <_ZN10UartDriver4instE>
    163c:	08 95       	ret

0000163e <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
    163e:	0c 94 19 17 	jmp	0x2e32	; 0x2e32 <pvPortMalloc>
}
    1642:	08 95       	ret

00001644 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
    1644:	1f 93       	push	r17
    1646:	cf 93       	push	r28
    1648:	df 93       	push	r29
    164a:	ec 01       	movw	r28, r24
    164c:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
    164e:	20 e0       	ldi	r18, 0x00	; 0
    1650:	44 e6       	ldi	r20, 0x64	; 100
    1652:	50 e0       	ldi	r21, 0x00	; 0
    1654:	60 e0       	ldi	r22, 0x00	; 0
    1656:	70 e0       	ldi	r23, 0x00	; 0
    1658:	8c 81       	ldd	r24, Y+4	; 0x04
    165a:	9d 81       	ldd	r25, Y+5	; 0x05
    165c:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <xQueueGenericReceive>
    1660:	81 30       	cpi	r24, 0x01	; 1
    1662:	61 f4       	brne	.+24     	; 0x167c <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
    1664:	5d 9b       	sbis	0x0b, 5	; 11
    1666:	fe cf       	rjmp	.-4      	; 0x1664 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
    1668:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
    166a:	20 e0       	ldi	r18, 0x00	; 0
    166c:	40 e0       	ldi	r20, 0x00	; 0
    166e:	50 e0       	ldi	r21, 0x00	; 0
    1670:	60 e0       	ldi	r22, 0x00	; 0
    1672:	70 e0       	ldi	r23, 0x00	; 0
    1674:	8c 81       	ldd	r24, Y+4	; 0x04
    1676:	9d 81       	ldd	r25, Y+5	; 0x05
    1678:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <xQueueGenericSend>
	}
}
    167c:	df 91       	pop	r29
    167e:	cf 91       	pop	r28
    1680:	1f 91       	pop	r17
    1682:	08 95       	ret

00001684 <_ZN10UartDriver12Device_WriteEc>:
    1684:	df cf       	rjmp	.-66     	; 0x1644 <_ZN10UartDriver12UART_PutcharEc>
    1686:	08 95       	ret

00001688 <_ZN10UartDriver14UART_PutStringEPKc>:
    1688:	0f 93       	push	r16
    168a:	1f 93       	push	r17
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	8c 01       	movw	r16, r24
    1692:	eb 01       	movw	r28, r22
    1694:	20 e0       	ldi	r18, 0x00	; 0
    1696:	44 e6       	ldi	r20, 0x64	; 100
    1698:	50 e0       	ldi	r21, 0x00	; 0
    169a:	60 e0       	ldi	r22, 0x00	; 0
    169c:	70 e0       	ldi	r23, 0x00	; 0
    169e:	fc 01       	movw	r30, r24
    16a0:	86 81       	ldd	r24, Z+6	; 0x06
    16a2:	97 81       	ldd	r25, Z+7	; 0x07
    16a4:	0e 94 fa 1a 	call	0x35f4	; 0x35f4 <xQueueGenericReceive>
    16a8:	81 30       	cpi	r24, 0x01	; 1
    16aa:	99 f4       	brne	.+38     	; 0x16d2 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
    16ac:	68 81       	ld	r22, Y
    16ae:	66 23       	and	r22, r22
    16b0:	31 f0       	breq	.+12     	; 0x16be <_ZN10UartDriver14UART_PutStringEPKc+0x36>
    16b2:	21 96       	adiw	r28, 0x01	; 1
    16b4:	c8 01       	movw	r24, r16
    16b6:	c6 df       	rcall	.-116    	; 0x1644 <_ZN10UartDriver12UART_PutcharEc>
    16b8:	69 91       	ld	r22, Y+
    16ba:	61 11       	cpse	r22, r1
    16bc:	fb cf       	rjmp	.-10     	; 0x16b4 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
    16be:	20 e0       	ldi	r18, 0x00	; 0
    16c0:	40 e0       	ldi	r20, 0x00	; 0
    16c2:	50 e0       	ldi	r21, 0x00	; 0
    16c4:	60 e0       	ldi	r22, 0x00	; 0
    16c6:	70 e0       	ldi	r23, 0x00	; 0
    16c8:	f8 01       	movw	r30, r16
    16ca:	86 81       	ldd	r24, Z+6	; 0x06
    16cc:	97 81       	ldd	r25, Z+7	; 0x07
    16ce:	0e 94 50 1a 	call	0x34a0	; 0x34a0 <xQueueGenericSend>
    16d2:	df 91       	pop	r29
    16d4:	cf 91       	pop	r28
    16d6:	1f 91       	pop	r17
    16d8:	0f 91       	pop	r16
    16da:	08 95       	ret

000016dc <_ZN10UartDriver13Device_WritesEPKc>:
    16dc:	d5 cf       	rjmp	.-86     	; 0x1688 <_ZN10UartDriver14UART_PutStringEPKc>
    16de:	08 95       	ret

000016e0 <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
    16e0:	cf 92       	push	r12
    16e2:	df 92       	push	r13
    16e4:	ef 92       	push	r14
    16e6:	ff 92       	push	r15
    16e8:	cf 93       	push	r28
    16ea:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
    16ec:	fb 01       	movw	r30, r22
    16ee:	20 81       	ld	r18, Z
    16f0:	31 81       	ldd	r19, Z+1	; 0x01
    16f2:	c9 01       	movw	r24, r18
    16f4:	a0 e0       	ldi	r26, 0x00	; 0
    16f6:	b0 e0       	ldi	r27, 0x00	; 0
    16f8:	88 0f       	add	r24, r24
    16fa:	99 1f       	adc	r25, r25
    16fc:	aa 1f       	adc	r26, r26
    16fe:	bb 1f       	adc	r27, r27
    1700:	88 0f       	add	r24, r24
    1702:	99 1f       	adc	r25, r25
    1704:	aa 1f       	adc	r26, r26
    1706:	bb 1f       	adc	r27, r27
    1708:	9c 01       	movw	r18, r24
    170a:	ad 01       	movw	r20, r26
    170c:	22 0f       	add	r18, r18
    170e:	33 1f       	adc	r19, r19
    1710:	44 1f       	adc	r20, r20
    1712:	55 1f       	adc	r21, r21
    1714:	22 0f       	add	r18, r18
    1716:	33 1f       	adc	r19, r19
    1718:	44 1f       	adc	r20, r20
    171a:	55 1f       	adc	r21, r21
    171c:	60 e0       	ldi	r22, 0x00	; 0
    171e:	74 e2       	ldi	r23, 0x24	; 36
    1720:	84 ef       	ldi	r24, 0xF4	; 244
    1722:	90 e0       	ldi	r25, 0x00	; 0
    1724:	0e 94 9c 22 	call	0x4538	; 0x4538 <__udivmodsi4>
    1728:	ca 01       	movw	r24, r20
    172a:	b9 01       	movw	r22, r18
    172c:	61 50       	subi	r22, 0x01	; 1
    172e:	71 09       	sbc	r23, r1
    1730:	81 09       	sbc	r24, r1
    1732:	91 09       	sbc	r25, r1
    1734:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
    1738:	20 e0       	ldi	r18, 0x00	; 0
    173a:	30 e0       	ldi	r19, 0x00	; 0
    173c:	40 e0       	ldi	r20, 0x00	; 0
    173e:	5f e3       	ldi	r21, 0x3F	; 63
    1740:	0e 94 82 20 	call	0x4104	; 0x4104 <__addsf3>
    1744:	6b 01       	movw	r12, r22
    1746:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
    1748:	0e 94 57 21 	call	0x42ae	; 0x42ae <__fixunssfsi>
    174c:	d6 2f       	mov	r29, r22
    174e:	f0 e0       	ldi	r31, 0x00	; 0
    1750:	cf 2f       	mov	r28, r31
    1752:	c7 01       	movw	r24, r14
    1754:	b6 01       	movw	r22, r12
    1756:	0e 94 57 21 	call	0x42ae	; 0x42ae <__fixunssfsi>
}
    175a:	ce 01       	movw	r24, r28
    175c:	86 2b       	or	r24, r22
    175e:	df 91       	pop	r29
    1760:	cf 91       	pop	r28
    1762:	ff 90       	pop	r15
    1764:	ef 90       	pop	r14
    1766:	df 90       	pop	r13
    1768:	cf 90       	pop	r12
    176a:	08 95       	ret

0000176c <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
    176c:	c0 98       	cbi	0x18, 0	; 24
    176e:	96 2f       	mov	r25, r22
    1770:	6f 71       	andi	r22, 0x1F	; 31
    1772:	86 2b       	or	r24, r22
    1774:	8f b9       	out	0x0f, r24	; 15
    1776:	77 9b       	sbis	0x0e, 7	; 14
    1778:	fe cf       	rjmp	.-4      	; 0x1776 <_Z14enc28j60ReadOphh+0xa>
    177a:	1f b8       	out	0x0f, r1	; 15
    177c:	77 9b       	sbis	0x0e, 7	; 14
    177e:	fe cf       	rjmp	.-4      	; 0x177c <_Z14enc28j60ReadOphh+0x10>
    1780:	99 23       	and	r25, r25
    1782:	1c f4       	brge	.+6      	; 0x178a <_Z14enc28j60ReadOphh+0x1e>
    1784:	1f b8       	out	0x0f, r1	; 15
    1786:	77 9b       	sbis	0x0e, 7	; 14
    1788:	fe cf       	rjmp	.-4      	; 0x1786 <_Z14enc28j60ReadOphh+0x1a>
    178a:	c0 9a       	sbi	0x18, 0	; 24
    178c:	8f b1       	in	r24, 0x0f	; 15
    178e:	08 95       	ret

00001790 <_Z15enc28j60WriteOphhh>:
    1790:	c0 98       	cbi	0x18, 0	; 24
    1792:	6f 71       	andi	r22, 0x1F	; 31
    1794:	86 2b       	or	r24, r22
    1796:	8f b9       	out	0x0f, r24	; 15
    1798:	77 9b       	sbis	0x0e, 7	; 14
    179a:	fe cf       	rjmp	.-4      	; 0x1798 <_Z15enc28j60WriteOphhh+0x8>
    179c:	4f b9       	out	0x0f, r20	; 15
    179e:	77 9b       	sbis	0x0e, 7	; 14
    17a0:	fe cf       	rjmp	.-4      	; 0x179e <_Z15enc28j60WriteOphhh+0xe>
    17a2:	c0 9a       	sbi	0x18, 0	; 24
    17a4:	08 95       	ret

000017a6 <_Z18enc28j60ReadBufferjPh>:
    17a6:	fb 01       	movw	r30, r22
    17a8:	c0 98       	cbi	0x18, 0	; 24
    17aa:	2a e3       	ldi	r18, 0x3A	; 58
    17ac:	2f b9       	out	0x0f, r18	; 15
    17ae:	77 9b       	sbis	0x0e, 7	; 14
    17b0:	fe cf       	rjmp	.-4      	; 0x17ae <_Z18enc28j60ReadBufferjPh+0x8>
    17b2:	00 97       	sbiw	r24, 0x00	; 0
    17b4:	61 f0       	breq	.+24     	; 0x17ce <_Z18enc28j60ReadBufferjPh+0x28>
    17b6:	df 01       	movw	r26, r30
    17b8:	a8 0f       	add	r26, r24
    17ba:	b9 1f       	adc	r27, r25
    17bc:	1f b8       	out	0x0f, r1	; 15
    17be:	77 9b       	sbis	0x0e, 7	; 14
    17c0:	fe cf       	rjmp	.-4      	; 0x17be <_Z18enc28j60ReadBufferjPh+0x18>
    17c2:	9f b1       	in	r25, 0x0f	; 15
    17c4:	91 93       	st	Z+, r25
    17c6:	ae 17       	cp	r26, r30
    17c8:	bf 07       	cpc	r27, r31
    17ca:	c1 f7       	brne	.-16     	; 0x17bc <_Z18enc28j60ReadBufferjPh+0x16>
    17cc:	01 c0       	rjmp	.+2      	; 0x17d0 <_Z18enc28j60ReadBufferjPh+0x2a>
    17ce:	df 01       	movw	r26, r30
    17d0:	1c 92       	st	X, r1
    17d2:	c0 9a       	sbi	0x18, 0	; 24
    17d4:	08 95       	ret

000017d6 <_Z19enc28j60WriteBufferjPh>:
    17d6:	fb 01       	movw	r30, r22
    17d8:	c0 98       	cbi	0x18, 0	; 24
    17da:	2a e7       	ldi	r18, 0x7A	; 122
    17dc:	2f b9       	out	0x0f, r18	; 15
    17de:	77 9b       	sbis	0x0e, 7	; 14
    17e0:	fe cf       	rjmp	.-4      	; 0x17de <_Z19enc28j60WriteBufferjPh+0x8>
    17e2:	00 97       	sbiw	r24, 0x00	; 0
    17e4:	61 f0       	breq	.+24     	; 0x17fe <_Z19enc28j60WriteBufferjPh+0x28>
    17e6:	9f 01       	movw	r18, r30
    17e8:	28 0f       	add	r18, r24
    17ea:	39 1f       	adc	r19, r25
    17ec:	03 c0       	rjmp	.+6      	; 0x17f4 <_Z19enc28j60WriteBufferjPh+0x1e>
    17ee:	2e 17       	cp	r18, r30
    17f0:	3f 07       	cpc	r19, r31
    17f2:	29 f0       	breq	.+10     	; 0x17fe <_Z19enc28j60WriteBufferjPh+0x28>
    17f4:	91 91       	ld	r25, Z+
    17f6:	9f b9       	out	0x0f, r25	; 15
    17f8:	77 9b       	sbis	0x0e, 7	; 14
    17fa:	fe cf       	rjmp	.-4      	; 0x17f8 <_Z19enc28j60WriteBufferjPh+0x22>
    17fc:	f8 cf       	rjmp	.-16     	; 0x17ee <_Z19enc28j60WriteBufferjPh+0x18>
    17fe:	c0 9a       	sbi	0x18, 0	; 24
    1800:	08 95       	ret

00001802 <_Z15enc28j60SetBankh>:
    1802:	1f 93       	push	r17
    1804:	cf 93       	push	r28
    1806:	df 93       	push	r29
    1808:	18 2f       	mov	r17, r24
    180a:	10 76       	andi	r17, 0x60	; 96
    180c:	c1 2f       	mov	r28, r17
    180e:	d0 e0       	ldi	r29, 0x00	; 0
    1810:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <_ZL12Enc28j60Bank>
    1814:	90 e0       	ldi	r25, 0x00	; 0
    1816:	c8 17       	cp	r28, r24
    1818:	d9 07       	cpc	r29, r25
    181a:	a1 f0       	breq	.+40     	; 0x1844 <_Z15enc28j60SetBankh+0x42>
    181c:	43 e0       	ldi	r20, 0x03	; 3
    181e:	6f e1       	ldi	r22, 0x1F	; 31
    1820:	80 ea       	ldi	r24, 0xA0	; 160
    1822:	b6 df       	rcall	.-148    	; 0x1790 <_Z15enc28j60WriteOphhh>
    1824:	ae 01       	movw	r20, r28
    1826:	55 95       	asr	r21
    1828:	47 95       	ror	r20
    182a:	55 95       	asr	r21
    182c:	47 95       	ror	r20
    182e:	55 95       	asr	r21
    1830:	47 95       	ror	r20
    1832:	55 95       	asr	r21
    1834:	47 95       	ror	r20
    1836:	55 95       	asr	r21
    1838:	47 95       	ror	r20
    183a:	6f e1       	ldi	r22, 0x1F	; 31
    183c:	80 e8       	ldi	r24, 0x80	; 128
    183e:	a8 df       	rcall	.-176    	; 0x1790 <_Z15enc28j60WriteOphhh>
    1840:	10 93 e2 01 	sts	0x01E2, r17	; 0x8001e2 <_ZL12Enc28j60Bank>
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	1f 91       	pop	r17
    184a:	08 95       	ret

0000184c <_Z12enc28j60Readh>:
    184c:	cf 93       	push	r28
    184e:	c8 2f       	mov	r28, r24
    1850:	d8 df       	rcall	.-80     	; 0x1802 <_Z15enc28j60SetBankh>
    1852:	6c 2f       	mov	r22, r28
    1854:	80 e0       	ldi	r24, 0x00	; 0
    1856:	8a df       	rcall	.-236    	; 0x176c <_Z14enc28j60ReadOphh>
    1858:	cf 91       	pop	r28
    185a:	08 95       	ret

0000185c <_Z13enc28j60Writehh>:
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	c8 2f       	mov	r28, r24
    1862:	d6 2f       	mov	r29, r22
    1864:	ce df       	rcall	.-100    	; 0x1802 <_Z15enc28j60SetBankh>
    1866:	4d 2f       	mov	r20, r29
    1868:	6c 2f       	mov	r22, r28
    186a:	80 e4       	ldi	r24, 0x40	; 64
    186c:	91 df       	rcall	.-222    	; 0x1790 <_Z15enc28j60WriteOphhh>
    186e:	df 91       	pop	r29
    1870:	cf 91       	pop	r28
    1872:	08 95       	ret

00001874 <_Z16enc28j60PhyWritehj>:
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	d6 2f       	mov	r29, r22
    187a:	c7 2f       	mov	r28, r23
    187c:	68 2f       	mov	r22, r24
    187e:	84 ed       	ldi	r24, 0xD4	; 212
    1880:	ed df       	rcall	.-38     	; 0x185c <_Z13enc28j60Writehh>
    1882:	6d 2f       	mov	r22, r29
    1884:	86 ed       	ldi	r24, 0xD6	; 214
    1886:	ea df       	rcall	.-44     	; 0x185c <_Z13enc28j60Writehh>
    1888:	6c 2f       	mov	r22, r28
    188a:	87 ed       	ldi	r24, 0xD7	; 215
    188c:	e7 df       	rcall	.-50     	; 0x185c <_Z13enc28j60Writehh>
    188e:	8a ee       	ldi	r24, 0xEA	; 234
    1890:	dd df       	rcall	.-70     	; 0x184c <_Z12enc28j60Readh>
    1892:	80 ff       	sbrs	r24, 0
    1894:	04 c0       	rjmp	.+8      	; 0x189e <_Z16enc28j60PhyWritehj+0x2a>
    1896:	85 e0       	ldi	r24, 0x05	; 5
    1898:	8a 95       	dec	r24
    189a:	f1 f7       	brne	.-4      	; 0x1898 <_Z16enc28j60PhyWritehj+0x24>
    189c:	f8 cf       	rjmp	.-16     	; 0x188e <_Z16enc28j60PhyWritehj+0x1a>
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	08 95       	ret

000018a4 <_Z14enc28j60clkouth>:
    18a4:	68 2f       	mov	r22, r24
    18a6:	67 70       	andi	r22, 0x07	; 7
    18a8:	85 e7       	ldi	r24, 0x75	; 117
    18aa:	d8 cf       	rjmp	.-80     	; 0x185c <_Z13enc28j60Writehh>
    18ac:	08 95       	ret

000018ae <_Z12enc28j60InitPh>:
    18ae:	cf 93       	push	r28
    18b0:	df 93       	push	r29
    18b2:	ec 01       	movw	r28, r24
    18b4:	b8 9a       	sbi	0x17, 0	; 23
    18b6:	c0 9a       	sbi	0x18, 0	; 24
    18b8:	a6 d2       	rcall	.+1356   	; 0x1e06 <_Z8spi_initv>
    18ba:	4f ef       	ldi	r20, 0xFF	; 255
    18bc:	60 e0       	ldi	r22, 0x00	; 0
    18be:	8f ef       	ldi	r24, 0xFF	; 255
    18c0:	67 df       	rcall	.-306    	; 0x1790 <_Z15enc28j60WriteOphhh>
    18c2:	82 e3       	ldi	r24, 0x32	; 50
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	a9 d2       	rcall	.+1362   	; 0x1e1a <_Z8delay_msj>
    18c8:	10 92 e1 01 	sts	0x01E1, r1	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
    18cc:	10 92 e0 01 	sts	0x01E0, r1	; 0x8001e0 <_ZL13NextPacketPtr>
    18d0:	60 e0       	ldi	r22, 0x00	; 0
    18d2:	88 e0       	ldi	r24, 0x08	; 8
    18d4:	c3 df       	rcall	.-122    	; 0x185c <_Z13enc28j60Writehh>
    18d6:	60 e0       	ldi	r22, 0x00	; 0
    18d8:	89 e0       	ldi	r24, 0x09	; 9
    18da:	c0 df       	rcall	.-128    	; 0x185c <_Z13enc28j60Writehh>
    18dc:	60 e0       	ldi	r22, 0x00	; 0
    18de:	8c e0       	ldi	r24, 0x0C	; 12
    18e0:	bd df       	rcall	.-134    	; 0x185c <_Z13enc28j60Writehh>
    18e2:	60 e0       	ldi	r22, 0x00	; 0
    18e4:	8d e0       	ldi	r24, 0x0D	; 13
    18e6:	ba df       	rcall	.-140    	; 0x185c <_Z13enc28j60Writehh>
    18e8:	6e ef       	ldi	r22, 0xFE	; 254
    18ea:	8a e0       	ldi	r24, 0x0A	; 10
    18ec:	b7 df       	rcall	.-146    	; 0x185c <_Z13enc28j60Writehh>
    18ee:	69 e1       	ldi	r22, 0x19	; 25
    18f0:	8b e0       	ldi	r24, 0x0B	; 11
    18f2:	b4 df       	rcall	.-152    	; 0x185c <_Z13enc28j60Writehh>
    18f4:	6f ef       	ldi	r22, 0xFF	; 255
    18f6:	84 e0       	ldi	r24, 0x04	; 4
    18f8:	b1 df       	rcall	.-158    	; 0x185c <_Z13enc28j60Writehh>
    18fa:	69 e1       	ldi	r22, 0x19	; 25
    18fc:	85 e0       	ldi	r24, 0x05	; 5
    18fe:	ae df       	rcall	.-164    	; 0x185c <_Z13enc28j60Writehh>
    1900:	6f ef       	ldi	r22, 0xFF	; 255
    1902:	86 e0       	ldi	r24, 0x06	; 6
    1904:	ab df       	rcall	.-170    	; 0x185c <_Z13enc28j60Writehh>
    1906:	6f e1       	ldi	r22, 0x1F	; 31
    1908:	87 e0       	ldi	r24, 0x07	; 7
    190a:	a8 df       	rcall	.-176    	; 0x185c <_Z13enc28j60Writehh>
    190c:	60 eb       	ldi	r22, 0xB0	; 176
    190e:	88 e3       	ldi	r24, 0x38	; 56
    1910:	a5 df       	rcall	.-182    	; 0x185c <_Z13enc28j60Writehh>
    1912:	6f e3       	ldi	r22, 0x3F	; 63
    1914:	88 e2       	ldi	r24, 0x28	; 40
    1916:	a2 df       	rcall	.-188    	; 0x185c <_Z13enc28j60Writehh>
    1918:	60 e3       	ldi	r22, 0x30	; 48
    191a:	89 e2       	ldi	r24, 0x29	; 41
    191c:	9f df       	rcall	.-194    	; 0x185c <_Z13enc28j60Writehh>
    191e:	69 ef       	ldi	r22, 0xF9	; 249
    1920:	80 e3       	ldi	r24, 0x30	; 48
    1922:	9c df       	rcall	.-200    	; 0x185c <_Z13enc28j60Writehh>
    1924:	67 ef       	ldi	r22, 0xF7	; 247
    1926:	81 e3       	ldi	r24, 0x31	; 49
    1928:	99 df       	rcall	.-206    	; 0x185c <_Z13enc28j60Writehh>
    192a:	6d e0       	ldi	r22, 0x0D	; 13
    192c:	80 ec       	ldi	r24, 0xC0	; 192
    192e:	96 df       	rcall	.-212    	; 0x185c <_Z13enc28j60Writehh>
    1930:	60 e0       	ldi	r22, 0x00	; 0
    1932:	81 ec       	ldi	r24, 0xC1	; 193
    1934:	93 df       	rcall	.-218    	; 0x185c <_Z13enc28j60Writehh>
    1936:	42 e3       	ldi	r20, 0x32	; 50
    1938:	62 ec       	ldi	r22, 0xC2	; 194
    193a:	80 e8       	ldi	r24, 0x80	; 128
    193c:	29 df       	rcall	.-430    	; 0x1790 <_Z15enc28j60WriteOphhh>
    193e:	62 e1       	ldi	r22, 0x12	; 18
    1940:	86 ec       	ldi	r24, 0xC6	; 198
    1942:	8c df       	rcall	.-232    	; 0x185c <_Z13enc28j60Writehh>
    1944:	6c e0       	ldi	r22, 0x0C	; 12
    1946:	87 ec       	ldi	r24, 0xC7	; 199
    1948:	89 df       	rcall	.-238    	; 0x185c <_Z13enc28j60Writehh>
    194a:	62 e1       	ldi	r22, 0x12	; 18
    194c:	84 ec       	ldi	r24, 0xC4	; 196
    194e:	86 df       	rcall	.-244    	; 0x185c <_Z13enc28j60Writehh>
    1950:	6c ed       	ldi	r22, 0xDC	; 220
    1952:	8a ec       	ldi	r24, 0xCA	; 202
    1954:	83 df       	rcall	.-250    	; 0x185c <_Z13enc28j60Writehh>
    1956:	65 e0       	ldi	r22, 0x05	; 5
    1958:	8b ec       	ldi	r24, 0xCB	; 203
    195a:	80 df       	rcall	.-256    	; 0x185c <_Z13enc28j60Writehh>
    195c:	68 81       	ld	r22, Y
    195e:	84 ee       	ldi	r24, 0xE4	; 228
    1960:	7d df       	rcall	.-262    	; 0x185c <_Z13enc28j60Writehh>
    1962:	69 81       	ldd	r22, Y+1	; 0x01
    1964:	85 ee       	ldi	r24, 0xE5	; 229
    1966:	7a df       	rcall	.-268    	; 0x185c <_Z13enc28j60Writehh>
    1968:	6a 81       	ldd	r22, Y+2	; 0x02
    196a:	82 ee       	ldi	r24, 0xE2	; 226
    196c:	77 df       	rcall	.-274    	; 0x185c <_Z13enc28j60Writehh>
    196e:	6b 81       	ldd	r22, Y+3	; 0x03
    1970:	83 ee       	ldi	r24, 0xE3	; 227
    1972:	74 df       	rcall	.-280    	; 0x185c <_Z13enc28j60Writehh>
    1974:	6c 81       	ldd	r22, Y+4	; 0x04
    1976:	80 ee       	ldi	r24, 0xE0	; 224
    1978:	71 df       	rcall	.-286    	; 0x185c <_Z13enc28j60Writehh>
    197a:	6d 81       	ldd	r22, Y+5	; 0x05
    197c:	81 ee       	ldi	r24, 0xE1	; 225
    197e:	6e df       	rcall	.-292    	; 0x185c <_Z13enc28j60Writehh>
    1980:	60 e0       	ldi	r22, 0x00	; 0
    1982:	71 e0       	ldi	r23, 0x01	; 1
    1984:	80 e1       	ldi	r24, 0x10	; 16
    1986:	76 df       	rcall	.-276    	; 0x1874 <_Z16enc28j60PhyWritehj>
    1988:	8f e1       	ldi	r24, 0x1F	; 31
    198a:	3b df       	rcall	.-394    	; 0x1802 <_Z15enc28j60SetBankh>
    198c:	40 ec       	ldi	r20, 0xC0	; 192
    198e:	6b e1       	ldi	r22, 0x1B	; 27
    1990:	80 e8       	ldi	r24, 0x80	; 128
    1992:	fe de       	rcall	.-516    	; 0x1790 <_Z15enc28j60WriteOphhh>
    1994:	44 e0       	ldi	r20, 0x04	; 4
    1996:	6f e1       	ldi	r22, 0x1F	; 31
    1998:	80 e8       	ldi	r24, 0x80	; 128
    199a:	fa de       	rcall	.-524    	; 0x1790 <_Z15enc28j60WriteOphhh>
    199c:	df 91       	pop	r29
    199e:	cf 91       	pop	r28
    19a0:	08 95       	ret

000019a2 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	ec 01       	movw	r28, r24
    19ac:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
    19ae:	6f ef       	ldi	r22, 0xFF	; 255
    19b0:	82 e0       	ldi	r24, 0x02	; 2
    19b2:	54 df       	rcall	.-344    	; 0x185c <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
    19b4:	69 e1       	ldi	r22, 0x19	; 25
    19b6:	83 e0       	ldi	r24, 0x03	; 3
    19b8:	51 df       	rcall	.-350    	; 0x185c <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
    19ba:	6c 2f       	mov	r22, r28
    19bc:	61 50       	subi	r22, 0x01	; 1
    19be:	86 e0       	ldi	r24, 0x06	; 6
    19c0:	4d df       	rcall	.-358    	; 0x185c <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
    19c2:	ce 01       	movw	r24, r28
    19c4:	81 50       	subi	r24, 0x01	; 1
    19c6:	96 4e       	sbci	r25, 0xE6	; 230
    19c8:	69 2f       	mov	r22, r25
    19ca:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
    19cc:	47 df       	rcall	.-370    	; 0x185c <_Z13enc28j60Writehh>
    19ce:	40 e0       	ldi	r20, 0x00	; 0
    19d0:	60 e0       	ldi	r22, 0x00	; 0
    19d2:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
    19d4:	dd de       	rcall	.-582    	; 0x1790 <_Z15enc28j60WriteOphhh>
    19d6:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
    19d8:	ce 01       	movw	r24, r28
    19da:	fd de       	rcall	.-518    	; 0x17d6 <_Z19enc28j60WriteBufferjPh>
    19dc:	48 e0       	ldi	r20, 0x08	; 8
    19de:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
    19e0:	80 e8       	ldi	r24, 0x80	; 128
    19e2:	d6 de       	rcall	.-596    	; 0x1790 <_Z15enc28j60WriteOphhh>
    19e4:	8c e1       	ldi	r24, 0x1C	; 28
    19e6:	32 df       	rcall	.-412    	; 0x184c <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
    19e8:	81 ff       	sbrs	r24, 1
    19ea:	04 c0       	rjmp	.+8      	; 0x19f4 <_Z18enc28j60PacketSendjPh+0x52>
    19ec:	48 e0       	ldi	r20, 0x08	; 8
    19ee:	6f e1       	ldi	r22, 0x1F	; 31
    19f0:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
    19f2:	ce de       	rcall	.-612    	; 0x1790 <_Z15enc28j60WriteOphhh>
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	1f 91       	pop	r17
    19fa:	0f 91       	pop	r16
    19fc:	08 95       	ret

000019fe <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
    19fe:	9f 92       	push	r9
    1a00:	af 92       	push	r10
    1a02:	bf 92       	push	r11
    1a04:	cf 92       	push	r12
    1a06:	df 92       	push	r13
    1a08:	ef 92       	push	r14
    1a0a:	ff 92       	push	r15
    1a0c:	0f 93       	push	r16
    1a0e:	1f 93       	push	r17
    1a10:	cf 93       	push	r28
    1a12:	df 93       	push	r29
    1a14:	5c 01       	movw	r10, r24
    1a16:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
    1a18:	89 e3       	ldi	r24, 0x39	; 57
    1a1a:	18 df       	rcall	.-464    	; 0x184c <_Z12enc28j60Readh>
    1a1c:	88 23       	and	r24, r24
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <_Z21enc28j60PacketReceivejPh+0x24>
    1a20:	45 c0       	rjmp	.+138    	; 0x1aac <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
    1a22:	60 91 e0 01 	lds	r22, 0x01E0	; 0x8001e0 <_ZL13NextPacketPtr>
    1a26:	c0 91 e1 01 	lds	r28, 0x01E1	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
    1a2a:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
    1a2c:	17 df       	rcall	.-466    	; 0x185c <_Z13enc28j60Writehh>
    1a2e:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1a30:	81 e0       	ldi	r24, 0x01	; 1
    1a32:	14 df       	rcall	.-472    	; 0x185c <_Z13enc28j60Writehh>
    1a34:	60 e0       	ldi	r22, 0x00	; 0
    1a36:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1a38:	99 de       	rcall	.-718    	; 0x176c <_Z14enc28j60ReadOphh>
    1a3a:	c8 2f       	mov	r28, r24
    1a3c:	60 e0       	ldi	r22, 0x00	; 0
    1a3e:	8a e3       	ldi	r24, 0x3A	; 58
    1a40:	95 de       	rcall	.-726    	; 0x176c <_Z14enc28j60ReadOphh>
    1a42:	d0 e0       	ldi	r29, 0x00	; 0
    1a44:	d8 2b       	or	r29, r24
    1a46:	d0 93 e1 01 	sts	0x01E1, r29	; 0x8001e1 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1a4a:	c0 93 e0 01 	sts	0x01E0, r28	; 0x8001e0 <_ZL13NextPacketPtr>
    1a4e:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1a50:	8a e3       	ldi	r24, 0x3A	; 58
    1a52:	8c de       	rcall	.-744    	; 0x176c <_Z14enc28j60ReadOphh>
    1a54:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
    1a56:	60 e0       	ldi	r22, 0x00	; 0
    1a58:	8a e3       	ldi	r24, 0x3A	; 58
    1a5a:	88 de       	rcall	.-752    	; 0x176c <_Z14enc28j60ReadOphh>
    1a5c:	98 2e       	mov	r9, r24
    1a5e:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
    1a60:	8a e3       	ldi	r24, 0x3A	; 58
    1a62:	84 de       	rcall	.-760    	; 0x176c <_Z14enc28j60ReadOphh>
    1a64:	c8 2e       	mov	r12, r24
    1a66:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
    1a68:	8a e3       	ldi	r24, 0x3A	; 58
    1a6a:	80 de       	rcall	.-768    	; 0x176c <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
    1a6c:	c7 fe       	sbrs	r12, 7
    1a6e:	0f c0       	rjmp	.+30     	; 0x1a8e <_Z21enc28j60PacketReceivejPh+0x90>
    1a70:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
    1a72:	a8 1a       	sub	r10, r24
    1a74:	b1 08       	sbc	r11, r1
    1a76:	10 e0       	ldi	r17, 0x00	; 0
    1a78:	19 29       	or	r17, r9
    1a7a:	04 50       	subi	r16, 0x04	; 4
    1a7c:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
    1a7e:	a0 16       	cp	r10, r16
    1a80:	b1 06       	cpc	r11, r17
    1a82:	08 f4       	brcc	.+2      	; 0x1a86 <_Z21enc28j60PacketReceivejPh+0x88>
    1a84:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
    1a86:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
    1a88:	c8 01       	movw	r24, r16
    1a8a:	8d de       	rcall	.-742    	; 0x17a6 <_Z18enc28j60ReadBufferjPh>
    1a8c:	02 c0       	rjmp	.+4      	; 0x1a92 <_Z21enc28j60PacketReceivejPh+0x94>
    1a8e:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
    1a90:	10 e0       	ldi	r17, 0x00	; 0
    1a92:	6c 2f       	mov	r22, r28
    1a94:	8c e0       	ldi	r24, 0x0C	; 12
    1a96:	e2 de       	rcall	.-572    	; 0x185c <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
    1a98:	6d 2f       	mov	r22, r29
    1a9a:	8d e0       	ldi	r24, 0x0D	; 13
    1a9c:	df de       	rcall	.-578    	; 0x185c <_Z13enc28j60Writehh>
    1a9e:	40 e4       	ldi	r20, 0x40	; 64
    1aa0:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
    1aa2:	80 e8       	ldi	r24, 0x80	; 128
    1aa4:	75 de       	rcall	.-790    	; 0x1790 <_Z15enc28j60WriteOphhh>
    1aa6:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
    1aa8:	91 2f       	mov	r25, r17
    1aaa:	02 c0       	rjmp	.+4      	; 0x1ab0 <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
    1aac:	80 e0       	ldi	r24, 0x00	; 0
    1aae:	90 e0       	ldi	r25, 0x00	; 0
    1ab0:	df 91       	pop	r29
    1ab2:	cf 91       	pop	r28
    1ab4:	1f 91       	pop	r17
    1ab6:	0f 91       	pop	r16
    1ab8:	ff 90       	pop	r15
    1aba:	ef 90       	pop	r14
    1abc:	df 90       	pop	r13
    1abe:	cf 90       	pop	r12
    1ac0:	bf 90       	pop	r11
    1ac2:	af 90       	pop	r10
    1ac4:	9f 90       	pop	r9
    1ac6:	08 95       	ret

00001ac8 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
    1ac8:	cf 92       	push	r12
    1aca:	df 92       	push	r13
    1acc:	ef 92       	push	r14
    1ace:	ff 92       	push	r15
    1ad0:	cf 93       	push	r28
    1ad2:	df 93       	push	r29
    1ad4:	ec 01       	movw	r28, r24
    1ad6:	db 01       	movw	r26, r22
    1ad8:	41 30       	cpi	r20, 0x01	; 1
    1ada:	61 f4       	brne	.+24     	; 0x1af4 <_Z8checksumPhjh+0x2c>
    1adc:	6b 01       	movw	r12, r22
    1ade:	88 e0       	ldi	r24, 0x08	; 8
    1ae0:	c8 1a       	sub	r12, r24
    1ae2:	d1 08       	sbc	r13, r1
    1ae4:	e1 2c       	mov	r14, r1
    1ae6:	f1 2c       	mov	r15, r1
    1ae8:	81 e1       	ldi	r24, 0x11	; 17
    1aea:	c8 0e       	add	r12, r24
    1aec:	d1 1c       	adc	r13, r1
    1aee:	e1 1c       	adc	r14, r1
    1af0:	f1 1c       	adc	r15, r1
    1af2:	11 c0       	rjmp	.+34     	; 0x1b16 <_Z8checksumPhjh+0x4e>
    1af4:	42 30       	cpi	r20, 0x02	; 2
    1af6:	61 f4       	brne	.+24     	; 0x1b10 <_Z8checksumPhjh+0x48>
    1af8:	6b 01       	movw	r12, r22
    1afa:	88 e0       	ldi	r24, 0x08	; 8
    1afc:	c8 1a       	sub	r12, r24
    1afe:	d1 08       	sbc	r13, r1
    1b00:	e1 2c       	mov	r14, r1
    1b02:	f1 2c       	mov	r15, r1
    1b04:	86 e0       	ldi	r24, 0x06	; 6
    1b06:	c8 0e       	add	r12, r24
    1b08:	d1 1c       	adc	r13, r1
    1b0a:	e1 1c       	adc	r14, r1
    1b0c:	f1 1c       	adc	r15, r1
    1b0e:	03 c0       	rjmp	.+6      	; 0x1b16 <_Z8checksumPhjh+0x4e>
    1b10:	c1 2c       	mov	r12, r1
    1b12:	d1 2c       	mov	r13, r1
    1b14:	76 01       	movw	r14, r12
    1b16:	a2 30       	cpi	r26, 0x02	; 2
    1b18:	b1 05       	cpc	r27, r1
    1b1a:	f0 f0       	brcs	.+60     	; 0x1b58 <_Z8checksumPhjh+0x90>
    1b1c:	9d 01       	movw	r18, r26
    1b1e:	fe 01       	movw	r30, r28
    1b20:	40 81       	ld	r20, Z
    1b22:	50 e0       	ldi	r21, 0x00	; 0
    1b24:	60 e0       	ldi	r22, 0x00	; 0
    1b26:	70 e0       	ldi	r23, 0x00	; 0
    1b28:	76 2f       	mov	r23, r22
    1b2a:	65 2f       	mov	r22, r21
    1b2c:	54 2f       	mov	r21, r20
    1b2e:	44 27       	eor	r20, r20
    1b30:	81 81       	ldd	r24, Z+1	; 0x01
    1b32:	48 2b       	or	r20, r24
    1b34:	c4 0e       	add	r12, r20
    1b36:	d5 1e       	adc	r13, r21
    1b38:	e6 1e       	adc	r14, r22
    1b3a:	f7 1e       	adc	r15, r23
    1b3c:	32 96       	adiw	r30, 0x02	; 2
    1b3e:	22 50       	subi	r18, 0x02	; 2
    1b40:	31 09       	sbc	r19, r1
    1b42:	22 30       	cpi	r18, 0x02	; 2
    1b44:	31 05       	cpc	r19, r1
    1b46:	60 f7       	brcc	.-40     	; 0x1b20 <_Z8checksumPhjh+0x58>
    1b48:	cd 01       	movw	r24, r26
    1b4a:	02 97       	sbiw	r24, 0x02	; 2
    1b4c:	8e 7f       	andi	r24, 0xFE	; 254
    1b4e:	02 96       	adiw	r24, 0x02	; 2
    1b50:	c8 0f       	add	r28, r24
    1b52:	d9 1f       	adc	r29, r25
    1b54:	a1 70       	andi	r26, 0x01	; 1
    1b56:	bb 27       	eor	r27, r27
    1b58:	ab 2b       	or	r26, r27
    1b5a:	61 f0       	breq	.+24     	; 0x1b74 <_Z8checksumPhjh+0xac>
    1b5c:	88 81       	ld	r24, Y
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	a0 e0       	ldi	r26, 0x00	; 0
    1b62:	b0 e0       	ldi	r27, 0x00	; 0
    1b64:	ba 2f       	mov	r27, r26
    1b66:	a9 2f       	mov	r26, r25
    1b68:	98 2f       	mov	r25, r24
    1b6a:	88 27       	eor	r24, r24
    1b6c:	c8 0e       	add	r12, r24
    1b6e:	d9 1e       	adc	r13, r25
    1b70:	ea 1e       	adc	r14, r26
    1b72:	fb 1e       	adc	r15, r27
    1b74:	a7 01       	movw	r20, r14
    1b76:	66 27       	eor	r22, r22
    1b78:	77 27       	eor	r23, r23
    1b7a:	41 15       	cp	r20, r1
    1b7c:	51 05       	cpc	r21, r1
    1b7e:	61 05       	cpc	r22, r1
    1b80:	71 05       	cpc	r23, r1
    1b82:	71 f0       	breq	.+28     	; 0x1ba0 <_Z8checksumPhjh+0xd8>
    1b84:	ee 24       	eor	r14, r14
    1b86:	ff 24       	eor	r15, r15
    1b88:	c4 0e       	add	r12, r20
    1b8a:	d5 1e       	adc	r13, r21
    1b8c:	e6 1e       	adc	r14, r22
    1b8e:	f7 1e       	adc	r15, r23
    1b90:	a7 01       	movw	r20, r14
    1b92:	66 27       	eor	r22, r22
    1b94:	77 27       	eor	r23, r23
    1b96:	41 15       	cp	r20, r1
    1b98:	51 05       	cpc	r21, r1
    1b9a:	61 05       	cpc	r22, r1
    1b9c:	71 05       	cpc	r23, r1
    1b9e:	91 f7       	brne	.-28     	; 0x1b84 <_Z8checksumPhjh+0xbc>
    1ba0:	c6 01       	movw	r24, r12
    1ba2:	80 95       	com	r24
    1ba4:	90 95       	com	r25
    1ba6:	df 91       	pop	r29
    1ba8:	cf 91       	pop	r28
    1baa:	ff 90       	pop	r15
    1bac:	ef 90       	pop	r14
    1bae:	df 90       	pop	r13
    1bb0:	cf 90       	pop	r12
    1bb2:	08 95       	ret

00001bb4 <_Z19init_ip_arp_udp_tcpPhS_h>:
    1bb4:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
    1bb8:	a6 2f       	mov	r26, r22
    1bba:	b7 2f       	mov	r27, r23
    1bbc:	e3 ee       	ldi	r30, 0xE3	; 227
    1bbe:	f1 e0       	ldi	r31, 0x01	; 1
    1bc0:	47 ee       	ldi	r20, 0xE7	; 231
    1bc2:	51 e0       	ldi	r21, 0x01	; 1
    1bc4:	2d 91       	ld	r18, X+
    1bc6:	21 93       	st	Z+, r18
    1bc8:	e4 17       	cp	r30, r20
    1bca:	f5 07       	cpc	r31, r21
    1bcc:	d9 f7       	brne	.-10     	; 0x1bc4 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
    1bce:	a8 2f       	mov	r26, r24
    1bd0:	b9 2f       	mov	r27, r25
    1bd2:	e7 ee       	ldi	r30, 0xE7	; 231
    1bd4:	f1 e0       	ldi	r31, 0x01	; 1
    1bd6:	2d ee       	ldi	r18, 0xED	; 237
    1bd8:	31 e0       	ldi	r19, 0x01	; 1
    1bda:	8d 91       	ld	r24, X+
    1bdc:	81 93       	st	Z+, r24
    1bde:	e2 17       	cp	r30, r18
    1be0:	f3 07       	cpc	r31, r19
    1be2:	d9 f7       	brne	.-10     	; 0x1bda <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
    1be4:	08 95       	ret

00001be6 <_Z25eth_type_is_arp_and_my_ipPhj>:
    1be6:	69 32       	cpi	r22, 0x29	; 41
    1be8:	71 05       	cpc	r23, r1
    1bea:	c8 f0       	brcs	.+50     	; 0x1c1e <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
    1bec:	fc 01       	movw	r30, r24
    1bee:	24 85       	ldd	r18, Z+12	; 0x0c
    1bf0:	28 30       	cpi	r18, 0x08	; 8
    1bf2:	b9 f4       	brne	.+46     	; 0x1c22 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
    1bf4:	25 85       	ldd	r18, Z+13	; 0x0d
    1bf6:	26 30       	cpi	r18, 0x06	; 6
    1bf8:	b1 f4       	brne	.+44     	; 0x1c26 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
    1bfa:	36 a1       	ldd	r19, Z+38	; 0x26
    1bfc:	20 91 e3 01 	lds	r18, 0x01E3	; 0x8001e3 <_ZL6ipaddr>
    1c00:	32 13       	cpse	r19, r18
    1c02:	13 c0       	rjmp	.+38     	; 0x1c2a <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
    1c04:	b7 96       	adiw	r30, 0x27	; 39
    1c06:	a4 ee       	ldi	r26, 0xE4	; 228
    1c08:	b1 e0       	ldi	r27, 0x01	; 1
    1c0a:	8a 96       	adiw	r24, 0x2a	; 42
    1c0c:	31 91       	ld	r19, Z+
    1c0e:	2d 91       	ld	r18, X+
    1c10:	32 13       	cpse	r19, r18
    1c12:	0d c0       	rjmp	.+26     	; 0x1c2e <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
    1c14:	e8 17       	cp	r30, r24
    1c16:	f9 07       	cpc	r31, r25
    1c18:	c9 f7       	brne	.-14     	; 0x1c0c <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
    1c1a:	81 e0       	ldi	r24, 0x01	; 1
    1c1c:	08 95       	ret
    1c1e:	80 e0       	ldi	r24, 0x00	; 0
    1c20:	08 95       	ret
    1c22:	80 e0       	ldi	r24, 0x00	; 0
    1c24:	08 95       	ret
    1c26:	80 e0       	ldi	r24, 0x00	; 0
    1c28:	08 95       	ret
    1c2a:	80 e0       	ldi	r24, 0x00	; 0
    1c2c:	08 95       	ret
    1c2e:	80 e0       	ldi	r24, 0x00	; 0
    1c30:	08 95       	ret

00001c32 <_Z24eth_type_is_ip_and_my_ipPhj>:
    1c32:	cf 93       	push	r28
    1c34:	df 93       	push	r29
    1c36:	fc 01       	movw	r30, r24
    1c38:	6a 32       	cpi	r22, 0x2A	; 42
    1c3a:	71 05       	cpc	r23, r1
    1c3c:	e0 f0       	brcs	.+56     	; 0x1c76 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
    1c3e:	84 85       	ldd	r24, Z+12	; 0x0c
    1c40:	88 30       	cpi	r24, 0x08	; 8
    1c42:	d9 f4       	brne	.+54     	; 0x1c7a <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
    1c44:	85 85       	ldd	r24, Z+13	; 0x0d
    1c46:	81 11       	cpse	r24, r1
    1c48:	1a c0       	rjmp	.+52     	; 0x1c7e <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
    1c4a:	96 85       	ldd	r25, Z+14	; 0x0e
    1c4c:	95 34       	cpi	r25, 0x45	; 69
    1c4e:	c1 f4       	brne	.+48     	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c50:	26 8d       	ldd	r18, Z+30	; 0x1e
    1c52:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <_ZL6ipaddr>
    1c56:	29 13       	cpse	r18, r25
    1c58:	13 c0       	rjmp	.+38     	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c5a:	df 01       	movw	r26, r30
    1c5c:	5f 96       	adiw	r26, 0x1f	; 31
    1c5e:	c4 ee       	ldi	r28, 0xE4	; 228
    1c60:	d1 e0       	ldi	r29, 0x01	; 1
    1c62:	b2 96       	adiw	r30, 0x22	; 34
    1c64:	2d 91       	ld	r18, X+
    1c66:	99 91       	ld	r25, Y+
    1c68:	29 13       	cpse	r18, r25
    1c6a:	0a c0       	rjmp	.+20     	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c6c:	ae 17       	cp	r26, r30
    1c6e:	bf 07       	cpc	r27, r31
    1c70:	c9 f7       	brne	.-14     	; 0x1c64 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
    1c72:	81 e0       	ldi	r24, 0x01	; 1
    1c74:	05 c0       	rjmp	.+10     	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c76:	80 e0       	ldi	r24, 0x00	; 0
    1c78:	03 c0       	rjmp	.+6      	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c7a:	80 e0       	ldi	r24, 0x00	; 0
    1c7c:	01 c0       	rjmp	.+2      	; 0x1c80 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    1c7e:	80 e0       	ldi	r24, 0x00	; 0
    1c80:	df 91       	pop	r29
    1c82:	cf 91       	pop	r28
    1c84:	08 95       	ret

00001c86 <_Z8make_ethPh>:
    1c86:	fc 01       	movw	r30, r24
    1c88:	a7 ee       	ldi	r26, 0xE7	; 231
    1c8a:	b1 e0       	ldi	r27, 0x01	; 1
    1c8c:	9c 01       	movw	r18, r24
    1c8e:	2a 5f       	subi	r18, 0xFA	; 250
    1c90:	3f 4f       	sbci	r19, 0xFF	; 255
    1c92:	86 81       	ldd	r24, Z+6	; 0x06
    1c94:	81 93       	st	Z+, r24
    1c96:	8d 91       	ld	r24, X+
    1c98:	85 83       	std	Z+5, r24	; 0x05
    1c9a:	e2 17       	cp	r30, r18
    1c9c:	f3 07       	cpc	r31, r19
    1c9e:	c9 f7       	brne	.-14     	; 0x1c92 <_Z8make_ethPh+0xc>
    1ca0:	08 95       	ret

00001ca2 <_Z20fill_ip_hdr_checksumPh>:
    1ca2:	cf 93       	push	r28
    1ca4:	df 93       	push	r29
    1ca6:	ec 01       	movw	r28, r24
    1ca8:	18 8e       	std	Y+24, r1	; 0x18
    1caa:	19 8e       	std	Y+25, r1	; 0x19
    1cac:	80 e4       	ldi	r24, 0x40	; 64
    1cae:	8c 8b       	std	Y+20, r24	; 0x14
    1cb0:	1d 8a       	std	Y+21, r1	; 0x15
    1cb2:	8e 8b       	std	Y+22, r24	; 0x16
    1cb4:	40 e0       	ldi	r20, 0x00	; 0
    1cb6:	64 e1       	ldi	r22, 0x14	; 20
    1cb8:	70 e0       	ldi	r23, 0x00	; 0
    1cba:	ce 01       	movw	r24, r28
    1cbc:	0e 96       	adiw	r24, 0x0e	; 14
    1cbe:	04 df       	rcall	.-504    	; 0x1ac8 <_Z8checksumPhjh>
    1cc0:	98 8f       	std	Y+24, r25	; 0x18
    1cc2:	89 8f       	std	Y+25, r24	; 0x19
    1cc4:	df 91       	pop	r29
    1cc6:	cf 91       	pop	r28
    1cc8:	08 95       	ret

00001cca <_Z7make_ipPh>:
    1cca:	ac 01       	movw	r20, r24
    1ccc:	a3 ee       	ldi	r26, 0xE3	; 227
    1cce:	b1 e0       	ldi	r27, 0x01	; 1
    1cd0:	fc 01       	movw	r30, r24
    1cd2:	7a 96       	adiw	r30, 0x1a	; 26
    1cd4:	27 ee       	ldi	r18, 0xE7	; 231
    1cd6:	31 e0       	ldi	r19, 0x01	; 1
    1cd8:	90 81       	ld	r25, Z
    1cda:	94 83       	std	Z+4, r25	; 0x04
    1cdc:	9d 91       	ld	r25, X+
    1cde:	91 93       	st	Z+, r25
    1ce0:	a2 17       	cp	r26, r18
    1ce2:	b3 07       	cpc	r27, r19
    1ce4:	c9 f7       	brne	.-14     	; 0x1cd8 <_Z7make_ipPh+0xe>
    1ce6:	ca 01       	movw	r24, r20
    1ce8:	dc cf       	rjmp	.-72     	; 0x1ca2 <_Z20fill_ip_hdr_checksumPh>
    1cea:	08 95       	ret

00001cec <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
    1cec:	cf 93       	push	r28
    1cee:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    1cf0:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    1cf2:	c9 df       	rcall	.-110    	; 0x1c86 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    1cf4:	1c 8a       	std	Y+20, r1	; 0x14
    1cf6:	82 e0       	ldi	r24, 0x02	; 2
    1cf8:	8d 8b       	std	Y+21, r24	; 0x15
    1cfa:	a7 ee       	ldi	r26, 0xE7	; 231
    1cfc:	b1 e0       	ldi	r27, 0x01	; 1
    1cfe:	fe 01       	movw	r30, r28
    1d00:	76 96       	adiw	r30, 0x16	; 22
    1d02:	2d ee       	ldi	r18, 0xED	; 237
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    1d04:	31 e0       	ldi	r19, 0x01	; 1
    1d06:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    1d08:	82 87       	std	Z+10, r24	; 0x0a
    1d0a:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    1d0c:	81 93       	st	Z+, r24
    1d0e:	a2 17       	cp	r26, r18
    1d10:	b3 07       	cpc	r27, r19
    1d12:	c9 f7       	brne	.-14     	; 0x1d06 <_Z28make_arp_answer_from_requestPh+0x1a>
    1d14:	a3 ee       	ldi	r26, 0xE3	; 227
    1d16:	b1 e0       	ldi	r27, 0x01	; 1
    1d18:	fe 01       	movw	r30, r28
    1d1a:	7c 96       	adiw	r30, 0x1c	; 28
    1d1c:	27 ee       	ldi	r18, 0xE7	; 231
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    1d1e:	31 e0       	ldi	r19, 0x01	; 1
    1d20:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    1d22:	82 87       	std	Z+10, r24	; 0x0a
    1d24:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    1d26:	81 93       	st	Z+, r24
    1d28:	a2 17       	cp	r26, r18
    1d2a:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    1d2c:	c9 f7       	brne	.-14     	; 0x1d20 <_Z28make_arp_answer_from_requestPh+0x34>
    1d2e:	be 01       	movw	r22, r28
    1d30:	8a e2       	ldi	r24, 0x2A	; 42
    1d32:	90 e0       	ldi	r25, 0x00	; 0
}
    1d34:	36 de       	rcall	.-916    	; 0x19a2 <_Z18enc28j60PacketSendjPh>
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	08 95       	ret

00001d3c <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    1d3c:	0f 93       	push	r16
    1d3e:	1f 93       	push	r17
    1d40:	cf 93       	push	r28
    1d42:	df 93       	push	r29
    1d44:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    1d46:	8b 01       	movw	r16, r22
    1d48:	9e df       	rcall	.-196    	; 0x1c86 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    1d4a:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    1d4c:	be df       	rcall	.-132    	; 0x1cca <_Z7make_ipPh>
    1d4e:	1a a2       	std	Y+34, r1	; 0x22
    1d50:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    1d52:	88 3f       	cpi	r24, 0xF8	; 248
    1d54:	18 f0       	brcs	.+6      	; 0x1d5c <_Z28make_echo_reply_from_requestPhj+0x20>
    1d56:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    1d58:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
    1d5a:	9d a3       	std	Y+37, r25	; 0x25
    1d5c:	88 5f       	subi	r24, 0xF8	; 248
    1d5e:	8c a3       	std	Y+36, r24	; 0x24
}
    1d60:	be 01       	movw	r22, r28
    1d62:	c8 01       	movw	r24, r16
    1d64:	1e de       	rcall	.-964    	; 0x19a2 <_Z18enc28j60PacketSendjPh>
    1d66:	df 91       	pop	r29
    1d68:	cf 91       	pop	r28
    1d6a:	1f 91       	pop	r17
    1d6c:	0f 91       	pop	r16
    1d6e:	08 95       	ret

00001d70 <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    1d70:	df 92       	push	r13
    1d72:	ef 92       	push	r14
    1d74:	ff 92       	push	r15
    1d76:	0f 93       	push	r16
    1d78:	1f 93       	push	r17
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	ec 01       	movw	r28, r24
    1d80:	d6 2e       	mov	r13, r22
    1d82:	e7 2e       	mov	r14, r23
    1d84:	04 2f       	mov	r16, r20
    1d86:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    1d88:	f3 2e       	mov	r15, r19
    1d8a:	7d df       	rcall	.-262    	; 0x1c86 <_Z8make_ethPh>
    1d8c:	0d 3d       	cpi	r16, 0xDD	; 221
    1d8e:	08 f0       	brcs	.+2      	; 0x1d92 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    1d90:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    1d92:	18 8a       	std	Y+16, r1	; 0x10
    1d94:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    1d96:	80 0f       	add	r24, r16
    1d98:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	96 df       	rcall	.-212    	; 0x1cca <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    1d9e:	8a a1       	ldd	r24, Y+34	; 0x22
    1da0:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    1da2:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    1da4:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    1da6:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    1da8:	1b a3       	std	Y+35, r17	; 0x23
    1daa:	1e a2       	std	Y+38, r1	; 0x26
    1dac:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    1dae:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    1db0:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
    1db2:	18 a6       	std	Y+40, r1	; 0x28
    1db4:	19 a6       	std	Y+41, r1	; 0x29
    1db6:	00 23       	and	r16, r16
    1db8:	81 f0       	breq	.+32     	; 0x1dda <_Z27make_udp_reply_from_requestPhPchj+0x6a>
    1dba:	ad 2d       	mov	r26, r13
    1dbc:	be 2d       	mov	r27, r14
    1dbe:	fe 01       	movw	r30, r28
    1dc0:	ba 96       	adiw	r30, 0x2a	; 42
    1dc2:	2f ef       	ldi	r18, 0xFF	; 255
    1dc4:	20 0f       	add	r18, r16
    1dc6:	30 e0       	ldi	r19, 0x00	; 0
    1dc8:	25 5d       	subi	r18, 0xD5	; 213
    1dca:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
    1dcc:	2c 0f       	add	r18, r28
    1dce:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    1dd0:	9d 91       	ld	r25, X+
    1dd2:	91 93       	st	Z+, r25
    1dd4:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    1dd6:	f3 07       	cpc	r31, r19
    1dd8:	d9 f7       	brne	.-10     	; 0x1dd0 <_Z27make_udp_reply_from_requestPhPchj+0x60>
    1dda:	10 e0       	ldi	r17, 0x00	; 0
    1ddc:	b8 01       	movw	r22, r16
    1dde:	60 5f       	subi	r22, 0xF0	; 240
    1de0:	7f 4f       	sbci	r23, 0xFF	; 255
    1de2:	41 e0       	ldi	r20, 0x01	; 1
    1de4:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1de6:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    1de8:	6f de       	rcall	.-802    	; 0x1ac8 <_Z8checksumPhjh>
    1dea:	98 a7       	std	Y+40, r25	; 0x28
    1dec:	89 a7       	std	Y+41, r24	; 0x29
    1dee:	be 01       	movw	r22, r28
}
    1df0:	c8 01       	movw	r24, r16
    1df2:	8a 96       	adiw	r24, 0x2a	; 42
    1df4:	d6 dd       	rcall	.-1108   	; 0x19a2 <_Z18enc28j60PacketSendjPh>
    1df6:	df 91       	pop	r29
    1df8:	cf 91       	pop	r28
    1dfa:	1f 91       	pop	r17
    1dfc:	0f 91       	pop	r16
    1dfe:	ff 90       	pop	r15
    1e00:	ef 90       	pop	r14
    1e02:	df 90       	pop	r13
    1e04:	08 95       	ret

00001e06 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1e06:	87 b3       	in	r24, 0x17	; 23
    1e08:	86 60       	ori	r24, 0x06	; 6
    1e0a:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    1e0c:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    1e0e:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    1e10:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    1e12:	80 e5       	ldi	r24, 0x50	; 80
    1e14:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    1e16:	70 9a       	sbi	0x0e, 0	; 14
    1e18:	08 95       	ret

00001e1a <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1e1a:	00 97       	sbiw	r24, 0x00	; 0
    1e1c:	41 f0       	breq	.+16     	; 0x1e2e <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1e1e:	ef eb       	ldi	r30, 0xBF	; 191
    1e20:	f0 e0       	ldi	r31, 0x00	; 0
    1e22:	31 97       	sbiw	r30, 0x01	; 1
    1e24:	f1 f7       	brne	.-4      	; 0x1e22 <_Z8delay_msj+0x8>
    1e26:	00 c0       	rjmp	.+0      	; 0x1e28 <_Z8delay_msj+0xe>
    1e28:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    1e2a:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1e2c:	c1 f7       	brne	.-16     	; 0x1e1e <_Z8delay_msj+0x4>
    1e2e:	08 95       	ret

00001e30 <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    1e30:	e4 ec       	ldi	r30, 0xC4	; 196
    1e32:	f2 e0       	ldi	r31, 0x02	; 2
    1e34:	84 85       	ldd	r24, Z+12	; 0x0c
    1e36:	95 85       	ldd	r25, Z+13	; 0x0d
    1e38:	01 96       	adiw	r24, 0x01	; 1
    1e3a:	95 87       	std	Z+13, r25	; 0x0d
    1e3c:	84 87       	std	Z+12, r24	; 0x0c
	Ctl_LCD_Cursor++;
    1e3e:	80 91 ab 02 	lds	r24, 0x02AB	; 0x8002ab <Ctl_LCD_Cursor>
    1e42:	8f 5f       	subi	r24, 0xFF	; 255
    1e44:	80 93 ab 02 	sts	0x02AB, r24	; 0x8002ab <Ctl_LCD_Cursor>
	cbi(PORTB,5); //통신 램프 클리어
    1e48:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6); //통신 램프 클리어 	
    1e4a:	c6 98       	cbi	0x18, 6	; 24
	#if USE_SYSTEM_SEC
		//mem4[SYSTEM_SEC_CLOCK]++;
		current_states_times++;
    1e4c:	80 91 3c 03 	lds	r24, 0x033C	; 0x80033c <current_states_times>
    1e50:	90 91 3d 03 	lds	r25, 0x033D	; 0x80033d <current_states_times+0x1>
    1e54:	a0 91 3e 03 	lds	r26, 0x033E	; 0x80033e <current_states_times+0x2>
    1e58:	b0 91 3f 03 	lds	r27, 0x033F	; 0x80033f <current_states_times+0x3>
    1e5c:	01 96       	adiw	r24, 0x01	; 1
    1e5e:	a1 1d       	adc	r26, r1
    1e60:	b1 1d       	adc	r27, r1
    1e62:	80 93 3c 03 	sts	0x033C, r24	; 0x80033c <current_states_times>
    1e66:	90 93 3d 03 	sts	0x033D, r25	; 0x80033d <current_states_times+0x1>
    1e6a:	a0 93 3e 03 	sts	0x033E, r26	; 0x80033e <current_states_times+0x2>
    1e6e:	b0 93 3f 03 	sts	0x033F, r27	; 0x80033f <current_states_times+0x3>
    1e72:	08 95       	ret

00001e74 <_Z7ADC_ISR8Dev_typej>:
	#endif
}
void ADC_ISR(Dev_type Device,uint16_t Arg)
{
    1e74:	08 95       	ret

00001e76 <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,80,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    1e76:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    1e7a:	81 11       	cpse	r24, r1
    1e7c:	03 c0       	rjmp	.+6      	; 0x1e84 <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    1e7e:	81 e0       	ldi	r24, 0x01	; 1
    1e80:	80 93 aa 02 	sts	0x02AA, r24	; 0x8002aa <chatter_flag>
    1e84:	08 95       	ret

00001e86 <_ZL5proc2Pv>:

#if USE_ETH
static uint8_t buf[BUFFER_SIZE+1];
//SemaphoreHandle_t eth_mutex;
static void proc2(void* pvParam)
{
    1e86:	cf 93       	push	r28
    1e88:	df 93       	push	r29
    1e8a:	cd b7       	in	r28, 0x3d	; 61
    1e8c:	de b7       	in	r29, 0x3e	; 62
    1e8e:	64 97       	sbiw	r28, 0x14	; 20
    1e90:	0f b6       	in	r0, 0x3f	; 63
    1e92:	f8 94       	cli
    1e94:	de bf       	out	0x3e, r29	; 62
    1e96:	0f be       	out	0x3f, r0	; 63
    1e98:	cd bf       	out	0x3d, r28	; 61
	//eth_mutex= xSemaphoreCreateMutex();
RESET_ETH:
	//xSemaphoreGive(eth_mutex);
    char led_flag = 0;
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1e9a:	0f 2e       	mov	r0, r31
    1e9c:	fc ea       	ldi	r31, 0xAC	; 172
    1e9e:	4f 2e       	mov	r4, r31
    1ea0:	f2 e0       	ldi	r31, 0x02	; 2
    1ea2:	5f 2e       	mov	r5, r31
    1ea4:	f0 2d       	mov	r31, r0

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1ea6:	0f 2e       	mov	r0, r31
    1ea8:	f4 e0       	ldi	r31, 0x04	; 4
    1eaa:	8f 2e       	mov	r8, r31
    1eac:	f3 e0       	ldi	r31, 0x03	; 3
    1eae:	9f 2e       	mov	r9, r31
    1eb0:	f0 2d       	mov	r31, r0
    1eb2:	0f 2e       	mov	r0, r31
    1eb4:	f6 e0       	ldi	r31, 0x06	; 6
    1eb6:	af 2e       	mov	r10, r31
    1eb8:	f3 e0       	ldi	r31, 0x03	; 3
    1eba:	bf 2e       	mov	r11, r31
    1ebc:	f0 2d       	mov	r31, r0
    1ebe:	0f 2e       	mov	r0, r31
    1ec0:	f8 e0       	ldi	r31, 0x08	; 8
    1ec2:	6f 2e       	mov	r6, r31
    1ec4:	f3 e0       	ldi	r31, 0x03	; 3
    1ec6:	7f 2e       	mov	r7, r31
    1ec8:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01)  //리눅스 서버용 파싱 
		 {
			 uint8_t temp[16] = {0};
    1eca:	ce 01       	movw	r24, r28
    1ecc:	01 96       	adiw	r24, 0x01	; 1
    1ece:	9a 8b       	std	Y+18, r25	; 0x12
    1ed0:	89 8b       	std	Y+17, r24	; 0x11

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1ed2:	33 24       	eor	r3, r3
    1ed4:	33 94       	inc	r3
{
	//eth_mutex= xSemaphoreCreateMutex();
RESET_ETH:
	//xSemaphoreGive(eth_mutex);
    char led_flag = 0;
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1ed6:	f2 01       	movw	r30, r4
    1ed8:	80 81       	ld	r24, Z
    1eda:	91 81       	ldd	r25, Z+1	; 0x01
    1edc:	a2 81       	ldd	r26, Z+2	; 0x02
    1ede:	b3 81       	ldd	r27, Z+3	; 0x03
    1ee0:	80 93 a4 02 	sts	0x02A4, r24	; 0x8002a4 <_ZL4myip>
    1ee4:	90 93 a5 02 	sts	0x02A5, r25	; 0x8002a5 <_ZL4myip+0x1>
    1ee8:	a0 93 a6 02 	sts	0x02A6, r26	; 0x8002a6 <_ZL4myip+0x2>
    1eec:	b0 93 a7 02 	sts	0x02A7, r27	; 0x8002a7 <_ZL4myip+0x3>

	uint16_t plen;
	DDRB = 0xff;
    1ef0:	8f ef       	ldi	r24, 0xFF	; 255
    1ef2:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    1ef4:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    1ef6:	81 e0       	ldi	r24, 0x01	; 1
    1ef8:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    1efa:	d9 dc       	rcall	.-1614   	; 0x18ae <_Z12enc28j60InitPh>
    1efc:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    1efe:	d2 dc       	rcall	.-1628   	; 0x18a4 <_Z14enc28j60clkouth>
    1f00:	8a e0       	ldi	r24, 0x0A	; 10
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    1f08:	66 e7       	ldi	r22, 0x76	; 118
    1f0a:	74 e0       	ldi	r23, 0x04	; 4
    1f0c:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    1f0e:	b2 dc       	rcall	.-1692   	; 0x1874 <_Z16enc28j60PhyWritehj>
    1f10:	84 e1       	ldi	r24, 0x14	; 20
    1f12:	90 e0       	ldi	r25, 0x00	; 0
    1f14:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <vTaskDelay>
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    1f18:	40 e5       	ldi	r20, 0x50	; 80
    1f1a:	64 ea       	ldi	r22, 0xA4	; 164
    1f1c:	72 e0       	ldi	r23, 0x02	; 2
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	91 e0       	ldi	r25, 0x01	; 1
static void proc2(void* pvParam)
{
	//eth_mutex= xSemaphoreCreateMutex();
RESET_ETH:
	//xSemaphoreGive(eth_mutex);
    char led_flag = 0;
    1f22:	48 de       	rcall	.-880    	; 0x1bb4 <_Z19init_ip_arp_udp_tcpPhS_h>

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1f24:	21 2c       	mov	r2, r1
    1f26:	0f 2e       	mov	r0, r31
    1f28:	fa e0       	ldi	r31, 0x0A	; 10
    1f2a:	cf 2e       	mov	r12, r31
    1f2c:	f3 e0       	ldi	r31, 0x03	; 3
    1f2e:	df 2e       	mov	r13, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[19] = {0};
			 data[0] = mem4[TEMP];
    1f30:	f0 2d       	mov	r31, r0
    1f32:	0d ee       	ldi	r16, 0xED	; 237
    1f34:	11 e0       	ldi	r17, 0x01	; 1
    1f36:	0f 2e       	mov	r0, r31
    1f38:	f4 ec       	ldi	r31, 0xC4	; 196
    1f3a:	ef 2e       	mov	r14, r31
    1f3c:	f2 e0       	ldi	r31, 0x02	; 2
    1f3e:	ff 2e       	mov	r15, r31

	 while(1)
	 {	 

		 
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1f40:	f0 2d       	mov	r31, r0
    1f42:	d2 01       	movw	r26, r4
    1f44:	8c 91       	ld	r24, X
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	f4 01       	movw	r30, r8
    1f4a:	60 81       	ld	r22, Z
    1f4c:	71 81       	ldd	r23, Z+1	; 0x01
    1f4e:	11 96       	adiw	r26, 0x01	; 1
    1f50:	4c 91       	ld	r20, X
    1f52:	50 e0       	ldi	r21, 0x00	; 0
    1f54:	33 2d       	mov	r19, r3
    1f56:	d5 01       	movw	r26, r10
    1f58:	ed 91       	ld	r30, X+
    1f5a:	fc 91       	ld	r31, X
    1f5c:	4e 17       	cp	r20, r30
    1f5e:	5f 07       	cpc	r21, r31
    1f60:	09 f4       	brne	.+2      	; 0x1f64 <_ZL5proc2Pv+0xde>
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	23 2d       	mov	r18, r3
    1f66:	86 17       	cp	r24, r22
    1f68:	97 07       	cpc	r25, r23
    1f6a:	09 f4       	brne	.+2      	; 0x1f6e <_ZL5proc2Pv+0xe8>
    1f6c:	20 e0       	ldi	r18, 0x00	; 0
    1f6e:	32 2b       	or	r19, r18
    1f70:	f2 01       	movw	r30, r4
    1f72:	42 81       	ldd	r20, Z+2	; 0x02
    1f74:	50 e0       	ldi	r21, 0x00	; 0
    1f76:	23 2d       	mov	r18, r3
    1f78:	d3 01       	movw	r26, r6
    1f7a:	ed 91       	ld	r30, X+
    1f7c:	fc 91       	ld	r31, X
    1f7e:	4e 17       	cp	r20, r30
    1f80:	5f 07       	cpc	r21, r31
    1f82:	09 f4       	brne	.+2      	; 0x1f86 <_ZL5proc2Pv+0x100>
    1f84:	20 e0       	ldi	r18, 0x00	; 0
    1f86:	23 2b       	or	r18, r19
    1f88:	71 f4       	brne	.+28     	; 0x1fa6 <_ZL5proc2Pv+0x120>
    1f8a:	f2 01       	movw	r30, r4
    1f8c:	23 81       	ldd	r18, Z+3	; 0x03
    1f8e:	30 e0       	ldi	r19, 0x00	; 0
    1f90:	43 2d       	mov	r20, r3
    1f92:	d6 01       	movw	r26, r12
    1f94:	ed 91       	ld	r30, X+
    1f96:	fc 91       	ld	r31, X
    1f98:	2e 17       	cp	r18, r30
    1f9a:	3f 07       	cpc	r19, r31
    1f9c:	09 f4       	brne	.+2      	; 0x1fa0 <_ZL5proc2Pv+0x11a>
    1f9e:	40 e0       	ldi	r20, 0x00	; 0
    1fa0:	44 23       	and	r20, r20
    1fa2:	09 f4       	brne	.+2      	; 0x1fa6 <_ZL5proc2Pv+0x120>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    1fa4:	47 c0       	rjmp	.+142    	; 0x2034 <_ZL5proc2Pv+0x1ae>
    1fa6:	86 17       	cp	r24, r22
    1fa8:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    1faa:	41 f0       	breq	.+16     	; 0x1fbc <_ZL5proc2Pv+0x136>
    1fac:	80 e0       	ldi	r24, 0x00	; 0
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	0e 94 de 22 	call	0x45bc	; 0x45bc <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    1fb4:	f4 01       	movw	r30, r8
    1fb6:	80 81       	ld	r24, Z
    1fb8:	d2 01       	movw	r26, r4
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    1fba:	8c 93       	st	X, r24
    1fbc:	f5 01       	movw	r30, r10
    1fbe:	60 81       	ld	r22, Z
    1fc0:	71 81       	ldd	r23, Z+1	; 0x01
    1fc2:	d2 01       	movw	r26, r4
    1fc4:	11 96       	adiw	r26, 0x01	; 1
    1fc6:	8c 91       	ld	r24, X
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	86 17       	cp	r24, r22
    1fcc:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    1fce:	49 f0       	breq	.+18     	; 0x1fe2 <_ZL5proc2Pv+0x15c>
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	90 e0       	ldi	r25, 0x00	; 0
    1fd4:	0e 94 de 22 	call	0x45bc	; 0x45bc <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    1fd8:	f5 01       	movw	r30, r10
    1fda:	80 81       	ld	r24, Z
    1fdc:	d2 01       	movw	r26, r4
    1fde:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    1fe0:	8c 93       	st	X, r24
    1fe2:	f3 01       	movw	r30, r6
    1fe4:	60 81       	ld	r22, Z
    1fe6:	71 81       	ldd	r23, Z+1	; 0x01
    1fe8:	d2 01       	movw	r26, r4
    1fea:	12 96       	adiw	r26, 0x02	; 2
    1fec:	8c 91       	ld	r24, X
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	86 17       	cp	r24, r22
    1ff2:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    1ff4:	49 f0       	breq	.+18     	; 0x2008 <_ZL5proc2Pv+0x182>
    1ff6:	82 e0       	ldi	r24, 0x02	; 2
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	0e 94 de 22 	call	0x45bc	; 0x45bc <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    1ffe:	f3 01       	movw	r30, r6
    2000:	80 81       	ld	r24, Z
    2002:	d2 01       	movw	r26, r4
    2004:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    2006:	8c 93       	st	X, r24
    2008:	60 91 0a 03 	lds	r22, 0x030A	; 0x80030a <mem4+0x46>
    200c:	70 91 0b 03 	lds	r23, 0x030B	; 0x80030b <mem4+0x47>
    2010:	f2 01       	movw	r30, r4
    2012:	83 81       	ldd	r24, Z+3	; 0x03
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	86 17       	cp	r24, r22
    2018:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    201a:	49 f0       	breq	.+18     	; 0x202e <_ZL5proc2Pv+0x1a8>
    201c:	83 e0       	ldi	r24, 0x03	; 3
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	0e 94 de 22 	call	0x45bc	; 0x45bc <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    2024:	80 91 0a 03 	lds	r24, 0x030A	; 0x80030a <mem4+0x46>
    2028:	d2 01       	movw	r26, r4
    202a:	13 96       	adiw	r26, 0x03	; 3
			 }
			 cls_var = 1;
    202c:	8c 93       	st	X, r24
    202e:	30 92 a8 02 	sts	0x02A8, r3	; 0x8002a8 <cls_var>
			 goto RESET_ETH;
		 }
		// xSemaphoreTake(eth_mutex,100);
			 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    2032:	51 cf       	rjmp	.-350    	; 0x1ed6 <_ZL5proc2Pv+0x50>
    2034:	63 e1       	ldi	r22, 0x13	; 19
    2036:	72 e0       	ldi	r23, 0x02	; 2
    2038:	80 e8       	ldi	r24, 0x80	; 128
    203a:	90 e0       	ldi	r25, 0x00	; 0
    203c:	e0 dc       	rcall	.-1600   	; 0x19fe <_Z21enc28j60PacketReceivejPh>
		// xSemaphoreGive(eth_mutex);
		 if(plen==0)
    203e:	9c 8b       	std	Y+20, r25	; 0x14
    2040:	8b 8b       	std	Y+19, r24	; 0x13
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	09 f4       	brne	.+2      	; 0x2048 <_ZL5proc2Pv+0x1c2>
    2046:	77 c0       	rjmp	.+238    	; 0x2136 <_ZL5proc2Pv+0x2b0>
    2048:	bc 01       	movw	r22, r24
    204a:	83 e1       	ldi	r24, 0x13	; 19
    204c:	92 e0       	ldi	r25, 0x02	; 2
		 {
			 make_arp_answer_from_request(buf);
    204e:	cb dd       	rcall	.-1130   	; 0x1be6 <_Z25eth_type_is_arp_and_my_ipPhj>
    2050:	88 23       	and	r24, r24
    2052:	21 f0       	breq	.+8      	; 0x205c <_ZL5proc2Pv+0x1d6>
			 continue;
    2054:	83 e1       	ldi	r24, 0x13	; 19
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    2056:	92 e0       	ldi	r25, 0x02	; 2
    2058:	49 de       	rcall	.-878    	; 0x1cec <_Z28make_arp_answer_from_requestPh>
    205a:	73 cf       	rjmp	.-282    	; 0x1f42 <_ZL5proc2Pv+0xbc>
    205c:	6b 89       	ldd	r22, Y+19	; 0x13
    205e:	7c 89       	ldd	r23, Y+20	; 0x14
    2060:	83 e1       	ldi	r24, 0x13	; 19
    2062:	92 e0       	ldi	r25, 0x02	; 2
    2064:	e6 dd       	rcall	.-1076   	; 0x1c32 <_Z24eth_type_is_ip_and_my_ipPhj>
    2066:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    2068:	09 f4       	brne	.+2      	; 0x206c <_ZL5proc2Pv+0x1e6>
    206a:	6b cf       	rjmp	.-298    	; 0x1f42 <_ZL5proc2Pv+0xbc>
    206c:	80 91 2a 02 	lds	r24, 0x022A	; 0x80022a <_ZL3buf+0x17>
    2070:	81 30       	cpi	r24, 0x01	; 1
    2072:	51 f4       	brne	.+20     	; 0x2088 <_ZL5proc2Pv+0x202>
		 {
			make_echo_reply_from_request(buf,plen);
    2074:	80 91 35 02 	lds	r24, 0x0235	; 0x800235 <_ZL3buf+0x22>
    2078:	88 30       	cpi	r24, 0x08	; 8
    207a:	31 f4       	brne	.+12     	; 0x2088 <_ZL5proc2Pv+0x202>
    207c:	6b 89       	ldd	r22, Y+19	; 0x13
    207e:	7c 89       	ldd	r23, Y+20	; 0x14
			continue;
    2080:	83 e1       	ldi	r24, 0x13	; 19
		 }
		 if(buf[UDP_DATA_P] == 0x01)  //리눅스 서버용 파싱 
    2082:	92 e0       	ldi	r25, 0x02	; 2
    2084:	5b de       	rcall	.-842    	; 0x1d3c <_Z28make_echo_reply_from_requestPhj>
    2086:	5d cf       	rjmp	.-326    	; 0x1f42 <_ZL5proc2Pv+0xbc>
    2088:	80 91 3d 02 	lds	r24, 0x023D	; 0x80023d <_ZL3buf+0x2a>
		 {
			 uint8_t temp[16] = {0};
    208c:	81 30       	cpi	r24, 0x01	; 1
    208e:	09 f0       	breq	.+2      	; 0x2092 <_ZL5proc2Pv+0x20c>
    2090:	52 c0       	rjmp	.+164    	; 0x2136 <_ZL5proc2Pv+0x2b0>
    2092:	80 e1       	ldi	r24, 0x10	; 16
    2094:	e9 89       	ldd	r30, Y+17	; 0x11
    2096:	fa 89       	ldd	r31, Y+18	; 0x12
			 uint8_t loop = buf[UDP_DATA_P + 1];
    2098:	11 92       	st	Z+, r1
    209a:	8a 95       	dec	r24
			 uint8_t start = 2;
			 uint8_t num = 0;
			 if(loop > 12)
    209c:	e9 f7       	brne	.-6      	; 0x2098 <_ZL5proc2Pv+0x212>
    209e:	40 91 3e 02 	lds	r20, 0x023E	; 0x80023e <_ZL3buf+0x2b>
			 {
				 goto UDP_SEND;
			 }
			 for(uint8_t i=1;i<loop+1;i++)
    20a2:	4d 30       	cpi	r20, 0x0D	; 13
    20a4:	08 f0       	brcs	.+2      	; 0x20a8 <_ZL5proc2Pv+0x222>
    20a6:	47 c0       	rjmp	.+142    	; 0x2136 <_ZL5proc2Pv+0x2b0>
    20a8:	50 e0       	ldi	r21, 0x00	; 0
    20aa:	4f 5f       	subi	r20, 0xFF	; 255
    20ac:	5f 4f       	sbci	r21, 0xFF	; 255
    20ae:	42 30       	cpi	r20, 0x02	; 2
    20b0:	51 05       	cpc	r21, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    20b2:	0c f0       	brlt	.+2      	; 0x20b6 <_ZL5proc2Pv+0x230>
    20b4:	ce c0       	rjmp	.+412    	; 0x2252 <_ZL5proc2Pv+0x3cc>
    20b6:	22 c0       	rjmp	.+68     	; 0x20fc <_ZL5proc2Pv+0x276>
    20b8:	fc 01       	movw	r30, r24
    20ba:	ed 5e       	subi	r30, 0xED	; 237
    20bc:	fd 4f       	sbci	r31, 0xFD	; 253
    20be:	63 a5       	ldd	r22, Z+43	; 0x2b
    20c0:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    20c2:	e8 0f       	add	r30, r24
    20c4:	f9 1f       	adc	r31, r25
				 {
					 mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    20c6:	60 83       	st	Z, r22
    20c8:	20 fd       	sbrc	r18, 0
    20ca:	12 c0       	rjmp	.+36     	; 0x20f0 <_ZL5proc2Pv+0x26a>
    20cc:	e3 2f       	mov	r30, r19
    20ce:	f0 e0       	ldi	r31, 0x00	; 0
    20d0:	ee 0f       	add	r30, r30
    20d2:	ff 1f       	adc	r31, r31
    20d4:	e8 52       	subi	r30, 0x28	; 40
    20d6:	fd 4f       	sbci	r31, 0xFD	; 253
    20d8:	af ef       	ldi	r26, 0xFF	; 255
    20da:	bf ef       	ldi	r27, 0xFF	; 255
    20dc:	ac 0f       	add	r26, r28
    20de:	bd 1f       	adc	r27, r29
    20e0:	a8 0f       	add	r26, r24
    20e2:	b9 1f       	adc	r27, r25
    20e4:	8c 91       	ld	r24, X
    20e6:	90 e0       	ldi	r25, 0x00	; 0
					 num++;
    20e8:	96 2b       	or	r25, r22
			 uint8_t num = 0;
			 if(loop > 12)
			 {
				 goto UDP_SEND;
			 }
			 for(uint8_t i=1;i<loop+1;i++)
    20ea:	91 83       	std	Z+1, r25	; 0x01
    20ec:	80 83       	st	Z, r24
    20ee:	3f 5f       	subi	r19, 0xFF	; 255
    20f0:	2f 5f       	subi	r18, 0xFF	; 255
    20f2:	82 2f       	mov	r24, r18
    20f4:	90 e0       	ldi	r25, 0x00	; 0
				 {
					 mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					 num++;
				 }
			 }
			  mem4[GOAL_CNT] =  (0xff00 & (buf[UDP_DATA_P + 14] << 8))| (0x00ff & buf[UDP_DATA_P + 15]);
    20f6:	84 17       	cp	r24, r20
    20f8:	95 07       	cpc	r25, r21
    20fa:	f4 f2       	brlt	.-68     	; 0x20b8 <_ZL5proc2Pv+0x232>
    20fc:	e3 e1       	ldi	r30, 0x13	; 19
    20fe:	f2 e0       	ldi	r31, 0x02	; 2
    2100:	80 ad       	ldd	r24, Z+56	; 0x38
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	98 2f       	mov	r25, r24
    2106:	88 27       	eor	r24, r24
    2108:	21 ad       	ldd	r18, Z+57	; 0x39
    210a:	82 2b       	or	r24, r18
    210c:	d7 01       	movw	r26, r14
    210e:	51 96       	adiw	r26, 0x11	; 17
			  mem4[TARGET_MAX] = mem4[GOAL_CNT];
    2110:	9c 93       	st	X, r25
    2112:	8e 93       	st	-X, r24
    2114:	50 97       	sbiw	r26, 0x10	; 16
    2116:	dd 96       	adiw	r26, 0x3d	; 61
			  mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    2118:	9c 93       	st	X, r25
    211a:	8e 93       	st	-X, r24
    211c:	dc 97       	sbiw	r26, 0x3c	; 60
    211e:	d9 96       	adiw	r26, 0x39	; 57
			  mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    2120:	9c 93       	st	X, r25
    2122:	8e 93       	st	-X, r24
    2124:	d8 97       	sbiw	r26, 0x38	; 56
    2126:	d7 96       	adiw	r26, 0x37	; 55
			  mem4[TARGET_CMP] = mem4[GOAL_CNT];
    2128:	9c 93       	st	X, r25
    212a:	8e 93       	st	-X, r24
    212c:	d6 97       	sbiw	r26, 0x36	; 54
    212e:	df 96       	adiw	r26, 0x3f	; 63
					 num++;
				 }
			 }
		 }*/
		 UDP_SEND:
			 led_flag = ~led_flag;
    2130:	9c 93       	st	X, r25
			 if(led_flag)
    2132:	8e 93       	st	-X, r24
			 {
				 PORTB = sbi(PORTB,4);
    2134:	de 97       	sbiw	r26, 0x3e	; 62
    2136:	20 94       	com	r2
    2138:	29 f0       	breq	.+10     	; 0x2144 <_ZL5proc2Pv+0x2be>
    213a:	88 b3       	in	r24, 0x18	; 24
    213c:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    213e:	88 bb       	out	0x18, r24	; 24
    2140:	88 bb       	out	0x18, r24	; 24
    2142:	04 c0       	rjmp	.+8      	; 0x214c <_ZL5proc2Pv+0x2c6>
    2144:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[19] = {0};
			 data[0] = mem4[TEMP];
    2146:	8f 7e       	andi	r24, 0xEF	; 239
    2148:	88 bb       	out	0x18, r24	; 24
    214a:	88 bb       	out	0x18, r24	; 24
    214c:	f7 01       	movw	r30, r14
    214e:	82 81       	ldd	r24, Z+2	; 0x02
    2150:	93 81       	ldd	r25, Z+3	; 0x03
    2152:	d8 01       	movw	r26, r16
			 data[1] = mem4[COUNT];
    2154:	11 96       	adiw	r26, 0x01	; 1
    2156:	9c 93       	st	X, r25
    2158:	8e 93       	st	-X, r24
    215a:	86 81       	ldd	r24, Z+6	; 0x06
    215c:	97 81       	ldd	r25, Z+7	; 0x07
    215e:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    2160:	9c 93       	st	X, r25
    2162:	8e 93       	st	-X, r24
    2164:	12 97       	sbiw	r26, 0x02	; 2
    2166:	84 81       	ldd	r24, Z+4	; 0x04
    2168:	95 81       	ldd	r25, Z+5	; 0x05
    216a:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    216c:	9c 93       	st	X, r25
    216e:	8e 93       	st	-X, r24
    2170:	14 97       	sbiw	r26, 0x04	; 4
    2172:	80 89       	ldd	r24, Z+16	; 0x10
    2174:	91 89       	ldd	r25, Z+17	; 0x11
    2176:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    2178:	9c 93       	st	X, r25
    217a:	8e 93       	st	-X, r24
    217c:	16 97       	sbiw	r26, 0x06	; 6
    217e:	82 89       	ldd	r24, Z+18	; 0x12
    2180:	93 89       	ldd	r25, Z+19	; 0x13
    2182:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    2184:	9c 93       	st	X, r25
    2186:	8e 93       	st	-X, r24
    2188:	18 97       	sbiw	r26, 0x08	; 8
    218a:	84 85       	ldd	r24, Z+12	; 0x0c
    218c:	95 85       	ldd	r25, Z+13	; 0x0d
    218e:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    2190:	9c 93       	st	X, r25
    2192:	8e 93       	st	-X, r24
    2194:	1a 97       	sbiw	r26, 0x0a	; 10
    2196:	82 85       	ldd	r24, Z+10	; 0x0a
    2198:	93 85       	ldd	r25, Z+11	; 0x0b
    219a:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    219c:	9c 93       	st	X, r25
    219e:	8e 93       	st	-X, r24
    21a0:	1c 97       	sbiw	r26, 0x0c	; 12
    21a2:	80 85       	ldd	r24, Z+8	; 0x08
    21a4:	91 85       	ldd	r25, Z+9	; 0x09
    21a6:	1f 96       	adiw	r26, 0x0f	; 15
			 data[8] = mem4[CURRENT_RUN_NUMBER];  //현재 생산 페이지
    21a8:	9c 93       	st	X, r25
    21aa:	8e 93       	st	-X, r24
    21ac:	1e 97       	sbiw	r26, 0x0e	; 14
    21ae:	e8 e1       	ldi	r30, 0x18	; 24
    21b0:	f3 e0       	ldi	r31, 0x03	; 3
    21b2:	80 81       	ld	r24, Z
    21b4:	91 81       	ldd	r25, Z+1	; 0x01
    21b6:	51 96       	adiw	r26, 0x11	; 17
			 data[9] = mem4[CURRENT_STATE_ON]; //혀재 생산 상태 값을 보냄. 가동중 or 가동 아닌 상태
    21b8:	9c 93       	st	X, r25
    21ba:	8e 93       	st	-X, r24
    21bc:	50 97       	sbiw	r26, 0x10	; 16
    21be:	a6 e1       	ldi	r26, 0x16	; 22
    21c0:	b3 e0       	ldi	r27, 0x03	; 3
    21c2:	8d 91       	ld	r24, X+
    21c4:	9c 91       	ld	r25, X
			 data[10] = mem4[START_BUTTON]; //현재 시작 버튼의 상태를 보냄
    21c6:	f8 01       	movw	r30, r16
    21c8:	93 8b       	std	Z+19, r25	; 0x13
    21ca:	82 8b       	std	Z+18, r24	; 0x12
    21cc:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <mem4+0x4c>
    21d0:	90 91 11 03 	lds	r25, 0x0311	; 0x800311 <mem4+0x4d>
			 data[11] = mem4[CURRENT_PAGE]; //현재 뷰 페이지 정보 
    21d4:	95 8b       	std	Z+21, r25	; 0x15
    21d6:	84 8b       	std	Z+20, r24	; 0x14
    21d8:	80 91 14 03 	lds	r24, 0x0314	; 0x800314 <mem4+0x50>
    21dc:	90 91 15 03 	lds	r25, 0x0315	; 0x800315 <mem4+0x51>
			 data[12] = device_serial;
    21e0:	97 8b       	std	Z+23, r25	; 0x17
    21e2:	86 8b       	std	Z+22, r24	; 0x16
    21e4:	81 e0       	ldi	r24, 0x01	; 1
			 data[13] = mem4[UDP_DATA0];
    21e6:	90 ef       	ldi	r25, 0xF0	; 240
    21e8:	91 8f       	std	Z+25, r25	; 0x19
    21ea:	80 8f       	std	Z+24, r24	; 0x18
    21ec:	d7 01       	movw	r26, r14
    21ee:	54 96       	adiw	r26, 0x14	; 20
    21f0:	8d 91       	ld	r24, X+
    21f2:	9c 91       	ld	r25, X
			 data[14] = mem4[UDP_DATA1];
    21f4:	55 97       	sbiw	r26, 0x15	; 21
    21f6:	93 8f       	std	Z+27, r25	; 0x1b
    21f8:	82 8f       	std	Z+26, r24	; 0x1a
    21fa:	56 96       	adiw	r26, 0x16	; 22
    21fc:	8d 91       	ld	r24, X+
    21fe:	9c 91       	ld	r25, X
			 data[15] = mem4[UDP_DATA2];
    2200:	57 97       	sbiw	r26, 0x17	; 23
    2202:	95 8f       	std	Z+29, r25	; 0x1d
    2204:	84 8f       	std	Z+28, r24	; 0x1c
    2206:	58 96       	adiw	r26, 0x18	; 24
    2208:	8d 91       	ld	r24, X+
    220a:	9c 91       	ld	r25, X
			 data[16] = mem4[UDP_DATA3];
    220c:	59 97       	sbiw	r26, 0x19	; 25
    220e:	97 8f       	std	Z+31, r25	; 0x1f
    2210:	86 8f       	std	Z+30, r24	; 0x1e
    2212:	5a 96       	adiw	r26, 0x1a	; 26
    2214:	8d 91       	ld	r24, X+
    2216:	9c 91       	ld	r25, X
			 data[17] = mem4[UDP_DATA4];
    2218:	5b 97       	sbiw	r26, 0x1b	; 27
    221a:	91 a3       	std	Z+33, r25	; 0x21
    221c:	80 a3       	std	Z+32, r24	; 0x20
    221e:	5c 96       	adiw	r26, 0x1c	; 28
    2220:	8d 91       	ld	r24, X+
    2222:	9c 91       	ld	r25, X
			 data[18] = mem4[UDP_DATA5];
    2224:	5d 97       	sbiw	r26, 0x1d	; 29
    2226:	93 a3       	std	Z+35, r25	; 0x23
    2228:	82 a3       	std	Z+34, r24	; 0x22
    222a:	5e 96       	adiw	r26, 0x1e	; 30
    222c:	8d 91       	ld	r24, X+
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    222e:	9c 91       	ld	r25, X
    2230:	5f 97       	sbiw	r26, 0x1f	; 31
    2232:	95 a3       	std	Z+37, r25	; 0x25
    2234:	84 a3       	std	Z+36, r24	; 0x24
    2236:	2f e0       	ldi	r18, 0x0F	; 15
    2238:	37 e2       	ldi	r19, 0x27	; 39
    223a:	46 e2       	ldi	r20, 0x26	; 38
			// memcpy(buf,data,sizeof(data));
			 //enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+sizeof(data),buf);
			 //vTaskDelay(500);
			 //memset(buf,0,sizeof(buf));
			 //vTaskDelay(100);
			 lcd_cnt++;
    223c:	b8 01       	movw	r22, r16
    223e:	83 e1       	ldi	r24, 0x13	; 19
    2240:	92 e0       	ldi	r25, 0x02	; 2
    2242:	96 dd       	rcall	.-1236   	; 0x1d70 <_Z27make_udp_reply_from_requestPhPchj>
    2244:	80 91 a9 02 	lds	r24, 0x02A9	; 0x8002a9 <lcd_cnt>
			taskYIELD();
    2248:	8f 5f       	subi	r24, 0xFF	; 255
    224a:	80 93 a9 02 	sts	0x02A9, r24	; 0x8002a9 <lcd_cnt>
			 {
				 goto UDP_SEND;
			 }
			 for(uint8_t i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    224e:	50 d7       	rcall	.+3744   	; 0x30f0 <vPortYield>
    2250:	78 ce       	rjmp	.-784    	; 0x1f42 <_ZL5proc2Pv+0xbc>
    2252:	80 91 3f 02 	lds	r24, 0x023F	; 0x80023f <_ZL3buf+0x2c>
    2256:	89 83       	std	Y+1, r24	; 0x01
    2258:	21 e0       	ldi	r18, 0x01	; 1
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	49 cf       	rjmp	.-366    	; 0x20f0 <_ZL5proc2Pv+0x26a>

0000225e <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    225e:	cf 93       	push	r28
    2260:	df 93       	push	r29
    2262:	cd b7       	in	r28, 0x3d	; 61
    2264:	de b7       	in	r29, 0x3e	; 62
    2266:	2f 97       	sbiw	r28, 0x0f	; 15
    2268:	0f b6       	in	r0, 0x3f	; 63
    226a:	f8 94       	cli
    226c:	de bf       	out	0x3e, r29	; 62
    226e:	0f be       	out	0x3f, r0	; 63
    2270:	cd bf       	out	0x3d, r28	; 61
    2272:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    2274:	fe 01       	movw	r30, r28
    2276:	31 96       	adiw	r30, 0x01	; 1
    2278:	8f e0       	ldi	r24, 0x0F	; 15
    227a:	df 01       	movw	r26, r30
    227c:	1d 92       	st	X+, r1
    227e:	8a 95       	dec	r24
    2280:	e9 f7       	brne	.-6      	; 0x227c <_ZL5proc1Pv+0x1e>
		
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    2282:	04 ec       	ldi	r16, 0xC4	; 196
    2284:	12 e0       	ldi	r17, 0x02	; 2
    2286:	5e 01       	movw	r10, r28
    2288:	b0 e1       	ldi	r27, 0x10	; 16
    228a:	ab 0e       	add	r10, r27
    228c:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    228e:	0f 2e       	mov	r0, r31
    2290:	fa e9       	ldi	r31, 0x9A	; 154
    2292:	8f 2e       	mov	r8, r31
    2294:	91 2c       	mov	r9, r1
    2296:	f0 2d       	mov	r31, r0
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    2298:	0f 2e       	mov	r0, r31
    229a:	fc e0       	ldi	r31, 0x0C	; 12
    229c:	6f 2e       	mov	r6, r31
    229e:	f3 e0       	ldi	r31, 0x03	; 3
    22a0:	7f 2e       	mov	r7, r31
    22a2:	f0 2d       	mov	r31, r0

				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    22a4:	0f 2e       	mov	r0, r31
    22a6:	f3 e0       	ldi	r31, 0x03	; 3
    22a8:	2f 2e       	mov	r2, r31
    22aa:	31 2c       	mov	r3, r1
    22ac:	f0 2d       	mov	r31, r0
					Alarm_Start();
				}
				else //PLC
				{
					Alarm_Stop();
					if(mem4[START_BUTTON] == ON)
    22ae:	0f 2e       	mov	r0, r31
    22b0:	f0 e1       	ldi	r31, 0x10	; 16
    22b2:	4f 2e       	mov	r4, r31
    22b4:	f3 e0       	ldi	r31, 0x03	; 3
    22b6:	5f 2e       	mov	r5, r31
    22b8:	f0 2d       	mov	r31, r0
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
		
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    22ba:	f8 01       	movw	r30, r16
    22bc:	80 89       	ldd	r24, Z+16	; 0x10
    22be:	91 89       	ldd	r25, Z+17	; 0x11
    22c0:	26 ad       	ldd	r18, Z+62	; 0x3e
    22c2:	37 ad       	ldd	r19, Z+63	; 0x3f
    22c4:	28 17       	cp	r18, r24
    22c6:	39 07       	cpc	r19, r25
    22c8:	41 f0       	breq	.+16     	; 0x22da <_ZL5proc1Pv+0x7c>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    22ca:	95 af       	std	Z+61, r25	; 0x3d
    22cc:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    22ce:	91 af       	std	Z+57, r25	; 0x39
    22d0:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    22d2:	97 ab       	std	Z+55, r25	; 0x37
    22d4:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    22d6:	97 af       	std	Z+63, r25	; 0x3f
    22d8:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    22da:	c6 01       	movw	r24, r12
    22dc:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    22e0:	8f 30       	cpi	r24, 0x0F	; 15
    22e2:	58 f3       	brcs	.-42     	; 0x22ba <_ZL5proc1Pv+0x5c>
    22e4:	ce 01       	movw	r24, r28
    22e6:	01 96       	adiw	r24, 0x01	; 1
    22e8:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    22ea:	c6 01       	movw	r24, r12
    22ec:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    22f0:	d7 01       	movw	r26, r14
    22f2:	8d 93       	st	X+, r24
    22f4:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    22f6:	aa 15       	cp	r26, r10
    22f8:	bb 05       	cpc	r27, r11
    22fa:	b9 f7       	brne	.-18     	; 0x22ea <_ZL5proc1Pv+0x8c>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    22fc:	89 81       	ldd	r24, Y+1	; 0x01
    22fe:	82 30       	cpi	r24, 0x02	; 2
    2300:	09 f0       	breq	.+2      	; 0x2304 <_ZL5proc1Pv+0xa6>
    2302:	74 c0       	rjmp	.+232    	; 0x23ec <_ZL5proc1Pv+0x18e>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    2304:	88 85       	ldd	r24, Y+8	; 0x08
    2306:	90 e0       	ldi	r25, 0x00	; 0
    2308:	98 2f       	mov	r25, r24
    230a:	88 27       	eor	r24, r24
    230c:	29 85       	ldd	r18, Y+9	; 0x09
    230e:	82 2b       	or	r24, r18
    2310:	90 93 4f 03 	sts	0x034F, r25	; 0x80034f <count_number+0x1>
    2314:	80 93 4e 03 	sts	0x034E, r24	; 0x80034e <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    2318:	8a 85       	ldd	r24, Y+10	; 0x0a
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	98 2f       	mov	r25, r24
    231e:	88 27       	eor	r24, r24
    2320:	2b 85       	ldd	r18, Y+11	; 0x0b
    2322:	82 2b       	or	r24, r18
    2324:	90 93 4d 03 	sts	0x034D, r25	; 0x80034d <current_temp+0x1>
    2328:	80 93 4c 03 	sts	0x034C, r24	; 0x80034c <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    232c:	2c 85       	ldd	r18, Y+12	; 0x0c
    232e:	30 e0       	ldi	r19, 0x00	; 0
    2330:	32 2f       	mov	r19, r18
    2332:	22 27       	eor	r18, r18
    2334:	4d 85       	ldd	r20, Y+13	; 0x0d
    2336:	24 2b       	or	r18, r20
    2338:	30 93 4b 03 	sts	0x034B, r19	; 0x80034b <current_pressure+0x1>
    233c:	20 93 4a 03 	sts	0x034A, r18	; 0x80034a <current_pressure>
				mem4[TEMP] = current_temp;
    2340:	f8 01       	movw	r30, r16
    2342:	93 83       	std	Z+3, r25	; 0x03
    2344:	82 83       	std	Z+2, r24	; 0x02
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    2346:	d3 01       	movw	r26, r6
    2348:	ed 90       	ld	r14, X+
    234a:	fc 90       	ld	r15, X
    234c:	e1 14       	cp	r14, r1
    234e:	f1 04       	cpc	r15, r1
    2350:	19 f0       	breq	.+6      	; 0x2358 <_ZL5proc1Pv+0xfa>
				{
					Alarm_Start();
    2352:	0e 94 25 08 	call	0x104a	; 0x104a <Alarm_Start>
    2356:	33 c0       	rjmp	.+102    	; 0x23be <_ZL5proc1Pv+0x160>
				}
				else //PLC
				{
					Alarm_Stop();
    2358:	0e 94 21 08 	call	0x1042	; 0x1042 <Alarm_Stop>
					if(mem4[START_BUTTON] == ON)
    235c:	f2 01       	movw	r30, r4
    235e:	80 81       	ld	r24, Z
    2360:	91 81       	ldd	r25, Z+1	; 0x01
    2362:	01 97       	sbiw	r24, 0x01	; 1
    2364:	61 f5       	brne	.+88     	; 0x23be <_ZL5proc1Pv+0x160>
					{
						uint8_t i;
						for(i=0;i<PAGE_MAX;i++)
						{
							if(current_states_lookup_table[i] == ON)
    2366:	a0 e4       	ldi	r26, 0x40	; 64
    2368:	b3 e0       	ldi	r27, 0x03	; 3
    236a:	8c 91       	ld	r24, X
    236c:	81 30       	cpi	r24, 0x01	; 1
    236e:	59 f0       	breq	.+22     	; 0x2386 <_ZL5proc1Pv+0x128>
    2370:	a1 e4       	ldi	r26, 0x41	; 65
    2372:	b3 e0       	ldi	r27, 0x03	; 3
				{
					Alarm_Stop();
					if(mem4[START_BUTTON] == ON)
					{
						uint8_t i;
						for(i=0;i<PAGE_MAX;i++)
    2374:	e1 e0       	ldi	r30, 0x01	; 1
    2376:	cd 01       	movw	r24, r26
    2378:	80 54       	subi	r24, 0x40	; 64
    237a:	93 40       	sbci	r25, 0x03	; 3
    237c:	7c 01       	movw	r14, r24
						{
							if(current_states_lookup_table[i] == ON)
    237e:	8d 91       	ld	r24, X+
    2380:	81 30       	cpi	r24, 0x01	; 1
    2382:	71 f4       	brne	.+28     	; 0x23a0 <_ZL5proc1Pv+0x142>
    2384:	01 c0       	rjmp	.+2      	; 0x2388 <_ZL5proc1Pv+0x12a>
    2386:	e0 e0       	ldi	r30, 0x00	; 0
							{
								current_cnt_mem[i] = count_number;
    2388:	d7 01       	movw	r26, r14
    238a:	aa 0f       	add	r26, r26
    238c:	bb 1f       	adc	r27, r27
    238e:	a0 55       	subi	r26, 0x50	; 80
    2390:	bd 4f       	sbci	r27, 0xFD	; 253
    2392:	80 91 4e 03 	lds	r24, 0x034E	; 0x80034e <count_number>
    2396:	90 91 4f 03 	lds	r25, 0x034F	; 0x80034f <count_number+0x1>
    239a:	8d 93       	st	X+, r24
    239c:	9c 93       	st	X, r25
								break;
    239e:	03 c0       	rjmp	.+6      	; 0x23a6 <_ZL5proc1Pv+0x148>
				{
					Alarm_Stop();
					if(mem4[START_BUTTON] == ON)
					{
						uint8_t i;
						for(i=0;i<PAGE_MAX;i++)
    23a0:	ef 5f       	subi	r30, 0xFF	; 255
    23a2:	ea 30       	cpi	r30, 0x0A	; 10
    23a4:	41 f7       	brne	.-48     	; 0x2376 <_ZL5proc1Pv+0x118>
							{
								current_cnt_mem[i] = count_number;
								break;
							}
						}
						mem4[COUNT] = current_cnt_mem[i]; 
    23a6:	f0 e0       	ldi	r31, 0x00	; 0
    23a8:	ee 0f       	add	r30, r30
    23aa:	ff 1f       	adc	r31, r31
    23ac:	e0 55       	subi	r30, 0x50	; 80
    23ae:	fd 4f       	sbci	r31, 0xFD	; 253
    23b0:	80 81       	ld	r24, Z
    23b2:	91 81       	ldd	r25, Z+1	; 0x01
    23b4:	d8 01       	movw	r26, r16
    23b6:	17 96       	adiw	r26, 0x07	; 7
    23b8:	9c 93       	st	X, r25
    23ba:	8e 93       	st	-X, r24
    23bc:	16 97       	sbiw	r26, 0x06	; 6
					}

				}
				mem4[PRESSURE] = current_pressure;
    23be:	80 91 4a 03 	lds	r24, 0x034A	; 0x80034a <current_pressure>
    23c2:	90 91 4b 03 	lds	r25, 0x034B	; 0x80034b <current_pressure+0x1>
    23c6:	f8 01       	movw	r30, r16
    23c8:	95 83       	std	Z+5, r25	; 0x05
    23ca:	84 83       	std	Z+4, r24	; 0x04
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    23cc:	20 89       	ldd	r18, Z+16	; 0x10
    23ce:	31 89       	ldd	r19, Z+17	; 0x11
    23d0:	86 81       	ldd	r24, Z+6	; 0x06
    23d2:	97 81       	ldd	r25, Z+7	; 0x07
    23d4:	28 17       	cp	r18, r24
    23d6:	39 07       	cpc	r19, r25
    23d8:	09 f0       	breq	.+2      	; 0x23dc <_ZL5proc1Pv+0x17e>
    23da:	6f cf       	rjmp	.-290    	; 0x22ba <_ZL5proc1Pv+0x5c>
    23dc:	82 89       	ldd	r24, Z+18	; 0x12
    23de:	93 89       	ldd	r25, Z+19	; 0x13
    23e0:	89 2b       	or	r24, r25
    23e2:	09 f0       	breq	.+2      	; 0x23e6 <_ZL5proc1Pv+0x188>
    23e4:	6a cf       	rjmp	.-300    	; 0x22ba <_ZL5proc1Pv+0x5c>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    23e6:	33 8a       	std	Z+19, r3	; 0x13
    23e8:	22 8a       	std	Z+18, r2	; 0x12
    23ea:	67 cf       	rjmp	.-306    	; 0x22ba <_ZL5proc1Pv+0x5c>
				}
			}
			else
			{
				cbi(PORTB,7);
    23ec:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    23ee:	46 e0       	ldi	r20, 0x06	; 6
    23f0:	61 e0       	ldi	r22, 0x01	; 1
    23f2:	88 e5       	ldi	r24, 0x58	; 88
    23f4:	93 e0       	ldi	r25, 0x03	; 3
    23f6:	0e 94 02 06 	call	0xc04	; 0xc04 <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    23fa:	45 e0       	ldi	r20, 0x05	; 5
    23fc:	50 e0       	ldi	r21, 0x00	; 0
    23fe:	68 e5       	ldi	r22, 0x58	; 88
    2400:	73 e0       	ldi	r23, 0x03	; 3
    2402:	c6 01       	movw	r24, r12
    2404:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    2408:	d4 01       	movw	r26, r8
    240a:	8c 91       	ld	r24, X
    240c:	8f 77       	andi	r24, 0x7F	; 127
    240e:	8c 93       	st	X, r24
				sb->SerialFlush();
    2410:	c6 01       	movw	r24, r12
    2412:	0e 94 d2 06 	call	0xda4	; 0xda4 <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    2416:	f4 01       	movw	r30, r8
    2418:	80 81       	ld	r24, Z
    241a:	80 68       	ori	r24, 0x80	; 128
    241c:	80 83       	st	Z, r24
				sbi(PORTB,7);
    241e:	c7 9a       	sbi	0x18, 7	; 24
    2420:	4c cf       	rjmp	.-360    	; 0x22ba <_ZL5proc1Pv+0x5c>

00002422 <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    2422:	cf 93       	push	r28
    2424:	df 93       	push	r29
    2426:	cd b7       	in	r28, 0x3d	; 61
    2428:	de b7       	in	r29, 0x3e	; 62
    242a:	2a 97       	sbiw	r28, 0x0a	; 10
    242c:	0f b6       	in	r0, 0x3f	; 63
    242e:	f8 94       	cli
    2430:	de bf       	out	0x3e, r29	; 62
    2432:	0f be       	out	0x3f, r0	; 63
    2434:	cd bf       	out	0x3d, r28	; 61
    2436:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    2438:	b1 2c       	mov	r11, r1
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			if(mem4[START_BUTTON] == ON)
    243a:	0f 2e       	mov	r0, r31
    243c:	f0 e1       	ldi	r31, 0x10	; 16
    243e:	6f 2e       	mov	r6, r31
    2440:	f3 e0       	ldi	r31, 0x03	; 3
    2442:	7f 2e       	mov	r7, r31
    2444:	f0 2d       	mov	r31, r0
				if(current_states_lookup_table[mem4[CURRENT_RUN_NUMBER]] == ON)
				{
					current_cnt_mem[mem4[CURRENT_RUN_NUMBER]]++;
				}
			}
			chatter_flag = 2;
    2446:	68 94       	set
    2448:	33 24       	eor	r3, r3
    244a:	31 f8       	bld	r3, 1
		if(PIND == 0xff && chatter_flag == 2)//
		{
			vTaskDelay(10);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    244c:	04 ec       	ldi	r16, 0xC4	; 196
    244e:	12 e0       	ldi	r17, 0x02	; 2
			{
				mem4[MIN] = 0;
				mem4[HOUR]++;
			}
		}
		mem4[COUNT] = current_cnt_mem[mem4[CURRENT_PAGE]];
    2450:	0f 2e       	mov	r0, r31
    2452:	f4 e1       	ldi	r31, 0x14	; 20
    2454:	cf 2e       	mov	r12, r31
    2456:	f3 e0       	ldi	r31, 0x03	; 3
    2458:	df 2e       	mov	r13, r31
    245a:	f0 2d       	mov	r31, r0
    245c:	2e 01       	movw	r4, r28
    245e:	8c e0       	ldi	r24, 0x0C	; 12
    2460:	48 0e       	add	r4, r24
    2462:	51 1c       	adc	r5, r1
    2464:	68 94       	set
    2466:	22 24       	eor	r2, r2
    2468:	24 f8       	bld	r2, 4
    246a:	4e 01       	movw	r8, r28
    246c:	99 e0       	ldi	r25, 0x09	; 9
    246e:	89 0e       	add	r8, r25
    2470:	91 1c       	adc	r9, r1
    2472:	1a c0       	rjmp	.+52     	; 0x24a8 <_ZL4procPv+0x86>
    2474:	aa 24       	eor	r10, r10
    2476:	a3 94       	inc	r10
    2478:	bb 24       	eor	r11, r11
    247a:	b3 94       	inc	r11
    247c:	15 c0       	rjmp	.+42     	; 0x24a8 <_ZL4procPv+0x86>
    247e:	aa 24       	eor	r10, r10
    2480:	a3 94       	inc	r10
    2482:	bb 24       	eor	r11, r11
    2484:	b3 94       	inc	r11
    2486:	10 c0       	rjmp	.+32     	; 0x24a8 <_ZL4procPv+0x86>
    2488:	68 94       	set
    248a:	aa 24       	eor	r10, r10
    248c:	a2 f8       	bld	r10, 2
    248e:	bb 24       	eor	r11, r11
    2490:	b3 94       	inc	r11
    2492:	0a c0       	rjmp	.+20     	; 0x24a8 <_ZL4procPv+0x86>
    2494:	0f 2e       	mov	r0, r31
    2496:	f5 e0       	ldi	r31, 0x05	; 5
    2498:	af 2e       	mov	r10, r31
    249a:	f0 2d       	mov	r31, r0
    249c:	bb 24       	eor	r11, r11
    249e:	b3 94       	inc	r11
    24a0:	03 c0       	rjmp	.+6      	; 0x24a8 <_ZL4procPv+0x86>
    24a2:	a2 2c       	mov	r10, r2
    24a4:	bb 24       	eor	r11, r11
    24a6:	b3 94       	inc	r11
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    24a8:	80 b3       	in	r24, 0x10	; 16
    24aa:	8e 3f       	cpi	r24, 0xFE	; 254
    24ac:	f9 f4       	brne	.+62     	; 0x24ec <_ZL4procPv+0xca>
    24ae:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    24b2:	81 30       	cpi	r24, 0x01	; 1
    24b4:	d9 f4       	brne	.+54     	; 0x24ec <_ZL4procPv+0xca>
    24b6:	80 c1       	rjmp	.+768    	; 0x27b8 <_ZL4procPv+0x396>
		{
			if(mem4[START_BUTTON] == ON)
			{
				if(current_states_lookup_table[mem4[CURRENT_RUN_NUMBER]] == ON)
    24b8:	a8 e1       	ldi	r26, 0x18	; 24
    24ba:	b3 e0       	ldi	r27, 0x03	; 3
    24bc:	8d 91       	ld	r24, X+
    24be:	9c 91       	ld	r25, X
    24c0:	fc 01       	movw	r30, r24
    24c2:	e0 5c       	subi	r30, 0xC0	; 192
    24c4:	fc 4f       	sbci	r31, 0xFC	; 252
    24c6:	20 81       	ld	r18, Z
    24c8:	21 30       	cpi	r18, 0x01	; 1
    24ca:	51 f4       	brne	.+20     	; 0x24e0 <_ZL4procPv+0xbe>
				{
					current_cnt_mem[mem4[CURRENT_RUN_NUMBER]]++;
    24cc:	88 0f       	add	r24, r24
    24ce:	99 1f       	adc	r25, r25
    24d0:	fc 01       	movw	r30, r24
    24d2:	e0 55       	subi	r30, 0x50	; 80
    24d4:	fd 4f       	sbci	r31, 0xFD	; 253
    24d6:	80 81       	ld	r24, Z
    24d8:	91 81       	ldd	r25, Z+1	; 0x01
    24da:	01 96       	adiw	r24, 0x01	; 1
    24dc:	91 83       	std	Z+1, r25	; 0x01
    24de:	80 83       	st	Z, r24
				}
			}
			chatter_flag = 2;
    24e0:	30 92 aa 02 	sts	0x02AA, r3	; 0x8002aa <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    24e4:	80 b3       	in	r24, 0x10	; 16
    24e6:	8f 3f       	cpi	r24, 0xFF	; 255
    24e8:	49 f4       	brne	.+18     	; 0x24fc <_ZL4procPv+0xda>
    24ea:	6d c1       	rjmp	.+730    	; 0x27c6 <_ZL4procPv+0x3a4>
    24ec:	80 b3       	in	r24, 0x10	; 16
    24ee:	8f 3f       	cpi	r24, 0xFF	; 255
    24f0:	29 f4       	brne	.+10     	; 0x24fc <_ZL4procPv+0xda>
    24f2:	80 91 aa 02 	lds	r24, 0x02AA	; 0x8002aa <chatter_flag>
    24f6:	82 30       	cpi	r24, 0x02	; 2
    24f8:	09 f4       	brne	.+2      	; 0x24fc <_ZL4procPv+0xda>
    24fa:	65 c1       	rjmp	.+714    	; 0x27c6 <_ZL4procPv+0x3a4>
		{
			vTaskDelay(10);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    24fc:	f8 01       	movw	r30, r16
    24fe:	84 85       	ldd	r24, Z+12	; 0x0c
    2500:	95 85       	ldd	r25, Z+13	; 0x0d
    2502:	cc 97       	sbiw	r24, 0x3c	; 60
    2504:	94 f0       	brlt	.+36     	; 0x252a <_ZL4procPv+0x108>
		{
			mem4[SEC] = 0;
    2506:	15 86       	std	Z+13, r1	; 0x0d
    2508:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    250a:	82 85       	ldd	r24, Z+10	; 0x0a
    250c:	93 85       	ldd	r25, Z+11	; 0x0b
    250e:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    2510:	8c 33       	cpi	r24, 0x3C	; 60
    2512:	91 05       	cpc	r25, r1
    2514:	1c f4       	brge	.+6      	; 0x251c <_ZL4procPv+0xfa>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    2516:	93 87       	std	Z+11, r25	; 0x0b
    2518:	82 87       	std	Z+10, r24	; 0x0a
    251a:	07 c0       	rjmp	.+14     	; 0x252a <_ZL4procPv+0x108>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    251c:	13 86       	std	Z+11, r1	; 0x0b
    251e:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    2520:	80 85       	ldd	r24, Z+8	; 0x08
    2522:	91 85       	ldd	r25, Z+9	; 0x09
    2524:	01 96       	adiw	r24, 0x01	; 1
    2526:	91 87       	std	Z+9, r25	; 0x09
    2528:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		mem4[COUNT] = current_cnt_mem[mem4[CURRENT_PAGE]];
    252a:	d6 01       	movw	r26, r12
    252c:	ed 91       	ld	r30, X+
    252e:	fc 91       	ld	r31, X
    2530:	ee 0f       	add	r30, r30
    2532:	ff 1f       	adc	r31, r31
    2534:	e0 55       	subi	r30, 0x50	; 80
    2536:	fd 4f       	sbci	r31, 0xFD	; 253
    2538:	80 81       	ld	r24, Z
    253a:	91 81       	ldd	r25, Z+1	; 0x01
    253c:	f8 01       	movw	r30, r16
    253e:	97 83       	std	Z+7, r25	; 0x07
    2540:	86 83       	std	Z+6, r24	; 0x06
		if(read_Flag == 0)
    2542:	b1 10       	cpse	r11, r1
    2544:	59 c0       	rjmp	.+178    	; 0x25f8 <_ZL4procPv+0x1d6>
		{
			if(sb->SerialAvailable() >= 2)
    2546:	c7 01       	movw	r24, r14
    2548:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    254c:	82 30       	cpi	r24, 0x02	; 2
    254e:	08 f4       	brcc	.+2      	; 0x2552 <_ZL4procPv+0x130>
    2550:	41 c1       	rjmp	.+642    	; 0x27d4 <_ZL4procPv+0x3b2>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    2552:	c7 01       	movw	r24, r14
    2554:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    2558:	89 83       	std	Y+1, r24	; 0x01
    255a:	c7 01       	movw	r24, r14
    255c:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    2560:	8a 83       	std	Y+2, r24	; 0x02
					#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
					#endif
				}
				if(buf1[0] != 0x01)
    2562:	99 81       	ldd	r25, Y+1	; 0x01
    2564:	91 30       	cpi	r25, 0x01	; 1
    2566:	b1 f4       	brne	.+44     	; 0x2594 <_ZL4procPv+0x172>
				{
				//	read_Flag = 0;
					goto FREAM_ERROR;
				}
				if(buf1[1] == 0x01)
    2568:	81 30       	cpi	r24, 0x01	; 1
    256a:	09 f4       	brne	.+2      	; 0x256e <_ZL4procPv+0x14c>
    256c:	4a c0       	rjmp	.+148    	; 0x2602 <_ZL4procPv+0x1e0>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    256e:	84 30       	cpi	r24, 0x04	; 4
    2570:	09 f4       	brne	.+2      	; 0x2574 <_ZL4procPv+0x152>
    2572:	5e c0       	rjmp	.+188    	; 0x2630 <_ZL4procPv+0x20e>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    2574:	85 30       	cpi	r24, 0x05	; 5
    2576:	09 f4       	brne	.+2      	; 0x257a <_ZL4procPv+0x158>
    2578:	89 c0       	rjmp	.+274    	; 0x268c <_ZL4procPv+0x26a>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    257a:	80 31       	cpi	r24, 0x10	; 16
    257c:	59 f4       	brne	.+22     	; 0x2594 <_ZL4procPv+0x172>
    257e:	b4 c0       	rjmp	.+360    	; 0x26e8 <_ZL4procPv+0x2c6>
    2580:	68 94       	set
    2582:	aa 24       	eor	r10, r10
    2584:	a2 f8       	bld	r10, 2
    2586:	06 c0       	rjmp	.+12     	; 0x2594 <_ZL4procPv+0x172>
    2588:	0f 2e       	mov	r0, r31
    258a:	f5 e0       	ldi	r31, 0x05	; 5
    258c:	af 2e       	mov	r10, r31
    258e:	f0 2d       	mov	r31, r0
    2590:	01 c0       	rjmp	.+2      	; 0x2594 <_ZL4procPv+0x172>
    2592:	a2 2c       	mov	r10, r2
				{
					FREAM_ERROR:
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    2594:	41 e0       	ldi	r20, 0x01	; 1
    2596:	61 e0       	ldi	r22, 0x01	; 1
    2598:	88 e5       	ldi	r24, 0x58	; 88
    259a:	93 e0       	ldi	r25, 0x03	; 3
    259c:	0e 94 02 06 	call	0xc04	; 0xc04 <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    25a0:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);
    25a2:	57 98       	cbi	0x0a, 7	; 10
					dev->getInterfaceAddr(UART0)->Stop_Device();                                                                                                                                                                                                                
    25a4:	60 e0       	ldi	r22, 0x00	; 0
    25a6:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    25aa:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    25ae:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    25b2:	dc 01       	movw	r26, r24
    25b4:	ed 91       	ld	r30, X+
    25b6:	fc 91       	ld	r31, X
    25b8:	00 84       	ldd	r0, Z+8	; 0x08
    25ba:	f1 85       	ldd	r31, Z+9	; 0x09
    25bc:	e0 2d       	mov	r30, r0
    25be:	09 95       	icall
					sb->SerialFlush();
    25c0:	c7 01       	movw	r24, r14
    25c2:	0e 94 d2 06 	call	0xda4	; 0xda4 <_ZN12SerialBuffer11SerialFlushEv>
					dev->getInterfaceAddr(UART0)->Start_Device(0);
    25c6:	60 e0       	ldi	r22, 0x00	; 0
    25c8:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    25cc:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    25d0:	0e 94 2f 09 	call	0x125e	; 0x125e <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    25d4:	dc 01       	movw	r26, r24
    25d6:	ed 91       	ld	r30, X+
    25d8:	fc 91       	ld	r31, X
    25da:	02 84       	ldd	r0, Z+10	; 0x0a
    25dc:	f3 85       	ldd	r31, Z+11	; 0x0b
    25de:	e0 2d       	mov	r30, r0
    25e0:	60 e0       	ldi	r22, 0x00	; 0
    25e2:	09 95       	icall
					sbi(UCSR0B,RXCIE0);
    25e4:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    25e6:	45 e0       	ldi	r20, 0x05	; 5
    25e8:	50 e0       	ldi	r21, 0x00	; 0
    25ea:	68 e5       	ldi	r22, 0x58	; 88
    25ec:	73 e0       	ldi	r23, 0x03	; 3
    25ee:	c7 01       	movw	r24, r14
    25f0:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    25f4:	c7 9a       	sbi	0x18, 7	; 24
    25f6:	ee c0       	rjmp	.+476    	; 0x27d4 <_ZL4procPv+0x3b2>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    25f8:	b1 e0       	ldi	r27, 0x01	; 1
    25fa:	bb 12       	cpse	r11, r27
    25fc:	55 cf       	rjmp	.-342    	; 0x24a8 <_ZL4procPv+0x86>
		{
			if(function_code == 0x01)  
    25fe:	ab 12       	cpse	r10, r27
    2600:	14 c0       	rjmp	.+40     	; 0x262a <_ZL4procPv+0x208>
			{
				if(sb->SerialAvailable() >= 6)
    2602:	c7 01       	movw	r24, r14
    2604:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    2608:	86 30       	cpi	r24, 0x06	; 6
    260a:	08 f4       	brcc	.+2      	; 0x260e <_ZL4procPv+0x1ec>
    260c:	33 cf       	rjmp	.-410    	; 0x2474 <_ZL4procPv+0x52>
    260e:	5e 01       	movw	r10, r28
    2610:	e3 e0       	ldi	r30, 0x03	; 3
    2612:	ae 0e       	add	r10, r30
    2614:	b1 1c       	adc	r11, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    2616:	c7 01       	movw	r24, r14
    2618:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    261c:	d5 01       	movw	r26, r10
    261e:	8d 93       	st	X+, r24
    2620:	5d 01       	movw	r10, r26
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    2622:	8a 16       	cp	r8, r26
    2624:	9b 06       	cpc	r9, r27
    2626:	b9 f7       	brne	.-18     	; 0x2616 <_ZL4procPv+0x1f4>
    2628:	2a cf       	rjmp	.-428    	; 0x247e <_ZL4procPv+0x5c>
						#endif
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    262a:	b4 e0       	ldi	r27, 0x04	; 4
    262c:	ab 12       	cpse	r10, r27
    262e:	2b c0       	rjmp	.+86     	; 0x2686 <_ZL4procPv+0x264>
			{
				if(sb->SerialAvailable() >= 6)
    2630:	c7 01       	movw	r24, r14
    2632:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    2636:	86 30       	cpi	r24, 0x06	; 6
    2638:	08 f4       	brcc	.+2      	; 0x263c <_ZL4procPv+0x21a>
    263a:	26 cf       	rjmp	.-436    	; 0x2488 <_ZL4procPv+0x66>
    263c:	5e 01       	movw	r10, r28
    263e:	e3 e0       	ldi	r30, 0x03	; 3
    2640:	ae 0e       	add	r10, r30
    2642:	b1 1c       	adc	r11, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    2644:	c7 01       	movw	r24, r14
    2646:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    264a:	d5 01       	movw	r26, r10
    264c:	8d 93       	st	X+, r24
    264e:	5d 01       	movw	r10, r26
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    2650:	a8 15       	cp	r26, r8
    2652:	b9 05       	cpc	r27, r9
    2654:	b9 f7       	brne	.-18     	; 0x2644 <_ZL4procPv+0x222>
						#if PACKET_DEBUG
							sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크 
    2656:	8c 81       	ldd	r24, Y+4	; 0x04
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	cc 97       	sbiw	r24, 0x3c	; 60
    265c:	0c f0       	brlt	.+2      	; 0x2660 <_ZL4procPv+0x23e>
    265e:	90 cf       	rjmp	.-224    	; 0x2580 <_ZL4procPv+0x15e>
							//sb->SerialWrite((char*)&exception,sizeof(exception));
							goto FREAM_ERROR;
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
    2660:	a8 01       	movw	r20, r16
    2662:	68 e6       	ldi	r22, 0x68	; 104
    2664:	73 e0       	ldi	r23, 0x03	; 3
    2666:	ce 01       	movw	r24, r28
    2668:	01 96       	adiw	r24, 0x01	; 1
    266a:	0e 94 85 05 	call	0xb0a	; 0xb0a <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
							sb->SerialWrite((char*)&func04,sizeof(func04));
    266e:	47 e0       	ldi	r20, 0x07	; 7
    2670:	50 e0       	ldi	r21, 0x00	; 0
    2672:	68 e6       	ldi	r22, 0x68	; 104
    2674:	73 e0       	ldi	r23, 0x03	; 3
    2676:	c7 01       	movw	r24, r14
    2678:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN12SerialBuffer11SerialWriteEPKci>
    267c:	68 94       	set
    267e:	aa 24       	eor	r10, r10
    2680:	a2 f8       	bld	r10, 2
							read_Flag = 0;
    2682:	b1 2c       	mov	r11, r1
    2684:	11 cf       	rjmp	.-478    	; 0x24a8 <_ZL4procPv+0x86>
					}

				}
			}
			else if(function_code == 0x05) //터치 버튼 
    2686:	b5 e0       	ldi	r27, 0x05	; 5
    2688:	ab 12       	cpse	r10, r27
    268a:	2b c0       	rjmp	.+86     	; 0x26e2 <_ZL4procPv+0x2c0>
			{
				if(sb->SerialAvailable() >= 6)
    268c:	c7 01       	movw	r24, r14
    268e:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    2692:	86 30       	cpi	r24, 0x06	; 6
    2694:	08 f4       	brcc	.+2      	; 0x2698 <_ZL4procPv+0x276>
    2696:	fe ce       	rjmp	.-516    	; 0x2494 <_ZL4procPv+0x72>
    2698:	5e 01       	movw	r10, r28
    269a:	e3 e0       	ldi	r30, 0x03	; 3
    269c:	ae 0e       	add	r10, r30
    269e:	b1 1c       	adc	r11, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    26a0:	c7 01       	movw	r24, r14
    26a2:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    26a6:	d5 01       	movw	r26, r10
    26a8:	8d 93       	st	X+, r24
    26aa:	5d 01       	movw	r10, r26
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    26ac:	a8 15       	cp	r26, r8
    26ae:	b9 05       	cpc	r27, r9
    26b0:	b9 f7       	brne	.-18     	; 0x26a0 <_ZL4procPv+0x27e>
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크
    26b2:	8c 81       	ldd	r24, Y+4	; 0x04
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	cc 97       	sbiw	r24, 0x3c	; 60
    26b8:	0c f0       	brlt	.+2      	; 0x26bc <_ZL4procPv+0x29a>
    26ba:	66 cf       	rjmp	.-308    	; 0x2588 <_ZL4procPv+0x166>
					{
						goto FREAM_ERROR;
					}
					else
					{
						GetFunc05Data(buf1,&func05);
    26bc:	6f e6       	ldi	r22, 0x6F	; 111
    26be:	73 e0       	ldi	r23, 0x03	; 3
    26c0:	ce 01       	movw	r24, r28
    26c2:	01 96       	adiw	r24, 0x01	; 1
    26c4:	0e 94 a6 05 	call	0xb4c	; 0xb4c <_Z13GetFunc05DataPcP17GetFunctionCode05>
						sb->SerialWrite((char*)&func05,sizeof(func05));
    26c8:	48 e0       	ldi	r20, 0x08	; 8
    26ca:	50 e0       	ldi	r21, 0x00	; 0
    26cc:	6f e6       	ldi	r22, 0x6F	; 111
    26ce:	73 e0       	ldi	r23, 0x03	; 3
    26d0:	c7 01       	movw	r24, r14
    26d2:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN12SerialBuffer11SerialWriteEPKci>
    26d6:	0f 2e       	mov	r0, r31
    26d8:	f5 e0       	ldi	r31, 0x05	; 5
    26da:	af 2e       	mov	r10, r31
    26dc:	f0 2d       	mov	r31, r0
						read_Flag = 0;
    26de:	b1 2c       	mov	r11, r1
    26e0:	e3 ce       	rjmp	.-570    	; 0x24a8 <_ZL4procPv+0x86>
					}
	
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    26e2:	b0 e1       	ldi	r27, 0x10	; 16
    26e4:	ab 12       	cpse	r10, r27
    26e6:	e0 ce       	rjmp	.-576    	; 0x24a8 <_ZL4procPv+0x86>
			{
				if(sb->SerialAvailable() >= 9)
    26e8:	c7 01       	movw	r24, r14
    26ea:	0e 94 c7 06 	call	0xd8e	; 0xd8e <_ZN12SerialBuffer15SerialAvailableEv>
    26ee:	89 30       	cpi	r24, 0x09	; 9
    26f0:	08 f4       	brcc	.+2      	; 0x26f4 <_ZL4procPv+0x2d2>
    26f2:	d7 ce       	rjmp	.-594    	; 0x24a2 <_ZL4procPv+0x80>
    26f4:	5e 01       	movw	r10, r28
    26f6:	e3 e0       	ldi	r30, 0x03	; 3
    26f8:	ae 0e       	add	r10, r30
    26fa:	b1 1c       	adc	r11, r1
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    26fc:	c7 01       	movw	r24, r14
    26fe:	0e 94 9b 06 	call	0xd36	; 0xd36 <_ZN12SerialBuffer10SerialReadEv>
    2702:	d5 01       	movw	r26, r10
    2704:	8d 93       	st	X+, r24
    2706:	5d 01       	movw	r10, r26
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    2708:	a4 15       	cp	r26, r4
    270a:	b5 05       	cpc	r27, r5
    270c:	b9 f7       	brne	.-18     	; 0x26fc <_ZL4procPv+0x2da>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    270e:	a8 01       	movw	r20, r16
    2710:	6d e5       	ldi	r22, 0x5D	; 93
    2712:	73 e0       	ldi	r23, 0x03	; 3
    2714:	ce 01       	movw	r24, r28
    2716:	01 96       	adiw	r24, 0x01	; 1
    2718:	0e 94 bf 05 	call	0xb7e	; 0xb7e <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr >= MAX_ENUM)  //주소 사이즈 체크
    271c:	8c 81       	ldd	r24, Y+4	; 0x04
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	cc 97       	sbiw	r24, 0x3c	; 60
    2722:	0c f0       	brlt	.+2      	; 0x2726 <_ZL4procPv+0x304>
    2724:	36 cf       	rjmp	.-404    	; 0x2592 <_ZL4procPv+0x170>
					{
						goto FREAM_ERROR;
					}
					else
					{
						if(func10.startingAddressLo == 38)
    2726:	80 91 60 03 	lds	r24, 0x0360	; 0x800360 <func10+0x3>
    272a:	86 32       	cpi	r24, 0x26	; 38
    272c:	e9 f4       	brne	.+58     	; 0x2768 <_ZL4procPv+0x346>
						{
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == 0) //룩업 테이블은 처음 시작시 0값이어야 함,
    272e:	f6 01       	movw	r30, r12
    2730:	20 81       	ld	r18, Z
    2732:	31 81       	ldd	r19, Z+1	; 0x01
    2734:	f9 01       	movw	r30, r18
    2736:	e0 5c       	subi	r30, 0xC0	; 192
    2738:	fc 4f       	sbci	r31, 0xFC	; 252
    273a:	80 81       	ld	r24, Z
    273c:	81 11       	cpse	r24, r1
    273e:	2c c0       	rjmp	.+88     	; 0x2798 <_ZL4procPv+0x376>
							{
								uint8_t flag = 0;
								mem4[START_BUTTON] = ON;
    2740:	e1 e0       	ldi	r30, 0x01	; 1
    2742:	f0 e0       	ldi	r31, 0x00	; 0
    2744:	d3 01       	movw	r26, r6
    2746:	ed 93       	st	X+, r30
    2748:	fc 93       	st	X, r31
								mem4[CURRENT_STATE_ON] = ON; // 시작 등 ON
    274a:	a6 e1       	ldi	r26, 0x16	; 22
    274c:	b3 e0       	ldi	r27, 0x03	; 3
    274e:	ed 93       	st	X+, r30
    2750:	fc 93       	st	X, r31
    2752:	e0 e4       	ldi	r30, 0x40	; 64
    2754:	f3 e0       	ldi	r31, 0x03	; 3
								//룩업 테이블을 먼저 확인 함. 한개라도 가동중이면 리턴함, 가동이 반드시 끝나고 시작해야함(페이지 이동 후 시작 시)
								for(uint8_t i = 0; i< PAGE_MAX;i++)
								{
									if(current_states_lookup_table[i] == ON)
    2756:	81 91       	ld	r24, Z+
    2758:	81 30       	cpi	r24, 0x01	; 1
    275a:	f1 f0       	breq	.+60     	; 0x2798 <_ZL4procPv+0x376>
							{
								uint8_t flag = 0;
								mem4[START_BUTTON] = ON;
								mem4[CURRENT_STATE_ON] = ON; // 시작 등 ON
								//룩업 테이블을 먼저 확인 함. 한개라도 가동중이면 리턴함, 가동이 반드시 끝나고 시작해야함(페이지 이동 후 시작 시)
								for(uint8_t i = 0; i< PAGE_MAX;i++)
    275c:	8a e4       	ldi	r24, 0x4A	; 74
    275e:	93 e0       	ldi	r25, 0x03	; 3
    2760:	8e 17       	cp	r24, r30
    2762:	9f 07       	cpc	r25, r31
    2764:	c1 f7       	brne	.-16     	; 0x2756 <_ZL4procPv+0x334>
    2766:	38 c0       	rjmp	.+112    	; 0x27d8 <_ZL4procPv+0x3b6>
									current_states_lookup_table[mem4[CURRENT_PAGE]] = ON;
									mem4[CURRENT_RUN_NUMBER] = mem4[CURRENT_PAGE];
								}
							}
						}
						if(func10.startingAddressLo == 39)
    2768:	87 32       	cpi	r24, 0x27	; 39
    276a:	b1 f4       	brne	.+44     	; 0x2798 <_ZL4procPv+0x376>
						{
						
							if(current_states_lookup_table[mem4[CURRENT_PAGE]] == ON)
    276c:	d6 01       	movw	r26, r12
    276e:	8d 91       	ld	r24, X+
    2770:	9c 91       	ld	r25, X
    2772:	fc 01       	movw	r30, r24
    2774:	e0 5c       	subi	r30, 0xC0	; 192
    2776:	fc 4f       	sbci	r31, 0xFC	; 252
    2778:	20 81       	ld	r18, Z
    277a:	21 30       	cpi	r18, 0x01	; 1
    277c:	69 f4       	brne	.+26     	; 0x2798 <_ZL4procPv+0x376>
							{
								current_states_lookup_table[mem4[CURRENT_PAGE]] = 0;
    277e:	fc 01       	movw	r30, r24
    2780:	e0 5c       	subi	r30, 0xC0	; 192
    2782:	fc 4f       	sbci	r31, 0xFC	; 252
    2784:	10 82       	st	Z, r1
								mem4[START_BUTTON] = OFF;
    2786:	82 e0       	ldi	r24, 0x02	; 2
    2788:	90 e0       	ldi	r25, 0x00	; 0
    278a:	f3 01       	movw	r30, r6
    278c:	91 83       	std	Z+1, r25	; 0x01
    278e:	80 83       	st	Z, r24
								mem4[CURRENT_STATE_ON] = 0;//시작 등  OFF
    2790:	a6 e1       	ldi	r26, 0x16	; 22
    2792:	b3 e0       	ldi	r27, 0x03	; 3
    2794:	1d 92       	st	X+, r1
    2796:	1c 92       	st	X, r1
							}
						}
						ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    2798:	60 e5       	ldi	r22, 0x50	; 80
    279a:	73 e0       	ldi	r23, 0x03	; 3
    279c:	ce 01       	movw	r24, r28
    279e:	01 96       	adiw	r24, 0x01	; 1
    27a0:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
						sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    27a4:	48 e0       	ldi	r20, 0x08	; 8
    27a6:	50 e0       	ldi	r21, 0x00	; 0
    27a8:	60 e5       	ldi	r22, 0x50	; 80
    27aa:	73 e0       	ldi	r23, 0x03	; 3
    27ac:	c7 01       	movw	r24, r14
    27ae:	0e 94 5f 06 	call	0xcbe	; 0xcbe <_ZN12SerialBuffer11SerialWriteEPKci>
    27b2:	a2 2c       	mov	r10, r2
						read_Flag = 0;
    27b4:	b1 2c       	mov	r11, r1
    27b6:	78 ce       	rjmp	.-784    	; 0x24a8 <_ZL4procPv+0x86>
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			if(mem4[START_BUTTON] == ON)
    27b8:	f3 01       	movw	r30, r6
    27ba:	80 81       	ld	r24, Z
    27bc:	91 81       	ldd	r25, Z+1	; 0x01
    27be:	01 97       	sbiw	r24, 0x01	; 1
    27c0:	09 f0       	breq	.+2      	; 0x27c4 <_ZL4procPv+0x3a2>
    27c2:	8e ce       	rjmp	.-740    	; 0x24e0 <_ZL4procPv+0xbe>
    27c4:	79 ce       	rjmp	.-782    	; 0x24b8 <_ZL4procPv+0x96>
			}
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
		{
			vTaskDelay(10);
    27c6:	8a e0       	ldi	r24, 0x0A	; 10
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <vTaskDelay>
			chatter_flag = 0;
    27ce:	10 92 aa 02 	sts	0x02AA, r1	; 0x8002aa <chatter_flag>
    27d2:	94 ce       	rjmp	.-728    	; 0x24fc <_ZL4procPv+0xda>
					}
					else
					{
						GetFunc05Data(buf1,&func05);
						sb->SerialWrite((char*)&func05,sizeof(func05));
						read_Flag = 0;
    27d4:	b1 2c       	mov	r11, r1
    27d6:	68 ce       	rjmp	.-816    	; 0x24a8 <_ZL4procPv+0x86>
										break;
									}
								}
								if(flag == 0)
								{
									current_states_lookup_table[mem4[CURRENT_PAGE]] = ON;
    27d8:	f9 01       	movw	r30, r18
    27da:	e0 5c       	subi	r30, 0xC0	; 192
    27dc:	fc 4f       	sbci	r31, 0xFC	; 252
    27de:	81 e0       	ldi	r24, 0x01	; 1
    27e0:	80 83       	st	Z, r24
									mem4[CURRENT_RUN_NUMBER] = mem4[CURRENT_PAGE];
    27e2:	a8 e1       	ldi	r26, 0x18	; 24
    27e4:	b3 e0       	ldi	r27, 0x03	; 3
    27e6:	2d 93       	st	X+, r18
    27e8:	3c 93       	st	X, r19
    27ea:	d6 cf       	rjmp	.-84     	; 0x2798 <_ZL4procPv+0x376>

000027ec <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    27ec:	80 91 77 03 	lds	r24, 0x0377	; 0x800377 <DataStruct>
    27f0:	90 91 78 03 	lds	r25, 0x0378	; 0x800378 <DataStruct+0x1>
    27f4:	0e 94 3a 06 	call	0xc74	; 0xc74 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    27f8:	c5 9a       	sbi	0x18, 5	; 24
    27fa:	08 95       	ret

000027fc <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    27fc:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <DataStruct+0x2>
    2800:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <DataStruct+0x3>
    2804:	0e 94 3a 06 	call	0xc74	; 0xc74 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    2808:	c6 9a       	sbi	0x18, 6	; 24
    280a:	08 95       	ret

0000280c <_Z16Count_Sensor_ISR8Dev_typej>:
{

}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,80,Set_Alarm);
    280c:	4b e3       	ldi	r20, 0x3B	; 59
    280e:	5f e0       	ldi	r21, 0x0F	; 15
    2810:	60 e5       	ldi	r22, 0x50	; 80
    2812:	70 e0       	ldi	r23, 0x00	; 0
    2814:	80 e0       	ldi	r24, 0x00	; 0
    2816:	0c 94 29 08 	jmp	0x1052	; 0x1052 <Alarm_Open>
    281a:	08 95       	ret

0000281c <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    281c:	cf 93       	push	r28
    281e:	df 93       	push	r29
	dev = new Dev_Manager();
    2820:	84 e1       	ldi	r24, 0x14	; 20
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	0e 94 d8 08 	call	0x11b0	; 0x11b0 <_ZN11Dev_ManagernwEj>
    2828:	ec 01       	movw	r28, r24
    282a:	0e 94 a5 08 	call	0x114a	; 0x114a <_ZN11Dev_ManagerC1Ev>
    282e:	d0 93 84 03 	sts	0x0384, r29	; 0x800384 <dev+0x1>
    2832:	c0 93 83 03 	sts	0x0383, r28	; 0x800383 <dev>
	#if USE_LCD
		lcd = new Char_LCD2004A();
	#endif
	#if USE_ADC
		adc = new Adc();
    2836:	84 e0       	ldi	r24, 0x04	; 4
    2838:	90 e0       	ldi	r25, 0x00	; 0
    283a:	0e 94 16 08 	call	0x102c	; 0x102c <_ZN3AdcnwEj>
    283e:	fc 01       	movw	r30, r24
    2840:	12 82       	std	Z+2, r1	; 0x02
    2842:	13 82       	std	Z+3, r1	; 0x03
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Adc : public DeviceDriveInterFace
    2844:	8b e0       	ldi	r24, 0x0B	; 11
    2846:	91 e0       	ldi	r25, 0x01	; 1
    2848:	91 83       	std	Z+1, r25	; 0x01
    284a:	80 83       	st	Z, r24
    284c:	f0 93 82 03 	sts	0x0382, r31	; 0x800382 <adc+0x1>
    2850:	e0 93 81 03 	sts	0x0381, r30	; 0x800381 <adc>
		dev->Register_Dev(adc,_ADC);
    2854:	44 e0       	ldi	r20, 0x04	; 4
    2856:	bf 01       	movw	r22, r30
    2858:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    285c:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2860:	0e 94 cf 08 	call	0x119e	; 0x119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	#endif
	dev->Register_Dev(new UartDriver,UART0);
    2864:	88 e0       	ldi	r24, 0x08	; 8
    2866:	90 e0       	ldi	r25, 0x00	; 0
    2868:	0e 94 1f 0b 	call	0x163e	; 0x163e <_ZN10UartDrivernwEj>
    286c:	ec 01       	movw	r28, r24
    286e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <_ZN10UartDriverC1Ev>
    2872:	40 e0       	ldi	r20, 0x00	; 0
    2874:	be 01       	movw	r22, r28
    2876:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    287a:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    287e:	0e 94 cf 08 	call	0x119e	; 0x119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    2882:	88 e0       	ldi	r24, 0x08	; 8
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <_ZN11RS485DrivernwEj>
    288a:	ec 01       	movw	r28, r24
    288c:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <_ZN11RS485DriverC1Ev>
    2890:	41 e0       	ldi	r20, 0x01	; 1
    2892:	be 01       	movw	r22, r28
    2894:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2898:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    289c:	0e 94 cf 08 	call	0x119e	; 0x119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    28a0:	82 e0       	ldi	r24, 0x02	; 2
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	0e 94 44 0a 	call	0x1488	; 0x1488 <_ZN5TimernwEj>
    28a8:	ec 01       	movw	r28, r24
    28aa:	0e 94 3e 0a 	call	0x147c	; 0x147c <_ZN5TimerC1Ev>
    28ae:	42 e0       	ldi	r20, 0x02	; 2
    28b0:	be 01       	movw	r22, r28
    28b2:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    28b6:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    28ba:	0e 94 cf 08 	call	0x119e	; 0x119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    28be:	82 e0       	ldi	r24, 0x02	; 2
    28c0:	90 e0       	ldi	r25, 0x00	; 0
    28c2:	0e 94 a2 08 	call	0x1144	; 0x1144 <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    28c6:	2b e1       	ldi	r18, 0x1B	; 27
    28c8:	31 e0       	ldi	r19, 0x01	; 1
    28ca:	fc 01       	movw	r30, r24
    28cc:	31 83       	std	Z+1, r19	; 0x01
    28ce:	20 83       	st	Z, r18
    28d0:	43 e0       	ldi	r20, 0x03	; 3
    28d2:	bc 01       	movw	r22, r24
    28d4:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    28d8:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    28dc:	0e 94 cf 08 	call	0x119e	; 0x119e <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	
	dev->Device_Init(UART0);
    28e0:	60 e0       	ldi	r22, 0x00	; 0
    28e2:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    28e6:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    28ea:	0e 94 03 09 	call	0x1206	; 0x1206 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    28ee:	61 e0       	ldi	r22, 0x01	; 1
    28f0:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    28f4:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    28f8:	0e 94 03 09 	call	0x1206	; 0x1206 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    28fc:	62 e0       	ldi	r22, 0x02	; 2
    28fe:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2902:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2906:	0e 94 03 09 	call	0x1206	; 0x1206 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    290a:	63 e0       	ldi	r22, 0x03	; 3
    290c:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2910:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2914:	0e 94 03 09 	call	0x1206	; 0x1206 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	#if USE_ADC
		dev->Device_Init(_ADC);
    2918:	64 e0       	ldi	r22, 0x04	; 4
    291a:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    291e:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2922:	0e 94 03 09 	call	0x1206	; 0x1206 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	#endif
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    2926:	47 e5       	ldi	r20, 0x57	; 87
    2928:	51 e0       	ldi	r21, 0x01	; 1
    292a:	60 e0       	ldi	r22, 0x00	; 0
    292c:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2930:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2934:	0e 94 ef 08 	call	0x11de	; 0x11de <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    2938:	4d e7       	ldi	r20, 0x7D	; 125
    293a:	51 e0       	ldi	r21, 0x01	; 1
    293c:	61 e0       	ldi	r22, 0x01	; 1
    293e:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2942:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2946:	0e 94 ef 08 	call	0x11de	; 0x11de <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    294a:	df 91       	pop	r29
    294c:	cf 91       	pop	r28
    294e:	08 95       	ret

00002950 <main>:
#if USE_ADC
	uint16_t Adc_channels[8] = {0};
	uint8_t Adc_check_flag[8] = {0};
#endif
int main( void )
{
    2950:	cf 92       	push	r12
    2952:	df 92       	push	r13
    2954:	ef 92       	push	r14
    2956:	ff 92       	push	r15
    2958:	0f 93       	push	r16
    295a:	cf 93       	push	r28
    295c:	df 93       	push	r29
	mem4[CURRENT_PAGE] = 0;//초기 페이지는 1 
    295e:	10 92 15 03 	sts	0x0315, r1	; 0x800315 <mem4+0x51>
    2962:	10 92 14 03 	sts	0x0314, r1	; 0x800314 <mem4+0x50>
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    2966:	80 e0       	ldi	r24, 0x00	; 0
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	0e 94 d6 22 	call	0x45ac	; 0x45ac <eeprom_read_byte>
    296e:	d8 2e       	mov	r13, r24
    2970:	90 e0       	ldi	r25, 0x00	; 0
    2972:	90 93 05 03 	sts	0x0305, r25	; 0x800305 <mem4+0x41>
    2976:	80 93 04 03 	sts	0x0304, r24	; 0x800304 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	90 e0       	ldi	r25, 0x00	; 0
    297e:	0e 94 d6 22 	call	0x45ac	; 0x45ac <eeprom_read_byte>
    2982:	d8 2f       	mov	r29, r24
    2984:	90 e0       	ldi	r25, 0x00	; 0
    2986:	90 93 07 03 	sts	0x0307, r25	; 0x800307 <mem4+0x43>
    298a:	80 93 06 03 	sts	0x0306, r24	; 0x800306 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    298e:	82 e0       	ldi	r24, 0x02	; 2
    2990:	90 e0       	ldi	r25, 0x00	; 0
    2992:	0e 94 d6 22 	call	0x45ac	; 0x45ac <eeprom_read_byte>
    2996:	c8 2f       	mov	r28, r24
    2998:	90 e0       	ldi	r25, 0x00	; 0
    299a:	90 93 09 03 	sts	0x0309, r25	; 0x800309 <mem4+0x45>
    299e:	80 93 08 03 	sts	0x0308, r24	; 0x800308 <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    29a2:	83 e0       	ldi	r24, 0x03	; 3
    29a4:	90 e0       	ldi	r25, 0x00	; 0
    29a6:	0e 94 d6 22 	call	0x45ac	; 0x45ac <eeprom_read_byte>
    29aa:	28 2f       	mov	r18, r24
    29ac:	30 e0       	ldi	r19, 0x00	; 0
    29ae:	30 93 0b 03 	sts	0x030B, r19	; 0x80030b <mem4+0x47>
    29b2:	20 93 0a 03 	sts	0x030A, r18	; 0x80030a <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    29b6:	ec ea       	ldi	r30, 0xAC	; 172
    29b8:	f2 e0       	ldi	r31, 0x02	; 2
    29ba:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    29bc:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    29be:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    29c0:	83 83       	std	Z+3, r24	; 0x03
int main( void )
{
	mem4[CURRENT_PAGE] = 0;//초기 페이지는 1 
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    29c2:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    29c4:	2b df       	rcall	.-426    	; 0x281c <_Z8Init_Devv>
    29c6:	46 ef       	ldi	r20, 0xF6	; 246
    29c8:	53 e1       	ldi	r21, 0x13	; 19
    29ca:	60 e0       	ldi	r22, 0x00	; 0
    29cc:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    29d0:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    29d4:	0e 94 15 09 	call	0x122a	; 0x122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    29d8:	4e ef       	ldi	r20, 0xFE	; 254
    29da:	53 e1       	ldi	r21, 0x13	; 19
    29dc:	61 e0       	ldi	r22, 0x01	; 1
    29de:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    29e2:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    29e6:	0e 94 15 09 	call	0x122a	; 0x122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    29ea:	48 e1       	ldi	r20, 0x18	; 24
    29ec:	5f e0       	ldi	r21, 0x0F	; 15
    29ee:	62 e0       	ldi	r22, 0x02	; 2
    29f0:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    29f4:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    29f8:	0e 94 15 09 	call	0x122a	; 0x122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    29fc:	46 e0       	ldi	r20, 0x06	; 6
    29fe:	54 e1       	ldi	r21, 0x14	; 20
    2a00:	63 e0       	ldi	r22, 0x03	; 3
    2a02:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2a06:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2a0a:	0e 94 15 09 	call	0x122a	; 0x122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	#if USE_ADC
		dev->Open_Handle(_ADC,ADC_ISR);
    2a0e:	4a e3       	ldi	r20, 0x3A	; 58
    2a10:	5f e0       	ldi	r21, 0x0F	; 15
    2a12:	64 e0       	ldi	r22, 0x04	; 4
    2a14:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <dev>
    2a18:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <dev+0x1>
    2a1c:	0e 94 15 09 	call	0x122a	; 0x122a <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	#endif
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    2a20:	88 e8       	ldi	r24, 0x88	; 136
    2a22:	90 e0       	ldi	r25, 0x00	; 0
    2a24:	0e 94 37 06 	call	0xc6e	; 0xc6e <_ZN12SerialBuffernwEj>
    2a28:	6c 01       	movw	r12, r24
    2a2a:	60 91 83 03 	lds	r22, 0x0383	; 0x800383 <dev>
    2a2e:	70 91 84 03 	lds	r23, 0x0384	; 0x800384 <dev+0x1>
    2a32:	40 e0       	ldi	r20, 0x00	; 0
    2a34:	0e 94 12 06 	call	0xc24	; 0xc24 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    2a38:	c1 14       	cp	r12, r1
    2a3a:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    2a3c:	21 f4       	brne	.+8      	; 0x2a46 <main+0xf6>
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	0e 94 ef 22 	call	0x45de	; 0x45de <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    2a46:	88 e8       	ldi	r24, 0x88	; 136
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	0e 94 37 06 	call	0xc6e	; 0xc6e <_ZN12SerialBuffernwEj>
    2a4e:	ec 01       	movw	r28, r24
    2a50:	60 91 83 03 	lds	r22, 0x0383	; 0x800383 <dev>
    2a54:	70 91 84 03 	lds	r23, 0x0384	; 0x800384 <dev+0x1>
    2a58:	41 e0       	ldi	r20, 0x01	; 1
    2a5a:	0e 94 12 06 	call	0xc24	; 0xc24 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    2a5e:	20 97       	sbiw	r28, 0x00	; 0
	{
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    2a60:	21 f4       	brne	.+8      	; 0x2a6a <main+0x11a>
    2a62:	81 e0       	ldi	r24, 0x01	; 1
    2a64:	90 e0       	ldi	r25, 0x00	; 0
    2a66:	0e 94 ef 22 	call	0x45de	; 0x45de <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    2a6a:	e7 e7       	ldi	r30, 0x77	; 119
    2a6c:	f3 e0       	ldi	r31, 0x03	; 3
    2a6e:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    2a70:	c0 82       	st	Z, r12
    2a72:	d3 83       	std	Z+3, r29	; 0x03
		}
	}
	

		
	Alarm_Init(); //알람 초기화
    2a74:	c2 83       	std	Z+2, r28	; 0x02
    2a76:	0e 94 19 08 	call	0x1032	; 0x1032 <Alarm_Init>
	"Task1",      //테스크 이름
	300+MAX_ENUM,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    2a7a:	78 94       	sei
    2a7c:	e1 2c       	mov	r14, r1
    2a7e:	f1 2c       	mov	r15, r1
    2a80:	02 e0       	ldi	r16, 0x02	; 2
    2a82:	96 01       	movw	r18, r12
    2a84:	48 e6       	ldi	r20, 0x68	; 104
    2a86:	51 e0       	ldi	r21, 0x01	; 1
    2a88:	64 ea       	ldi	r22, 0xA4	; 164
    2a8a:	71 e0       	ldi	r23, 0x01	; 1
    2a8c:	81 e1       	ldi	r24, 0x11	; 17
    2a8e:	92 e1       	ldi	r25, 0x12	; 18
		"Task2",      //테스크 이름
		200,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    2a90:	de d6       	rcall	.+3516   	; 0x384e <xTaskCreate>
    2a92:	9e 01       	movw	r18, r28
    2a94:	48 ec       	ldi	r20, 0xC8	; 200
    2a96:	50 e0       	ldi	r21, 0x00	; 0
    2a98:	6a ea       	ldi	r22, 0xAA	; 170
    2a9a:	71 e0       	ldi	r23, 0x01	; 1
    2a9c:	8f e2       	ldi	r24, 0x2F	; 47
    2a9e:	91 e1       	ldi	r25, 0x11	; 17
				"Task3",      //테스크 이름
				900,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    2aa0:	d6 d6       	rcall	.+3500   	; 0x384e <xTaskCreate>
    2aa2:	20 e0       	ldi	r18, 0x00	; 0
    2aa4:	30 e0       	ldi	r19, 0x00	; 0
    2aa6:	44 e8       	ldi	r20, 0x84	; 132
    2aa8:	53 e0       	ldi	r21, 0x03	; 3
    2aaa:	60 eb       	ldi	r22, 0xB0	; 176
    2aac:	71 e0       	ldi	r23, 0x01	; 1
    2aae:	83 e4       	ldi	r24, 0x43	; 67
    2ab0:	9f e0       	ldi	r25, 0x0F	; 15
		"Task3",      //테스크 이름
		200,                   //스택의 크기
		NULL,       // 테스크 매개 변수
		2,                     //테스크 우선 순위0.
		NULL                   //태스크 핸들
		);
    2ab2:	cd d6       	rcall	.+3482   	; 0x384e <xTaskCreate>
    2ab4:	20 e0       	ldi	r18, 0x00	; 0
    2ab6:	30 e0       	ldi	r19, 0x00	; 0
    2ab8:	48 ec       	ldi	r20, 0xC8	; 200
    2aba:	50 e0       	ldi	r21, 0x00	; 0
    2abc:	60 eb       	ldi	r22, 0xB0	; 176
    2abe:	71 e0       	ldi	r23, 0x01	; 1
    2ac0:	8e e1       	ldi	r24, 0x1E	; 30
		#endif	

		
	
	vTaskStartScheduler();//스케줄러 실행 
    2ac2:	96 e1       	ldi	r25, 0x16	; 22
    2ac4:	c4 d6       	rcall	.+3464   	; 0x384e <xTaskCreate>
	return 0;
}
    2ac6:	c1 d7       	rcall	.+3970   	; 0x3a4a <vTaskStartScheduler>
    2ac8:	80 e0       	ldi	r24, 0x00	; 0
    2aca:	90 e0       	ldi	r25, 0x00	; 0
    2acc:	df 91       	pop	r29
    2ace:	cf 91       	pop	r28
    2ad0:	0f 91       	pop	r16
    2ad2:	ff 90       	pop	r15
    2ad4:	ef 90       	pop	r14
    2ad6:	df 90       	pop	r13
    2ad8:	cf 90       	pop	r12
    2ada:	08 95       	ret

00002adc <_Z9fnCalTempf>:
	100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
	110, 111, 112, 113, 114, 115, 116, 117, 118, 119,
120};

float fnCalTemp(float lfOneVolt)
{
    2adc:	4f 92       	push	r4
    2ade:	5f 92       	push	r5
    2ae0:	6f 92       	push	r6
    2ae2:	7f 92       	push	r7
    2ae4:	8f 92       	push	r8
    2ae6:	9f 92       	push	r9
    2ae8:	af 92       	push	r10
    2aea:	bf 92       	push	r11
    2aec:	cf 92       	push	r12
    2aee:	df 92       	push	r13
    2af0:	ef 92       	push	r14
    2af2:	ff 92       	push	r15
    2af4:	0f 93       	push	r16
    2af6:	1f 93       	push	r17
    2af8:	cf 93       	push	r28
    2afa:	df 93       	push	r29
    2afc:	cd b7       	in	r28, 0x3d	; 61
    2afe:	de b7       	in	r29, 0x3e	; 62
    2b00:	28 97       	sbiw	r28, 0x08	; 8
    2b02:	0f b6       	in	r0, 0x3f	; 63
    2b04:	f8 94       	cli
    2b06:	de bf       	out	0x3e, r29	; 62
    2b08:	0f be       	out	0x3f, r0	; 63
    2b0a:	cd bf       	out	0x3d, r28	; 61
    2b0c:	6b 01       	movw	r12, r22
    2b0e:	7c 01       	movw	r14, r24
	uint8_t dClass = 0;
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
	{
		if( lfOneVolt<pgm_read_float(&g_alfVolt[i]) )
    2b10:	ee e0       	ldi	r30, 0x0E	; 14
    2b12:	f8 e0       	ldi	r31, 0x08	; 8
    2b14:	25 91       	lpm	r18, Z+
    2b16:	35 91       	lpm	r19, Z+
    2b18:	45 91       	lpm	r20, Z+
    2b1a:	54 91       	lpm	r21, Z
    2b1c:	0e 94 e6 20 	call	0x41cc	; 0x41cc <__cmpsf2>
    2b20:	88 23       	and	r24, r24
    2b22:	c4 f0       	brlt	.+48     	; 0x2b54 <_Z9fnCalTempf+0x78>
    2b24:	02 e1       	ldi	r16, 0x12	; 18
    2b26:	18 e0       	ldi	r17, 0x08	; 8
{
	uint8_t i = 0;
	uint8_t dClass = 0;
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
    2b28:	21 e0       	ldi	r18, 0x01	; 1
    2b2a:	29 83       	std	Y+1, r18	; 0x01
	{
		if( lfOneVolt<pgm_read_float(&g_alfVolt[i]) )
    2b2c:	f8 01       	movw	r30, r16
    2b2e:	65 91       	lpm	r22, Z+
    2b30:	75 91       	lpm	r23, Z+
    2b32:	85 91       	lpm	r24, Z+
    2b34:	94 91       	lpm	r25, Z
    2b36:	a7 01       	movw	r20, r14
    2b38:	96 01       	movw	r18, r12
    2b3a:	0e 94 35 22 	call	0x446a	; 0x446a <__gesf2>
    2b3e:	18 16       	cp	r1, r24
    2b40:	54 f0       	brlt	.+20     	; 0x2b56 <_Z9fnCalTempf+0x7a>
{
	uint8_t i = 0;
	uint8_t dClass = 0;
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
    2b42:	39 81       	ldd	r19, Y+1	; 0x01
    2b44:	3f 5f       	subi	r19, 0xFF	; 255
    2b46:	39 83       	std	Y+1, r19	; 0x01
    2b48:	0c 5f       	subi	r16, 0xFC	; 252
    2b4a:	1f 4f       	sbci	r17, 0xFF	; 255
    2b4c:	31 3a       	cpi	r19, 0xA1	; 161
    2b4e:	71 f7       	brne	.-36     	; 0x2b2c <_Z9fnCalTempf+0x50>
120};

float fnCalTemp(float lfOneVolt)
{
	uint8_t i = 0;
	uint8_t dClass = 0;
    2b50:	19 82       	std	Y+1, r1	; 0x01
    2b52:	01 c0       	rjmp	.+2      	; 0x2b56 <_Z9fnCalTempf+0x7a>
	float lfCalTemp = 0;
	
	for( i=0; i<161; i++ )
    2b54:	19 82       	std	Y+1, r1	; 0x01
		{
			dClass = i;
			break;
		}
	}
	if (pgm_read_dword(&g_adTemp[dClass-1])<0 )
    2b56:	49 81       	ldd	r20, Y+1	; 0x01
    2b58:	a4 2f       	mov	r26, r20
    2b5a:	b0 e0       	ldi	r27, 0x00	; 0
    2b5c:	9d 01       	movw	r18, r26
    2b5e:	21 50       	subi	r18, 0x01	; 1
    2b60:	31 09       	sbc	r19, r1
    2b62:	f9 01       	movw	r30, r18
    2b64:	ee 0f       	add	r30, r30
    2b66:	ff 1f       	adc	r31, r31
    2b68:	e4 53       	subi	r30, 0x34	; 52
    2b6a:	f9 4f       	sbci	r31, 0xF9	; 249
    2b6c:	45 91       	lpm	r20, Z+
    2b6e:	55 91       	lpm	r21, Z+
    2b70:	65 91       	lpm	r22, Z+
    2b72:	74 91       	lpm	r23, Z
		//정답지: 32~40 간략화           //1도   상위 고정값 - 측정된 값    /1도 구간에서 저항 변환량
		lfCalTemp = pgm_read_dword(&g_adTemp[dClass-1]) + (1 * ( (pgm_read_float(&g_alfVolt[dClass])-lfOneVolt)/(pgm_read_float(&g_alfVolt[dClass])-pgm_read_float(&g_alfVolt[dClass-1])) ));
	}
	else
	{
		lfCalTemp = pgm_read_dword(&g_adTemp[dClass]) - (1 * ( (pgm_read_float(&g_alfVolt[dClass])-lfOneVolt)/(pgm_read_float(&g_alfVolt[dClass])-pgm_read_float(&g_alfVolt[dClass-1])) ));
    2b74:	fd 01       	movw	r30, r26
    2b76:	ee 0f       	add	r30, r30
    2b78:	ff 1f       	adc	r31, r31
    2b7a:	e4 53       	subi	r30, 0x34	; 52
    2b7c:	f9 4f       	sbci	r31, 0xF9	; 249
    2b7e:	65 91       	lpm	r22, Z+
    2b80:	75 91       	lpm	r23, Z+
    2b82:	85 91       	lpm	r24, Z+
    2b84:	94 91       	lpm	r25, Z
    2b86:	ad 01       	movw	r20, r26
    2b88:	44 0f       	add	r20, r20
    2b8a:	55 1f       	adc	r21, r21
    2b8c:	44 0f       	add	r20, r20
    2b8e:	55 1f       	adc	r21, r21
    2b90:	42 5f       	subi	r20, 0xF2	; 242
    2b92:	57 4f       	sbci	r21, 0xF7	; 247
    2b94:	fa 01       	movw	r30, r20
    2b96:	45 90       	lpm	r4, Z+
    2b98:	55 90       	lpm	r5, Z+
    2b9a:	65 90       	lpm	r6, Z+
    2b9c:	74 90       	lpm	r7, Z
    2b9e:	fa 01       	movw	r30, r20
    2ba0:	85 90       	lpm	r8, Z+
    2ba2:	95 90       	lpm	r9, Z+
    2ba4:	a5 90       	lpm	r10, Z+
    2ba6:	b4 90       	lpm	r11, Z
    2ba8:	f9 01       	movw	r30, r18
    2baa:	ee 0f       	add	r30, r30
    2bac:	ff 1f       	adc	r31, r31
    2bae:	ee 0f       	add	r30, r30
    2bb0:	ff 1f       	adc	r31, r31
    2bb2:	e2 5f       	subi	r30, 0xF2	; 242
    2bb4:	f7 4f       	sbci	r31, 0xF7	; 247
    2bb6:	25 91       	lpm	r18, Z+
    2bb8:	35 91       	lpm	r19, Z+
    2bba:	45 91       	lpm	r20, Z+
    2bbc:	54 91       	lpm	r21, Z
    2bbe:	29 83       	std	Y+1, r18	; 0x01
    2bc0:	3a 83       	std	Y+2, r19	; 0x02
    2bc2:	4b 83       	std	Y+3, r20	; 0x03
    2bc4:	5c 83       	std	Y+4, r21	; 0x04
	}
	return lfCalTemp;
    2bc6:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
    2bca:	6d 83       	std	Y+5, r22	; 0x05
    2bcc:	7e 83       	std	Y+6, r23	; 0x06
    2bce:	8f 83       	std	Y+7, r24	; 0x07
    2bd0:	98 87       	std	Y+8, r25	; 0x08
    2bd2:	a7 01       	movw	r20, r14
    2bd4:	96 01       	movw	r18, r12
    2bd6:	c3 01       	movw	r24, r6
    2bd8:	b2 01       	movw	r22, r4
    2bda:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
    2bde:	6b 01       	movw	r12, r22
    2be0:	7c 01       	movw	r14, r24
    2be2:	29 81       	ldd	r18, Y+1	; 0x01
    2be4:	3a 81       	ldd	r19, Y+2	; 0x02
    2be6:	4b 81       	ldd	r20, Y+3	; 0x03
    2be8:	5c 81       	ldd	r21, Y+4	; 0x04
    2bea:	c5 01       	movw	r24, r10
    2bec:	b4 01       	movw	r22, r8
    2bee:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
    2bf2:	9b 01       	movw	r18, r22
    2bf4:	ac 01       	movw	r20, r24
    2bf6:	c7 01       	movw	r24, r14
    2bf8:	b6 01       	movw	r22, r12
    2bfa:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <__divsf3>
    2bfe:	9b 01       	movw	r18, r22
    2c00:	ac 01       	movw	r20, r24
    2c02:	6d 81       	ldd	r22, Y+5	; 0x05
    2c04:	7e 81       	ldd	r23, Y+6	; 0x06
    2c06:	8f 81       	ldd	r24, Y+7	; 0x07
    2c08:	98 85       	ldd	r25, Y+8	; 0x08
    2c0a:	0e 94 81 20 	call	0x4102	; 0x4102 <__subsf3>
}
    2c0e:	28 96       	adiw	r28, 0x08	; 8
    2c10:	0f b6       	in	r0, 0x3f	; 63
    2c12:	f8 94       	cli
    2c14:	de bf       	out	0x3e, r29	; 62
    2c16:	0f be       	out	0x3f, r0	; 63
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	df 91       	pop	r29
    2c1c:	cf 91       	pop	r28
    2c1e:	1f 91       	pop	r17
    2c20:	0f 91       	pop	r16
    2c22:	ff 90       	pop	r15
    2c24:	ef 90       	pop	r14
    2c26:	df 90       	pop	r13
    2c28:	cf 90       	pop	r12
    2c2a:	bf 90       	pop	r11
    2c2c:	af 90       	pop	r10
    2c2e:	9f 90       	pop	r9
    2c30:	8f 90       	pop	r8
    2c32:	7f 90       	pop	r7
    2c34:	6f 90       	pop	r6
    2c36:	5f 90       	pop	r5
    2c38:	4f 90       	pop	r4
    2c3a:	08 95       	ret

00002c3c <_ZL5proc3Pv>:

static void proc3(void* pvParam)
{
    2c3c:	cf 93       	push	r28
    2c3e:	df 93       	push	r29
    2c40:	00 d0       	rcall	.+0      	; 0x2c42 <_ZL5proc3Pv+0x6>
    2c42:	00 d0       	rcall	.+0      	; 0x2c44 <_ZL5proc3Pv+0x8>
    2c44:	cd b7       	in	r28, 0x3d	; 61
    2c46:	de b7       	in	r29, 0x3e	; 62
	DFRobotHighTemperature PT100(5.000);
    2c48:	40 e0       	ldi	r20, 0x00	; 0
    2c4a:	50 e0       	ldi	r21, 0x00	; 0
    2c4c:	60 ea       	ldi	r22, 0xA0	; 160
    2c4e:	70 e4       	ldi	r23, 0x40	; 64
    2c50:	ce 01       	movw	r24, r28
    2c52:	01 96       	adiw	r24, 0x01	; 1
    2c54:	0e 94 dd 06 	call	0xdba	; 0xdba <_ZN22DFRobotHighTemperatureC1Ef>
	uint8_t cnt = 0;
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
    2c58:	31 2c       	mov	r3, r1
static void proc3(void* pvParam)
{
	DFRobotHighTemperature PT100(5.000);
	uint8_t cnt = 0;
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
    2c5a:	c1 2c       	mov	r12, r1

static void proc3(void* pvParam)
{
	DFRobotHighTemperature PT100(5.000);
	uint8_t cnt = 0;
	uint8_t seq = 0;
    2c5c:	10 e0       	ldi	r17, 0x00	; 0
}

static void proc3(void* pvParam)
{
	DFRobotHighTemperature PT100(5.000);
	uint8_t cnt = 0;
    2c5e:	00 e0       	ldi	r16, 0x00	; 0
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
	while(1)
	{
		adc->Start_Device(seq % 3);
    2c60:	0f 2e       	mov	r0, r31
    2c62:	fb ea       	ldi	r31, 0xAB	; 171
    2c64:	df 2e       	mov	r13, r31
    2c66:	f0 2d       	mov	r31, r0
			cnt1++;
		}
		else if(channel == 2)
		{
			uint16_t read = ADCL+((uint16_t)ADCH << 8);
			Adc_channels[channel] += read;
    2c68:	0f 2e       	mov	r0, r31
    2c6a:	f4 e9       	ldi	r31, 0x94	; 148
    2c6c:	ef 2e       	mov	r14, r31
    2c6e:	f2 e0       	ldi	r31, 0x02	; 2
    2c70:	ff 2e       	mov	r15, r31
    2c72:	f0 2d       	mov	r31, r0
		}
		else if(cnt1 >= ADC_LOOP)
		{
			unsigned int temp = Adc_channels[1] / ADC_LOOP;
			//int temp1 = PT100.readTemperature(temp);
			mem4[LOCAL_PT100_SENSOR] = temp - 5;
    2c74:	0f 2e       	mov	r0, r31
    2c76:	f8 e3       	ldi	r31, 0x38	; 56
    2c78:	8f 2e       	mov	r8, r31
    2c7a:	f3 e0       	ldi	r31, 0x03	; 3
    2c7c:	9f 2e       	mov	r9, r31
    2c7e:	f0 2d       	mov	r31, r0
			cnt2++;
		}
		
		if(cnt >= ADC_LOOP)
		{
			mem4[LOCAL_TEMP_SENSOR] = Adc_channels[0] / ADC_LOOP;
    2c80:	0f 2e       	mov	r0, r31
    2c82:	f6 e3       	ldi	r31, 0x36	; 54
    2c84:	af 2e       	mov	r10, r31
    2c86:	f3 e0       	ldi	r31, 0x03	; 3
    2c88:	bf 2e       	mov	r11, r31
    2c8a:	f0 2d       	mov	r31, r0
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
	while(1)
	{
		adc->Start_Device(seq % 3);
    2c8c:	a0 91 81 03 	lds	r26, 0x0381	; 0x800381 <adc>
    2c90:	b0 91 82 03 	lds	r27, 0x0382	; 0x800382 <adc+0x1>
    2c94:	1d 9d       	mul	r17, r13
    2c96:	91 2d       	mov	r25, r1
    2c98:	11 24       	eor	r1, r1
    2c9a:	96 95       	lsr	r25
    2c9c:	89 2f       	mov	r24, r25
    2c9e:	88 0f       	add	r24, r24
    2ca0:	98 0f       	add	r25, r24
    2ca2:	61 2f       	mov	r22, r17
    2ca4:	69 1b       	sub	r22, r25
    2ca6:	ed 91       	ld	r30, X+
    2ca8:	fc 91       	ld	r31, X
    2caa:	11 97       	sbiw	r26, 0x01	; 1
    2cac:	02 84       	ldd	r0, Z+10	; 0x0a
    2cae:	f3 85       	ldd	r31, Z+11	; 0x0b
    2cb0:	e0 2d       	mov	r30, r0
    2cb2:	cd 01       	movw	r24, r26
    2cb4:	09 95       	icall
		uint8_t channel = ADMUX & 0x1f; 
    2cb6:	87 b1       	in	r24, 0x07	; 7
    2cb8:	8f 71       	andi	r24, 0x1F	; 31
    2cba:	78 2e       	mov	r7, r24
		vTaskDelay(10);
    2cbc:	8a e0       	ldi	r24, 0x0A	; 10
    2cbe:	90 e0       	ldi	r25, 0x00	; 0
    2cc0:	0e 94 83 1e 	call	0x3d06	; 0x3d06 <vTaskDelay>
		if(channel == 0)
    2cc4:	71 10       	cpse	r7, r1
    2cc6:	2d c0       	rjmp	.+90     	; 0x2d22 <_ZL5proc3Pv+0xe6>
		{
			uint16_t read = ADCL+((uint16_t)ADCH << 8);
    2cc8:	84 b1       	in	r24, 0x04	; 4
    2cca:	65 b1       	in	r22, 0x05	; 5
			float temp = read * 4.8828125;
			Adc_channels[channel] = Adc_channels[channel] + (temp / 10);
    2ccc:	70 e0       	ldi	r23, 0x00	; 0
    2cce:	76 2f       	mov	r23, r22
    2cd0:	66 27       	eor	r22, r22
    2cd2:	68 0f       	add	r22, r24
    2cd4:	71 1d       	adc	r23, r1
    2cd6:	80 e0       	ldi	r24, 0x00	; 0
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
    2cde:	20 e0       	ldi	r18, 0x00	; 0
    2ce0:	30 e4       	ldi	r19, 0x40	; 64
    2ce2:	4c e9       	ldi	r20, 0x9C	; 156
    2ce4:	50 e4       	ldi	r21, 0x40	; 64
    2ce6:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
    2cea:	20 e0       	ldi	r18, 0x00	; 0
    2cec:	30 e0       	ldi	r19, 0x00	; 0
    2cee:	40 e2       	ldi	r20, 0x20	; 32
    2cf0:	51 e4       	ldi	r21, 0x41	; 65
    2cf2:	0e 94 ea 20 	call	0x41d4	; 0x41d4 <__divsf3>
    2cf6:	2b 01       	movw	r4, r22
    2cf8:	3c 01       	movw	r6, r24
    2cfa:	f7 01       	movw	r30, r14
    2cfc:	60 81       	ld	r22, Z
    2cfe:	71 81       	ldd	r23, Z+1	; 0x01
    2d00:	80 e0       	ldi	r24, 0x00	; 0
    2d02:	90 e0       	ldi	r25, 0x00	; 0
    2d04:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
    2d08:	9b 01       	movw	r18, r22
    2d0a:	ac 01       	movw	r20, r24
    2d0c:	c3 01       	movw	r24, r6
    2d0e:	b2 01       	movw	r22, r4
    2d10:	0e 94 82 20 	call	0x4104	; 0x4104 <__addsf3>
    2d14:	0e 94 57 21 	call	0x42ae	; 0x42ae <__fixunssfsi>
    2d18:	f7 01       	movw	r30, r14
    2d1a:	71 83       	std	Z+1, r23	; 0x01
    2d1c:	60 83       	st	Z, r22
			cnt++;
    2d1e:	0f 5f       	subi	r16, 0xFF	; 255
    2d20:	2a c0       	rjmp	.+84     	; 0x2d76 <_ZL5proc3Pv+0x13a>
		}
		else if(channel == 1)
    2d22:	f1 e0       	ldi	r31, 0x01	; 1
    2d24:	7f 12       	cpse	r7, r31
    2d26:	14 c0       	rjmp	.+40     	; 0x2d50 <_ZL5proc3Pv+0x114>
		{
			uint16_t read = ADCL+((uint16_t)ADCH << 8);
    2d28:	84 b1       	in	r24, 0x04	; 4
    2d2a:	65 b1       	in	r22, 0x05	; 5
			Adc_channels[channel] +=PT100.readTemperature(read);
    2d2c:	70 e0       	ldi	r23, 0x00	; 0
    2d2e:	76 2f       	mov	r23, r22
    2d30:	66 27       	eor	r22, r22
    2d32:	68 0f       	add	r22, r24
    2d34:	71 1d       	adc	r23, r1
    2d36:	ce 01       	movw	r24, r28
    2d38:	01 96       	adiw	r24, 0x01	; 1
    2d3a:	0e 94 40 07 	call	0xe80	; 0xe80 <_ZN22DFRobotHighTemperature15readTemperatureEj>
    2d3e:	f7 01       	movw	r30, r14
    2d40:	22 81       	ldd	r18, Z+2	; 0x02
    2d42:	33 81       	ldd	r19, Z+3	; 0x03
    2d44:	82 0f       	add	r24, r18
    2d46:	93 1f       	adc	r25, r19
    2d48:	93 83       	std	Z+3, r25	; 0x03
    2d4a:	82 83       	std	Z+2, r24	; 0x02
			//mem4[LOCAL_PT100_SENSOR] = read;
			cnt1++;
    2d4c:	c3 94       	inc	r12
    2d4e:	13 c0       	rjmp	.+38     	; 0x2d76 <_ZL5proc3Pv+0x13a>
		}
		else if(channel == 2)
    2d50:	f2 e0       	ldi	r31, 0x02	; 2
    2d52:	7f 12       	cpse	r7, r31
    2d54:	10 c0       	rjmp	.+32     	; 0x2d76 <_ZL5proc3Pv+0x13a>
		{
			uint16_t read = ADCL+((uint16_t)ADCH << 8);
    2d56:	84 b1       	in	r24, 0x04	; 4
    2d58:	95 b1       	in	r25, 0x05	; 5
			Adc_channels[channel] += read;
    2d5a:	f7 01       	movw	r30, r14
    2d5c:	24 81       	ldd	r18, Z+4	; 0x04
    2d5e:	35 81       	ldd	r19, Z+5	; 0x05
    2d60:	28 0f       	add	r18, r24
    2d62:	31 1d       	adc	r19, r1
    2d64:	89 2f       	mov	r24, r25
    2d66:	90 e0       	ldi	r25, 0x00	; 0
    2d68:	98 2f       	mov	r25, r24
    2d6a:	88 27       	eor	r24, r24
    2d6c:	82 0f       	add	r24, r18
    2d6e:	93 1f       	adc	r25, r19
    2d70:	95 83       	std	Z+5, r25	; 0x05
    2d72:	84 83       	std	Z+4, r24	; 0x04
			cnt2++;
    2d74:	33 94       	inc	r3
		}
		
		if(cnt >= ADC_LOOP)
    2d76:	0e 31       	cpi	r16, 0x1E	; 30
    2d78:	a8 f0       	brcs	.+42     	; 0x2da4 <_ZL5proc3Pv+0x168>
		{
			mem4[LOCAL_TEMP_SENSOR] = Adc_channels[0] / ADC_LOOP;
    2d7a:	f7 01       	movw	r30, r14
    2d7c:	20 81       	ld	r18, Z
    2d7e:	31 81       	ldd	r19, Z+1	; 0x01
    2d80:	a9 e8       	ldi	r26, 0x89	; 137
    2d82:	b8 e8       	ldi	r27, 0x88	; 136
    2d84:	0e 94 be 22 	call	0x457c	; 0x457c <__umulhisi3>
    2d88:	92 95       	swap	r25
    2d8a:	82 95       	swap	r24
    2d8c:	8f 70       	andi	r24, 0x0F	; 15
    2d8e:	89 27       	eor	r24, r25
    2d90:	9f 70       	andi	r25, 0x0F	; 15
    2d92:	89 27       	eor	r24, r25
    2d94:	f5 01       	movw	r30, r10
    2d96:	91 83       	std	Z+1, r25	; 0x01
    2d98:	80 83       	st	Z, r24
			Adc_channels[0] = 0;
    2d9a:	f7 01       	movw	r30, r14
    2d9c:	11 82       	std	Z+1, r1	; 0x01
    2d9e:	10 82       	st	Z, r1
			cnt = 0;
    2da0:	00 e0       	ldi	r16, 0x00	; 0
    2da2:	45 c0       	rjmp	.+138    	; 0x2e2e <_ZL5proc3Pv+0x1f2>
		}
		else if(cnt1 >= ADC_LOOP)
    2da4:	fd e1       	ldi	r31, 0x1D	; 29
    2da6:	fc 15       	cp	r31, r12
    2da8:	b0 f4       	brcc	.+44     	; 0x2dd6 <_ZL5proc3Pv+0x19a>
		{
			unsigned int temp = Adc_channels[1] / ADC_LOOP;
			//int temp1 = PT100.readTemperature(temp);
			mem4[LOCAL_PT100_SENSOR] = temp - 5;
    2daa:	f7 01       	movw	r30, r14
    2dac:	22 81       	ldd	r18, Z+2	; 0x02
    2dae:	33 81       	ldd	r19, Z+3	; 0x03
    2db0:	a9 e8       	ldi	r26, 0x89	; 137
    2db2:	b8 e8       	ldi	r27, 0x88	; 136
    2db4:	0e 94 be 22 	call	0x457c	; 0x457c <__umulhisi3>
    2db8:	92 95       	swap	r25
    2dba:	82 95       	swap	r24
    2dbc:	8f 70       	andi	r24, 0x0F	; 15
    2dbe:	89 27       	eor	r24, r25
    2dc0:	9f 70       	andi	r25, 0x0F	; 15
    2dc2:	89 27       	eor	r24, r25
    2dc4:	05 97       	sbiw	r24, 0x05	; 5
    2dc6:	f4 01       	movw	r30, r8
    2dc8:	91 83       	std	Z+1, r25	; 0x01
    2dca:	80 83       	st	Z, r24
			Adc_channels[1] = 0;
    2dcc:	f7 01       	movw	r30, r14
    2dce:	13 82       	std	Z+3, r1	; 0x03
    2dd0:	12 82       	std	Z+2, r1	; 0x02
			cnt1 = 0;
    2dd2:	c1 2c       	mov	r12, r1
    2dd4:	2c c0       	rjmp	.+88     	; 0x2e2e <_ZL5proc3Pv+0x1f2>
		}
		else if(cnt2 >= ADC_LOOP)
    2dd6:	fd e1       	ldi	r31, 0x1D	; 29
    2dd8:	f3 15       	cp	r31, r3
    2dda:	48 f5       	brcc	.+82     	; 0x2e2e <_ZL5proc3Pv+0x1f2>
		{
			float vin = (Adc_channels[2] / ADC_LOOP )* 0.004887;
			float temp = fnCalTemp(vin);
    2ddc:	f7 01       	movw	r30, r14
    2dde:	24 81       	ldd	r18, Z+4	; 0x04
    2de0:	35 81       	ldd	r19, Z+5	; 0x05
    2de2:	a9 e8       	ldi	r26, 0x89	; 137
    2de4:	b8 e8       	ldi	r27, 0x88	; 136
    2de6:	0e 94 be 22 	call	0x457c	; 0x457c <__umulhisi3>
    2dea:	92 95       	swap	r25
    2dec:	82 95       	swap	r24
    2dee:	8f 70       	andi	r24, 0x0F	; 15
    2df0:	89 27       	eor	r24, r25
    2df2:	9f 70       	andi	r25, 0x0F	; 15
    2df4:	89 27       	eor	r24, r25
    2df6:	bc 01       	movw	r22, r24
    2df8:	80 e0       	ldi	r24, 0x00	; 0
    2dfa:	90 e0       	ldi	r25, 0x00	; 0
    2dfc:	0e 94 83 21 	call	0x4306	; 0x4306 <__floatunsisf>
    2e00:	21 e2       	ldi	r18, 0x21	; 33
    2e02:	33 e2       	ldi	r19, 0x23	; 35
    2e04:	40 ea       	ldi	r20, 0xA0	; 160
    2e06:	5b e3       	ldi	r21, 0x3B	; 59
    2e08:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
    2e0c:	67 de       	rcall	.-818    	; 0x2adc <_Z9fnCalTempf>
			mem4[LOCAL_NTC_SENSOR] = temp * 10;
    2e0e:	20 e0       	ldi	r18, 0x00	; 0
    2e10:	30 e0       	ldi	r19, 0x00	; 0
    2e12:	40 e2       	ldi	r20, 0x20	; 32
    2e14:	51 e4       	ldi	r21, 0x41	; 65
    2e16:	0e 94 39 22 	call	0x4472	; 0x4472 <__mulsf3>
    2e1a:	0e 94 52 21 	call	0x42a4	; 0x42a4 <__fixsfsi>
    2e1e:	ea e3       	ldi	r30, 0x3A	; 58
    2e20:	f3 e0       	ldi	r31, 0x03	; 3
    2e22:	71 83       	std	Z+1, r23	; 0x01
    2e24:	60 83       	st	Z, r22
			Adc_channels[2] = 0;
    2e26:	f7 01       	movw	r30, r14
    2e28:	15 82       	std	Z+5, r1	; 0x05
    2e2a:	14 82       	std	Z+4, r1	; 0x04
			
			cnt2 = 0;
    2e2c:	31 2c       	mov	r3, r1
		}
		seq++;
    2e2e:	1f 5f       	subi	r17, 0xFF	; 255
	DFRobotHighTemperature PT100(5.000);
	uint8_t cnt = 0;
	uint8_t seq = 0;
	uint8_t cnt1 = 0;
	uint8_t cnt2 = 0;
	while(1)
    2e30:	2d cf       	rjmp	.-422    	; 0x2c8c <_ZL5proc3Pv+0x50>

00002e32 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2e32:	cf 93       	push	r28
    2e34:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2e36:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    2e38:	30 d6       	rcall	.+3168   	; 0x3a9a <vTaskSuspendAll>
    2e3a:	80 91 85 03 	lds	r24, 0x0385	; 0x800385 <pucAlignedHeap.2069>
    2e3e:	90 91 86 03 	lds	r25, 0x0386	; 0x800386 <pucAlignedHeap.2069+0x1>
    2e42:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2e44:	31 f4       	brne	.+12     	; 0x2e52 <pvPortMalloc+0x20>
    2e46:	8a e8       	ldi	r24, 0x8A	; 138
    2e48:	93 e0       	ldi	r25, 0x03	; 3
    2e4a:	90 93 86 03 	sts	0x0386, r25	; 0x800386 <pucAlignedHeap.2069+0x1>
    2e4e:	80 93 85 03 	sts	0x0385, r24	; 0x800385 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2e52:	20 91 87 03 	lds	r18, 0x0387	; 0x800387 <xNextFreeByte>
    2e56:	30 91 88 03 	lds	r19, 0x0388	; 0x800388 <xNextFreeByte+0x1>
    2e5a:	c9 01       	movw	r24, r18
    2e5c:	8c 0f       	add	r24, r28
    2e5e:	9d 1f       	adc	r25, r29
    2e60:	87 3b       	cpi	r24, 0xB7	; 183
    2e62:	4b e0       	ldi	r20, 0x0B	; 11
    2e64:	94 07       	cpc	r25, r20
    2e66:	70 f4       	brcc	.+28     	; 0x2e84 <pvPortMalloc+0x52>
    2e68:	28 17       	cp	r18, r24
    2e6a:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2e6c:	70 f4       	brcc	.+28     	; 0x2e8a <pvPortMalloc+0x58>
    2e6e:	c0 91 85 03 	lds	r28, 0x0385	; 0x800385 <pucAlignedHeap.2069>
    2e72:	d0 91 86 03 	lds	r29, 0x0386	; 0x800386 <pucAlignedHeap.2069+0x1>
    2e76:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    2e78:	d3 1f       	adc	r29, r19
    2e7a:	90 93 88 03 	sts	0x0388, r25	; 0x800388 <xNextFreeByte+0x1>
    2e7e:	80 93 87 03 	sts	0x0387, r24	; 0x800387 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2e82:	05 c0       	rjmp	.+10     	; 0x2e8e <pvPortMalloc+0x5c>
    2e84:	c0 e0       	ldi	r28, 0x00	; 0
    2e86:	d0 e0       	ldi	r29, 0x00	; 0
    2e88:	02 c0       	rjmp	.+4      	; 0x2e8e <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2e8a:	c0 e0       	ldi	r28, 0x00	; 0
    2e8c:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    2e8e:	c2 d6       	rcall	.+3460   	; 0x3c14 <xTaskResumeAll>
    2e90:	ce 01       	movw	r24, r28
    2e92:	df 91       	pop	r29
    2e94:	cf 91       	pop	r28
    2e96:	08 95       	ret

00002e98 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2e98:	08 95       	ret

00002e9a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    2e9a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2e9c:	03 96       	adiw	r24, 0x03	; 3
    2e9e:	92 83       	std	Z+2, r25	; 0x02
    2ea0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2ea2:	2f ef       	ldi	r18, 0xFF	; 255
    2ea4:	3f ef       	ldi	r19, 0xFF	; 255
    2ea6:	34 83       	std	Z+4, r19	; 0x04
    2ea8:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2eaa:	96 83       	std	Z+6, r25	; 0x06
    2eac:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2eae:	90 87       	std	Z+8, r25	; 0x08
    2eb0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    2eb2:	10 82       	st	Z, r1
    2eb4:	08 95       	ret

00002eb6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2eb6:	fc 01       	movw	r30, r24
    2eb8:	11 86       	std	Z+9, r1	; 0x09
    2eba:	10 86       	std	Z+8, r1	; 0x08
    2ebc:	08 95       	ret

00002ebe <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2ebe:	cf 93       	push	r28
    2ec0:	df 93       	push	r29
    2ec2:	9c 01       	movw	r18, r24
    2ec4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    2ec6:	dc 01       	movw	r26, r24
    2ec8:	11 96       	adiw	r26, 0x01	; 1
    2eca:	cd 91       	ld	r28, X+
    2ecc:	dc 91       	ld	r29, X
    2ece:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    2ed0:	d3 83       	std	Z+3, r29	; 0x03
    2ed2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    2ed4:	8c 81       	ldd	r24, Y+4	; 0x04
    2ed6:	9d 81       	ldd	r25, Y+5	; 0x05
    2ed8:	95 83       	std	Z+5, r25	; 0x05
    2eda:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    2edc:	8c 81       	ldd	r24, Y+4	; 0x04
    2ede:	9d 81       	ldd	r25, Y+5	; 0x05
    2ee0:	dc 01       	movw	r26, r24
    2ee2:	13 96       	adiw	r26, 0x03	; 3
    2ee4:	7c 93       	st	X, r23
    2ee6:	6e 93       	st	-X, r22
    2ee8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    2eea:	7d 83       	std	Y+5, r23	; 0x05
    2eec:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2eee:	31 87       	std	Z+9, r19	; 0x09
    2ef0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    2ef2:	f9 01       	movw	r30, r18
    2ef4:	80 81       	ld	r24, Z
    2ef6:	8f 5f       	subi	r24, 0xFF	; 255
    2ef8:	80 83       	st	Z, r24
}
    2efa:	df 91       	pop	r29
    2efc:	cf 91       	pop	r28
    2efe:	08 95       	ret

00002f00 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    2f00:	cf 93       	push	r28
    2f02:	df 93       	push	r29
    2f04:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    2f06:	48 81       	ld	r20, Y
    2f08:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2f0a:	4f 3f       	cpi	r20, 0xFF	; 255
    2f0c:	2f ef       	ldi	r18, 0xFF	; 255
    2f0e:	52 07       	cpc	r21, r18
    2f10:	21 f4       	brne	.+8      	; 0x2f1a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2f12:	fc 01       	movw	r30, r24
    2f14:	a7 81       	ldd	r26, Z+7	; 0x07
    2f16:	b0 85       	ldd	r27, Z+8	; 0x08
    2f18:	0d c0       	rjmp	.+26     	; 0x2f34 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    2f1a:	dc 01       	movw	r26, r24
    2f1c:	13 96       	adiw	r26, 0x03	; 3
    2f1e:	01 c0       	rjmp	.+2      	; 0x2f22 <vListInsert+0x22>
    2f20:	df 01       	movw	r26, r30
    2f22:	12 96       	adiw	r26, 0x02	; 2
    2f24:	ed 91       	ld	r30, X+
    2f26:	fc 91       	ld	r31, X
    2f28:	13 97       	sbiw	r26, 0x03	; 3
    2f2a:	20 81       	ld	r18, Z
    2f2c:	31 81       	ldd	r19, Z+1	; 0x01
    2f2e:	42 17       	cp	r20, r18
    2f30:	53 07       	cpc	r21, r19
    2f32:	b0 f7       	brcc	.-20     	; 0x2f20 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2f34:	12 96       	adiw	r26, 0x02	; 2
    2f36:	ed 91       	ld	r30, X+
    2f38:	fc 91       	ld	r31, X
    2f3a:	13 97       	sbiw	r26, 0x03	; 3
    2f3c:	fb 83       	std	Y+3, r31	; 0x03
    2f3e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2f40:	d5 83       	std	Z+5, r29	; 0x05
    2f42:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2f44:	bd 83       	std	Y+5, r27	; 0x05
    2f46:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2f48:	13 96       	adiw	r26, 0x03	; 3
    2f4a:	dc 93       	st	X, r29
    2f4c:	ce 93       	st	-X, r28
    2f4e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2f50:	99 87       	std	Y+9, r25	; 0x09
    2f52:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2f54:	fc 01       	movw	r30, r24
    2f56:	20 81       	ld	r18, Z
    2f58:	2f 5f       	subi	r18, 0xFF	; 255
    2f5a:	20 83       	st	Z, r18
}
    2f5c:	df 91       	pop	r29
    2f5e:	cf 91       	pop	r28
    2f60:	08 95       	ret

00002f62 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2f62:	cf 93       	push	r28
    2f64:	df 93       	push	r29
    2f66:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2f68:	a0 85       	ldd	r26, Z+8	; 0x08
    2f6a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    2f6c:	c2 81       	ldd	r28, Z+2	; 0x02
    2f6e:	d3 81       	ldd	r29, Z+3	; 0x03
    2f70:	84 81       	ldd	r24, Z+4	; 0x04
    2f72:	95 81       	ldd	r25, Z+5	; 0x05
    2f74:	9d 83       	std	Y+5, r25	; 0x05
    2f76:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2f78:	c4 81       	ldd	r28, Z+4	; 0x04
    2f7a:	d5 81       	ldd	r29, Z+5	; 0x05
    2f7c:	82 81       	ldd	r24, Z+2	; 0x02
    2f7e:	93 81       	ldd	r25, Z+3	; 0x03
    2f80:	9b 83       	std	Y+3, r25	; 0x03
    2f82:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2f84:	11 96       	adiw	r26, 0x01	; 1
    2f86:	8d 91       	ld	r24, X+
    2f88:	9c 91       	ld	r25, X
    2f8a:	12 97       	sbiw	r26, 0x02	; 2
    2f8c:	e8 17       	cp	r30, r24
    2f8e:	f9 07       	cpc	r31, r25
    2f90:	31 f4       	brne	.+12     	; 0x2f9e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2f92:	84 81       	ldd	r24, Z+4	; 0x04
    2f94:	95 81       	ldd	r25, Z+5	; 0x05
    2f96:	12 96       	adiw	r26, 0x02	; 2
    2f98:	9c 93       	st	X, r25
    2f9a:	8e 93       	st	-X, r24
    2f9c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    2f9e:	11 86       	std	Z+9, r1	; 0x09
    2fa0:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2fa2:	8c 91       	ld	r24, X
    2fa4:	81 50       	subi	r24, 0x01	; 1
    2fa6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2fa8:	df 91       	pop	r29
    2faa:	cf 91       	pop	r28
    2fac:	08 95       	ret

00002fae <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    2fae:	31 e1       	ldi	r19, 0x11	; 17
    2fb0:	fc 01       	movw	r30, r24
    2fb2:	30 83       	st	Z, r19
    2fb4:	31 97       	sbiw	r30, 0x01	; 1
    2fb6:	22 e2       	ldi	r18, 0x22	; 34
    2fb8:	20 83       	st	Z, r18
    2fba:	31 97       	sbiw	r30, 0x01	; 1
    2fbc:	a3 e3       	ldi	r26, 0x33	; 51
    2fbe:	a0 83       	st	Z, r26
    2fc0:	31 97       	sbiw	r30, 0x01	; 1
    2fc2:	60 83       	st	Z, r22
    2fc4:	31 97       	sbiw	r30, 0x01	; 1
    2fc6:	70 83       	st	Z, r23
    2fc8:	31 97       	sbiw	r30, 0x01	; 1
    2fca:	10 82       	st	Z, r1
    2fcc:	31 97       	sbiw	r30, 0x01	; 1
    2fce:	60 e8       	ldi	r22, 0x80	; 128
    2fd0:	60 83       	st	Z, r22
    2fd2:	31 97       	sbiw	r30, 0x01	; 1
    2fd4:	10 82       	st	Z, r1
    2fd6:	31 97       	sbiw	r30, 0x01	; 1
    2fd8:	62 e0       	ldi	r22, 0x02	; 2
    2fda:	60 83       	st	Z, r22
    2fdc:	31 97       	sbiw	r30, 0x01	; 1
    2fde:	63 e0       	ldi	r22, 0x03	; 3
    2fe0:	60 83       	st	Z, r22
    2fe2:	31 97       	sbiw	r30, 0x01	; 1
    2fe4:	64 e0       	ldi	r22, 0x04	; 4
    2fe6:	60 83       	st	Z, r22
    2fe8:	31 97       	sbiw	r30, 0x01	; 1
    2fea:	65 e0       	ldi	r22, 0x05	; 5
    2fec:	60 83       	st	Z, r22
    2fee:	31 97       	sbiw	r30, 0x01	; 1
    2ff0:	66 e0       	ldi	r22, 0x06	; 6
    2ff2:	60 83       	st	Z, r22
    2ff4:	31 97       	sbiw	r30, 0x01	; 1
    2ff6:	67 e0       	ldi	r22, 0x07	; 7
    2ff8:	60 83       	st	Z, r22
    2ffa:	31 97       	sbiw	r30, 0x01	; 1
    2ffc:	68 e0       	ldi	r22, 0x08	; 8
    2ffe:	60 83       	st	Z, r22
    3000:	31 97       	sbiw	r30, 0x01	; 1
    3002:	69 e0       	ldi	r22, 0x09	; 9
    3004:	60 83       	st	Z, r22
    3006:	31 97       	sbiw	r30, 0x01	; 1
    3008:	60 e1       	ldi	r22, 0x10	; 16
    300a:	60 83       	st	Z, r22
    300c:	31 97       	sbiw	r30, 0x01	; 1
    300e:	30 83       	st	Z, r19
    3010:	31 97       	sbiw	r30, 0x01	; 1
    3012:	32 e1       	ldi	r19, 0x12	; 18
    3014:	30 83       	st	Z, r19
    3016:	31 97       	sbiw	r30, 0x01	; 1
    3018:	33 e1       	ldi	r19, 0x13	; 19
    301a:	30 83       	st	Z, r19
    301c:	31 97       	sbiw	r30, 0x01	; 1
    301e:	34 e1       	ldi	r19, 0x14	; 20
    3020:	30 83       	st	Z, r19
    3022:	31 97       	sbiw	r30, 0x01	; 1
    3024:	35 e1       	ldi	r19, 0x15	; 21
    3026:	30 83       	st	Z, r19
    3028:	31 97       	sbiw	r30, 0x01	; 1
    302a:	36 e1       	ldi	r19, 0x16	; 22
    302c:	30 83       	st	Z, r19
    302e:	31 97       	sbiw	r30, 0x01	; 1
    3030:	37 e1       	ldi	r19, 0x17	; 23
    3032:	30 83       	st	Z, r19
    3034:	31 97       	sbiw	r30, 0x01	; 1
    3036:	38 e1       	ldi	r19, 0x18	; 24
    3038:	30 83       	st	Z, r19
    303a:	31 97       	sbiw	r30, 0x01	; 1
    303c:	39 e1       	ldi	r19, 0x19	; 25
    303e:	30 83       	st	Z, r19
    3040:	31 97       	sbiw	r30, 0x01	; 1
    3042:	30 e2       	ldi	r19, 0x20	; 32
    3044:	30 83       	st	Z, r19
    3046:	31 97       	sbiw	r30, 0x01	; 1
    3048:	31 e2       	ldi	r19, 0x21	; 33
    304a:	30 83       	st	Z, r19
    304c:	31 97       	sbiw	r30, 0x01	; 1
    304e:	20 83       	st	Z, r18
    3050:	31 97       	sbiw	r30, 0x01	; 1
    3052:	23 e2       	ldi	r18, 0x23	; 35
    3054:	20 83       	st	Z, r18
    3056:	31 97       	sbiw	r30, 0x01	; 1
    3058:	40 83       	st	Z, r20
    305a:	31 97       	sbiw	r30, 0x01	; 1
    305c:	50 83       	st	Z, r21
    305e:	31 97       	sbiw	r30, 0x01	; 1
    3060:	26 e2       	ldi	r18, 0x26	; 38
    3062:	20 83       	st	Z, r18
    3064:	31 97       	sbiw	r30, 0x01	; 1
    3066:	27 e2       	ldi	r18, 0x27	; 39
    3068:	20 83       	st	Z, r18
    306a:	31 97       	sbiw	r30, 0x01	; 1
    306c:	28 e2       	ldi	r18, 0x28	; 40
    306e:	20 83       	st	Z, r18
    3070:	31 97       	sbiw	r30, 0x01	; 1
    3072:	29 e2       	ldi	r18, 0x29	; 41
    3074:	20 83       	st	Z, r18
    3076:	31 97       	sbiw	r30, 0x01	; 1
    3078:	20 e3       	ldi	r18, 0x30	; 48
    307a:	20 83       	st	Z, r18
    307c:	31 97       	sbiw	r30, 0x01	; 1
    307e:	21 e3       	ldi	r18, 0x31	; 49
    3080:	20 83       	st	Z, r18
    3082:	86 97       	sbiw	r24, 0x26	; 38
    3084:	08 95       	ret

00003086 <xPortStartScheduler>:
    3086:	1b bc       	out	0x2b, r1	; 43
    3088:	89 ef       	ldi	r24, 0xF9	; 249
    308a:	8a bd       	out	0x2a, r24	; 42
    308c:	8b e0       	ldi	r24, 0x0B	; 11
    308e:	8e bd       	out	0x2e, r24	; 46
    3090:	87 b7       	in	r24, 0x37	; 55
    3092:	80 61       	ori	r24, 0x10	; 16
    3094:	87 bf       	out	0x37, r24	; 55
    3096:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    309a:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    309e:	cd 91       	ld	r28, X+
    30a0:	cd bf       	out	0x3d, r28	; 61
    30a2:	dd 91       	ld	r29, X+
    30a4:	de bf       	out	0x3e, r29	; 62
    30a6:	ff 91       	pop	r31
    30a8:	ef 91       	pop	r30
    30aa:	df 91       	pop	r29
    30ac:	cf 91       	pop	r28
    30ae:	bf 91       	pop	r27
    30b0:	af 91       	pop	r26
    30b2:	9f 91       	pop	r25
    30b4:	8f 91       	pop	r24
    30b6:	7f 91       	pop	r23
    30b8:	6f 91       	pop	r22
    30ba:	5f 91       	pop	r21
    30bc:	4f 91       	pop	r20
    30be:	3f 91       	pop	r19
    30c0:	2f 91       	pop	r18
    30c2:	1f 91       	pop	r17
    30c4:	0f 91       	pop	r16
    30c6:	ff 90       	pop	r15
    30c8:	ef 90       	pop	r14
    30ca:	df 90       	pop	r13
    30cc:	cf 90       	pop	r12
    30ce:	bf 90       	pop	r11
    30d0:	af 90       	pop	r10
    30d2:	9f 90       	pop	r9
    30d4:	8f 90       	pop	r8
    30d6:	7f 90       	pop	r7
    30d8:	6f 90       	pop	r6
    30da:	5f 90       	pop	r5
    30dc:	4f 90       	pop	r4
    30de:	3f 90       	pop	r3
    30e0:	2f 90       	pop	r2
    30e2:	1f 90       	pop	r1
    30e4:	0f 90       	pop	r0
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	0f 90       	pop	r0
    30ea:	08 95       	ret
    30ec:	81 e0       	ldi	r24, 0x01	; 1
    30ee:	08 95       	ret

000030f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30f0:	0f 92       	push	r0
    30f2:	0f b6       	in	r0, 0x3f	; 63
    30f4:	f8 94       	cli
    30f6:	0f 92       	push	r0
    30f8:	1f 92       	push	r1
    30fa:	11 24       	eor	r1, r1
    30fc:	2f 92       	push	r2
    30fe:	3f 92       	push	r3
    3100:	4f 92       	push	r4
    3102:	5f 92       	push	r5
    3104:	6f 92       	push	r6
    3106:	7f 92       	push	r7
    3108:	8f 92       	push	r8
    310a:	9f 92       	push	r9
    310c:	af 92       	push	r10
    310e:	bf 92       	push	r11
    3110:	cf 92       	push	r12
    3112:	df 92       	push	r13
    3114:	ef 92       	push	r14
    3116:	ff 92       	push	r15
    3118:	0f 93       	push	r16
    311a:	1f 93       	push	r17
    311c:	2f 93       	push	r18
    311e:	3f 93       	push	r19
    3120:	4f 93       	push	r20
    3122:	5f 93       	push	r21
    3124:	6f 93       	push	r22
    3126:	7f 93       	push	r23
    3128:	8f 93       	push	r24
    312a:	9f 93       	push	r25
    312c:	af 93       	push	r26
    312e:	bf 93       	push	r27
    3130:	cf 93       	push	r28
    3132:	df 93       	push	r29
    3134:	ef 93       	push	r30
    3136:	ff 93       	push	r31
    3138:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    313c:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3140:	0d b6       	in	r0, 0x3d	; 61
    3142:	0d 92       	st	X+, r0
    3144:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    3146:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    3148:	25 d6       	rcall	.+3146   	; 0x3d94 <vTaskSwitchContext>
    314a:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    314e:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3152:	cd 91       	ld	r28, X+
    3154:	cd bf       	out	0x3d, r28	; 61
    3156:	dd 91       	ld	r29, X+
    3158:	de bf       	out	0x3e, r29	; 62
    315a:	ff 91       	pop	r31
    315c:	ef 91       	pop	r30
    315e:	df 91       	pop	r29
    3160:	cf 91       	pop	r28
    3162:	bf 91       	pop	r27
    3164:	af 91       	pop	r26
    3166:	9f 91       	pop	r25
    3168:	8f 91       	pop	r24
    316a:	7f 91       	pop	r23
    316c:	6f 91       	pop	r22
    316e:	5f 91       	pop	r21
    3170:	4f 91       	pop	r20
    3172:	3f 91       	pop	r19
    3174:	2f 91       	pop	r18
    3176:	1f 91       	pop	r17
    3178:	0f 91       	pop	r16
    317a:	ff 90       	pop	r15
    317c:	ef 90       	pop	r14
    317e:	df 90       	pop	r13
    3180:	cf 90       	pop	r12
    3182:	bf 90       	pop	r11
    3184:	af 90       	pop	r10
    3186:	9f 90       	pop	r9
    3188:	8f 90       	pop	r8
    318a:	7f 90       	pop	r7
    318c:	6f 90       	pop	r6
    318e:	5f 90       	pop	r5
    3190:	4f 90       	pop	r4
    3192:	3f 90       	pop	r3
    3194:	2f 90       	pop	r2
    3196:	1f 90       	pop	r1
    3198:	0f 90       	pop	r0
    319a:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    319c:	0f 90       	pop	r0
    319e:	08 95       	ret

000031a0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    31a0:	0f 92       	push	r0
    31a2:	0f b6       	in	r0, 0x3f	; 63
    31a4:	f8 94       	cli
    31a6:	0f 92       	push	r0
    31a8:	1f 92       	push	r1
    31aa:	11 24       	eor	r1, r1
    31ac:	2f 92       	push	r2
    31ae:	3f 92       	push	r3
    31b0:	4f 92       	push	r4
    31b2:	5f 92       	push	r5
    31b4:	6f 92       	push	r6
    31b6:	7f 92       	push	r7
    31b8:	8f 92       	push	r8
    31ba:	9f 92       	push	r9
    31bc:	af 92       	push	r10
    31be:	bf 92       	push	r11
    31c0:	cf 92       	push	r12
    31c2:	df 92       	push	r13
    31c4:	ef 92       	push	r14
    31c6:	ff 92       	push	r15
    31c8:	0f 93       	push	r16
    31ca:	1f 93       	push	r17
    31cc:	2f 93       	push	r18
    31ce:	3f 93       	push	r19
    31d0:	4f 93       	push	r20
    31d2:	5f 93       	push	r21
    31d4:	6f 93       	push	r22
    31d6:	7f 93       	push	r23
    31d8:	8f 93       	push	r24
    31da:	9f 93       	push	r25
    31dc:	af 93       	push	r26
    31de:	bf 93       	push	r27
    31e0:	cf 93       	push	r28
    31e2:	df 93       	push	r29
    31e4:	ef 93       	push	r30
    31e6:	ff 93       	push	r31
    31e8:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    31ec:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    31f0:	0d b6       	in	r0, 0x3d	; 61
    31f2:	0d 92       	st	X+, r0
    31f4:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    31f6:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    31f8:	56 d4       	rcall	.+2220   	; 0x3aa6 <xTaskIncrementTick>
    31fa:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    31fc:	cb d5       	rcall	.+2966   	; 0x3d94 <vTaskSwitchContext>
    31fe:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3202:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3206:	cd 91       	ld	r28, X+
    3208:	cd bf       	out	0x3d, r28	; 61
    320a:	dd 91       	ld	r29, X+
    320c:	de bf       	out	0x3e, r29	; 62
    320e:	ff 91       	pop	r31
    3210:	ef 91       	pop	r30
    3212:	df 91       	pop	r29
    3214:	cf 91       	pop	r28
    3216:	bf 91       	pop	r27
    3218:	af 91       	pop	r26
    321a:	9f 91       	pop	r25
    321c:	8f 91       	pop	r24
    321e:	7f 91       	pop	r23
    3220:	6f 91       	pop	r22
    3222:	5f 91       	pop	r21
    3224:	4f 91       	pop	r20
    3226:	3f 91       	pop	r19
    3228:	2f 91       	pop	r18
    322a:	1f 91       	pop	r17
    322c:	0f 91       	pop	r16
    322e:	ff 90       	pop	r15
    3230:	ef 90       	pop	r14
    3232:	df 90       	pop	r13
    3234:	cf 90       	pop	r12
    3236:	bf 90       	pop	r11
    3238:	af 90       	pop	r10
    323a:	9f 90       	pop	r9
    323c:	8f 90       	pop	r8
    323e:	7f 90       	pop	r7
    3240:	6f 90       	pop	r6
    3242:	5f 90       	pop	r5
    3244:	4f 90       	pop	r4
    3246:	3f 90       	pop	r3
    3248:	2f 90       	pop	r2
    324a:	1f 90       	pop	r1
    324c:	0f 90       	pop	r0
    324e:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    3250:	0f 90       	pop	r0
    3252:	08 95       	ret

00003254 <__vector_12>:
    3254:	a5 df       	rcall	.-182    	; 0x31a0 <vPortYieldFromTick>
    3256:	18 95       	reti

00003258 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3258:	0f 93       	push	r16
    325a:	1f 93       	push	r17
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
    3260:	ec 01       	movw	r28, r24
    3262:	04 2f       	mov	r16, r20
    3264:	1a 8d       	ldd	r17, Y+26	; 0x1a
    3266:	4c 8d       	ldd	r20, Y+28	; 0x1c
    3268:	41 11       	cpse	r20, r1
    326a:	0b c0       	rjmp	.+22     	; 0x3282 <prvCopyDataToQueue+0x2a>
    326c:	88 81       	ld	r24, Y
    326e:	99 81       	ldd	r25, Y+1	; 0x01
    3270:	89 2b       	or	r24, r25
    3272:	09 f0       	breq	.+2      	; 0x3276 <prvCopyDataToQueue+0x1e>
    3274:	41 c0       	rjmp	.+130    	; 0x32f8 <prvCopyDataToQueue+0xa0>
    3276:	8a 81       	ldd	r24, Y+2	; 0x02
    3278:	9b 81       	ldd	r25, Y+3	; 0x03
    327a:	f1 d6       	rcall	.+3554   	; 0x405e <xTaskPriorityDisinherit>
    327c:	1b 82       	std	Y+3, r1	; 0x03
    327e:	1a 82       	std	Y+2, r1	; 0x02
    3280:	42 c0       	rjmp	.+132    	; 0x3306 <prvCopyDataToQueue+0xae>
    3282:	01 11       	cpse	r16, r1
    3284:	17 c0       	rjmp	.+46     	; 0x32b4 <prvCopyDataToQueue+0x5c>
    3286:	50 e0       	ldi	r21, 0x00	; 0
    3288:	8c 81       	ldd	r24, Y+4	; 0x04
    328a:	9d 81       	ldd	r25, Y+5	; 0x05
    328c:	0e 94 cd 22 	call	0x459a	; 0x459a <memcpy>
    3290:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3292:	8c 81       	ldd	r24, Y+4	; 0x04
    3294:	9d 81       	ldd	r25, Y+5	; 0x05
    3296:	82 0f       	add	r24, r18
    3298:	91 1d       	adc	r25, r1
    329a:	9d 83       	std	Y+5, r25	; 0x05
    329c:	8c 83       	std	Y+4, r24	; 0x04
    329e:	2a 81       	ldd	r18, Y+2	; 0x02
    32a0:	3b 81       	ldd	r19, Y+3	; 0x03
    32a2:	82 17       	cp	r24, r18
    32a4:	93 07       	cpc	r25, r19
    32a6:	50 f1       	brcs	.+84     	; 0x32fc <prvCopyDataToQueue+0xa4>
    32a8:	88 81       	ld	r24, Y
    32aa:	99 81       	ldd	r25, Y+1	; 0x01
    32ac:	9d 83       	std	Y+5, r25	; 0x05
    32ae:	8c 83       	std	Y+4, r24	; 0x04
    32b0:	80 e0       	ldi	r24, 0x00	; 0
    32b2:	29 c0       	rjmp	.+82     	; 0x3306 <prvCopyDataToQueue+0xae>
    32b4:	50 e0       	ldi	r21, 0x00	; 0
    32b6:	8e 81       	ldd	r24, Y+6	; 0x06
    32b8:	9f 81       	ldd	r25, Y+7	; 0x07
    32ba:	0e 94 cd 22 	call	0x459a	; 0x459a <memcpy>
    32be:	8c 8d       	ldd	r24, Y+28	; 0x1c
    32c0:	90 e0       	ldi	r25, 0x00	; 0
    32c2:	91 95       	neg	r25
    32c4:	81 95       	neg	r24
    32c6:	91 09       	sbc	r25, r1
    32c8:	2e 81       	ldd	r18, Y+6	; 0x06
    32ca:	3f 81       	ldd	r19, Y+7	; 0x07
    32cc:	28 0f       	add	r18, r24
    32ce:	39 1f       	adc	r19, r25
    32d0:	3f 83       	std	Y+7, r19	; 0x07
    32d2:	2e 83       	std	Y+6, r18	; 0x06
    32d4:	48 81       	ld	r20, Y
    32d6:	59 81       	ldd	r21, Y+1	; 0x01
    32d8:	24 17       	cp	r18, r20
    32da:	35 07       	cpc	r19, r21
    32dc:	30 f4       	brcc	.+12     	; 0x32ea <prvCopyDataToQueue+0x92>
    32de:	2a 81       	ldd	r18, Y+2	; 0x02
    32e0:	3b 81       	ldd	r19, Y+3	; 0x03
    32e2:	82 0f       	add	r24, r18
    32e4:	93 1f       	adc	r25, r19
    32e6:	9f 83       	std	Y+7, r25	; 0x07
    32e8:	8e 83       	std	Y+6, r24	; 0x06
    32ea:	02 30       	cpi	r16, 0x02	; 2
    32ec:	49 f4       	brne	.+18     	; 0x3300 <prvCopyDataToQueue+0xa8>
    32ee:	11 23       	and	r17, r17
    32f0:	49 f0       	breq	.+18     	; 0x3304 <prvCopyDataToQueue+0xac>
    32f2:	11 50       	subi	r17, 0x01	; 1
    32f4:	80 e0       	ldi	r24, 0x00	; 0
    32f6:	07 c0       	rjmp	.+14     	; 0x3306 <prvCopyDataToQueue+0xae>
    32f8:	80 e0       	ldi	r24, 0x00	; 0
    32fa:	05 c0       	rjmp	.+10     	; 0x3306 <prvCopyDataToQueue+0xae>
    32fc:	80 e0       	ldi	r24, 0x00	; 0
    32fe:	03 c0       	rjmp	.+6      	; 0x3306 <prvCopyDataToQueue+0xae>
    3300:	80 e0       	ldi	r24, 0x00	; 0
    3302:	01 c0       	rjmp	.+2      	; 0x3306 <prvCopyDataToQueue+0xae>
    3304:	80 e0       	ldi	r24, 0x00	; 0
    3306:	1f 5f       	subi	r17, 0xFF	; 255
    3308:	1a 8f       	std	Y+26, r17	; 0x1a
    330a:	df 91       	pop	r29
    330c:	cf 91       	pop	r28
    330e:	1f 91       	pop	r17
    3310:	0f 91       	pop	r16
    3312:	08 95       	ret

00003314 <prvCopyDataFromQueue>:
    3314:	fc 01       	movw	r30, r24
    3316:	44 8d       	ldd	r20, Z+28	; 0x1c
    3318:	44 23       	and	r20, r20
    331a:	a9 f0       	breq	.+42     	; 0x3346 <prvCopyDataFromQueue+0x32>
    331c:	50 e0       	ldi	r21, 0x00	; 0
    331e:	26 81       	ldd	r18, Z+6	; 0x06
    3320:	37 81       	ldd	r19, Z+7	; 0x07
    3322:	24 0f       	add	r18, r20
    3324:	35 1f       	adc	r19, r21
    3326:	37 83       	std	Z+7, r19	; 0x07
    3328:	26 83       	std	Z+6, r18	; 0x06
    332a:	82 81       	ldd	r24, Z+2	; 0x02
    332c:	93 81       	ldd	r25, Z+3	; 0x03
    332e:	28 17       	cp	r18, r24
    3330:	39 07       	cpc	r19, r25
    3332:	20 f0       	brcs	.+8      	; 0x333c <prvCopyDataFromQueue+0x28>
    3334:	80 81       	ld	r24, Z
    3336:	91 81       	ldd	r25, Z+1	; 0x01
    3338:	97 83       	std	Z+7, r25	; 0x07
    333a:	86 83       	std	Z+6, r24	; 0x06
    333c:	cb 01       	movw	r24, r22
    333e:	66 81       	ldd	r22, Z+6	; 0x06
    3340:	77 81       	ldd	r23, Z+7	; 0x07
    3342:	0c 94 cd 22 	jmp	0x459a	; 0x459a <memcpy>
    3346:	08 95       	ret

00003348 <prvUnlockQueue>:
    3348:	ef 92       	push	r14
    334a:	ff 92       	push	r15
    334c:	0f 93       	push	r16
    334e:	1f 93       	push	r17
    3350:	cf 93       	push	r28
    3352:	8c 01       	movw	r16, r24
    3354:	0f b6       	in	r0, 0x3f	; 63
    3356:	f8 94       	cli
    3358:	0f 92       	push	r0
    335a:	fc 01       	movw	r30, r24
    335c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    335e:	1c 16       	cp	r1, r28
    3360:	9c f4       	brge	.+38     	; 0x3388 <prvUnlockQueue+0x40>
    3362:	81 89       	ldd	r24, Z+17	; 0x11
    3364:	81 11       	cpse	r24, r1
    3366:	06 c0       	rjmp	.+12     	; 0x3374 <prvUnlockQueue+0x2c>
    3368:	0f c0       	rjmp	.+30     	; 0x3388 <prvUnlockQueue+0x40>
    336a:	f8 01       	movw	r30, r16
    336c:	81 89       	ldd	r24, Z+17	; 0x11
    336e:	81 11       	cpse	r24, r1
    3370:	05 c0       	rjmp	.+10     	; 0x337c <prvUnlockQueue+0x34>
    3372:	0a c0       	rjmp	.+20     	; 0x3388 <prvUnlockQueue+0x40>
    3374:	78 01       	movw	r14, r16
    3376:	f1 e1       	ldi	r31, 0x11	; 17
    3378:	ef 0e       	add	r14, r31
    337a:	f1 1c       	adc	r15, r1
    337c:	c7 01       	movw	r24, r14
    337e:	80 d5       	rcall	.+2816   	; 0x3e80 <xTaskRemoveFromEventList>
    3380:	81 11       	cpse	r24, r1
    3382:	07 d6       	rcall	.+3086   	; 0x3f92 <vTaskMissedYield>
    3384:	c1 50       	subi	r28, 0x01	; 1
    3386:	89 f7       	brne	.-30     	; 0x336a <prvUnlockQueue+0x22>
    3388:	8f ef       	ldi	r24, 0xFF	; 255
    338a:	f8 01       	movw	r30, r16
    338c:	86 8f       	std	Z+30, r24	; 0x1e
    338e:	0f 90       	pop	r0
    3390:	0f be       	out	0x3f, r0	; 63
    3392:	0f b6       	in	r0, 0x3f	; 63
    3394:	f8 94       	cli
    3396:	0f 92       	push	r0
    3398:	c5 8d       	ldd	r28, Z+29	; 0x1d
    339a:	1c 16       	cp	r1, r28
    339c:	9c f4       	brge	.+38     	; 0x33c4 <prvUnlockQueue+0x7c>
    339e:	80 85       	ldd	r24, Z+8	; 0x08
    33a0:	81 11       	cpse	r24, r1
    33a2:	06 c0       	rjmp	.+12     	; 0x33b0 <prvUnlockQueue+0x68>
    33a4:	0f c0       	rjmp	.+30     	; 0x33c4 <prvUnlockQueue+0x7c>
    33a6:	f8 01       	movw	r30, r16
    33a8:	80 85       	ldd	r24, Z+8	; 0x08
    33aa:	81 11       	cpse	r24, r1
    33ac:	05 c0       	rjmp	.+10     	; 0x33b8 <prvUnlockQueue+0x70>
    33ae:	0a c0       	rjmp	.+20     	; 0x33c4 <prvUnlockQueue+0x7c>
    33b0:	78 01       	movw	r14, r16
    33b2:	f8 e0       	ldi	r31, 0x08	; 8
    33b4:	ef 0e       	add	r14, r31
    33b6:	f1 1c       	adc	r15, r1
    33b8:	c7 01       	movw	r24, r14
    33ba:	62 d5       	rcall	.+2756   	; 0x3e80 <xTaskRemoveFromEventList>
    33bc:	81 11       	cpse	r24, r1
    33be:	e9 d5       	rcall	.+3026   	; 0x3f92 <vTaskMissedYield>
    33c0:	c1 50       	subi	r28, 0x01	; 1
    33c2:	89 f7       	brne	.-30     	; 0x33a6 <prvUnlockQueue+0x5e>
    33c4:	8f ef       	ldi	r24, 0xFF	; 255
    33c6:	f8 01       	movw	r30, r16
    33c8:	85 8f       	std	Z+29, r24	; 0x1d
    33ca:	0f 90       	pop	r0
    33cc:	0f be       	out	0x3f, r0	; 63
    33ce:	cf 91       	pop	r28
    33d0:	1f 91       	pop	r17
    33d2:	0f 91       	pop	r16
    33d4:	ff 90       	pop	r15
    33d6:	ef 90       	pop	r14
    33d8:	08 95       	ret

000033da <xQueueGenericReset>:
    33da:	cf 93       	push	r28
    33dc:	df 93       	push	r29
    33de:	ec 01       	movw	r28, r24
    33e0:	0f b6       	in	r0, 0x3f	; 63
    33e2:	f8 94       	cli
    33e4:	0f 92       	push	r0
    33e6:	48 81       	ld	r20, Y
    33e8:	59 81       	ldd	r21, Y+1	; 0x01
    33ea:	2c 8d       	ldd	r18, Y+28	; 0x1c
    33ec:	30 e0       	ldi	r19, 0x00	; 0
    33ee:	7b 8d       	ldd	r23, Y+27	; 0x1b
    33f0:	72 9f       	mul	r23, r18
    33f2:	c0 01       	movw	r24, r0
    33f4:	73 9f       	mul	r23, r19
    33f6:	90 0d       	add	r25, r0
    33f8:	11 24       	eor	r1, r1
    33fa:	fa 01       	movw	r30, r20
    33fc:	e8 0f       	add	r30, r24
    33fe:	f9 1f       	adc	r31, r25
    3400:	fb 83       	std	Y+3, r31	; 0x03
    3402:	ea 83       	std	Y+2, r30	; 0x02
    3404:	1a 8e       	std	Y+26, r1	; 0x1a
    3406:	5d 83       	std	Y+5, r21	; 0x05
    3408:	4c 83       	std	Y+4, r20	; 0x04
    340a:	82 1b       	sub	r24, r18
    340c:	93 0b       	sbc	r25, r19
    340e:	84 0f       	add	r24, r20
    3410:	95 1f       	adc	r25, r21
    3412:	9f 83       	std	Y+7, r25	; 0x07
    3414:	8e 83       	std	Y+6, r24	; 0x06
    3416:	8f ef       	ldi	r24, 0xFF	; 255
    3418:	8d 8f       	std	Y+29, r24	; 0x1d
    341a:	8e 8f       	std	Y+30, r24	; 0x1e
    341c:	61 11       	cpse	r22, r1
    341e:	0a c0       	rjmp	.+20     	; 0x3434 <xQueueGenericReset+0x5a>
    3420:	88 85       	ldd	r24, Y+8	; 0x08
    3422:	88 23       	and	r24, r24
    3424:	69 f0       	breq	.+26     	; 0x3440 <xQueueGenericReset+0x66>
    3426:	ce 01       	movw	r24, r28
    3428:	08 96       	adiw	r24, 0x08	; 8
    342a:	2a d5       	rcall	.+2644   	; 0x3e80 <xTaskRemoveFromEventList>
    342c:	88 23       	and	r24, r24
    342e:	41 f0       	breq	.+16     	; 0x3440 <xQueueGenericReset+0x66>
    3430:	5f de       	rcall	.-834    	; 0x30f0 <vPortYield>
    3432:	06 c0       	rjmp	.+12     	; 0x3440 <xQueueGenericReset+0x66>
    3434:	ce 01       	movw	r24, r28
    3436:	08 96       	adiw	r24, 0x08	; 8
    3438:	30 dd       	rcall	.-1440   	; 0x2e9a <vListInitialise>
    343a:	ce 01       	movw	r24, r28
    343c:	41 96       	adiw	r24, 0x11	; 17
    343e:	2d dd       	rcall	.-1446   	; 0x2e9a <vListInitialise>
    3440:	0f 90       	pop	r0
    3442:	0f be       	out	0x3f, r0	; 63
    3444:	81 e0       	ldi	r24, 0x01	; 1
    3446:	df 91       	pop	r29
    3448:	cf 91       	pop	r28
    344a:	08 95       	ret

0000344c <xQueueGenericCreate>:
    344c:	0f 93       	push	r16
    344e:	1f 93       	push	r17
    3450:	cf 93       	push	r28
    3452:	df 93       	push	r29
    3454:	08 2f       	mov	r16, r24
    3456:	16 2f       	mov	r17, r22
    3458:	66 23       	and	r22, r22
    345a:	b1 f0       	breq	.+44     	; 0x3488 <xQueueGenericCreate+0x3c>
    345c:	86 9f       	mul	r24, r22
    345e:	c0 01       	movw	r24, r0
    3460:	11 24       	eor	r1, r1
    3462:	4f 96       	adiw	r24, 0x1f	; 31
    3464:	e6 dc       	rcall	.-1588   	; 0x2e32 <pvPortMalloc>
    3466:	ec 01       	movw	r28, r24
    3468:	00 97       	sbiw	r24, 0x00	; 0
    346a:	39 f4       	brne	.+14     	; 0x347a <xQueueGenericCreate+0x2e>
    346c:	13 c0       	rjmp	.+38     	; 0x3494 <xQueueGenericCreate+0x48>
    346e:	0b 8f       	std	Y+27, r16	; 0x1b
    3470:	1c 8f       	std	Y+28, r17	; 0x1c
    3472:	61 e0       	ldi	r22, 0x01	; 1
    3474:	ce 01       	movw	r24, r28
    3476:	b1 df       	rcall	.-158    	; 0x33da <xQueueGenericReset>
    3478:	0d c0       	rjmp	.+26     	; 0x3494 <xQueueGenericCreate+0x48>
    347a:	4f 96       	adiw	r24, 0x1f	; 31
    347c:	99 83       	std	Y+1, r25	; 0x01
    347e:	88 83       	st	Y, r24
    3480:	f6 cf       	rjmp	.-20     	; 0x346e <xQueueGenericCreate+0x22>
    3482:	d9 83       	std	Y+1, r29	; 0x01
    3484:	c8 83       	st	Y, r28
    3486:	f3 cf       	rjmp	.-26     	; 0x346e <xQueueGenericCreate+0x22>
    3488:	8f e1       	ldi	r24, 0x1F	; 31
    348a:	90 e0       	ldi	r25, 0x00	; 0
    348c:	d2 dc       	rcall	.-1628   	; 0x2e32 <pvPortMalloc>
    348e:	ec 01       	movw	r28, r24
    3490:	89 2b       	or	r24, r25
    3492:	b9 f7       	brne	.-18     	; 0x3482 <xQueueGenericCreate+0x36>
    3494:	ce 01       	movw	r24, r28
    3496:	df 91       	pop	r29
    3498:	cf 91       	pop	r28
    349a:	1f 91       	pop	r17
    349c:	0f 91       	pop	r16
    349e:	08 95       	ret

000034a0 <xQueueGenericSend>:
    34a0:	9f 92       	push	r9
    34a2:	af 92       	push	r10
    34a4:	bf 92       	push	r11
    34a6:	cf 92       	push	r12
    34a8:	df 92       	push	r13
    34aa:	ef 92       	push	r14
    34ac:	ff 92       	push	r15
    34ae:	0f 93       	push	r16
    34b0:	1f 93       	push	r17
    34b2:	cf 93       	push	r28
    34b4:	df 93       	push	r29
    34b6:	00 d0       	rcall	.+0      	; 0x34b8 <xQueueGenericSend+0x18>
    34b8:	00 d0       	rcall	.+0      	; 0x34ba <xQueueGenericSend+0x1a>
    34ba:	1f 92       	push	r1
    34bc:	cd b7       	in	r28, 0x3d	; 61
    34be:	de b7       	in	r29, 0x3e	; 62
    34c0:	8c 01       	movw	r16, r24
    34c2:	6b 01       	movw	r12, r22
    34c4:	5d 83       	std	Y+5, r21	; 0x05
    34c6:	4c 83       	std	Y+4, r20	; 0x04
    34c8:	a2 2e       	mov	r10, r18
    34ca:	b1 2c       	mov	r11, r1
    34cc:	99 24       	eor	r9, r9
    34ce:	93 94       	inc	r9
    34d0:	7c 01       	movw	r14, r24
    34d2:	88 e0       	ldi	r24, 0x08	; 8
    34d4:	e8 0e       	add	r14, r24
    34d6:	f1 1c       	adc	r15, r1
    34d8:	0f b6       	in	r0, 0x3f	; 63
    34da:	f8 94       	cli
    34dc:	0f 92       	push	r0
    34de:	f8 01       	movw	r30, r16
    34e0:	92 8d       	ldd	r25, Z+26	; 0x1a
    34e2:	83 8d       	ldd	r24, Z+27	; 0x1b
    34e4:	98 17       	cp	r25, r24
    34e6:	18 f0       	brcs	.+6      	; 0x34ee <xQueueGenericSend+0x4e>
    34e8:	f2 e0       	ldi	r31, 0x02	; 2
    34ea:	af 12       	cpse	r10, r31
    34ec:	15 c0       	rjmp	.+42     	; 0x3518 <xQueueGenericSend+0x78>
    34ee:	4a 2d       	mov	r20, r10
    34f0:	b6 01       	movw	r22, r12
    34f2:	c8 01       	movw	r24, r16
    34f4:	b1 de       	rcall	.-670    	; 0x3258 <prvCopyDataToQueue>
    34f6:	f8 01       	movw	r30, r16
    34f8:	91 89       	ldd	r25, Z+17	; 0x11
    34fa:	99 23       	and	r25, r25
    34fc:	39 f0       	breq	.+14     	; 0x350c <xQueueGenericSend+0x6c>
    34fe:	c8 01       	movw	r24, r16
    3500:	41 96       	adiw	r24, 0x11	; 17
    3502:	be d4       	rcall	.+2428   	; 0x3e80 <xTaskRemoveFromEventList>
    3504:	88 23       	and	r24, r24
    3506:	21 f0       	breq	.+8      	; 0x3510 <xQueueGenericSend+0x70>
    3508:	f3 dd       	rcall	.-1050   	; 0x30f0 <vPortYield>
    350a:	02 c0       	rjmp	.+4      	; 0x3510 <xQueueGenericSend+0x70>
    350c:	81 11       	cpse	r24, r1
    350e:	f0 dd       	rcall	.-1056   	; 0x30f0 <vPortYield>
    3510:	0f 90       	pop	r0
    3512:	0f be       	out	0x3f, r0	; 63
    3514:	81 e0       	ldi	r24, 0x01	; 1
    3516:	45 c0       	rjmp	.+138    	; 0x35a2 <xQueueGenericSend+0x102>
    3518:	8c 81       	ldd	r24, Y+4	; 0x04
    351a:	9d 81       	ldd	r25, Y+5	; 0x05
    351c:	89 2b       	or	r24, r25
    351e:	21 f4       	brne	.+8      	; 0x3528 <xQueueGenericSend+0x88>
    3520:	0f 90       	pop	r0
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	80 e0       	ldi	r24, 0x00	; 0
    3526:	3d c0       	rjmp	.+122    	; 0x35a2 <xQueueGenericSend+0x102>
    3528:	b1 10       	cpse	r11, r1
    352a:	04 c0       	rjmp	.+8      	; 0x3534 <xQueueGenericSend+0x94>
    352c:	ce 01       	movw	r24, r28
    352e:	01 96       	adiw	r24, 0x01	; 1
    3530:	ed d4       	rcall	.+2522   	; 0x3f0c <vTaskSetTimeOutState>
    3532:	b9 2c       	mov	r11, r9
    3534:	0f 90       	pop	r0
    3536:	0f be       	out	0x3f, r0	; 63
    3538:	b0 d2       	rcall	.+1376   	; 0x3a9a <vTaskSuspendAll>
    353a:	0f b6       	in	r0, 0x3f	; 63
    353c:	f8 94       	cli
    353e:	0f 92       	push	r0
    3540:	f8 01       	movw	r30, r16
    3542:	85 8d       	ldd	r24, Z+29	; 0x1d
    3544:	8f 3f       	cpi	r24, 0xFF	; 255
    3546:	09 f4       	brne	.+2      	; 0x354a <xQueueGenericSend+0xaa>
    3548:	15 8e       	std	Z+29, r1	; 0x1d
    354a:	f8 01       	movw	r30, r16
    354c:	86 8d       	ldd	r24, Z+30	; 0x1e
    354e:	8f 3f       	cpi	r24, 0xFF	; 255
    3550:	09 f4       	brne	.+2      	; 0x3554 <xQueueGenericSend+0xb4>
    3552:	16 8e       	std	Z+30, r1	; 0x1e
    3554:	0f 90       	pop	r0
    3556:	0f be       	out	0x3f, r0	; 63
    3558:	be 01       	movw	r22, r28
    355a:	6c 5f       	subi	r22, 0xFC	; 252
    355c:	7f 4f       	sbci	r23, 0xFF	; 255
    355e:	ce 01       	movw	r24, r28
    3560:	01 96       	adiw	r24, 0x01	; 1
    3562:	df d4       	rcall	.+2494   	; 0x3f22 <xTaskCheckForTimeOut>
    3564:	81 11       	cpse	r24, r1
    3566:	19 c0       	rjmp	.+50     	; 0x359a <xQueueGenericSend+0xfa>
    3568:	0f b6       	in	r0, 0x3f	; 63
    356a:	f8 94       	cli
    356c:	0f 92       	push	r0
    356e:	f8 01       	movw	r30, r16
    3570:	92 8d       	ldd	r25, Z+26	; 0x1a
    3572:	0f 90       	pop	r0
    3574:	0f be       	out	0x3f, r0	; 63
    3576:	83 8d       	ldd	r24, Z+27	; 0x1b
    3578:	98 13       	cpse	r25, r24
    357a:	0b c0       	rjmp	.+22     	; 0x3592 <xQueueGenericSend+0xf2>
    357c:	6c 81       	ldd	r22, Y+4	; 0x04
    357e:	7d 81       	ldd	r23, Y+5	; 0x05
    3580:	c7 01       	movw	r24, r14
    3582:	6e d4       	rcall	.+2268   	; 0x3e60 <vTaskPlaceOnEventList>
    3584:	c8 01       	movw	r24, r16
    3586:	e0 de       	rcall	.-576    	; 0x3348 <prvUnlockQueue>
    3588:	45 d3       	rcall	.+1674   	; 0x3c14 <xTaskResumeAll>
    358a:	81 11       	cpse	r24, r1
    358c:	a5 cf       	rjmp	.-182    	; 0x34d8 <xQueueGenericSend+0x38>
    358e:	b0 dd       	rcall	.-1184   	; 0x30f0 <vPortYield>
    3590:	a3 cf       	rjmp	.-186    	; 0x34d8 <xQueueGenericSend+0x38>
    3592:	c8 01       	movw	r24, r16
    3594:	d9 de       	rcall	.-590    	; 0x3348 <prvUnlockQueue>
    3596:	3e d3       	rcall	.+1660   	; 0x3c14 <xTaskResumeAll>
    3598:	9f cf       	rjmp	.-194    	; 0x34d8 <xQueueGenericSend+0x38>
    359a:	c8 01       	movw	r24, r16
    359c:	d5 de       	rcall	.-598    	; 0x3348 <prvUnlockQueue>
    359e:	3a d3       	rcall	.+1652   	; 0x3c14 <xTaskResumeAll>
    35a0:	80 e0       	ldi	r24, 0x00	; 0
    35a2:	0f 90       	pop	r0
    35a4:	0f 90       	pop	r0
    35a6:	0f 90       	pop	r0
    35a8:	0f 90       	pop	r0
    35aa:	0f 90       	pop	r0
    35ac:	df 91       	pop	r29
    35ae:	cf 91       	pop	r28
    35b0:	1f 91       	pop	r17
    35b2:	0f 91       	pop	r16
    35b4:	ff 90       	pop	r15
    35b6:	ef 90       	pop	r14
    35b8:	df 90       	pop	r13
    35ba:	cf 90       	pop	r12
    35bc:	bf 90       	pop	r11
    35be:	af 90       	pop	r10
    35c0:	9f 90       	pop	r9
    35c2:	08 95       	ret

000035c4 <xQueueCreateMutex>:
    35c4:	cf 93       	push	r28
    35c6:	df 93       	push	r29
    35c8:	48 2f       	mov	r20, r24
    35ca:	60 e0       	ldi	r22, 0x00	; 0
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	3e df       	rcall	.-388    	; 0x344c <xQueueGenericCreate>
    35d0:	ec 01       	movw	r28, r24
    35d2:	00 97       	sbiw	r24, 0x00	; 0
    35d4:	59 f0       	breq	.+22     	; 0x35ec <xQueueCreateMutex+0x28>
    35d6:	1b 82       	std	Y+3, r1	; 0x03
    35d8:	1a 82       	std	Y+2, r1	; 0x02
    35da:	19 82       	std	Y+1, r1	; 0x01
    35dc:	18 82       	st	Y, r1
    35de:	1e 82       	std	Y+6, r1	; 0x06
    35e0:	20 e0       	ldi	r18, 0x00	; 0
    35e2:	40 e0       	ldi	r20, 0x00	; 0
    35e4:	50 e0       	ldi	r21, 0x00	; 0
    35e6:	60 e0       	ldi	r22, 0x00	; 0
    35e8:	70 e0       	ldi	r23, 0x00	; 0
    35ea:	5a df       	rcall	.-332    	; 0x34a0 <xQueueGenericSend>
    35ec:	ce 01       	movw	r24, r28
    35ee:	df 91       	pop	r29
    35f0:	cf 91       	pop	r28
    35f2:	08 95       	ret

000035f4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    35f4:	8f 92       	push	r8
    35f6:	9f 92       	push	r9
    35f8:	af 92       	push	r10
    35fa:	bf 92       	push	r11
    35fc:	cf 92       	push	r12
    35fe:	df 92       	push	r13
    3600:	ef 92       	push	r14
    3602:	ff 92       	push	r15
    3604:	0f 93       	push	r16
    3606:	1f 93       	push	r17
    3608:	cf 93       	push	r28
    360a:	df 93       	push	r29
    360c:	00 d0       	rcall	.+0      	; 0x360e <xQueueGenericReceive+0x1a>
    360e:	00 d0       	rcall	.+0      	; 0x3610 <xQueueGenericReceive+0x1c>
    3610:	1f 92       	push	r1
    3612:	cd b7       	in	r28, 0x3d	; 61
    3614:	de b7       	in	r29, 0x3e	; 62
    3616:	8c 01       	movw	r16, r24
    3618:	5b 01       	movw	r10, r22
    361a:	5d 83       	std	Y+5, r21	; 0x05
    361c:	4c 83       	std	Y+4, r20	; 0x04
    361e:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    3620:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3622:	99 24       	eor	r9, r9
    3624:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3626:	6c 01       	movw	r12, r24
    3628:	81 e1       	ldi	r24, 0x11	; 17
    362a:	c8 0e       	add	r12, r24
    362c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    362e:	0f b6       	in	r0, 0x3f	; 63
    3630:	f8 94       	cli
    3632:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3634:	f8 01       	movw	r30, r16
    3636:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3638:	ff 20       	and	r15, r15
    363a:	61 f1       	breq	.+88     	; 0x3694 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    363c:	c6 80       	ldd	r12, Z+6	; 0x06
    363e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3640:	b5 01       	movw	r22, r10
    3642:	c8 01       	movw	r24, r16
    3644:	67 de       	rcall	.-818    	; 0x3314 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3646:	81 10       	cpse	r8, r1
    3648:	16 c0       	rjmp	.+44     	; 0x3676 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    364a:	fa 94       	dec	r15
    364c:	f8 01       	movw	r30, r16
    364e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3650:	80 81       	ld	r24, Z
    3652:	91 81       	ldd	r25, Z+1	; 0x01
    3654:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3656:	21 f4       	brne	.+8      	; 0x3660 <xQueueGenericReceive+0x6c>
    3658:	42 d5       	rcall	.+2692   	; 0x40de <pvTaskIncrementMutexHeldCount>
    365a:	f8 01       	movw	r30, r16
    365c:	93 83       	std	Z+3, r25	; 0x03
    365e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3660:	f8 01       	movw	r30, r16
    3662:	80 85       	ldd	r24, Z+8	; 0x08
    3664:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3666:	91 f0       	breq	.+36     	; 0x368c <xQueueGenericReceive+0x98>
    3668:	c8 01       	movw	r24, r16
    366a:	08 96       	adiw	r24, 0x08	; 8
    366c:	09 d4       	rcall	.+2066   	; 0x3e80 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    366e:	88 23       	and	r24, r24
    3670:	69 f0       	breq	.+26     	; 0x368c <xQueueGenericReceive+0x98>
    3672:	3e dd       	rcall	.-1412   	; 0x30f0 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3674:	0b c0       	rjmp	.+22     	; 0x368c <xQueueGenericReceive+0x98>
    3676:	f8 01       	movw	r30, r16
    3678:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    367a:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    367c:	81 89       	ldd	r24, Z+17	; 0x11
    367e:	88 23       	and	r24, r24
    3680:	29 f0       	breq	.+10     	; 0x368c <xQueueGenericReceive+0x98>
    3682:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3684:	41 96       	adiw	r24, 0x11	; 17
    3686:	fc d3       	rcall	.+2040   	; 0x3e80 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3688:	81 11       	cpse	r24, r1
    368a:	32 dd       	rcall	.-1436   	; 0x30f0 <vPortYield>
				return pdPASS;
    368c:	0f 90       	pop	r0
    368e:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3690:	81 e0       	ldi	r24, 0x01	; 1
    3692:	58 c0       	rjmp	.+176    	; 0x3744 <xQueueGenericReceive+0x150>
    3694:	8c 81       	ldd	r24, Y+4	; 0x04
    3696:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3698:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    369a:	21 f4       	brne	.+8      	; 0x36a4 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    369c:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    369e:	0f be       	out	0x3f, r0	; 63
    36a0:	80 e0       	ldi	r24, 0x00	; 0
    36a2:	50 c0       	rjmp	.+160    	; 0x3744 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    36a4:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    36a6:	04 c0       	rjmp	.+8      	; 0x36b0 <xQueueGenericReceive+0xbc>
    36a8:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    36aa:	01 96       	adiw	r24, 0x01	; 1
    36ac:	2f d4       	rcall	.+2142   	; 0x3f0c <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    36ae:	e9 2c       	mov	r14, r9
    36b0:	0f 90       	pop	r0
    36b2:	0f be       	out	0x3f, r0	; 63
    36b4:	f2 d1       	rcall	.+996    	; 0x3a9a <vTaskSuspendAll>
    36b6:	0f b6       	in	r0, 0x3f	; 63
    36b8:	f8 94       	cli
    36ba:	0f 92       	push	r0
    36bc:	f8 01       	movw	r30, r16
    36be:	85 8d       	ldd	r24, Z+29	; 0x1d
    36c0:	8f 3f       	cpi	r24, 0xFF	; 255
    36c2:	09 f4       	brne	.+2      	; 0x36c6 <xQueueGenericReceive+0xd2>
    36c4:	15 8e       	std	Z+29, r1	; 0x1d
    36c6:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    36c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    36ca:	8f 3f       	cpi	r24, 0xFF	; 255
    36cc:	09 f4       	brne	.+2      	; 0x36d0 <xQueueGenericReceive+0xdc>
    36ce:	16 8e       	std	Z+30, r1	; 0x1e
    36d0:	0f 90       	pop	r0
    36d2:	0f be       	out	0x3f, r0	; 63
    36d4:	be 01       	movw	r22, r28
    36d6:	6c 5f       	subi	r22, 0xFC	; 252
    36d8:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    36da:	ce 01       	movw	r24, r28
    36dc:	01 96       	adiw	r24, 0x01	; 1
    36de:	21 d4       	rcall	.+2114   	; 0x3f22 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    36e0:	81 11       	cpse	r24, r1
    36e2:	24 c0       	rjmp	.+72     	; 0x372c <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    36e4:	0f b6       	in	r0, 0x3f	; 63
    36e6:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    36e8:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    36ea:	f8 01       	movw	r30, r16
    36ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    36ee:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    36f0:	0f be       	out	0x3f, r0	; 63
    36f2:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    36f4:	17 c0       	rjmp	.+46     	; 0x3724 <xQueueGenericReceive+0x130>
    36f6:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    36f8:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    36fa:	89 2b       	or	r24, r25
    36fc:	41 f4       	brne	.+16     	; 0x370e <xQueueGenericReceive+0x11a>
    36fe:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    3700:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    3702:	0f 92       	push	r0
    3704:	82 81       	ldd	r24, Z+2	; 0x02
    3706:	93 81       	ldd	r25, Z+3	; 0x03
    3708:	48 d4       	rcall	.+2192   	; 0x3f9a <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    370a:	0f 90       	pop	r0
    370c:	0f be       	out	0x3f, r0	; 63
    370e:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3710:	7d 81       	ldd	r23, Y+5	; 0x05
    3712:	c6 01       	movw	r24, r12
    3714:	a5 d3       	rcall	.+1866   	; 0x3e60 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    3716:	c8 01       	movw	r24, r16
    3718:	17 de       	rcall	.-978    	; 0x3348 <prvUnlockQueue>
    371a:	7c d2       	rcall	.+1272   	; 0x3c14 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    371c:	81 11       	cpse	r24, r1
    371e:	87 cf       	rjmp	.-242    	; 0x362e <xQueueGenericReceive+0x3a>
    3720:	e7 dc       	rcall	.-1586   	; 0x30f0 <vPortYield>
			( void ) xTaskResumeAll();
    3722:	85 cf       	rjmp	.-246    	; 0x362e <xQueueGenericReceive+0x3a>
    3724:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3726:	10 de       	rcall	.-992    	; 0x3348 <prvUnlockQueue>
    3728:	75 d2       	rcall	.+1258   	; 0x3c14 <xTaskResumeAll>
    372a:	81 cf       	rjmp	.-254    	; 0x362e <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    372c:	c8 01       	movw	r24, r16
    372e:	0c de       	rcall	.-1000   	; 0x3348 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3730:	71 d2       	rcall	.+1250   	; 0x3c14 <xTaskResumeAll>
    3732:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3734:	f8 94       	cli
    3736:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    3738:	f8 01       	movw	r30, r16
    373a:	82 8d       	ldd	r24, Z+26	; 0x1a
    373c:	0f 90       	pop	r0
    373e:	0f be       	out	0x3f, r0	; 63
    3740:	81 11       	cpse	r24, r1
    3742:	75 cf       	rjmp	.-278    	; 0x362e <xQueueGenericReceive+0x3a>
    3744:	0f 90       	pop	r0
    3746:	0f 90       	pop	r0
    3748:	0f 90       	pop	r0
    374a:	0f 90       	pop	r0
    374c:	0f 90       	pop	r0
    374e:	df 91       	pop	r29
    3750:	cf 91       	pop	r28
    3752:	1f 91       	pop	r17
    3754:	0f 91       	pop	r16
    3756:	ff 90       	pop	r15
    3758:	ef 90       	pop	r14
    375a:	df 90       	pop	r13
    375c:	cf 90       	pop	r12
    375e:	bf 90       	pop	r11
    3760:	af 90       	pop	r10
    3762:	9f 90       	pop	r9
    3764:	8f 90       	pop	r8
    3766:	08 95       	ret

00003768 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    3768:	e0 91 6d 0f 	lds	r30, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    376c:	f0 91 6e 0f 	lds	r31, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    3770:	80 81       	ld	r24, Z
    3772:	81 11       	cpse	r24, r1
    3774:	07 c0       	rjmp	.+14     	; 0x3784 <prvResetNextTaskUnblockTime+0x1c>
    3776:	8f ef       	ldi	r24, 0xFF	; 255
    3778:	9f ef       	ldi	r25, 0xFF	; 255
    377a:	90 93 45 0f 	sts	0x0F45, r25	; 0x800f45 <xNextTaskUnblockTime+0x1>
    377e:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <xNextTaskUnblockTime>
    3782:	08 95       	ret
    3784:	e0 91 6d 0f 	lds	r30, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    3788:	f0 91 6e 0f 	lds	r31, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    378c:	05 80       	ldd	r0, Z+5	; 0x05
    378e:	f6 81       	ldd	r31, Z+6	; 0x06
    3790:	e0 2d       	mov	r30, r0
    3792:	06 80       	ldd	r0, Z+6	; 0x06
    3794:	f7 81       	ldd	r31, Z+7	; 0x07
    3796:	e0 2d       	mov	r30, r0
    3798:	82 81       	ldd	r24, Z+2	; 0x02
    379a:	93 81       	ldd	r25, Z+3	; 0x03
    379c:	90 93 45 0f 	sts	0x0F45, r25	; 0x800f45 <xNextTaskUnblockTime+0x1>
    37a0:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <xNextTaskUnblockTime>
    37a4:	08 95       	ret

000037a6 <prvAddCurrentTaskToDelayedList>:
    37a6:	ff 92       	push	r15
    37a8:	0f 93       	push	r16
    37aa:	1f 93       	push	r17
    37ac:	cf 93       	push	r28
    37ae:	df 93       	push	r29
    37b0:	ec 01       	movw	r28, r24
    37b2:	f6 2e       	mov	r15, r22
    37b4:	00 91 4c 0f 	lds	r16, 0x0F4C	; 0x800f4c <xTickCount>
    37b8:	10 91 4d 0f 	lds	r17, 0x0F4D	; 0x800f4d <xTickCount+0x1>
    37bc:	80 91 a5 0f 	lds	r24, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    37c0:	90 91 a6 0f 	lds	r25, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    37c4:	02 96       	adiw	r24, 0x02	; 2
    37c6:	cd db       	rcall	.-2150   	; 0x2f62 <uxListRemove>
    37c8:	cf 3f       	cpi	r28, 0xFF	; 255
    37ca:	8f ef       	ldi	r24, 0xFF	; 255
    37cc:	d8 07       	cpc	r29, r24
    37ce:	61 f4       	brne	.+24     	; 0x37e8 <prvAddCurrentTaskToDelayedList+0x42>
    37d0:	ff 20       	and	r15, r15
    37d2:	51 f0       	breq	.+20     	; 0x37e8 <prvAddCurrentTaskToDelayedList+0x42>
    37d4:	60 91 a5 0f 	lds	r22, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    37d8:	70 91 a6 0f 	lds	r23, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    37dc:	6e 5f       	subi	r22, 0xFE	; 254
    37de:	7f 4f       	sbci	r23, 0xFF	; 255
    37e0:	8f e4       	ldi	r24, 0x4F	; 79
    37e2:	9f e0       	ldi	r25, 0x0F	; 15
    37e4:	6c db       	rcall	.-2344   	; 0x2ebe <vListInsertEnd>
    37e6:	2d c0       	rjmp	.+90     	; 0x3842 <prvAddCurrentTaskToDelayedList+0x9c>
    37e8:	c0 0f       	add	r28, r16
    37ea:	d1 1f       	adc	r29, r17
    37ec:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    37f0:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    37f4:	d3 83       	std	Z+3, r29	; 0x03
    37f6:	c2 83       	std	Z+2, r28	; 0x02
    37f8:	c0 17       	cp	r28, r16
    37fa:	d1 07       	cpc	r29, r17
    37fc:	60 f4       	brcc	.+24     	; 0x3816 <prvAddCurrentTaskToDelayedList+0x70>
    37fe:	60 91 a5 0f 	lds	r22, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3802:	70 91 a6 0f 	lds	r23, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3806:	80 91 6b 0f 	lds	r24, 0x0F6B	; 0x800f6b <pxOverflowDelayedTaskList>
    380a:	90 91 6c 0f 	lds	r25, 0x0F6C	; 0x800f6c <pxOverflowDelayedTaskList+0x1>
    380e:	6e 5f       	subi	r22, 0xFE	; 254
    3810:	7f 4f       	sbci	r23, 0xFF	; 255
    3812:	76 db       	rcall	.-2324   	; 0x2f00 <vListInsert>
    3814:	16 c0       	rjmp	.+44     	; 0x3842 <prvAddCurrentTaskToDelayedList+0x9c>
    3816:	60 91 a5 0f 	lds	r22, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    381a:	70 91 a6 0f 	lds	r23, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    381e:	80 91 6d 0f 	lds	r24, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    3822:	90 91 6e 0f 	lds	r25, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    3826:	6e 5f       	subi	r22, 0xFE	; 254
    3828:	7f 4f       	sbci	r23, 0xFF	; 255
    382a:	6a db       	rcall	.-2348   	; 0x2f00 <vListInsert>
    382c:	80 91 44 0f 	lds	r24, 0x0F44	; 0x800f44 <xNextTaskUnblockTime>
    3830:	90 91 45 0f 	lds	r25, 0x0F45	; 0x800f45 <xNextTaskUnblockTime+0x1>
    3834:	c8 17       	cp	r28, r24
    3836:	d9 07       	cpc	r29, r25
    3838:	20 f4       	brcc	.+8      	; 0x3842 <prvAddCurrentTaskToDelayedList+0x9c>
    383a:	d0 93 45 0f 	sts	0x0F45, r29	; 0x800f45 <xNextTaskUnblockTime+0x1>
    383e:	c0 93 44 0f 	sts	0x0F44, r28	; 0x800f44 <xNextTaskUnblockTime>
    3842:	df 91       	pop	r29
    3844:	cf 91       	pop	r28
    3846:	1f 91       	pop	r17
    3848:	0f 91       	pop	r16
    384a:	ff 90       	pop	r15
    384c:	08 95       	ret

0000384e <xTaskCreate>:
    384e:	4f 92       	push	r4
    3850:	5f 92       	push	r5
    3852:	6f 92       	push	r6
    3854:	7f 92       	push	r7
    3856:	8f 92       	push	r8
    3858:	9f 92       	push	r9
    385a:	af 92       	push	r10
    385c:	bf 92       	push	r11
    385e:	cf 92       	push	r12
    3860:	df 92       	push	r13
    3862:	ef 92       	push	r14
    3864:	ff 92       	push	r15
    3866:	0f 93       	push	r16
    3868:	cf 93       	push	r28
    386a:	df 93       	push	r29
    386c:	4c 01       	movw	r8, r24
    386e:	6b 01       	movw	r12, r22
    3870:	5a 01       	movw	r10, r20
    3872:	29 01       	movw	r4, r18
    3874:	ca 01       	movw	r24, r20
    3876:	dd da       	rcall	.-2630   	; 0x2e32 <pvPortMalloc>
    3878:	3c 01       	movw	r6, r24
    387a:	89 2b       	or	r24, r25
    387c:	09 f4       	brne	.+2      	; 0x3880 <xTaskCreate+0x32>
    387e:	d4 c0       	rjmp	.+424    	; 0x3a28 <xTaskCreate+0x1da>
    3880:	88 e2       	ldi	r24, 0x28	; 40
    3882:	90 e0       	ldi	r25, 0x00	; 0
    3884:	d6 da       	rcall	.-2644   	; 0x2e32 <pvPortMalloc>
    3886:	ec 01       	movw	r28, r24
    3888:	89 2b       	or	r24, r25
    388a:	71 f0       	breq	.+28     	; 0x38a8 <xTaskCreate+0x5a>
    388c:	78 8e       	std	Y+24, r7	; 0x18
    388e:	6f 8a       	std	Y+23, r6	; 0x17
    3890:	81 e0       	ldi	r24, 0x01	; 1
    3892:	a8 1a       	sub	r10, r24
    3894:	b1 08       	sbc	r11, r1
    3896:	6a 0c       	add	r6, r10
    3898:	7b 1c       	adc	r7, r11
    389a:	d6 01       	movw	r26, r12
    389c:	8c 91       	ld	r24, X
    389e:	89 8f       	std	Y+25, r24	; 0x19
    38a0:	8c 91       	ld	r24, X
    38a2:	81 11       	cpse	r24, r1
    38a4:	04 c0       	rjmp	.+8      	; 0x38ae <xTaskCreate+0x60>
    38a6:	17 c0       	rjmp	.+46     	; 0x38d6 <xTaskCreate+0x88>
    38a8:	c3 01       	movw	r24, r6
    38aa:	f6 da       	rcall	.-2580   	; 0x2e98 <vPortFree>
    38ac:	bd c0       	rjmp	.+378    	; 0x3a28 <xTaskCreate+0x1da>
    38ae:	ae 01       	movw	r20, r28
    38b0:	46 5e       	subi	r20, 0xE6	; 230
    38b2:	5f 4f       	sbci	r21, 0xFF	; 255
    38b4:	f6 01       	movw	r30, r12
    38b6:	31 96       	adiw	r30, 0x01	; 1
    38b8:	b8 e0       	ldi	r27, 0x08	; 8
    38ba:	cb 0e       	add	r12, r27
    38bc:	d1 1c       	adc	r13, r1
    38be:	cf 01       	movw	r24, r30
    38c0:	21 91       	ld	r18, Z+
    38c2:	da 01       	movw	r26, r20
    38c4:	2d 93       	st	X+, r18
    38c6:	ad 01       	movw	r20, r26
    38c8:	dc 01       	movw	r26, r24
    38ca:	8c 91       	ld	r24, X
    38cc:	88 23       	and	r24, r24
    38ce:	19 f0       	breq	.+6      	; 0x38d6 <xTaskCreate+0x88>
    38d0:	ec 15       	cp	r30, r12
    38d2:	fd 05       	cpc	r31, r13
    38d4:	a1 f7       	brne	.-24     	; 0x38be <xTaskCreate+0x70>
    38d6:	18 a2       	std	Y+32, r1	; 0x20
    38d8:	04 30       	cpi	r16, 0x04	; 4
    38da:	08 f0       	brcs	.+2      	; 0x38de <xTaskCreate+0x90>
    38dc:	03 e0       	ldi	r16, 0x03	; 3
    38de:	0e 8b       	std	Y+22, r16	; 0x16
    38e0:	09 a3       	std	Y+33, r16	; 0x21
    38e2:	1a a2       	std	Y+34, r1	; 0x22
    38e4:	6e 01       	movw	r12, r28
    38e6:	b2 e0       	ldi	r27, 0x02	; 2
    38e8:	cb 0e       	add	r12, r27
    38ea:	d1 1c       	adc	r13, r1
    38ec:	c6 01       	movw	r24, r12
    38ee:	e3 da       	rcall	.-2618   	; 0x2eb6 <vListInitialiseItem>
    38f0:	ce 01       	movw	r24, r28
    38f2:	0c 96       	adiw	r24, 0x0c	; 12
    38f4:	e0 da       	rcall	.-2624   	; 0x2eb6 <vListInitialiseItem>
    38f6:	d9 87       	std	Y+9, r29	; 0x09
    38f8:	c8 87       	std	Y+8, r28	; 0x08
    38fa:	84 e0       	ldi	r24, 0x04	; 4
    38fc:	90 e0       	ldi	r25, 0x00	; 0
    38fe:	80 1b       	sub	r24, r16
    3900:	91 09       	sbc	r25, r1
    3902:	9d 87       	std	Y+13, r25	; 0x0d
    3904:	8c 87       	std	Y+12, r24	; 0x0c
    3906:	db 8b       	std	Y+19, r29	; 0x13
    3908:	ca 8b       	std	Y+18, r28	; 0x12
    390a:	1b a2       	std	Y+35, r1	; 0x23
    390c:	1c a2       	std	Y+36, r1	; 0x24
    390e:	1d a2       	std	Y+37, r1	; 0x25
    3910:	1e a2       	std	Y+38, r1	; 0x26
    3912:	1f a2       	std	Y+39, r1	; 0x27
    3914:	a2 01       	movw	r20, r4
    3916:	b4 01       	movw	r22, r8
    3918:	c3 01       	movw	r24, r6
    391a:	49 db       	rcall	.-2414   	; 0x2fae <pxPortInitialiseStack>
    391c:	99 83       	std	Y+1, r25	; 0x01
    391e:	88 83       	st	Y, r24
    3920:	e1 14       	cp	r14, r1
    3922:	f1 04       	cpc	r15, r1
    3924:	19 f0       	breq	.+6      	; 0x392c <xTaskCreate+0xde>
    3926:	f7 01       	movw	r30, r14
    3928:	d1 83       	std	Z+1, r29	; 0x01
    392a:	c0 83       	st	Z, r28
    392c:	0f b6       	in	r0, 0x3f	; 63
    392e:	f8 94       	cli
    3930:	0f 92       	push	r0
    3932:	80 91 4e 0f 	lds	r24, 0x0F4E	; 0x800f4e <uxCurrentNumberOfTasks>
    3936:	8f 5f       	subi	r24, 0xFF	; 255
    3938:	80 93 4e 0f 	sts	0x0F4E, r24	; 0x800f4e <uxCurrentNumberOfTasks>
    393c:	80 91 a5 0f 	lds	r24, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3940:	90 91 a6 0f 	lds	r25, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3944:	89 2b       	or	r24, r25
    3946:	89 f5       	brne	.+98     	; 0x39aa <xTaskCreate+0x15c>
    3948:	d0 93 a6 0f 	sts	0x0FA6, r29	; 0x800fa6 <pxCurrentTCB+0x1>
    394c:	c0 93 a5 0f 	sts	0x0FA5, r28	; 0x800fa5 <pxCurrentTCB>
    3950:	80 91 4e 0f 	lds	r24, 0x0F4E	; 0x800f4e <uxCurrentNumberOfTasks>
    3954:	81 30       	cpi	r24, 0x01	; 1
    3956:	09 f0       	breq	.+2      	; 0x395a <xTaskCreate+0x10c>
    3958:	38 c0       	rjmp	.+112    	; 0x39ca <xTaskCreate+0x17c>
    395a:	81 e8       	ldi	r24, 0x81	; 129
    395c:	9f e0       	ldi	r25, 0x0F	; 15
    395e:	9d da       	rcall	.-2758   	; 0x2e9a <vListInitialise>
    3960:	8a e8       	ldi	r24, 0x8A	; 138
    3962:	9f e0       	ldi	r25, 0x0F	; 15
    3964:	9a da       	rcall	.-2764   	; 0x2e9a <vListInitialise>
    3966:	83 e9       	ldi	r24, 0x93	; 147
    3968:	9f e0       	ldi	r25, 0x0F	; 15
    396a:	97 da       	rcall	.-2770   	; 0x2e9a <vListInitialise>
    396c:	8c e9       	ldi	r24, 0x9C	; 156
    396e:	9f e0       	ldi	r25, 0x0F	; 15
    3970:	94 da       	rcall	.-2776   	; 0x2e9a <vListInitialise>
    3972:	88 e7       	ldi	r24, 0x78	; 120
    3974:	9f e0       	ldi	r25, 0x0F	; 15
    3976:	91 da       	rcall	.-2782   	; 0x2e9a <vListInitialise>
    3978:	8f e6       	ldi	r24, 0x6F	; 111
    397a:	9f e0       	ldi	r25, 0x0F	; 15
    397c:	8e da       	rcall	.-2788   	; 0x2e9a <vListInitialise>
    397e:	82 e6       	ldi	r24, 0x62	; 98
    3980:	9f e0       	ldi	r25, 0x0F	; 15
    3982:	8b da       	rcall	.-2794   	; 0x2e9a <vListInitialise>
    3984:	89 e5       	ldi	r24, 0x59	; 89
    3986:	9f e0       	ldi	r25, 0x0F	; 15
    3988:	88 da       	rcall	.-2800   	; 0x2e9a <vListInitialise>
    398a:	8f e4       	ldi	r24, 0x4F	; 79
    398c:	9f e0       	ldi	r25, 0x0F	; 15
    398e:	85 da       	rcall	.-2806   	; 0x2e9a <vListInitialise>
    3990:	88 e7       	ldi	r24, 0x78	; 120
    3992:	9f e0       	ldi	r25, 0x0F	; 15
    3994:	90 93 6e 0f 	sts	0x0F6E, r25	; 0x800f6e <pxDelayedTaskList+0x1>
    3998:	80 93 6d 0f 	sts	0x0F6D, r24	; 0x800f6d <pxDelayedTaskList>
    399c:	8f e6       	ldi	r24, 0x6F	; 111
    399e:	9f e0       	ldi	r25, 0x0F	; 15
    39a0:	90 93 6c 0f 	sts	0x0F6C, r25	; 0x800f6c <pxOverflowDelayedTaskList+0x1>
    39a4:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <pxOverflowDelayedTaskList>
    39a8:	10 c0       	rjmp	.+32     	; 0x39ca <xTaskCreate+0x17c>
    39aa:	80 91 4a 0f 	lds	r24, 0x0F4A	; 0x800f4a <xSchedulerRunning>
    39ae:	81 11       	cpse	r24, r1
    39b0:	0c c0       	rjmp	.+24     	; 0x39ca <xTaskCreate+0x17c>
    39b2:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    39b6:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    39ba:	96 89       	ldd	r25, Z+22	; 0x16
    39bc:	8e 89       	ldd	r24, Y+22	; 0x16
    39be:	89 17       	cp	r24, r25
    39c0:	20 f0       	brcs	.+8      	; 0x39ca <xTaskCreate+0x17c>
    39c2:	d0 93 a6 0f 	sts	0x0FA6, r29	; 0x800fa6 <pxCurrentTCB+0x1>
    39c6:	c0 93 a5 0f 	sts	0x0FA5, r28	; 0x800fa5 <pxCurrentTCB>
    39ca:	80 91 46 0f 	lds	r24, 0x0F46	; 0x800f46 <uxTaskNumber>
    39ce:	8f 5f       	subi	r24, 0xFF	; 255
    39d0:	80 93 46 0f 	sts	0x0F46, r24	; 0x800f46 <uxTaskNumber>
    39d4:	8e 89       	ldd	r24, Y+22	; 0x16
    39d6:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    39da:	98 17       	cp	r25, r24
    39dc:	10 f4       	brcc	.+4      	; 0x39e2 <xTaskCreate+0x194>
    39de:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	9c 01       	movw	r18, r24
    39e6:	22 0f       	add	r18, r18
    39e8:	33 1f       	adc	r19, r19
    39ea:	22 0f       	add	r18, r18
    39ec:	33 1f       	adc	r19, r19
    39ee:	22 0f       	add	r18, r18
    39f0:	33 1f       	adc	r19, r19
    39f2:	82 0f       	add	r24, r18
    39f4:	93 1f       	adc	r25, r19
    39f6:	b6 01       	movw	r22, r12
    39f8:	8f 57       	subi	r24, 0x7F	; 127
    39fa:	90 4f       	sbci	r25, 0xF0	; 240
    39fc:	60 da       	rcall	.-2880   	; 0x2ebe <vListInsertEnd>
    39fe:	0f 90       	pop	r0
    3a00:	0f be       	out	0x3f, r0	; 63
    3a02:	80 91 4a 0f 	lds	r24, 0x0F4A	; 0x800f4a <xSchedulerRunning>
    3a06:	88 23       	and	r24, r24
    3a08:	59 f0       	breq	.+22     	; 0x3a20 <xTaskCreate+0x1d2>
    3a0a:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3a0e:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3a12:	96 89       	ldd	r25, Z+22	; 0x16
    3a14:	8e 89       	ldd	r24, Y+22	; 0x16
    3a16:	98 17       	cp	r25, r24
    3a18:	28 f4       	brcc	.+10     	; 0x3a24 <xTaskCreate+0x1d6>
    3a1a:	6a db       	rcall	.-2348   	; 0x30f0 <vPortYield>
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	05 c0       	rjmp	.+10     	; 0x3a2a <xTaskCreate+0x1dc>
    3a20:	81 e0       	ldi	r24, 0x01	; 1
    3a22:	03 c0       	rjmp	.+6      	; 0x3a2a <xTaskCreate+0x1dc>
    3a24:	81 e0       	ldi	r24, 0x01	; 1
    3a26:	01 c0       	rjmp	.+2      	; 0x3a2a <xTaskCreate+0x1dc>
    3a28:	8f ef       	ldi	r24, 0xFF	; 255
    3a2a:	df 91       	pop	r29
    3a2c:	cf 91       	pop	r28
    3a2e:	0f 91       	pop	r16
    3a30:	ff 90       	pop	r15
    3a32:	ef 90       	pop	r14
    3a34:	df 90       	pop	r13
    3a36:	cf 90       	pop	r12
    3a38:	bf 90       	pop	r11
    3a3a:	af 90       	pop	r10
    3a3c:	9f 90       	pop	r9
    3a3e:	8f 90       	pop	r8
    3a40:	7f 90       	pop	r7
    3a42:	6f 90       	pop	r6
    3a44:	5f 90       	pop	r5
    3a46:	4f 90       	pop	r4
    3a48:	08 95       	ret

00003a4a <vTaskStartScheduler>:
    3a4a:	ef 92       	push	r14
    3a4c:	ff 92       	push	r15
    3a4e:	0f 93       	push	r16
    3a50:	0f 2e       	mov	r0, r31
    3a52:	f2 e4       	ldi	r31, 0x42	; 66
    3a54:	ef 2e       	mov	r14, r31
    3a56:	ff e0       	ldi	r31, 0x0F	; 15
    3a58:	ff 2e       	mov	r15, r31
    3a5a:	f0 2d       	mov	r31, r0
    3a5c:	00 e0       	ldi	r16, 0x00	; 0
    3a5e:	20 e0       	ldi	r18, 0x00	; 0
    3a60:	30 e0       	ldi	r19, 0x00	; 0
    3a62:	45 e5       	ldi	r20, 0x55	; 85
    3a64:	50 e0       	ldi	r21, 0x00	; 0
    3a66:	66 eb       	ldi	r22, 0xB6	; 182
    3a68:	71 e0       	ldi	r23, 0x01	; 1
    3a6a:	83 e9       	ldi	r24, 0x93	; 147
    3a6c:	9e e1       	ldi	r25, 0x1E	; 30
    3a6e:	ef de       	rcall	.-546    	; 0x384e <xTaskCreate>
    3a70:	81 30       	cpi	r24, 0x01	; 1
    3a72:	79 f4       	brne	.+30     	; 0x3a92 <vTaskStartScheduler+0x48>
    3a74:	f8 94       	cli
    3a76:	8f ef       	ldi	r24, 0xFF	; 255
    3a78:	9f ef       	ldi	r25, 0xFF	; 255
    3a7a:	90 93 45 0f 	sts	0x0F45, r25	; 0x800f45 <xNextTaskUnblockTime+0x1>
    3a7e:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <xNextTaskUnblockTime>
    3a82:	81 e0       	ldi	r24, 0x01	; 1
    3a84:	80 93 4a 0f 	sts	0x0F4A, r24	; 0x800f4a <xSchedulerRunning>
    3a88:	10 92 4d 0f 	sts	0x0F4D, r1	; 0x800f4d <xTickCount+0x1>
    3a8c:	10 92 4c 0f 	sts	0x0F4C, r1	; 0x800f4c <xTickCount>
    3a90:	fa da       	rcall	.-2572   	; 0x3086 <xPortStartScheduler>
    3a92:	0f 91       	pop	r16
    3a94:	ff 90       	pop	r15
    3a96:	ef 90       	pop	r14
    3a98:	08 95       	ret

00003a9a <vTaskSuspendAll>:
    3a9a:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3a9e:	8f 5f       	subi	r24, 0xFF	; 255
    3aa0:	80 93 41 0f 	sts	0x0F41, r24	; 0x800f41 <uxSchedulerSuspended>
    3aa4:	08 95       	ret

00003aa6 <xTaskIncrementTick>:
    3aa6:	cf 92       	push	r12
    3aa8:	df 92       	push	r13
    3aaa:	ef 92       	push	r14
    3aac:	ff 92       	push	r15
    3aae:	0f 93       	push	r16
    3ab0:	1f 93       	push	r17
    3ab2:	cf 93       	push	r28
    3ab4:	df 93       	push	r29
    3ab6:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3aba:	81 11       	cpse	r24, r1
    3abc:	95 c0       	rjmp	.+298    	; 0x3be8 <xTaskIncrementTick+0x142>
    3abe:	e0 90 4c 0f 	lds	r14, 0x0F4C	; 0x800f4c <xTickCount>
    3ac2:	f0 90 4d 0f 	lds	r15, 0x0F4D	; 0x800f4d <xTickCount+0x1>
    3ac6:	8f ef       	ldi	r24, 0xFF	; 255
    3ac8:	e8 1a       	sub	r14, r24
    3aca:	f8 0a       	sbc	r15, r24
    3acc:	f0 92 4d 0f 	sts	0x0F4D, r15	; 0x800f4d <xTickCount+0x1>
    3ad0:	e0 92 4c 0f 	sts	0x0F4C, r14	; 0x800f4c <xTickCount>
    3ad4:	e1 14       	cp	r14, r1
    3ad6:	f1 04       	cpc	r15, r1
    3ad8:	b1 f4       	brne	.+44     	; 0x3b06 <xTaskIncrementTick+0x60>
    3ada:	80 91 6d 0f 	lds	r24, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    3ade:	90 91 6e 0f 	lds	r25, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    3ae2:	20 91 6b 0f 	lds	r18, 0x0F6B	; 0x800f6b <pxOverflowDelayedTaskList>
    3ae6:	30 91 6c 0f 	lds	r19, 0x0F6C	; 0x800f6c <pxOverflowDelayedTaskList+0x1>
    3aea:	30 93 6e 0f 	sts	0x0F6E, r19	; 0x800f6e <pxDelayedTaskList+0x1>
    3aee:	20 93 6d 0f 	sts	0x0F6D, r18	; 0x800f6d <pxDelayedTaskList>
    3af2:	90 93 6c 0f 	sts	0x0F6C, r25	; 0x800f6c <pxOverflowDelayedTaskList+0x1>
    3af6:	80 93 6b 0f 	sts	0x0F6B, r24	; 0x800f6b <pxOverflowDelayedTaskList>
    3afa:	80 91 47 0f 	lds	r24, 0x0F47	; 0x800f47 <xNumOfOverflows>
    3afe:	8f 5f       	subi	r24, 0xFF	; 255
    3b00:	80 93 47 0f 	sts	0x0F47, r24	; 0x800f47 <xNumOfOverflows>
    3b04:	31 de       	rcall	.-926    	; 0x3768 <prvResetNextTaskUnblockTime>
    3b06:	80 91 44 0f 	lds	r24, 0x0F44	; 0x800f44 <xNextTaskUnblockTime>
    3b0a:	90 91 45 0f 	lds	r25, 0x0F45	; 0x800f45 <xNextTaskUnblockTime+0x1>
    3b0e:	e8 16       	cp	r14, r24
    3b10:	f9 06       	cpc	r15, r25
    3b12:	10 f4       	brcc	.+4      	; 0x3b18 <xTaskIncrementTick+0x72>
    3b14:	d1 2c       	mov	r13, r1
    3b16:	50 c0       	rjmp	.+160    	; 0x3bb8 <xTaskIncrementTick+0x112>
    3b18:	d1 2c       	mov	r13, r1
    3b1a:	cc 24       	eor	r12, r12
    3b1c:	c3 94       	inc	r12
    3b1e:	e0 91 6d 0f 	lds	r30, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    3b22:	f0 91 6e 0f 	lds	r31, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    3b26:	80 81       	ld	r24, Z
    3b28:	81 11       	cpse	r24, r1
    3b2a:	07 c0       	rjmp	.+14     	; 0x3b3a <xTaskIncrementTick+0x94>
    3b2c:	8f ef       	ldi	r24, 0xFF	; 255
    3b2e:	9f ef       	ldi	r25, 0xFF	; 255
    3b30:	90 93 45 0f 	sts	0x0F45, r25	; 0x800f45 <xNextTaskUnblockTime+0x1>
    3b34:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <xNextTaskUnblockTime>
    3b38:	3f c0       	rjmp	.+126    	; 0x3bb8 <xTaskIncrementTick+0x112>
    3b3a:	e0 91 6d 0f 	lds	r30, 0x0F6D	; 0x800f6d <pxDelayedTaskList>
    3b3e:	f0 91 6e 0f 	lds	r31, 0x0F6E	; 0x800f6e <pxDelayedTaskList+0x1>
    3b42:	05 80       	ldd	r0, Z+5	; 0x05
    3b44:	f6 81       	ldd	r31, Z+6	; 0x06
    3b46:	e0 2d       	mov	r30, r0
    3b48:	c6 81       	ldd	r28, Z+6	; 0x06
    3b4a:	d7 81       	ldd	r29, Z+7	; 0x07
    3b4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b4e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b50:	e8 16       	cp	r14, r24
    3b52:	f9 06       	cpc	r15, r25
    3b54:	28 f4       	brcc	.+10     	; 0x3b60 <xTaskIncrementTick+0xba>
    3b56:	90 93 45 0f 	sts	0x0F45, r25	; 0x800f45 <xNextTaskUnblockTime+0x1>
    3b5a:	80 93 44 0f 	sts	0x0F44, r24	; 0x800f44 <xNextTaskUnblockTime>
    3b5e:	2c c0       	rjmp	.+88     	; 0x3bb8 <xTaskIncrementTick+0x112>
    3b60:	8e 01       	movw	r16, r28
    3b62:	0e 5f       	subi	r16, 0xFE	; 254
    3b64:	1f 4f       	sbci	r17, 0xFF	; 255
    3b66:	c8 01       	movw	r24, r16
    3b68:	fc d9       	rcall	.-3080   	; 0x2f62 <uxListRemove>
    3b6a:	8c 89       	ldd	r24, Y+20	; 0x14
    3b6c:	9d 89       	ldd	r25, Y+21	; 0x15
    3b6e:	89 2b       	or	r24, r25
    3b70:	19 f0       	breq	.+6      	; 0x3b78 <xTaskIncrementTick+0xd2>
    3b72:	ce 01       	movw	r24, r28
    3b74:	0c 96       	adiw	r24, 0x0c	; 12
    3b76:	f5 d9       	rcall	.-3094   	; 0x2f62 <uxListRemove>
    3b78:	8e 89       	ldd	r24, Y+22	; 0x16
    3b7a:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    3b7e:	98 17       	cp	r25, r24
    3b80:	10 f4       	brcc	.+4      	; 0x3b86 <xTaskIncrementTick+0xe0>
    3b82:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    3b86:	90 e0       	ldi	r25, 0x00	; 0
    3b88:	9c 01       	movw	r18, r24
    3b8a:	22 0f       	add	r18, r18
    3b8c:	33 1f       	adc	r19, r19
    3b8e:	22 0f       	add	r18, r18
    3b90:	33 1f       	adc	r19, r19
    3b92:	22 0f       	add	r18, r18
    3b94:	33 1f       	adc	r19, r19
    3b96:	82 0f       	add	r24, r18
    3b98:	93 1f       	adc	r25, r19
    3b9a:	b8 01       	movw	r22, r16
    3b9c:	8f 57       	subi	r24, 0x7F	; 127
    3b9e:	90 4f       	sbci	r25, 0xF0	; 240
    3ba0:	8e d9       	rcall	.-3300   	; 0x2ebe <vListInsertEnd>
    3ba2:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3ba6:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3baa:	9e 89       	ldd	r25, Y+22	; 0x16
    3bac:	86 89       	ldd	r24, Z+22	; 0x16
    3bae:	98 17       	cp	r25, r24
    3bb0:	08 f4       	brcc	.+2      	; 0x3bb4 <xTaskIncrementTick+0x10e>
    3bb2:	b5 cf       	rjmp	.-150    	; 0x3b1e <xTaskIncrementTick+0x78>
    3bb4:	dc 2c       	mov	r13, r12
    3bb6:	b3 cf       	rjmp	.-154    	; 0x3b1e <xTaskIncrementTick+0x78>
    3bb8:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3bbc:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3bc0:	86 89       	ldd	r24, Z+22	; 0x16
    3bc2:	90 e0       	ldi	r25, 0x00	; 0
    3bc4:	fc 01       	movw	r30, r24
    3bc6:	ee 0f       	add	r30, r30
    3bc8:	ff 1f       	adc	r31, r31
    3bca:	ee 0f       	add	r30, r30
    3bcc:	ff 1f       	adc	r31, r31
    3bce:	ee 0f       	add	r30, r30
    3bd0:	ff 1f       	adc	r31, r31
    3bd2:	8e 0f       	add	r24, r30
    3bd4:	9f 1f       	adc	r25, r31
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	ef 57       	subi	r30, 0x7F	; 127
    3bda:	f0 4f       	sbci	r31, 0xF0	; 240
    3bdc:	80 81       	ld	r24, Z
    3bde:	82 30       	cpi	r24, 0x02	; 2
    3be0:	48 f0       	brcs	.+18     	; 0x3bf4 <xTaskIncrementTick+0x14e>
    3be2:	dd 24       	eor	r13, r13
    3be4:	d3 94       	inc	r13
    3be6:	06 c0       	rjmp	.+12     	; 0x3bf4 <xTaskIncrementTick+0x14e>
    3be8:	80 91 49 0f 	lds	r24, 0x0F49	; 0x800f49 <uxPendedTicks>
    3bec:	8f 5f       	subi	r24, 0xFF	; 255
    3bee:	80 93 49 0f 	sts	0x0F49, r24	; 0x800f49 <uxPendedTicks>
    3bf2:	d1 2c       	mov	r13, r1
    3bf4:	80 91 48 0f 	lds	r24, 0x0F48	; 0x800f48 <xYieldPending>
    3bf8:	88 23       	and	r24, r24
    3bfa:	11 f0       	breq	.+4      	; 0x3c00 <xTaskIncrementTick+0x15a>
    3bfc:	dd 24       	eor	r13, r13
    3bfe:	d3 94       	inc	r13
    3c00:	8d 2d       	mov	r24, r13
    3c02:	df 91       	pop	r29
    3c04:	cf 91       	pop	r28
    3c06:	1f 91       	pop	r17
    3c08:	0f 91       	pop	r16
    3c0a:	ff 90       	pop	r15
    3c0c:	ef 90       	pop	r14
    3c0e:	df 90       	pop	r13
    3c10:	cf 90       	pop	r12
    3c12:	08 95       	ret

00003c14 <xTaskResumeAll>:
    3c14:	df 92       	push	r13
    3c16:	ef 92       	push	r14
    3c18:	ff 92       	push	r15
    3c1a:	0f 93       	push	r16
    3c1c:	1f 93       	push	r17
    3c1e:	cf 93       	push	r28
    3c20:	df 93       	push	r29
    3c22:	0f b6       	in	r0, 0x3f	; 63
    3c24:	f8 94       	cli
    3c26:	0f 92       	push	r0
    3c28:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3c2c:	81 50       	subi	r24, 0x01	; 1
    3c2e:	80 93 41 0f 	sts	0x0F41, r24	; 0x800f41 <uxSchedulerSuspended>
    3c32:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3c36:	81 11       	cpse	r24, r1
    3c38:	59 c0       	rjmp	.+178    	; 0x3cec <xTaskResumeAll+0xd8>
    3c3a:	80 91 4e 0f 	lds	r24, 0x0F4E	; 0x800f4e <uxCurrentNumberOfTasks>
    3c3e:	81 11       	cpse	r24, r1
    3c40:	30 c0       	rjmp	.+96     	; 0x3ca2 <xTaskResumeAll+0x8e>
    3c42:	57 c0       	rjmp	.+174    	; 0x3cf2 <xTaskResumeAll+0xde>
    3c44:	d7 01       	movw	r26, r14
    3c46:	15 96       	adiw	r26, 0x05	; 5
    3c48:	ed 91       	ld	r30, X+
    3c4a:	fc 91       	ld	r31, X
    3c4c:	16 97       	sbiw	r26, 0x06	; 6
    3c4e:	c6 81       	ldd	r28, Z+6	; 0x06
    3c50:	d7 81       	ldd	r29, Z+7	; 0x07
    3c52:	ce 01       	movw	r24, r28
    3c54:	0c 96       	adiw	r24, 0x0c	; 12
    3c56:	85 d9       	rcall	.-3318   	; 0x2f62 <uxListRemove>
    3c58:	8e 01       	movw	r16, r28
    3c5a:	0e 5f       	subi	r16, 0xFE	; 254
    3c5c:	1f 4f       	sbci	r17, 0xFF	; 255
    3c5e:	c8 01       	movw	r24, r16
    3c60:	80 d9       	rcall	.-3328   	; 0x2f62 <uxListRemove>
    3c62:	8e 89       	ldd	r24, Y+22	; 0x16
    3c64:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    3c68:	98 17       	cp	r25, r24
    3c6a:	10 f4       	brcc	.+4      	; 0x3c70 <xTaskResumeAll+0x5c>
    3c6c:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    3c70:	90 e0       	ldi	r25, 0x00	; 0
    3c72:	9c 01       	movw	r18, r24
    3c74:	22 0f       	add	r18, r18
    3c76:	33 1f       	adc	r19, r19
    3c78:	22 0f       	add	r18, r18
    3c7a:	33 1f       	adc	r19, r19
    3c7c:	22 0f       	add	r18, r18
    3c7e:	33 1f       	adc	r19, r19
    3c80:	82 0f       	add	r24, r18
    3c82:	93 1f       	adc	r25, r19
    3c84:	b8 01       	movw	r22, r16
    3c86:	8f 57       	subi	r24, 0x7F	; 127
    3c88:	90 4f       	sbci	r25, 0xF0	; 240
    3c8a:	19 d9       	rcall	.-3534   	; 0x2ebe <vListInsertEnd>
    3c8c:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3c90:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3c94:	9e 89       	ldd	r25, Y+22	; 0x16
    3c96:	86 89       	ldd	r24, Z+22	; 0x16
    3c98:	98 17       	cp	r25, r24
    3c9a:	68 f0       	brcs	.+26     	; 0x3cb6 <xTaskResumeAll+0xa2>
    3c9c:	d0 92 48 0f 	sts	0x0F48, r13	; 0x800f48 <xYieldPending>
    3ca0:	0a c0       	rjmp	.+20     	; 0x3cb6 <xTaskResumeAll+0xa2>
    3ca2:	c0 e0       	ldi	r28, 0x00	; 0
    3ca4:	d0 e0       	ldi	r29, 0x00	; 0
    3ca6:	0f 2e       	mov	r0, r31
    3ca8:	f2 e6       	ldi	r31, 0x62	; 98
    3caa:	ef 2e       	mov	r14, r31
    3cac:	ff e0       	ldi	r31, 0x0F	; 15
    3cae:	ff 2e       	mov	r15, r31
    3cb0:	f0 2d       	mov	r31, r0
    3cb2:	dd 24       	eor	r13, r13
    3cb4:	d3 94       	inc	r13
    3cb6:	f7 01       	movw	r30, r14
    3cb8:	80 81       	ld	r24, Z
    3cba:	81 11       	cpse	r24, r1
    3cbc:	c3 cf       	rjmp	.-122    	; 0x3c44 <xTaskResumeAll+0x30>
    3cbe:	cd 2b       	or	r28, r29
    3cc0:	09 f0       	breq	.+2      	; 0x3cc4 <xTaskResumeAll+0xb0>
    3cc2:	52 dd       	rcall	.-1372   	; 0x3768 <prvResetNextTaskUnblockTime>
    3cc4:	c0 91 49 0f 	lds	r28, 0x0F49	; 0x800f49 <uxPendedTicks>
    3cc8:	cc 23       	and	r28, r28
    3cca:	49 f0       	breq	.+18     	; 0x3cde <xTaskResumeAll+0xca>
    3ccc:	d1 e0       	ldi	r29, 0x01	; 1
    3cce:	eb de       	rcall	.-554    	; 0x3aa6 <xTaskIncrementTick>
    3cd0:	81 11       	cpse	r24, r1
    3cd2:	d0 93 48 0f 	sts	0x0F48, r29	; 0x800f48 <xYieldPending>
    3cd6:	c1 50       	subi	r28, 0x01	; 1
    3cd8:	d1 f7       	brne	.-12     	; 0x3cce <xTaskResumeAll+0xba>
    3cda:	10 92 49 0f 	sts	0x0F49, r1	; 0x800f49 <uxPendedTicks>
    3cde:	80 91 48 0f 	lds	r24, 0x0F48	; 0x800f48 <xYieldPending>
    3ce2:	88 23       	and	r24, r24
    3ce4:	29 f0       	breq	.+10     	; 0x3cf0 <xTaskResumeAll+0xdc>
    3ce6:	04 da       	rcall	.-3064   	; 0x30f0 <vPortYield>
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
    3cea:	03 c0       	rjmp	.+6      	; 0x3cf2 <xTaskResumeAll+0xde>
    3cec:	80 e0       	ldi	r24, 0x00	; 0
    3cee:	01 c0       	rjmp	.+2      	; 0x3cf2 <xTaskResumeAll+0xde>
    3cf0:	80 e0       	ldi	r24, 0x00	; 0
    3cf2:	0f 90       	pop	r0
    3cf4:	0f be       	out	0x3f, r0	; 63
    3cf6:	df 91       	pop	r29
    3cf8:	cf 91       	pop	r28
    3cfa:	1f 91       	pop	r17
    3cfc:	0f 91       	pop	r16
    3cfe:	ff 90       	pop	r15
    3d00:	ef 90       	pop	r14
    3d02:	df 90       	pop	r13
    3d04:	08 95       	ret

00003d06 <vTaskDelay>:
    3d06:	cf 93       	push	r28
    3d08:	df 93       	push	r29
    3d0a:	ec 01       	movw	r28, r24
    3d0c:	89 2b       	or	r24, r25
    3d0e:	39 f0       	breq	.+14     	; 0x3d1e <vTaskDelay+0x18>
    3d10:	c4 de       	rcall	.-632    	; 0x3a9a <vTaskSuspendAll>
    3d12:	60 e0       	ldi	r22, 0x00	; 0
    3d14:	ce 01       	movw	r24, r28
    3d16:	47 dd       	rcall	.-1394   	; 0x37a6 <prvAddCurrentTaskToDelayedList>
    3d18:	7d df       	rcall	.-262    	; 0x3c14 <xTaskResumeAll>
    3d1a:	81 11       	cpse	r24, r1
    3d1c:	01 c0       	rjmp	.+2      	; 0x3d20 <vTaskDelay+0x1a>
    3d1e:	e8 d9       	rcall	.-3120   	; 0x30f0 <vPortYield>
    3d20:	df 91       	pop	r29
    3d22:	cf 91       	pop	r28
    3d24:	08 95       	ret

00003d26 <prvIdleTask>:
    3d26:	09 e5       	ldi	r16, 0x59	; 89
    3d28:	1f e0       	ldi	r17, 0x0F	; 15
    3d2a:	0f 2e       	mov	r0, r31
    3d2c:	f1 e8       	ldi	r31, 0x81	; 129
    3d2e:	ef 2e       	mov	r14, r31
    3d30:	ff e0       	ldi	r31, 0x0F	; 15
    3d32:	ff 2e       	mov	r15, r31
    3d34:	f0 2d       	mov	r31, r0
    3d36:	24 c0       	rjmp	.+72     	; 0x3d80 <prvIdleTask+0x5a>
    3d38:	b0 de       	rcall	.-672    	; 0x3a9a <vTaskSuspendAll>
    3d3a:	d8 01       	movw	r26, r16
    3d3c:	cc 91       	ld	r28, X
    3d3e:	6a df       	rcall	.-300    	; 0x3c14 <xTaskResumeAll>
    3d40:	cc 23       	and	r28, r28
    3d42:	f1 f0       	breq	.+60     	; 0x3d80 <prvIdleTask+0x5a>
    3d44:	0f b6       	in	r0, 0x3f	; 63
    3d46:	f8 94       	cli
    3d48:	0f 92       	push	r0
    3d4a:	d8 01       	movw	r26, r16
    3d4c:	15 96       	adiw	r26, 0x05	; 5
    3d4e:	ed 91       	ld	r30, X+
    3d50:	fc 91       	ld	r31, X
    3d52:	16 97       	sbiw	r26, 0x06	; 6
    3d54:	c6 81       	ldd	r28, Z+6	; 0x06
    3d56:	d7 81       	ldd	r29, Z+7	; 0x07
    3d58:	ce 01       	movw	r24, r28
    3d5a:	02 96       	adiw	r24, 0x02	; 2
    3d5c:	02 d9       	rcall	.-3580   	; 0x2f62 <uxListRemove>
    3d5e:	80 91 4e 0f 	lds	r24, 0x0F4E	; 0x800f4e <uxCurrentNumberOfTasks>
    3d62:	81 50       	subi	r24, 0x01	; 1
    3d64:	80 93 4e 0f 	sts	0x0F4E, r24	; 0x800f4e <uxCurrentNumberOfTasks>
    3d68:	80 91 58 0f 	lds	r24, 0x0F58	; 0x800f58 <uxDeletedTasksWaitingCleanUp>
    3d6c:	81 50       	subi	r24, 0x01	; 1
    3d6e:	80 93 58 0f 	sts	0x0F58, r24	; 0x800f58 <uxDeletedTasksWaitingCleanUp>
    3d72:	0f 90       	pop	r0
    3d74:	0f be       	out	0x3f, r0	; 63
    3d76:	8f 89       	ldd	r24, Y+23	; 0x17
    3d78:	98 8d       	ldd	r25, Y+24	; 0x18
    3d7a:	8e d8       	rcall	.-3812   	; 0x2e98 <vPortFree>
    3d7c:	ce 01       	movw	r24, r28
    3d7e:	8c d8       	rcall	.-3816   	; 0x2e98 <vPortFree>
    3d80:	80 91 58 0f 	lds	r24, 0x0F58	; 0x800f58 <uxDeletedTasksWaitingCleanUp>
    3d84:	81 11       	cpse	r24, r1
    3d86:	d8 cf       	rjmp	.-80     	; 0x3d38 <prvIdleTask+0x12>
    3d88:	f7 01       	movw	r30, r14
    3d8a:	80 81       	ld	r24, Z
    3d8c:	82 30       	cpi	r24, 0x02	; 2
    3d8e:	c0 f3       	brcs	.-16     	; 0x3d80 <prvIdleTask+0x5a>
    3d90:	af d9       	rcall	.-3234   	; 0x30f0 <vPortYield>
    3d92:	f6 cf       	rjmp	.-20     	; 0x3d80 <prvIdleTask+0x5a>

00003d94 <vTaskSwitchContext>:
    3d94:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3d98:	88 23       	and	r24, r24
    3d9a:	21 f0       	breq	.+8      	; 0x3da4 <vTaskSwitchContext+0x10>
    3d9c:	81 e0       	ldi	r24, 0x01	; 1
    3d9e:	80 93 48 0f 	sts	0x0F48, r24	; 0x800f48 <xYieldPending>
    3da2:	08 95       	ret
    3da4:	10 92 48 0f 	sts	0x0F48, r1	; 0x800f48 <xYieldPending>
    3da8:	20 91 4b 0f 	lds	r18, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    3dac:	82 2f       	mov	r24, r18
    3dae:	90 e0       	ldi	r25, 0x00	; 0
    3db0:	fc 01       	movw	r30, r24
    3db2:	ee 0f       	add	r30, r30
    3db4:	ff 1f       	adc	r31, r31
    3db6:	ee 0f       	add	r30, r30
    3db8:	ff 1f       	adc	r31, r31
    3dba:	ee 0f       	add	r30, r30
    3dbc:	ff 1f       	adc	r31, r31
    3dbe:	e8 0f       	add	r30, r24
    3dc0:	f9 1f       	adc	r31, r25
    3dc2:	ef 57       	subi	r30, 0x7F	; 127
    3dc4:	f0 4f       	sbci	r31, 0xF0	; 240
    3dc6:	30 81       	ld	r19, Z
    3dc8:	31 11       	cpse	r19, r1
    3dca:	11 c0       	rjmp	.+34     	; 0x3dee <vTaskSwitchContext+0x5a>
    3dcc:	21 50       	subi	r18, 0x01	; 1
    3dce:	82 2f       	mov	r24, r18
    3dd0:	90 e0       	ldi	r25, 0x00	; 0
    3dd2:	fc 01       	movw	r30, r24
    3dd4:	ee 0f       	add	r30, r30
    3dd6:	ff 1f       	adc	r31, r31
    3dd8:	ee 0f       	add	r30, r30
    3dda:	ff 1f       	adc	r31, r31
    3ddc:	ee 0f       	add	r30, r30
    3dde:	ff 1f       	adc	r31, r31
    3de0:	e8 0f       	add	r30, r24
    3de2:	f9 1f       	adc	r31, r25
    3de4:	ef 57       	subi	r30, 0x7F	; 127
    3de6:	f0 4f       	sbci	r31, 0xF0	; 240
    3de8:	30 81       	ld	r19, Z
    3dea:	33 23       	and	r19, r19
    3dec:	79 f3       	breq	.-34     	; 0x3dcc <vTaskSwitchContext+0x38>
    3dee:	ac 01       	movw	r20, r24
    3df0:	44 0f       	add	r20, r20
    3df2:	55 1f       	adc	r21, r21
    3df4:	44 0f       	add	r20, r20
    3df6:	55 1f       	adc	r21, r21
    3df8:	44 0f       	add	r20, r20
    3dfa:	55 1f       	adc	r21, r21
    3dfc:	48 0f       	add	r20, r24
    3dfe:	59 1f       	adc	r21, r25
    3e00:	da 01       	movw	r26, r20
    3e02:	af 57       	subi	r26, 0x7F	; 127
    3e04:	b0 4f       	sbci	r27, 0xF0	; 240
    3e06:	11 96       	adiw	r26, 0x01	; 1
    3e08:	ed 91       	ld	r30, X+
    3e0a:	fc 91       	ld	r31, X
    3e0c:	12 97       	sbiw	r26, 0x02	; 2
    3e0e:	02 80       	ldd	r0, Z+2	; 0x02
    3e10:	f3 81       	ldd	r31, Z+3	; 0x03
    3e12:	e0 2d       	mov	r30, r0
    3e14:	12 96       	adiw	r26, 0x02	; 2
    3e16:	fc 93       	st	X, r31
    3e18:	ee 93       	st	-X, r30
    3e1a:	11 97       	sbiw	r26, 0x01	; 1
    3e1c:	4c 57       	subi	r20, 0x7C	; 124
    3e1e:	50 4f       	sbci	r21, 0xF0	; 240
    3e20:	e4 17       	cp	r30, r20
    3e22:	f5 07       	cpc	r31, r21
    3e24:	29 f4       	brne	.+10     	; 0x3e30 <vTaskSwitchContext+0x9c>
    3e26:	42 81       	ldd	r20, Z+2	; 0x02
    3e28:	53 81       	ldd	r21, Z+3	; 0x03
    3e2a:	fd 01       	movw	r30, r26
    3e2c:	52 83       	std	Z+2, r21	; 0x02
    3e2e:	41 83       	std	Z+1, r20	; 0x01
    3e30:	fc 01       	movw	r30, r24
    3e32:	ee 0f       	add	r30, r30
    3e34:	ff 1f       	adc	r31, r31
    3e36:	ee 0f       	add	r30, r30
    3e38:	ff 1f       	adc	r31, r31
    3e3a:	ee 0f       	add	r30, r30
    3e3c:	ff 1f       	adc	r31, r31
    3e3e:	8e 0f       	add	r24, r30
    3e40:	9f 1f       	adc	r25, r31
    3e42:	fc 01       	movw	r30, r24
    3e44:	ef 57       	subi	r30, 0x7F	; 127
    3e46:	f0 4f       	sbci	r31, 0xF0	; 240
    3e48:	01 80       	ldd	r0, Z+1	; 0x01
    3e4a:	f2 81       	ldd	r31, Z+2	; 0x02
    3e4c:	e0 2d       	mov	r30, r0
    3e4e:	86 81       	ldd	r24, Z+6	; 0x06
    3e50:	97 81       	ldd	r25, Z+7	; 0x07
    3e52:	90 93 a6 0f 	sts	0x0FA6, r25	; 0x800fa6 <pxCurrentTCB+0x1>
    3e56:	80 93 a5 0f 	sts	0x0FA5, r24	; 0x800fa5 <pxCurrentTCB>
    3e5a:	20 93 4b 0f 	sts	0x0F4B, r18	; 0x800f4b <uxTopReadyPriority>
    3e5e:	08 95       	ret

00003e60 <vTaskPlaceOnEventList>:
    3e60:	cf 93       	push	r28
    3e62:	df 93       	push	r29
    3e64:	eb 01       	movw	r28, r22
    3e66:	60 91 a5 0f 	lds	r22, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3e6a:	70 91 a6 0f 	lds	r23, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3e6e:	64 5f       	subi	r22, 0xF4	; 244
    3e70:	7f 4f       	sbci	r23, 0xFF	; 255
    3e72:	46 d8       	rcall	.-3956   	; 0x2f00 <vListInsert>
    3e74:	61 e0       	ldi	r22, 0x01	; 1
    3e76:	ce 01       	movw	r24, r28
    3e78:	96 dc       	rcall	.-1748   	; 0x37a6 <prvAddCurrentTaskToDelayedList>
    3e7a:	df 91       	pop	r29
    3e7c:	cf 91       	pop	r28
    3e7e:	08 95       	ret

00003e80 <xTaskRemoveFromEventList>:
    3e80:	0f 93       	push	r16
    3e82:	1f 93       	push	r17
    3e84:	cf 93       	push	r28
    3e86:	df 93       	push	r29
    3e88:	dc 01       	movw	r26, r24
    3e8a:	15 96       	adiw	r26, 0x05	; 5
    3e8c:	ed 91       	ld	r30, X+
    3e8e:	fc 91       	ld	r31, X
    3e90:	16 97       	sbiw	r26, 0x06	; 6
    3e92:	c6 81       	ldd	r28, Z+6	; 0x06
    3e94:	d7 81       	ldd	r29, Z+7	; 0x07
    3e96:	8e 01       	movw	r16, r28
    3e98:	04 5f       	subi	r16, 0xF4	; 244
    3e9a:	1f 4f       	sbci	r17, 0xFF	; 255
    3e9c:	c8 01       	movw	r24, r16
    3e9e:	61 d8       	rcall	.-3902   	; 0x2f62 <uxListRemove>
    3ea0:	80 91 41 0f 	lds	r24, 0x0F41	; 0x800f41 <uxSchedulerSuspended>
    3ea4:	81 11       	cpse	r24, r1
    3ea6:	1b c0       	rjmp	.+54     	; 0x3ede <xTaskRemoveFromEventList+0x5e>
    3ea8:	0a 50       	subi	r16, 0x0A	; 10
    3eaa:	11 09       	sbc	r17, r1
    3eac:	c8 01       	movw	r24, r16
    3eae:	59 d8       	rcall	.-3918   	; 0x2f62 <uxListRemove>
    3eb0:	8e 89       	ldd	r24, Y+22	; 0x16
    3eb2:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    3eb6:	98 17       	cp	r25, r24
    3eb8:	10 f4       	brcc	.+4      	; 0x3ebe <xTaskRemoveFromEventList+0x3e>
    3eba:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    3ebe:	90 e0       	ldi	r25, 0x00	; 0
    3ec0:	9c 01       	movw	r18, r24
    3ec2:	22 0f       	add	r18, r18
    3ec4:	33 1f       	adc	r19, r19
    3ec6:	22 0f       	add	r18, r18
    3ec8:	33 1f       	adc	r19, r19
    3eca:	22 0f       	add	r18, r18
    3ecc:	33 1f       	adc	r19, r19
    3ece:	82 0f       	add	r24, r18
    3ed0:	93 1f       	adc	r25, r19
    3ed2:	b8 01       	movw	r22, r16
    3ed4:	8f 57       	subi	r24, 0x7F	; 127
    3ed6:	90 4f       	sbci	r25, 0xF0	; 240
    3ed8:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <vListInsertEnd>
    3edc:	05 c0       	rjmp	.+10     	; 0x3ee8 <xTaskRemoveFromEventList+0x68>
    3ede:	b8 01       	movw	r22, r16
    3ee0:	82 e6       	ldi	r24, 0x62	; 98
    3ee2:	9f e0       	ldi	r25, 0x0F	; 15
    3ee4:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <vListInsertEnd>
    3ee8:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3eec:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3ef0:	9e 89       	ldd	r25, Y+22	; 0x16
    3ef2:	86 89       	ldd	r24, Z+22	; 0x16
    3ef4:	89 17       	cp	r24, r25
    3ef6:	20 f4       	brcc	.+8      	; 0x3f00 <xTaskRemoveFromEventList+0x80>
    3ef8:	81 e0       	ldi	r24, 0x01	; 1
    3efa:	80 93 48 0f 	sts	0x0F48, r24	; 0x800f48 <xYieldPending>
    3efe:	01 c0       	rjmp	.+2      	; 0x3f02 <xTaskRemoveFromEventList+0x82>
    3f00:	80 e0       	ldi	r24, 0x00	; 0
    3f02:	df 91       	pop	r29
    3f04:	cf 91       	pop	r28
    3f06:	1f 91       	pop	r17
    3f08:	0f 91       	pop	r16
    3f0a:	08 95       	ret

00003f0c <vTaskSetTimeOutState>:
    3f0c:	20 91 47 0f 	lds	r18, 0x0F47	; 0x800f47 <xNumOfOverflows>
    3f10:	fc 01       	movw	r30, r24
    3f12:	20 83       	st	Z, r18
    3f14:	20 91 4c 0f 	lds	r18, 0x0F4C	; 0x800f4c <xTickCount>
    3f18:	30 91 4d 0f 	lds	r19, 0x0F4D	; 0x800f4d <xTickCount+0x1>
    3f1c:	32 83       	std	Z+2, r19	; 0x02
    3f1e:	21 83       	std	Z+1, r18	; 0x01
    3f20:	08 95       	ret

00003f22 <xTaskCheckForTimeOut>:
    3f22:	0f b6       	in	r0, 0x3f	; 63
    3f24:	f8 94       	cli
    3f26:	0f 92       	push	r0
    3f28:	40 91 4c 0f 	lds	r20, 0x0F4C	; 0x800f4c <xTickCount>
    3f2c:	50 91 4d 0f 	lds	r21, 0x0F4D	; 0x800f4d <xTickCount+0x1>
    3f30:	db 01       	movw	r26, r22
    3f32:	2d 91       	ld	r18, X+
    3f34:	3c 91       	ld	r19, X
    3f36:	2f 3f       	cpi	r18, 0xFF	; 255
    3f38:	bf ef       	ldi	r27, 0xFF	; 255
    3f3a:	3b 07       	cpc	r19, r27
    3f3c:	11 f1       	breq	.+68     	; 0x3f82 <xTaskCheckForTimeOut+0x60>
    3f3e:	e0 91 47 0f 	lds	r30, 0x0F47	; 0x800f47 <xNumOfOverflows>
    3f42:	dc 01       	movw	r26, r24
    3f44:	fc 91       	ld	r31, X
    3f46:	fe 17       	cp	r31, r30
    3f48:	39 f0       	breq	.+14     	; 0x3f58 <xTaskCheckForTimeOut+0x36>
    3f4a:	11 96       	adiw	r26, 0x01	; 1
    3f4c:	ed 91       	ld	r30, X+
    3f4e:	fc 91       	ld	r31, X
    3f50:	12 97       	sbiw	r26, 0x02	; 2
    3f52:	4e 17       	cp	r20, r30
    3f54:	5f 07       	cpc	r21, r31
    3f56:	b8 f4       	brcc	.+46     	; 0x3f86 <xTaskCheckForTimeOut+0x64>
    3f58:	dc 01       	movw	r26, r24
    3f5a:	11 96       	adiw	r26, 0x01	; 1
    3f5c:	ed 91       	ld	r30, X+
    3f5e:	fc 91       	ld	r31, X
    3f60:	12 97       	sbiw	r26, 0x02	; 2
    3f62:	da 01       	movw	r26, r20
    3f64:	ae 1b       	sub	r26, r30
    3f66:	bf 0b       	sbc	r27, r31
    3f68:	a2 17       	cp	r26, r18
    3f6a:	b3 07       	cpc	r27, r19
    3f6c:	70 f4       	brcc	.+28     	; 0x3f8a <xTaskCheckForTimeOut+0x68>
    3f6e:	db 01       	movw	r26, r22
    3f70:	e4 1b       	sub	r30, r20
    3f72:	f5 0b       	sbc	r31, r21
    3f74:	2e 0f       	add	r18, r30
    3f76:	3f 1f       	adc	r19, r31
    3f78:	2d 93       	st	X+, r18
    3f7a:	3c 93       	st	X, r19
    3f7c:	c7 df       	rcall	.-114    	; 0x3f0c <vTaskSetTimeOutState>
    3f7e:	80 e0       	ldi	r24, 0x00	; 0
    3f80:	05 c0       	rjmp	.+10     	; 0x3f8c <xTaskCheckForTimeOut+0x6a>
    3f82:	80 e0       	ldi	r24, 0x00	; 0
    3f84:	03 c0       	rjmp	.+6      	; 0x3f8c <xTaskCheckForTimeOut+0x6a>
    3f86:	81 e0       	ldi	r24, 0x01	; 1
    3f88:	01 c0       	rjmp	.+2      	; 0x3f8c <xTaskCheckForTimeOut+0x6a>
    3f8a:	81 e0       	ldi	r24, 0x01	; 1
    3f8c:	0f 90       	pop	r0
    3f8e:	0f be       	out	0x3f, r0	; 63
    3f90:	08 95       	ret

00003f92 <vTaskMissedYield>:
    3f92:	81 e0       	ldi	r24, 0x01	; 1
    3f94:	80 93 48 0f 	sts	0x0F48, r24	; 0x800f48 <xYieldPending>
    3f98:	08 95       	ret

00003f9a <vTaskPriorityInherit>:
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	cf 93       	push	r28
    3fa0:	df 93       	push	r29
    3fa2:	fc 01       	movw	r30, r24
    3fa4:	89 2b       	or	r24, r25
    3fa6:	09 f4       	brne	.+2      	; 0x3faa <vTaskPriorityInherit+0x10>
    3fa8:	55 c0       	rjmp	.+170    	; 0x4054 <vTaskPriorityInherit+0xba>
    3faa:	26 89       	ldd	r18, Z+22	; 0x16
    3fac:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3fb0:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3fb4:	56 96       	adiw	r26, 0x16	; 22
    3fb6:	8c 91       	ld	r24, X
    3fb8:	28 17       	cp	r18, r24
    3fba:	08 f0       	brcs	.+2      	; 0x3fbe <vTaskPriorityInherit+0x24>
    3fbc:	4b c0       	rjmp	.+150    	; 0x4054 <vTaskPriorityInherit+0xba>
    3fbe:	84 85       	ldd	r24, Z+12	; 0x0c
    3fc0:	95 85       	ldd	r25, Z+13	; 0x0d
    3fc2:	99 23       	and	r25, r25
    3fc4:	64 f0       	brlt	.+24     	; 0x3fde <vTaskPriorityInherit+0x44>
    3fc6:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    3fca:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    3fce:	56 96       	adiw	r26, 0x16	; 22
    3fd0:	3c 91       	ld	r19, X
    3fd2:	84 e0       	ldi	r24, 0x04	; 4
    3fd4:	90 e0       	ldi	r25, 0x00	; 0
    3fd6:	83 1b       	sub	r24, r19
    3fd8:	91 09       	sbc	r25, r1
    3fda:	95 87       	std	Z+13, r25	; 0x0d
    3fdc:	84 87       	std	Z+12, r24	; 0x0c
    3fde:	30 e0       	ldi	r19, 0x00	; 0
    3fe0:	c9 01       	movw	r24, r18
    3fe2:	88 0f       	add	r24, r24
    3fe4:	99 1f       	adc	r25, r25
    3fe6:	88 0f       	add	r24, r24
    3fe8:	99 1f       	adc	r25, r25
    3fea:	88 0f       	add	r24, r24
    3fec:	99 1f       	adc	r25, r25
    3fee:	28 0f       	add	r18, r24
    3ff0:	39 1f       	adc	r19, r25
    3ff2:	2f 57       	subi	r18, 0x7F	; 127
    3ff4:	30 4f       	sbci	r19, 0xF0	; 240
    3ff6:	82 85       	ldd	r24, Z+10	; 0x0a
    3ff8:	93 85       	ldd	r25, Z+11	; 0x0b
    3ffa:	82 17       	cp	r24, r18
    3ffc:	93 07       	cpc	r25, r19
    3ffe:	19 f5       	brne	.+70     	; 0x4046 <vTaskPriorityInherit+0xac>
    4000:	8f 01       	movw	r16, r30
    4002:	ef 01       	movw	r28, r30
    4004:	22 96       	adiw	r28, 0x02	; 2
    4006:	ce 01       	movw	r24, r28
    4008:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <uxListRemove>
    400c:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    4010:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    4014:	86 89       	ldd	r24, Z+22	; 0x16
    4016:	f8 01       	movw	r30, r16
    4018:	86 8b       	std	Z+22, r24	; 0x16
    401a:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    401e:	98 17       	cp	r25, r24
    4020:	10 f4       	brcc	.+4      	; 0x4026 <vTaskPriorityInherit+0x8c>
    4022:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    4026:	90 e0       	ldi	r25, 0x00	; 0
    4028:	9c 01       	movw	r18, r24
    402a:	22 0f       	add	r18, r18
    402c:	33 1f       	adc	r19, r19
    402e:	22 0f       	add	r18, r18
    4030:	33 1f       	adc	r19, r19
    4032:	22 0f       	add	r18, r18
    4034:	33 1f       	adc	r19, r19
    4036:	82 0f       	add	r24, r18
    4038:	93 1f       	adc	r25, r19
    403a:	be 01       	movw	r22, r28
    403c:	8f 57       	subi	r24, 0x7F	; 127
    403e:	90 4f       	sbci	r25, 0xF0	; 240
    4040:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <vListInsertEnd>
    4044:	07 c0       	rjmp	.+14     	; 0x4054 <vTaskPriorityInherit+0xba>
    4046:	a0 91 a5 0f 	lds	r26, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    404a:	b0 91 a6 0f 	lds	r27, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    404e:	56 96       	adiw	r26, 0x16	; 22
    4050:	8c 91       	ld	r24, X
    4052:	86 8b       	std	Z+22, r24	; 0x16
    4054:	df 91       	pop	r29
    4056:	cf 91       	pop	r28
    4058:	1f 91       	pop	r17
    405a:	0f 91       	pop	r16
    405c:	08 95       	ret

0000405e <xTaskPriorityDisinherit>:
    405e:	0f 93       	push	r16
    4060:	1f 93       	push	r17
    4062:	cf 93       	push	r28
    4064:	df 93       	push	r29
    4066:	fc 01       	movw	r30, r24
    4068:	89 2b       	or	r24, r25
    406a:	79 f1       	breq	.+94     	; 0x40ca <xTaskPriorityDisinherit+0x6c>
    406c:	82 a1       	ldd	r24, Z+34	; 0x22
    406e:	81 50       	subi	r24, 0x01	; 1
    4070:	82 a3       	std	Z+34, r24	; 0x22
    4072:	26 89       	ldd	r18, Z+22	; 0x16
    4074:	91 a1       	ldd	r25, Z+33	; 0x21
    4076:	29 17       	cp	r18, r25
    4078:	51 f1       	breq	.+84     	; 0x40ce <xTaskPriorityDisinherit+0x70>
    407a:	81 11       	cpse	r24, r1
    407c:	2a c0       	rjmp	.+84     	; 0x40d2 <xTaskPriorityDisinherit+0x74>
    407e:	ef 01       	movw	r28, r30
    4080:	8f 01       	movw	r16, r30
    4082:	0e 5f       	subi	r16, 0xFE	; 254
    4084:	1f 4f       	sbci	r17, 0xFF	; 255
    4086:	c8 01       	movw	r24, r16
    4088:	0e 94 b1 17 	call	0x2f62	; 0x2f62 <uxListRemove>
    408c:	89 a1       	ldd	r24, Y+33	; 0x21
    408e:	8e 8b       	std	Y+22, r24	; 0x16
    4090:	24 e0       	ldi	r18, 0x04	; 4
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	28 1b       	sub	r18, r24
    4096:	31 09       	sbc	r19, r1
    4098:	3d 87       	std	Y+13, r19	; 0x0d
    409a:	2c 87       	std	Y+12, r18	; 0x0c
    409c:	90 91 4b 0f 	lds	r25, 0x0F4B	; 0x800f4b <uxTopReadyPriority>
    40a0:	98 17       	cp	r25, r24
    40a2:	10 f4       	brcc	.+4      	; 0x40a8 <xTaskPriorityDisinherit+0x4a>
    40a4:	80 93 4b 0f 	sts	0x0F4B, r24	; 0x800f4b <uxTopReadyPriority>
    40a8:	90 e0       	ldi	r25, 0x00	; 0
    40aa:	9c 01       	movw	r18, r24
    40ac:	22 0f       	add	r18, r18
    40ae:	33 1f       	adc	r19, r19
    40b0:	22 0f       	add	r18, r18
    40b2:	33 1f       	adc	r19, r19
    40b4:	22 0f       	add	r18, r18
    40b6:	33 1f       	adc	r19, r19
    40b8:	82 0f       	add	r24, r18
    40ba:	93 1f       	adc	r25, r19
    40bc:	b8 01       	movw	r22, r16
    40be:	8f 57       	subi	r24, 0x7F	; 127
    40c0:	90 4f       	sbci	r25, 0xF0	; 240
    40c2:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <vListInsertEnd>
    40c6:	81 e0       	ldi	r24, 0x01	; 1
    40c8:	05 c0       	rjmp	.+10     	; 0x40d4 <xTaskPriorityDisinherit+0x76>
    40ca:	80 e0       	ldi	r24, 0x00	; 0
    40cc:	03 c0       	rjmp	.+6      	; 0x40d4 <xTaskPriorityDisinherit+0x76>
    40ce:	80 e0       	ldi	r24, 0x00	; 0
    40d0:	01 c0       	rjmp	.+2      	; 0x40d4 <xTaskPriorityDisinherit+0x76>
    40d2:	80 e0       	ldi	r24, 0x00	; 0
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	1f 91       	pop	r17
    40da:	0f 91       	pop	r16
    40dc:	08 95       	ret

000040de <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    40de:	80 91 a5 0f 	lds	r24, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    40e2:	90 91 a6 0f 	lds	r25, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    40e6:	89 2b       	or	r24, r25
    40e8:	39 f0       	breq	.+14     	; 0x40f8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    40ea:	e0 91 a5 0f 	lds	r30, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    40ee:	f0 91 a6 0f 	lds	r31, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
    40f2:	82 a1       	ldd	r24, Z+34	; 0x22
    40f4:	8f 5f       	subi	r24, 0xFF	; 255
    40f6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    40f8:	80 91 a5 0f 	lds	r24, 0x0FA5	; 0x800fa5 <pxCurrentTCB>
    40fc:	90 91 a6 0f 	lds	r25, 0x0FA6	; 0x800fa6 <pxCurrentTCB+0x1>
	}
    4100:	08 95       	ret

00004102 <__subsf3>:
    4102:	50 58       	subi	r21, 0x80	; 128

00004104 <__addsf3>:
    4104:	bb 27       	eor	r27, r27
    4106:	aa 27       	eor	r26, r26
    4108:	0e d0       	rcall	.+28     	; 0x4126 <__addsf3x>
    410a:	75 c1       	rjmp	.+746    	; 0x43f6 <__fp_round>
    410c:	66 d1       	rcall	.+716    	; 0x43da <__fp_pscA>
    410e:	30 f0       	brcs	.+12     	; 0x411c <__addsf3+0x18>
    4110:	6b d1       	rcall	.+726    	; 0x43e8 <__fp_pscB>
    4112:	20 f0       	brcs	.+8      	; 0x411c <__addsf3+0x18>
    4114:	31 f4       	brne	.+12     	; 0x4122 <__addsf3+0x1e>
    4116:	9f 3f       	cpi	r25, 0xFF	; 255
    4118:	11 f4       	brne	.+4      	; 0x411e <__addsf3+0x1a>
    411a:	1e f4       	brtc	.+6      	; 0x4122 <__addsf3+0x1e>
    411c:	5b c1       	rjmp	.+694    	; 0x43d4 <__fp_nan>
    411e:	0e f4       	brtc	.+2      	; 0x4122 <__addsf3+0x1e>
    4120:	e0 95       	com	r30
    4122:	e7 fb       	bst	r30, 7
    4124:	51 c1       	rjmp	.+674    	; 0x43c8 <__fp_inf>

00004126 <__addsf3x>:
    4126:	e9 2f       	mov	r30, r25
    4128:	77 d1       	rcall	.+750    	; 0x4418 <__fp_split3>
    412a:	80 f3       	brcs	.-32     	; 0x410c <__addsf3+0x8>
    412c:	ba 17       	cp	r27, r26
    412e:	62 07       	cpc	r22, r18
    4130:	73 07       	cpc	r23, r19
    4132:	84 07       	cpc	r24, r20
    4134:	95 07       	cpc	r25, r21
    4136:	18 f0       	brcs	.+6      	; 0x413e <__addsf3x+0x18>
    4138:	71 f4       	brne	.+28     	; 0x4156 <__addsf3x+0x30>
    413a:	9e f5       	brtc	.+102    	; 0x41a2 <__addsf3x+0x7c>
    413c:	8f c1       	rjmp	.+798    	; 0x445c <__fp_zero>
    413e:	0e f4       	brtc	.+2      	; 0x4142 <__addsf3x+0x1c>
    4140:	e0 95       	com	r30
    4142:	0b 2e       	mov	r0, r27
    4144:	ba 2f       	mov	r27, r26
    4146:	a0 2d       	mov	r26, r0
    4148:	0b 01       	movw	r0, r22
    414a:	b9 01       	movw	r22, r18
    414c:	90 01       	movw	r18, r0
    414e:	0c 01       	movw	r0, r24
    4150:	ca 01       	movw	r24, r20
    4152:	a0 01       	movw	r20, r0
    4154:	11 24       	eor	r1, r1
    4156:	ff 27       	eor	r31, r31
    4158:	59 1b       	sub	r21, r25
    415a:	99 f0       	breq	.+38     	; 0x4182 <__addsf3x+0x5c>
    415c:	59 3f       	cpi	r21, 0xF9	; 249
    415e:	50 f4       	brcc	.+20     	; 0x4174 <__addsf3x+0x4e>
    4160:	50 3e       	cpi	r21, 0xE0	; 224
    4162:	68 f1       	brcs	.+90     	; 0x41be <__addsf3x+0x98>
    4164:	1a 16       	cp	r1, r26
    4166:	f0 40       	sbci	r31, 0x00	; 0
    4168:	a2 2f       	mov	r26, r18
    416a:	23 2f       	mov	r18, r19
    416c:	34 2f       	mov	r19, r20
    416e:	44 27       	eor	r20, r20
    4170:	58 5f       	subi	r21, 0xF8	; 248
    4172:	f3 cf       	rjmp	.-26     	; 0x415a <__addsf3x+0x34>
    4174:	46 95       	lsr	r20
    4176:	37 95       	ror	r19
    4178:	27 95       	ror	r18
    417a:	a7 95       	ror	r26
    417c:	f0 40       	sbci	r31, 0x00	; 0
    417e:	53 95       	inc	r21
    4180:	c9 f7       	brne	.-14     	; 0x4174 <__addsf3x+0x4e>
    4182:	7e f4       	brtc	.+30     	; 0x41a2 <__addsf3x+0x7c>
    4184:	1f 16       	cp	r1, r31
    4186:	ba 0b       	sbc	r27, r26
    4188:	62 0b       	sbc	r22, r18
    418a:	73 0b       	sbc	r23, r19
    418c:	84 0b       	sbc	r24, r20
    418e:	ba f0       	brmi	.+46     	; 0x41be <__addsf3x+0x98>
    4190:	91 50       	subi	r25, 0x01	; 1
    4192:	a1 f0       	breq	.+40     	; 0x41bc <__addsf3x+0x96>
    4194:	ff 0f       	add	r31, r31
    4196:	bb 1f       	adc	r27, r27
    4198:	66 1f       	adc	r22, r22
    419a:	77 1f       	adc	r23, r23
    419c:	88 1f       	adc	r24, r24
    419e:	c2 f7       	brpl	.-16     	; 0x4190 <__addsf3x+0x6a>
    41a0:	0e c0       	rjmp	.+28     	; 0x41be <__addsf3x+0x98>
    41a2:	ba 0f       	add	r27, r26
    41a4:	62 1f       	adc	r22, r18
    41a6:	73 1f       	adc	r23, r19
    41a8:	84 1f       	adc	r24, r20
    41aa:	48 f4       	brcc	.+18     	; 0x41be <__addsf3x+0x98>
    41ac:	87 95       	ror	r24
    41ae:	77 95       	ror	r23
    41b0:	67 95       	ror	r22
    41b2:	b7 95       	ror	r27
    41b4:	f7 95       	ror	r31
    41b6:	9e 3f       	cpi	r25, 0xFE	; 254
    41b8:	08 f0       	brcs	.+2      	; 0x41bc <__addsf3x+0x96>
    41ba:	b3 cf       	rjmp	.-154    	; 0x4122 <__addsf3+0x1e>
    41bc:	93 95       	inc	r25
    41be:	88 0f       	add	r24, r24
    41c0:	08 f0       	brcs	.+2      	; 0x41c4 <__addsf3x+0x9e>
    41c2:	99 27       	eor	r25, r25
    41c4:	ee 0f       	add	r30, r30
    41c6:	97 95       	ror	r25
    41c8:	87 95       	ror	r24
    41ca:	08 95       	ret

000041cc <__cmpsf2>:
    41cc:	d9 d0       	rcall	.+434    	; 0x4380 <__fp_cmp>
    41ce:	08 f4       	brcc	.+2      	; 0x41d2 <__cmpsf2+0x6>
    41d0:	81 e0       	ldi	r24, 0x01	; 1
    41d2:	08 95       	ret

000041d4 <__divsf3>:
    41d4:	0c d0       	rcall	.+24     	; 0x41ee <__divsf3x>
    41d6:	0f c1       	rjmp	.+542    	; 0x43f6 <__fp_round>
    41d8:	07 d1       	rcall	.+526    	; 0x43e8 <__fp_pscB>
    41da:	40 f0       	brcs	.+16     	; 0x41ec <__divsf3+0x18>
    41dc:	fe d0       	rcall	.+508    	; 0x43da <__fp_pscA>
    41de:	30 f0       	brcs	.+12     	; 0x41ec <__divsf3+0x18>
    41e0:	21 f4       	brne	.+8      	; 0x41ea <__divsf3+0x16>
    41e2:	5f 3f       	cpi	r21, 0xFF	; 255
    41e4:	19 f0       	breq	.+6      	; 0x41ec <__divsf3+0x18>
    41e6:	f0 c0       	rjmp	.+480    	; 0x43c8 <__fp_inf>
    41e8:	51 11       	cpse	r21, r1
    41ea:	39 c1       	rjmp	.+626    	; 0x445e <__fp_szero>
    41ec:	f3 c0       	rjmp	.+486    	; 0x43d4 <__fp_nan>

000041ee <__divsf3x>:
    41ee:	14 d1       	rcall	.+552    	; 0x4418 <__fp_split3>
    41f0:	98 f3       	brcs	.-26     	; 0x41d8 <__divsf3+0x4>

000041f2 <__divsf3_pse>:
    41f2:	99 23       	and	r25, r25
    41f4:	c9 f3       	breq	.-14     	; 0x41e8 <__divsf3+0x14>
    41f6:	55 23       	and	r21, r21
    41f8:	b1 f3       	breq	.-20     	; 0x41e6 <__divsf3+0x12>
    41fa:	95 1b       	sub	r25, r21
    41fc:	55 0b       	sbc	r21, r21
    41fe:	bb 27       	eor	r27, r27
    4200:	aa 27       	eor	r26, r26
    4202:	62 17       	cp	r22, r18
    4204:	73 07       	cpc	r23, r19
    4206:	84 07       	cpc	r24, r20
    4208:	38 f0       	brcs	.+14     	; 0x4218 <__divsf3_pse+0x26>
    420a:	9f 5f       	subi	r25, 0xFF	; 255
    420c:	5f 4f       	sbci	r21, 0xFF	; 255
    420e:	22 0f       	add	r18, r18
    4210:	33 1f       	adc	r19, r19
    4212:	44 1f       	adc	r20, r20
    4214:	aa 1f       	adc	r26, r26
    4216:	a9 f3       	breq	.-22     	; 0x4202 <__divsf3_pse+0x10>
    4218:	33 d0       	rcall	.+102    	; 0x4280 <__divsf3_pse+0x8e>
    421a:	0e 2e       	mov	r0, r30
    421c:	3a f0       	brmi	.+14     	; 0x422c <__divsf3_pse+0x3a>
    421e:	e0 e8       	ldi	r30, 0x80	; 128
    4220:	30 d0       	rcall	.+96     	; 0x4282 <__divsf3_pse+0x90>
    4222:	91 50       	subi	r25, 0x01	; 1
    4224:	50 40       	sbci	r21, 0x00	; 0
    4226:	e6 95       	lsr	r30
    4228:	00 1c       	adc	r0, r0
    422a:	ca f7       	brpl	.-14     	; 0x421e <__divsf3_pse+0x2c>
    422c:	29 d0       	rcall	.+82     	; 0x4280 <__divsf3_pse+0x8e>
    422e:	fe 2f       	mov	r31, r30
    4230:	27 d0       	rcall	.+78     	; 0x4280 <__divsf3_pse+0x8e>
    4232:	66 0f       	add	r22, r22
    4234:	77 1f       	adc	r23, r23
    4236:	88 1f       	adc	r24, r24
    4238:	bb 1f       	adc	r27, r27
    423a:	26 17       	cp	r18, r22
    423c:	37 07       	cpc	r19, r23
    423e:	48 07       	cpc	r20, r24
    4240:	ab 07       	cpc	r26, r27
    4242:	b0 e8       	ldi	r27, 0x80	; 128
    4244:	09 f0       	breq	.+2      	; 0x4248 <__divsf3_pse+0x56>
    4246:	bb 0b       	sbc	r27, r27
    4248:	80 2d       	mov	r24, r0
    424a:	bf 01       	movw	r22, r30
    424c:	ff 27       	eor	r31, r31
    424e:	93 58       	subi	r25, 0x83	; 131
    4250:	5f 4f       	sbci	r21, 0xFF	; 255
    4252:	2a f0       	brmi	.+10     	; 0x425e <__divsf3_pse+0x6c>
    4254:	9e 3f       	cpi	r25, 0xFE	; 254
    4256:	51 05       	cpc	r21, r1
    4258:	68 f0       	brcs	.+26     	; 0x4274 <__divsf3_pse+0x82>
    425a:	b6 c0       	rjmp	.+364    	; 0x43c8 <__fp_inf>
    425c:	00 c1       	rjmp	.+512    	; 0x445e <__fp_szero>
    425e:	5f 3f       	cpi	r21, 0xFF	; 255
    4260:	ec f3       	brlt	.-6      	; 0x425c <__divsf3_pse+0x6a>
    4262:	98 3e       	cpi	r25, 0xE8	; 232
    4264:	dc f3       	brlt	.-10     	; 0x425c <__divsf3_pse+0x6a>
    4266:	86 95       	lsr	r24
    4268:	77 95       	ror	r23
    426a:	67 95       	ror	r22
    426c:	b7 95       	ror	r27
    426e:	f7 95       	ror	r31
    4270:	9f 5f       	subi	r25, 0xFF	; 255
    4272:	c9 f7       	brne	.-14     	; 0x4266 <__divsf3_pse+0x74>
    4274:	88 0f       	add	r24, r24
    4276:	91 1d       	adc	r25, r1
    4278:	96 95       	lsr	r25
    427a:	87 95       	ror	r24
    427c:	97 f9       	bld	r25, 7
    427e:	08 95       	ret
    4280:	e1 e0       	ldi	r30, 0x01	; 1
    4282:	66 0f       	add	r22, r22
    4284:	77 1f       	adc	r23, r23
    4286:	88 1f       	adc	r24, r24
    4288:	bb 1f       	adc	r27, r27
    428a:	62 17       	cp	r22, r18
    428c:	73 07       	cpc	r23, r19
    428e:	84 07       	cpc	r24, r20
    4290:	ba 07       	cpc	r27, r26
    4292:	20 f0       	brcs	.+8      	; 0x429c <__divsf3_pse+0xaa>
    4294:	62 1b       	sub	r22, r18
    4296:	73 0b       	sbc	r23, r19
    4298:	84 0b       	sbc	r24, r20
    429a:	ba 0b       	sbc	r27, r26
    429c:	ee 1f       	adc	r30, r30
    429e:	88 f7       	brcc	.-30     	; 0x4282 <__divsf3_pse+0x90>
    42a0:	e0 95       	com	r30
    42a2:	08 95       	ret

000042a4 <__fixsfsi>:
    42a4:	04 d0       	rcall	.+8      	; 0x42ae <__fixunssfsi>
    42a6:	68 94       	set
    42a8:	b1 11       	cpse	r27, r1
    42aa:	d9 c0       	rjmp	.+434    	; 0x445e <__fp_szero>
    42ac:	08 95       	ret

000042ae <__fixunssfsi>:
    42ae:	bc d0       	rcall	.+376    	; 0x4428 <__fp_splitA>
    42b0:	88 f0       	brcs	.+34     	; 0x42d4 <__fixunssfsi+0x26>
    42b2:	9f 57       	subi	r25, 0x7F	; 127
    42b4:	90 f0       	brcs	.+36     	; 0x42da <__fixunssfsi+0x2c>
    42b6:	b9 2f       	mov	r27, r25
    42b8:	99 27       	eor	r25, r25
    42ba:	b7 51       	subi	r27, 0x17	; 23
    42bc:	a0 f0       	brcs	.+40     	; 0x42e6 <__fixunssfsi+0x38>
    42be:	d1 f0       	breq	.+52     	; 0x42f4 <__fixunssfsi+0x46>
    42c0:	66 0f       	add	r22, r22
    42c2:	77 1f       	adc	r23, r23
    42c4:	88 1f       	adc	r24, r24
    42c6:	99 1f       	adc	r25, r25
    42c8:	1a f0       	brmi	.+6      	; 0x42d0 <__fixunssfsi+0x22>
    42ca:	ba 95       	dec	r27
    42cc:	c9 f7       	brne	.-14     	; 0x42c0 <__fixunssfsi+0x12>
    42ce:	12 c0       	rjmp	.+36     	; 0x42f4 <__fixunssfsi+0x46>
    42d0:	b1 30       	cpi	r27, 0x01	; 1
    42d2:	81 f0       	breq	.+32     	; 0x42f4 <__fixunssfsi+0x46>
    42d4:	c3 d0       	rcall	.+390    	; 0x445c <__fp_zero>
    42d6:	b1 e0       	ldi	r27, 0x01	; 1
    42d8:	08 95       	ret
    42da:	c0 c0       	rjmp	.+384    	; 0x445c <__fp_zero>
    42dc:	67 2f       	mov	r22, r23
    42de:	78 2f       	mov	r23, r24
    42e0:	88 27       	eor	r24, r24
    42e2:	b8 5f       	subi	r27, 0xF8	; 248
    42e4:	39 f0       	breq	.+14     	; 0x42f4 <__fixunssfsi+0x46>
    42e6:	b9 3f       	cpi	r27, 0xF9	; 249
    42e8:	cc f3       	brlt	.-14     	; 0x42dc <__fixunssfsi+0x2e>
    42ea:	86 95       	lsr	r24
    42ec:	77 95       	ror	r23
    42ee:	67 95       	ror	r22
    42f0:	b3 95       	inc	r27
    42f2:	d9 f7       	brne	.-10     	; 0x42ea <__fixunssfsi+0x3c>
    42f4:	3e f4       	brtc	.+14     	; 0x4304 <__fixunssfsi+0x56>
    42f6:	90 95       	com	r25
    42f8:	80 95       	com	r24
    42fa:	70 95       	com	r23
    42fc:	61 95       	neg	r22
    42fe:	7f 4f       	sbci	r23, 0xFF	; 255
    4300:	8f 4f       	sbci	r24, 0xFF	; 255
    4302:	9f 4f       	sbci	r25, 0xFF	; 255
    4304:	08 95       	ret

00004306 <__floatunsisf>:
    4306:	e8 94       	clt
    4308:	09 c0       	rjmp	.+18     	; 0x431c <__floatsisf+0x12>

0000430a <__floatsisf>:
    430a:	97 fb       	bst	r25, 7
    430c:	3e f4       	brtc	.+14     	; 0x431c <__floatsisf+0x12>
    430e:	90 95       	com	r25
    4310:	80 95       	com	r24
    4312:	70 95       	com	r23
    4314:	61 95       	neg	r22
    4316:	7f 4f       	sbci	r23, 0xFF	; 255
    4318:	8f 4f       	sbci	r24, 0xFF	; 255
    431a:	9f 4f       	sbci	r25, 0xFF	; 255
    431c:	99 23       	and	r25, r25
    431e:	a9 f0       	breq	.+42     	; 0x434a <__floatsisf+0x40>
    4320:	f9 2f       	mov	r31, r25
    4322:	96 e9       	ldi	r25, 0x96	; 150
    4324:	bb 27       	eor	r27, r27
    4326:	93 95       	inc	r25
    4328:	f6 95       	lsr	r31
    432a:	87 95       	ror	r24
    432c:	77 95       	ror	r23
    432e:	67 95       	ror	r22
    4330:	b7 95       	ror	r27
    4332:	f1 11       	cpse	r31, r1
    4334:	f8 cf       	rjmp	.-16     	; 0x4326 <__floatsisf+0x1c>
    4336:	fa f4       	brpl	.+62     	; 0x4376 <__floatsisf+0x6c>
    4338:	bb 0f       	add	r27, r27
    433a:	11 f4       	brne	.+4      	; 0x4340 <__floatsisf+0x36>
    433c:	60 ff       	sbrs	r22, 0
    433e:	1b c0       	rjmp	.+54     	; 0x4376 <__floatsisf+0x6c>
    4340:	6f 5f       	subi	r22, 0xFF	; 255
    4342:	7f 4f       	sbci	r23, 0xFF	; 255
    4344:	8f 4f       	sbci	r24, 0xFF	; 255
    4346:	9f 4f       	sbci	r25, 0xFF	; 255
    4348:	16 c0       	rjmp	.+44     	; 0x4376 <__floatsisf+0x6c>
    434a:	88 23       	and	r24, r24
    434c:	11 f0       	breq	.+4      	; 0x4352 <__floatsisf+0x48>
    434e:	96 e9       	ldi	r25, 0x96	; 150
    4350:	11 c0       	rjmp	.+34     	; 0x4374 <__floatsisf+0x6a>
    4352:	77 23       	and	r23, r23
    4354:	21 f0       	breq	.+8      	; 0x435e <__floatsisf+0x54>
    4356:	9e e8       	ldi	r25, 0x8E	; 142
    4358:	87 2f       	mov	r24, r23
    435a:	76 2f       	mov	r23, r22
    435c:	05 c0       	rjmp	.+10     	; 0x4368 <__floatsisf+0x5e>
    435e:	66 23       	and	r22, r22
    4360:	71 f0       	breq	.+28     	; 0x437e <__floatsisf+0x74>
    4362:	96 e8       	ldi	r25, 0x86	; 134
    4364:	86 2f       	mov	r24, r22
    4366:	70 e0       	ldi	r23, 0x00	; 0
    4368:	60 e0       	ldi	r22, 0x00	; 0
    436a:	2a f0       	brmi	.+10     	; 0x4376 <__floatsisf+0x6c>
    436c:	9a 95       	dec	r25
    436e:	66 0f       	add	r22, r22
    4370:	77 1f       	adc	r23, r23
    4372:	88 1f       	adc	r24, r24
    4374:	da f7       	brpl	.-10     	; 0x436c <__floatsisf+0x62>
    4376:	88 0f       	add	r24, r24
    4378:	96 95       	lsr	r25
    437a:	87 95       	ror	r24
    437c:	97 f9       	bld	r25, 7
    437e:	08 95       	ret

00004380 <__fp_cmp>:
    4380:	99 0f       	add	r25, r25
    4382:	00 08       	sbc	r0, r0
    4384:	55 0f       	add	r21, r21
    4386:	aa 0b       	sbc	r26, r26
    4388:	e0 e8       	ldi	r30, 0x80	; 128
    438a:	fe ef       	ldi	r31, 0xFE	; 254
    438c:	16 16       	cp	r1, r22
    438e:	17 06       	cpc	r1, r23
    4390:	e8 07       	cpc	r30, r24
    4392:	f9 07       	cpc	r31, r25
    4394:	c0 f0       	brcs	.+48     	; 0x43c6 <__fp_cmp+0x46>
    4396:	12 16       	cp	r1, r18
    4398:	13 06       	cpc	r1, r19
    439a:	e4 07       	cpc	r30, r20
    439c:	f5 07       	cpc	r31, r21
    439e:	98 f0       	brcs	.+38     	; 0x43c6 <__fp_cmp+0x46>
    43a0:	62 1b       	sub	r22, r18
    43a2:	73 0b       	sbc	r23, r19
    43a4:	84 0b       	sbc	r24, r20
    43a6:	95 0b       	sbc	r25, r21
    43a8:	39 f4       	brne	.+14     	; 0x43b8 <__fp_cmp+0x38>
    43aa:	0a 26       	eor	r0, r26
    43ac:	61 f0       	breq	.+24     	; 0x43c6 <__fp_cmp+0x46>
    43ae:	23 2b       	or	r18, r19
    43b0:	24 2b       	or	r18, r20
    43b2:	25 2b       	or	r18, r21
    43b4:	21 f4       	brne	.+8      	; 0x43be <__fp_cmp+0x3e>
    43b6:	08 95       	ret
    43b8:	0a 26       	eor	r0, r26
    43ba:	09 f4       	brne	.+2      	; 0x43be <__fp_cmp+0x3e>
    43bc:	a1 40       	sbci	r26, 0x01	; 1
    43be:	a6 95       	lsr	r26
    43c0:	8f ef       	ldi	r24, 0xFF	; 255
    43c2:	81 1d       	adc	r24, r1
    43c4:	81 1d       	adc	r24, r1
    43c6:	08 95       	ret

000043c8 <__fp_inf>:
    43c8:	97 f9       	bld	r25, 7
    43ca:	9f 67       	ori	r25, 0x7F	; 127
    43cc:	80 e8       	ldi	r24, 0x80	; 128
    43ce:	70 e0       	ldi	r23, 0x00	; 0
    43d0:	60 e0       	ldi	r22, 0x00	; 0
    43d2:	08 95       	ret

000043d4 <__fp_nan>:
    43d4:	9f ef       	ldi	r25, 0xFF	; 255
    43d6:	80 ec       	ldi	r24, 0xC0	; 192
    43d8:	08 95       	ret

000043da <__fp_pscA>:
    43da:	00 24       	eor	r0, r0
    43dc:	0a 94       	dec	r0
    43de:	16 16       	cp	r1, r22
    43e0:	17 06       	cpc	r1, r23
    43e2:	18 06       	cpc	r1, r24
    43e4:	09 06       	cpc	r0, r25
    43e6:	08 95       	ret

000043e8 <__fp_pscB>:
    43e8:	00 24       	eor	r0, r0
    43ea:	0a 94       	dec	r0
    43ec:	12 16       	cp	r1, r18
    43ee:	13 06       	cpc	r1, r19
    43f0:	14 06       	cpc	r1, r20
    43f2:	05 06       	cpc	r0, r21
    43f4:	08 95       	ret

000043f6 <__fp_round>:
    43f6:	09 2e       	mov	r0, r25
    43f8:	03 94       	inc	r0
    43fa:	00 0c       	add	r0, r0
    43fc:	11 f4       	brne	.+4      	; 0x4402 <__fp_round+0xc>
    43fe:	88 23       	and	r24, r24
    4400:	52 f0       	brmi	.+20     	; 0x4416 <__fp_round+0x20>
    4402:	bb 0f       	add	r27, r27
    4404:	40 f4       	brcc	.+16     	; 0x4416 <__fp_round+0x20>
    4406:	bf 2b       	or	r27, r31
    4408:	11 f4       	brne	.+4      	; 0x440e <__fp_round+0x18>
    440a:	60 ff       	sbrs	r22, 0
    440c:	04 c0       	rjmp	.+8      	; 0x4416 <__fp_round+0x20>
    440e:	6f 5f       	subi	r22, 0xFF	; 255
    4410:	7f 4f       	sbci	r23, 0xFF	; 255
    4412:	8f 4f       	sbci	r24, 0xFF	; 255
    4414:	9f 4f       	sbci	r25, 0xFF	; 255
    4416:	08 95       	ret

00004418 <__fp_split3>:
    4418:	57 fd       	sbrc	r21, 7
    441a:	90 58       	subi	r25, 0x80	; 128
    441c:	44 0f       	add	r20, r20
    441e:	55 1f       	adc	r21, r21
    4420:	59 f0       	breq	.+22     	; 0x4438 <__fp_splitA+0x10>
    4422:	5f 3f       	cpi	r21, 0xFF	; 255
    4424:	71 f0       	breq	.+28     	; 0x4442 <__fp_splitA+0x1a>
    4426:	47 95       	ror	r20

00004428 <__fp_splitA>:
    4428:	88 0f       	add	r24, r24
    442a:	97 fb       	bst	r25, 7
    442c:	99 1f       	adc	r25, r25
    442e:	61 f0       	breq	.+24     	; 0x4448 <__fp_splitA+0x20>
    4430:	9f 3f       	cpi	r25, 0xFF	; 255
    4432:	79 f0       	breq	.+30     	; 0x4452 <__fp_splitA+0x2a>
    4434:	87 95       	ror	r24
    4436:	08 95       	ret
    4438:	12 16       	cp	r1, r18
    443a:	13 06       	cpc	r1, r19
    443c:	14 06       	cpc	r1, r20
    443e:	55 1f       	adc	r21, r21
    4440:	f2 cf       	rjmp	.-28     	; 0x4426 <__fp_split3+0xe>
    4442:	46 95       	lsr	r20
    4444:	f1 df       	rcall	.-30     	; 0x4428 <__fp_splitA>
    4446:	08 c0       	rjmp	.+16     	; 0x4458 <__fp_splitA+0x30>
    4448:	16 16       	cp	r1, r22
    444a:	17 06       	cpc	r1, r23
    444c:	18 06       	cpc	r1, r24
    444e:	99 1f       	adc	r25, r25
    4450:	f1 cf       	rjmp	.-30     	; 0x4434 <__fp_splitA+0xc>
    4452:	86 95       	lsr	r24
    4454:	71 05       	cpc	r23, r1
    4456:	61 05       	cpc	r22, r1
    4458:	08 94       	sec
    445a:	08 95       	ret

0000445c <__fp_zero>:
    445c:	e8 94       	clt

0000445e <__fp_szero>:
    445e:	bb 27       	eor	r27, r27
    4460:	66 27       	eor	r22, r22
    4462:	77 27       	eor	r23, r23
    4464:	cb 01       	movw	r24, r22
    4466:	97 f9       	bld	r25, 7
    4468:	08 95       	ret

0000446a <__gesf2>:
    446a:	8a df       	rcall	.-236    	; 0x4380 <__fp_cmp>
    446c:	08 f4       	brcc	.+2      	; 0x4470 <__gesf2+0x6>
    446e:	8f ef       	ldi	r24, 0xFF	; 255
    4470:	08 95       	ret

00004472 <__mulsf3>:
    4472:	0b d0       	rcall	.+22     	; 0x448a <__mulsf3x>
    4474:	c0 cf       	rjmp	.-128    	; 0x43f6 <__fp_round>
    4476:	b1 df       	rcall	.-158    	; 0x43da <__fp_pscA>
    4478:	28 f0       	brcs	.+10     	; 0x4484 <__mulsf3+0x12>
    447a:	b6 df       	rcall	.-148    	; 0x43e8 <__fp_pscB>
    447c:	18 f0       	brcs	.+6      	; 0x4484 <__mulsf3+0x12>
    447e:	95 23       	and	r25, r21
    4480:	09 f0       	breq	.+2      	; 0x4484 <__mulsf3+0x12>
    4482:	a2 cf       	rjmp	.-188    	; 0x43c8 <__fp_inf>
    4484:	a7 cf       	rjmp	.-178    	; 0x43d4 <__fp_nan>
    4486:	11 24       	eor	r1, r1
    4488:	ea cf       	rjmp	.-44     	; 0x445e <__fp_szero>

0000448a <__mulsf3x>:
    448a:	c6 df       	rcall	.-116    	; 0x4418 <__fp_split3>
    448c:	a0 f3       	brcs	.-24     	; 0x4476 <__mulsf3+0x4>

0000448e <__mulsf3_pse>:
    448e:	95 9f       	mul	r25, r21
    4490:	d1 f3       	breq	.-12     	; 0x4486 <__mulsf3+0x14>
    4492:	95 0f       	add	r25, r21
    4494:	50 e0       	ldi	r21, 0x00	; 0
    4496:	55 1f       	adc	r21, r21
    4498:	62 9f       	mul	r22, r18
    449a:	f0 01       	movw	r30, r0
    449c:	72 9f       	mul	r23, r18
    449e:	bb 27       	eor	r27, r27
    44a0:	f0 0d       	add	r31, r0
    44a2:	b1 1d       	adc	r27, r1
    44a4:	63 9f       	mul	r22, r19
    44a6:	aa 27       	eor	r26, r26
    44a8:	f0 0d       	add	r31, r0
    44aa:	b1 1d       	adc	r27, r1
    44ac:	aa 1f       	adc	r26, r26
    44ae:	64 9f       	mul	r22, r20
    44b0:	66 27       	eor	r22, r22
    44b2:	b0 0d       	add	r27, r0
    44b4:	a1 1d       	adc	r26, r1
    44b6:	66 1f       	adc	r22, r22
    44b8:	82 9f       	mul	r24, r18
    44ba:	22 27       	eor	r18, r18
    44bc:	b0 0d       	add	r27, r0
    44be:	a1 1d       	adc	r26, r1
    44c0:	62 1f       	adc	r22, r18
    44c2:	73 9f       	mul	r23, r19
    44c4:	b0 0d       	add	r27, r0
    44c6:	a1 1d       	adc	r26, r1
    44c8:	62 1f       	adc	r22, r18
    44ca:	83 9f       	mul	r24, r19
    44cc:	a0 0d       	add	r26, r0
    44ce:	61 1d       	adc	r22, r1
    44d0:	22 1f       	adc	r18, r18
    44d2:	74 9f       	mul	r23, r20
    44d4:	33 27       	eor	r19, r19
    44d6:	a0 0d       	add	r26, r0
    44d8:	61 1d       	adc	r22, r1
    44da:	23 1f       	adc	r18, r19
    44dc:	84 9f       	mul	r24, r20
    44de:	60 0d       	add	r22, r0
    44e0:	21 1d       	adc	r18, r1
    44e2:	82 2f       	mov	r24, r18
    44e4:	76 2f       	mov	r23, r22
    44e6:	6a 2f       	mov	r22, r26
    44e8:	11 24       	eor	r1, r1
    44ea:	9f 57       	subi	r25, 0x7F	; 127
    44ec:	50 40       	sbci	r21, 0x00	; 0
    44ee:	8a f0       	brmi	.+34     	; 0x4512 <__mulsf3_pse+0x84>
    44f0:	e1 f0       	breq	.+56     	; 0x452a <__mulsf3_pse+0x9c>
    44f2:	88 23       	and	r24, r24
    44f4:	4a f0       	brmi	.+18     	; 0x4508 <__mulsf3_pse+0x7a>
    44f6:	ee 0f       	add	r30, r30
    44f8:	ff 1f       	adc	r31, r31
    44fa:	bb 1f       	adc	r27, r27
    44fc:	66 1f       	adc	r22, r22
    44fe:	77 1f       	adc	r23, r23
    4500:	88 1f       	adc	r24, r24
    4502:	91 50       	subi	r25, 0x01	; 1
    4504:	50 40       	sbci	r21, 0x00	; 0
    4506:	a9 f7       	brne	.-22     	; 0x44f2 <__mulsf3_pse+0x64>
    4508:	9e 3f       	cpi	r25, 0xFE	; 254
    450a:	51 05       	cpc	r21, r1
    450c:	70 f0       	brcs	.+28     	; 0x452a <__mulsf3_pse+0x9c>
    450e:	5c cf       	rjmp	.-328    	; 0x43c8 <__fp_inf>
    4510:	a6 cf       	rjmp	.-180    	; 0x445e <__fp_szero>
    4512:	5f 3f       	cpi	r21, 0xFF	; 255
    4514:	ec f3       	brlt	.-6      	; 0x4510 <__mulsf3_pse+0x82>
    4516:	98 3e       	cpi	r25, 0xE8	; 232
    4518:	dc f3       	brlt	.-10     	; 0x4510 <__mulsf3_pse+0x82>
    451a:	86 95       	lsr	r24
    451c:	77 95       	ror	r23
    451e:	67 95       	ror	r22
    4520:	b7 95       	ror	r27
    4522:	f7 95       	ror	r31
    4524:	e7 95       	ror	r30
    4526:	9f 5f       	subi	r25, 0xFF	; 255
    4528:	c1 f7       	brne	.-16     	; 0x451a <__mulsf3_pse+0x8c>
    452a:	fe 2b       	or	r31, r30
    452c:	88 0f       	add	r24, r24
    452e:	91 1d       	adc	r25, r1
    4530:	96 95       	lsr	r25
    4532:	87 95       	ror	r24
    4534:	97 f9       	bld	r25, 7
    4536:	08 95       	ret

00004538 <__udivmodsi4>:
    4538:	a1 e2       	ldi	r26, 0x21	; 33
    453a:	1a 2e       	mov	r1, r26
    453c:	aa 1b       	sub	r26, r26
    453e:	bb 1b       	sub	r27, r27
    4540:	fd 01       	movw	r30, r26
    4542:	0d c0       	rjmp	.+26     	; 0x455e <__udivmodsi4_ep>

00004544 <__udivmodsi4_loop>:
    4544:	aa 1f       	adc	r26, r26
    4546:	bb 1f       	adc	r27, r27
    4548:	ee 1f       	adc	r30, r30
    454a:	ff 1f       	adc	r31, r31
    454c:	a2 17       	cp	r26, r18
    454e:	b3 07       	cpc	r27, r19
    4550:	e4 07       	cpc	r30, r20
    4552:	f5 07       	cpc	r31, r21
    4554:	20 f0       	brcs	.+8      	; 0x455e <__udivmodsi4_ep>
    4556:	a2 1b       	sub	r26, r18
    4558:	b3 0b       	sbc	r27, r19
    455a:	e4 0b       	sbc	r30, r20
    455c:	f5 0b       	sbc	r31, r21

0000455e <__udivmodsi4_ep>:
    455e:	66 1f       	adc	r22, r22
    4560:	77 1f       	adc	r23, r23
    4562:	88 1f       	adc	r24, r24
    4564:	99 1f       	adc	r25, r25
    4566:	1a 94       	dec	r1
    4568:	69 f7       	brne	.-38     	; 0x4544 <__udivmodsi4_loop>
    456a:	60 95       	com	r22
    456c:	70 95       	com	r23
    456e:	80 95       	com	r24
    4570:	90 95       	com	r25
    4572:	9b 01       	movw	r18, r22
    4574:	ac 01       	movw	r20, r24
    4576:	bd 01       	movw	r22, r26
    4578:	cf 01       	movw	r24, r30
    457a:	08 95       	ret

0000457c <__umulhisi3>:
    457c:	a2 9f       	mul	r26, r18
    457e:	b0 01       	movw	r22, r0
    4580:	b3 9f       	mul	r27, r19
    4582:	c0 01       	movw	r24, r0
    4584:	a3 9f       	mul	r26, r19
    4586:	70 0d       	add	r23, r0
    4588:	81 1d       	adc	r24, r1
    458a:	11 24       	eor	r1, r1
    458c:	91 1d       	adc	r25, r1
    458e:	b2 9f       	mul	r27, r18
    4590:	70 0d       	add	r23, r0
    4592:	81 1d       	adc	r24, r1
    4594:	11 24       	eor	r1, r1
    4596:	91 1d       	adc	r25, r1
    4598:	08 95       	ret

0000459a <memcpy>:
    459a:	fb 01       	movw	r30, r22
    459c:	dc 01       	movw	r26, r24
    459e:	02 c0       	rjmp	.+4      	; 0x45a4 <memcpy+0xa>
    45a0:	01 90       	ld	r0, Z+
    45a2:	0d 92       	st	X+, r0
    45a4:	41 50       	subi	r20, 0x01	; 1
    45a6:	50 40       	sbci	r21, 0x00	; 0
    45a8:	d8 f7       	brcc	.-10     	; 0x45a0 <memcpy+0x6>
    45aa:	08 95       	ret

000045ac <eeprom_read_byte>:
    45ac:	e1 99       	sbic	0x1c, 1	; 28
    45ae:	fe cf       	rjmp	.-4      	; 0x45ac <eeprom_read_byte>
    45b0:	9f bb       	out	0x1f, r25	; 31
    45b2:	8e bb       	out	0x1e, r24	; 30
    45b4:	e0 9a       	sbi	0x1c, 0	; 28
    45b6:	99 27       	eor	r25, r25
    45b8:	8d b3       	in	r24, 0x1d	; 29
    45ba:	08 95       	ret

000045bc <eeprom_update_byte>:
    45bc:	26 2f       	mov	r18, r22

000045be <eeprom_update_r18>:
    45be:	e1 99       	sbic	0x1c, 1	; 28
    45c0:	fe cf       	rjmp	.-4      	; 0x45be <eeprom_update_r18>
    45c2:	9f bb       	out	0x1f, r25	; 31
    45c4:	8e bb       	out	0x1e, r24	; 30
    45c6:	e0 9a       	sbi	0x1c, 0	; 28
    45c8:	01 97       	sbiw	r24, 0x01	; 1
    45ca:	0d b2       	in	r0, 0x1d	; 29
    45cc:	02 16       	cp	r0, r18
    45ce:	31 f0       	breq	.+12     	; 0x45dc <eeprom_update_r18+0x1e>
    45d0:	2d bb       	out	0x1d, r18	; 29
    45d2:	0f b6       	in	r0, 0x3f	; 63
    45d4:	f8 94       	cli
    45d6:	e2 9a       	sbi	0x1c, 2	; 28
    45d8:	e1 9a       	sbi	0x1c, 1	; 28
    45da:	0f be       	out	0x3f, r0	; 63
    45dc:	08 95       	ret

000045de <_exit>:
    45de:	f8 94       	cli

000045e0 <__stop_program>:
    45e0:	ff cf       	rjmp	.-2      	; 0x45e0 <__stop_program>
