
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ac  00800100  00003148  000031dc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003148  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000afc  008001ac  008001ac  00003288  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003288  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000032b8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000940  00000000  00000000  000032f8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b9c0  00000000  00000000  00003c38  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000322c  00000000  00000000  0000f5f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000052fc  00000000  00000000  00012824  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000189c  00000000  00000000  00017b20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000033af  00000000  00000000  000193bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007f68  00000000  00000000  0001c76b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000930  00000000  00000000  000246d3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	8a c3       	rjmp	.+1812   	; 0x71a <__vector_1>
       6:	00 00       	nop
       8:	60 c0       	rjmp	.+192    	; 0xca <__bad_interrupt>
       a:	00 00       	nop
       c:	5e c0       	rjmp	.+188    	; 0xca <__bad_interrupt>
       e:	00 00       	nop
      10:	5c c0       	rjmp	.+184    	; 0xca <__bad_interrupt>
      12:	00 00       	nop
      14:	5a c0       	rjmp	.+180    	; 0xca <__bad_interrupt>
      16:	00 00       	nop
      18:	58 c0       	rjmp	.+176    	; 0xca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	56 c0       	rjmp	.+172    	; 0xca <__bad_interrupt>
      1e:	00 00       	nop
      20:	54 c0       	rjmp	.+168    	; 0xca <__bad_interrupt>
      22:	00 00       	nop
      24:	4d c4       	rjmp	.+2202   	; 0x8c0 <__vector_9>
      26:	00 00       	nop
      28:	50 c0       	rjmp	.+160    	; 0xca <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4e c0       	rjmp	.+156    	; 0xca <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <__vector_12>
      34:	4a c0       	rjmp	.+148    	; 0xca <__bad_interrupt>
      36:	00 00       	nop
      38:	48 c0       	rjmp	.+144    	; 0xca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	e1 c1       	rjmp	.+962    	; 0x400 <__vector_15>
      3e:	00 00       	nop
      40:	44 c0       	rjmp	.+136    	; 0xca <__bad_interrupt>
      42:	00 00       	nop
      44:	42 c0       	rjmp	.+132    	; 0xca <__bad_interrupt>
      46:	00 00       	nop
      48:	d7 c2       	rjmp	.+1454   	; 0x5f8 <__vector_18>
      4a:	00 00       	nop
      4c:	3e c0       	rjmp	.+124    	; 0xca <__bad_interrupt>
      4e:	00 00       	nop
      50:	3c c0       	rjmp	.+120    	; 0xca <__bad_interrupt>
      52:	00 00       	nop
      54:	3a c0       	rjmp	.+116    	; 0xca <__bad_interrupt>
      56:	00 00       	nop
      58:	38 c0       	rjmp	.+112    	; 0xca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	36 c0       	rjmp	.+108    	; 0xca <__bad_interrupt>
      5e:	00 00       	nop
      60:	34 c0       	rjmp	.+104    	; 0xca <__bad_interrupt>
      62:	00 00       	nop
      64:	32 c0       	rjmp	.+100    	; 0xca <__bad_interrupt>
      66:	00 00       	nop
      68:	30 c0       	rjmp	.+96     	; 0xca <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2e c0       	rjmp	.+92     	; 0xca <__bad_interrupt>
      6e:	00 00       	nop
      70:	24 c3       	rjmp	.+1608   	; 0x6ba <__vector_28>
      72:	00 00       	nop
      74:	2a c0       	rjmp	.+84     	; 0xca <__bad_interrupt>
      76:	00 00       	nop
      78:	ef c2       	rjmp	.+1502   	; 0x658 <__vector_30>
      7a:	00 00       	nop
      7c:	26 c0       	rjmp	.+76     	; 0xca <__bad_interrupt>
      7e:	00 00       	nop
      80:	24 c0       	rjmp	.+72     	; 0xca <__bad_interrupt>
      82:	00 00       	nop
      84:	22 c0       	rjmp	.+68     	; 0xca <__bad_interrupt>
      86:	00 00       	nop
      88:	20 c0       	rjmp	.+64     	; 0xca <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e8 e4       	ldi	r30, 0x48	; 72
      a0:	f1 e3       	ldi	r31, 0x31	; 49
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ac 3a       	cpi	r26, 0xAC	; 172
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2c e0       	ldi	r18, 0x0C	; 12
      b4:	ac ea       	ldi	r26, 0xAC	; 172
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a8 3a       	cpi	r26, 0xA8	; 168
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 0c 0d 	call	0x1a18	; 0x1a18 <main>
      c6:	0c 94 a2 18 	jmp	0x3144	; 0x3144 <_exit>

000000ca <__bad_interrupt>:
      ca:	9a cf       	rjmp	.-204    	; 0x0 <__vectors>

000000cc <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      cc:	fc 01       	movw	r30, r24
      ce:	68 0f       	add	r22, r24
      d0:	79 1f       	adc	r23, r25
      d2:	8f ef       	ldi	r24, 0xFF	; 255
      d4:	9f ef       	ldi	r25, 0xFF	; 255
      d6:	e6 17       	cp	r30, r22
      d8:	f7 07       	cpc	r31, r23
      da:	99 f0       	breq	.+38     	; 0x102 <_Z5CRC16Phi+0x36>
      dc:	21 91       	ld	r18, Z+
      de:	82 27       	eor	r24, r18
      e0:	28 e0       	ldi	r18, 0x08	; 8
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	ac 01       	movw	r20, r24
      e6:	41 70       	andi	r20, 0x01	; 1
      e8:	55 27       	eor	r21, r21
      ea:	96 95       	lsr	r25
      ec:	87 95       	ror	r24
      ee:	45 2b       	or	r20, r21
      f0:	21 f0       	breq	.+8      	; 0xfa <_Z5CRC16Phi+0x2e>
      f2:	41 e0       	ldi	r20, 0x01	; 1
      f4:	84 27       	eor	r24, r20
      f6:	40 ea       	ldi	r20, 0xA0	; 160
      f8:	94 27       	eor	r25, r20
      fa:	21 50       	subi	r18, 0x01	; 1
      fc:	31 09       	sbc	r19, r1
      fe:	91 f7       	brne	.-28     	; 0xe4 <_Z5CRC16Phi+0x18>
     100:	ea cf       	rjmp	.-44     	; 0xd6 <_Z5CRC16Phi+0xa>
     102:	08 95       	ret

00000104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	dc 01       	movw	r26, r24
     10a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     10c:	8c 91       	ld	r24, X
     10e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     110:	11 96       	adiw	r26, 0x01	; 1
     112:	8c 91       	ld	r24, X
     114:	11 97       	sbiw	r26, 0x01	; 1
     116:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     118:	13 96       	adiw	r26, 0x03	; 3
     11a:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     11c:	92 e0       	ldi	r25, 0x02	; 2
     11e:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     120:	e8 2f       	mov	r30, r24
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	ee 0f       	add	r30, r30
     126:	ff 1f       	adc	r31, r31
     128:	e4 0f       	add	r30, r20
     12a:	f5 1f       	adc	r31, r21
     12c:	81 81       	ldd	r24, Z+1	; 0x01
     12e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     130:	80 81       	ld	r24, Z
     132:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     134:	65 e0       	ldi	r22, 0x05	; 5
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	ce 01       	movw	r24, r28
     13a:	c8 df       	rcall	.-112    	; 0xcc <_Z5CRC16Phi>
	function04->CRC = crc16;
     13c:	9e 83       	std	Y+6, r25	; 0x06
     13e:	8d 83       	std	Y+5, r24	; 0x05
}
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	08 95       	ret

00000146 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     146:	cf 93       	push	r28
     148:	df 93       	push	r29
     14a:	fc 01       	movw	r30, r24
     14c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     14e:	80 81       	ld	r24, Z
     150:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     156:	82 81       	ldd	r24, Z+2	; 0x02
     158:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     15a:	83 81       	ldd	r24, Z+3	; 0x03
     15c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     15e:	84 81       	ldd	r24, Z+4	; 0x04
     160:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     162:	85 81       	ldd	r24, Z+5	; 0x05
     164:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     166:	66 e0       	ldi	r22, 0x06	; 6
     168:	70 e0       	ldi	r23, 0x00	; 0
     16a:	ce 01       	movw	r24, r28
     16c:	af df       	rcall	.-162    	; 0xcc <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     16e:	9f 83       	std	Y+7, r25	; 0x07
     170:	8e 83       	std	Y+6, r24	; 0x06
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	fc 01       	movw	r30, r24
     17e:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     180:	80 81       	ld	r24, Z
     182:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     184:	81 81       	ldd	r24, Z+1	; 0x01
     186:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     18c:	83 81       	ldd	r24, Z+3	; 0x03
     18e:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     190:	94 81       	ldd	r25, Z+4	; 0x04
     192:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     194:	95 81       	ldd	r25, Z+5	; 0x05
     196:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     198:	96 81       	ldd	r25, Z+6	; 0x06
     19a:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     19c:	27 81       	ldd	r18, Z+7	; 0x07
     19e:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1a0:	90 85       	ldd	r25, Z+8	; 0x08
     1a2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1a4:	e8 2f       	mov	r30, r24
     1a6:	f0 e0       	ldi	r31, 0x00	; 0
     1a8:	ee 0f       	add	r30, r30
     1aa:	ff 1f       	adc	r31, r31
     1ac:	e4 0f       	add	r30, r20
     1ae:	f5 1f       	adc	r31, r21
     1b0:	89 2f       	mov	r24, r25
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	92 2b       	or	r25, r18
     1b6:	91 83       	std	Z+1, r25	; 0x01
     1b8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1ba:	69 e0       	ldi	r22, 0x09	; 9
     1bc:	70 e0       	ldi	r23, 0x00	; 0
     1be:	ce 01       	movw	r24, r28
     1c0:	85 df       	rcall	.-246    	; 0xcc <_Z5CRC16Phi>
	function10->CRC = crc16;
     1c2:	9a 87       	std	Y+10, r25	; 0x0a
     1c4:	89 87       	std	Y+9, r24	; 0x09
}
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	08 95       	ret

000001cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	fc 01       	movw	r30, r24
     1d2:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1d4:	80 81       	ld	r24, Z
     1d6:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1d8:	81 81       	ldd	r24, Z+1	; 0x01
     1da:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1dc:	82 81       	ldd	r24, Z+2	; 0x02
     1de:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1e0:	83 81       	ldd	r24, Z+3	; 0x03
     1e2:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     1e8:	85 81       	ldd	r24, Z+5	; 0x05
     1ea:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     1ec:	66 e0       	ldi	r22, 0x06	; 6
     1ee:	70 e0       	ldi	r23, 0x00	; 0
     1f0:	ce 01       	movw	r24, r28
     1f2:	6c df       	rcall	.-296    	; 0xcc <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     1f4:	9f 83       	std	Y+7, r25	; 0x07
     1f6:	8e 83       	std	Y+6, r24	; 0x06
}
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	08 95       	ret

000001fe <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     204:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     206:	81 e8       	ldi	r24, 0x81	; 129
     208:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     20a:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     20c:	63 e0       	ldi	r22, 0x03	; 3
     20e:	70 e0       	ldi	r23, 0x00	; 0
     210:	ce 01       	movw	r24, r28
     212:	5c df       	rcall	.-328    	; 0xcc <_Z5CRC16Phi>
	Exception->CRC = crc16;
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	08 95       	ret

0000021e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     21e:	1f 93       	push	r17
     220:	cf 93       	push	r28
     222:	df 93       	push	r29
     224:	ec 01       	movw	r28, r24
     226:	cb 01       	movw	r24, r22
     228:	14 2f       	mov	r17, r20
     22a:	fe 01       	movw	r30, r28
     22c:	ea 57       	subi	r30, 0x7A	; 122
     22e:	ff 4f       	sbci	r31, 0xFF	; 255
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	64 2f       	mov	r22, r20
     236:	ca d1       	rcall	.+916    	; 0x5cc <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     238:	88 23       	and	r24, r24
     23a:	71 f0       	breq	.+28     	; 0x258 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     23c:	fe 01       	movw	r30, r28
     23e:	eb 57       	subi	r30, 0x7B	; 123
     240:	ff 4f       	sbci	r31, 0xFF	; 255
     242:	10 83       	st	Z, r17
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	10 82       	st	Z, r1
     248:	34 97       	sbiw	r30, 0x04	; 4
     24a:	11 82       	std	Z+1, r1	; 0x01
     24c:	10 82       	st	Z, r1
     24e:	ce 57       	subi	r28, 0x7E	; 126
     250:	df 4f       	sbci	r29, 0xFF	; 255
     252:	19 82       	std	Y+1, r1	; 0x01
     254:	18 82       	st	Y, r1
     256:	04 c0       	rjmp	.+8      	; 0x260 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     258:	ca 57       	subi	r28, 0x7A	; 122
     25a:	df 4f       	sbci	r29, 0xFF	; 255
     25c:	19 82       	std	Y+1, r1	; 0x01
     25e:	18 82       	st	Y, r1
     260:	df 91       	pop	r29
     262:	cf 91       	pop	r28
     264:	1f 91       	pop	r17
     266:	08 95       	ret

00000268 <_ZN12SerialBuffernwEj>:
     268:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
     26c:	08 95       	ret

0000026e <_ZN12SerialBuffer11SerialstoreEc>:
     26e:	fc 01       	movw	r30, r24
     270:	e0 58       	subi	r30, 0x80	; 128
     272:	ff 4f       	sbci	r31, 0xFF	; 255
     274:	20 81       	ld	r18, Z
     276:	2f 5f       	subi	r18, 0xFF	; 255
     278:	2f 77       	andi	r18, 0x7F	; 127
     27a:	19 f4       	brne	.+6      	; 0x282 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     27c:	11 82       	std	Z+1, r1	; 0x01
     27e:	10 82       	st	Z, r1
     280:	21 e0       	ldi	r18, 0x01	; 1
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	fc 01       	movw	r30, r24
     286:	ee 57       	subi	r30, 0x7E	; 126
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	40 81       	ld	r20, Z
     28c:	51 81       	ldd	r21, Z+1	; 0x01
     28e:	24 17       	cp	r18, r20
     290:	35 07       	cpc	r19, r21
     292:	89 f0       	breq	.+34     	; 0x2b6 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     294:	dc 01       	movw	r26, r24
     296:	a0 58       	subi	r26, 0x80	; 128
     298:	bf 4f       	sbci	r27, 0xFF	; 255
     29a:	ed 91       	ld	r30, X+
     29c:	fc 91       	ld	r31, X
     29e:	11 97       	sbiw	r26, 0x01	; 1
     2a0:	e8 0f       	add	r30, r24
     2a2:	f9 1f       	adc	r31, r25
     2a4:	61 83       	std	Z+1, r22	; 0x01
     2a6:	2d 93       	st	X+, r18
     2a8:	3c 93       	st	X, r19
     2aa:	fc 01       	movw	r30, r24
     2ac:	ec 57       	subi	r30, 0x7C	; 124
     2ae:	ff 4f       	sbci	r31, 0xFF	; 255
     2b0:	80 81       	ld	r24, Z
     2b2:	8f 5f       	subi	r24, 0xFF	; 255
     2b4:	80 83       	st	Z, r24
     2b6:	08 95       	ret

000002b8 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	1f 93       	push	r17
     2c8:	cf 93       	push	r28
     2ca:	8c 01       	movw	r16, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	7a 01       	movw	r14, r20
     2d0:	dc 01       	movw	r26, r24
     2d2:	ab 57       	subi	r26, 0x7B	; 123
     2d4:	bf 4f       	sbci	r27, 0xFF	; 255
     2d6:	fc 01       	movw	r30, r24
     2d8:	ea 57       	subi	r30, 0x7A	; 122
     2da:	ff 4f       	sbci	r31, 0xFF	; 255
     2dc:	6c 91       	ld	r22, X
     2de:	80 81       	ld	r24, Z
     2e0:	91 81       	ldd	r25, Z+1	; 0x01
     2e2:	81 d1       	rcall	.+770    	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2e4:	89 2b       	or	r24, r25
     2e6:	d1 f0       	breq	.+52     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2e8:	1e 14       	cp	r1, r14
     2ea:	1f 04       	cpc	r1, r15
     2ec:	bc f4       	brge	.+46     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2ee:	c0 e0       	ldi	r28, 0x00	; 0
     2f0:	58 01       	movw	r10, r16
     2f2:	85 e8       	ldi	r24, 0x85	; 133
     2f4:	a8 0e       	add	r10, r24
     2f6:	b1 1c       	adc	r11, r1
     2f8:	0a 57       	subi	r16, 0x7A	; 122
     2fa:	1f 4f       	sbci	r17, 0xFF	; 255
     2fc:	f6 01       	movw	r30, r12
     2fe:	ec 0f       	add	r30, r28
     300:	f1 1d       	adc	r31, r1
     302:	40 81       	ld	r20, Z
     304:	f5 01       	movw	r30, r10
     306:	60 81       	ld	r22, Z
     308:	f8 01       	movw	r30, r16
     30a:	80 81       	ld	r24, Z
     30c:	91 81       	ldd	r25, Z+1	; 0x01
     30e:	17 d1       	rcall	.+558    	; 0x53e <_ZN11Dev_Manager5WriteE8Dev_typec>
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	2c 2f       	mov	r18, r28
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	2e 15       	cp	r18, r14
     318:	3f 05       	cpc	r19, r15
     31a:	84 f3       	brlt	.-32     	; 0x2fc <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	bf 90       	pop	r11
     32c:	af 90       	pop	r10
     32e:	08 95       	ret

00000330 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     330:	fc 01       	movw	r30, r24
     332:	ee 57       	subi	r30, 0x7E	; 126
     334:	ff 4f       	sbci	r31, 0xFF	; 255
     336:	20 81       	ld	r18, Z
     338:	31 81       	ldd	r19, Z+1	; 0x01
     33a:	32 97       	sbiw	r30, 0x02	; 2
     33c:	40 81       	ld	r20, Z
     33e:	51 81       	ldd	r21, Z+1	; 0x01
     340:	42 17       	cp	r20, r18
     342:	53 07       	cpc	r21, r19
     344:	e9 f0       	breq	.+58     	; 0x380 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	3f 4f       	sbci	r19, 0xFF	; 255
     34a:	fc 01       	movw	r30, r24
     34c:	e2 0f       	add	r30, r18
     34e:	f3 1f       	adc	r31, r19
     350:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     352:	2f 77       	andi	r18, 0x7F	; 127
     354:	33 27       	eor	r19, r19
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	31 83       	std	Z+1, r19	; 0x01
     35e:	20 83       	st	Z, r18
		if (ib.tail == num)
     360:	32 96       	adiw	r30, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	26 17       	cp	r18, r22
     368:	37 07       	cpc	r19, r23
     36a:	61 f4       	brne	.+24     	; 0x384 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     36c:	32 97       	sbiw	r30, 0x02	; 2
     36e:	11 82       	std	Z+1, r1	; 0x01
     370:	10 82       	st	Z, r1
			ib.head = 0;
     372:	32 97       	sbiw	r30, 0x02	; 2
     374:	11 82       	std	Z+1, r1	; 0x01
     376:	10 82       	st	Z, r1
			num = 0;
     378:	34 96       	adiw	r30, 0x04	; 4
     37a:	10 82       	st	Z, r1
		}
		return data;
     37c:	84 2f       	mov	r24, r20
     37e:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     384:	84 2f       	mov	r24, r20
	}
}
     386:	08 95       	ret

00000388 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     388:	dc 01       	movw	r26, r24
     38a:	a0 58       	subi	r26, 0x80	; 128
     38c:	bf 4f       	sbci	r27, 0xFF	; 255
     38e:	fc 01       	movw	r30, r24
     390:	ee 57       	subi	r30, 0x7E	; 126
     392:	ff 4f       	sbci	r31, 0xFF	; 255
     394:	8c 91       	ld	r24, X
     396:	90 81       	ld	r25, Z
     398:	89 1b       	sub	r24, r25
}
     39a:	8f 77       	andi	r24, 0x7F	; 127
     39c:	08 95       	ret

0000039e <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     39e:	fc 01       	movw	r30, r24
     3a0:	ee 57       	subi	r30, 0x7E	; 126
     3a2:	ff 4f       	sbci	r31, 0xFF	; 255
     3a4:	11 82       	std	Z+1, r1	; 0x01
     3a6:	10 82       	st	Z, r1
	ib.head = 0;
     3a8:	32 97       	sbiw	r30, 0x02	; 2
     3aa:	11 82       	std	Z+1, r1	; 0x01
     3ac:	10 82       	st	Z, r1
	num = 0;
     3ae:	34 96       	adiw	r30, 0x04	; 4
     3b0:	10 82       	st	Z, r1
     3b2:	08 95       	ret

000003b4 <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
     3b4:	8c e0       	ldi	r24, 0x0C	; 12
     3b6:	83 bf       	out	0x33, r24	; 51
     3b8:	8c e7       	ldi	r24, 0x7C	; 124
     3ba:	81 bf       	out	0x31, r24	; 49
     3bc:	87 b7       	in	r24, 0x37	; 55
     3be:	82 60       	ori	r24, 0x02	; 2
     3c0:	87 bf       	out	0x37, r24	; 55
     3c2:	08 95       	ret

000003c4 <Alarm_Stop>:
     3c4:	87 b7       	in	r24, 0x37	; 55
     3c6:	8d 7f       	andi	r24, 0xFD	; 253
     3c8:	87 bf       	out	0x37, r24	; 55
     3ca:	08 95       	ret

000003cc <Alarm_Start>:
     3cc:	87 b7       	in	r24, 0x37	; 55
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	87 bf       	out	0x37, r24	; 55
     3d2:	08 95       	ret

000003d4 <Alarm_Open>:
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	fc 01       	movw	r30, r24
     3d8:	ee 0f       	add	r30, r30
     3da:	ff 1f       	adc	r31, r31
     3dc:	df 01       	movw	r26, r30
     3de:	a8 0f       	add	r26, r24
     3e0:	b9 1f       	adc	r27, r25
     3e2:	aa 0f       	add	r26, r26
     3e4:	bb 1f       	adc	r27, r27
     3e6:	a4 55       	subi	r26, 0x54	; 84
     3e8:	be 4f       	sbci	r27, 0xFE	; 254
     3ea:	11 96       	adiw	r26, 0x01	; 1
     3ec:	7c 93       	st	X, r23
     3ee:	6e 93       	st	-X, r22
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	1c 92       	st	X, r1
     3f4:	1e 92       	st	-X, r1
     3f6:	12 97       	sbiw	r26, 0x02	; 2
     3f8:	fd 01       	movw	r30, r26
     3fa:	55 83       	std	Z+5, r21	; 0x05
     3fc:	44 83       	std	Z+4, r20	; 0x04
     3fe:	08 95       	ret

00000400 <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
     400:	1f 92       	push	r1
     402:	0f 92       	push	r0
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	0f 92       	push	r0
     408:	11 24       	eor	r1, r1
     40a:	0b b6       	in	r0, 0x3b	; 59
     40c:	0f 92       	push	r0
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	1f 93       	push	r17
     416:	2f 93       	push	r18
     418:	3f 93       	push	r19
     41a:	4f 93       	push	r20
     41c:	5f 93       	push	r21
     41e:	6f 93       	push	r22
     420:	7f 93       	push	r23
     422:	8f 93       	push	r24
     424:	9f 93       	push	r25
     426:	af 93       	push	r26
     428:	bf 93       	push	r27
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	ef 93       	push	r30
     430:	ff 93       	push	r31
     432:	cc ea       	ldi	r28, 0xAC	; 172
     434:	d1 e0       	ldi	r29, 0x01	; 1
     436:	0f 2e       	mov	r0, r31
     438:	fa ec       	ldi	r31, 0xCA	; 202
     43a:	ef 2e       	mov	r14, r31
     43c:	f1 e0       	ldi	r31, 0x01	; 1
     43e:	ff 2e       	mov	r15, r31
     440:	f0 2d       	mov	r31, r0
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
     442:	ec 81       	ldd	r30, Y+4	; 0x04
     444:	fd 81       	ldd	r31, Y+5	; 0x05
     446:	30 97       	sbiw	r30, 0x00	; 0
     448:	79 f0       	breq	.+30     	; 0x468 <__vector_15+0x68>
		{
			AlarmTable[i].Time++;
     44a:	8a 81       	ldd	r24, Y+2	; 0x02
     44c:	9b 81       	ldd	r25, Y+3	; 0x03
     44e:	01 96       	adiw	r24, 0x01	; 1
     450:	9b 83       	std	Y+3, r25	; 0x03
     452:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
     454:	28 81       	ld	r18, Y
     456:	39 81       	ldd	r19, Y+1	; 0x01
     458:	82 17       	cp	r24, r18
     45a:	93 07       	cpc	r25, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <__vector_15+0x68>
			{
				AlarmTable[i].Time = 0;
     45e:	1b 82       	std	Y+3, r1	; 0x03
     460:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
     462:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
     464:	1d 82       	std	Y+5, r1	; 0x05
     466:	1c 82       	std	Y+4, r1	; 0x04
     468:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
     46a:	ce 15       	cp	r28, r14
     46c:	df 05       	cpc	r29, r15
     46e:	49 f7       	brne	.-46     	; 0x442 <__vector_15+0x42>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
     470:	ff 91       	pop	r31
     472:	ef 91       	pop	r30
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	bf 91       	pop	r27
     47a:	af 91       	pop	r26
     47c:	9f 91       	pop	r25
     47e:	8f 91       	pop	r24
     480:	7f 91       	pop	r23
     482:	6f 91       	pop	r22
     484:	5f 91       	pop	r21
     486:	4f 91       	pop	r20
     488:	3f 91       	pop	r19
     48a:	2f 91       	pop	r18
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	ff 90       	pop	r15
     492:	ef 90       	pop	r14
     494:	0f 90       	pop	r0
     496:	0b be       	out	0x3b, r0	; 59
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0
     49e:	1f 90       	pop	r1
     4a0:	18 95       	reti

000004a2 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	08 95       	ret

000004a6 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
	virtual void Device_Writes(const char* data){}
     4a6:	08 95       	ret

000004a8 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
     4a8:	08 95       	ret

000004aa <_ZN20DeviceDriveInterFace11Stop_DeviceEv>:
	virtual void Stop_Device(void){}
     4aa:	08 95       	ret

000004ac <_ZN20DeviceDriveInterFace12Start_DeviceEv>:
	virtual void Start_Device(void){}
     4ac:	08 95       	ret

000004ae <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
     4ae:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
     4b0:	8f ef       	ldi	r24, 0xFF	; 255
     4b2:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
     4b4:	ea e6       	ldi	r30, 0x6A	; 106
     4b6:	f0 e0       	ldi	r31, 0x00	; 0
     4b8:	80 81       	ld	r24, Z
     4ba:	82 60       	ori	r24, 0x02	; 2
     4bc:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
     4be:	80 81       	ld	r24, Z
     4c0:	8e 7f       	andi	r24, 0xFE	; 254
     4c2:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
     4c4:	89 b7       	in	r24, 0x39	; 57
     4c6:	81 60       	ori	r24, 0x01	; 1
     4c8:	89 bf       	out	0x39, r24	; 57
     4ca:	08 95       	ret

000004cc <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
     4cc:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
}
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     4d2:	28 e0       	ldi	r18, 0x08	; 8
     4d4:	dc 01       	movw	r26, r24
     4d6:	e2 2f       	mov	r30, r18
     4d8:	1d 92       	st	X+, r1
     4da:	ea 95       	dec	r30
     4dc:	e9 f7       	brne	.-6      	; 0x4d8 <_ZN11Dev_ManagerC1Ev+0x6>
     4de:	fc 01       	movw	r30, r24
     4e0:	38 96       	adiw	r30, 0x08	; 8
     4e2:	df 01       	movw	r26, r30
     4e4:	1d 92       	st	X+, r1
     4e6:	2a 95       	dec	r18
     4e8:	e9 f7       	brne	.-6      	; 0x4e4 <_ZN11Dev_ManagerC1Ev+0x12>
     4ea:	90 93 cb 01 	sts	0x01CB, r25	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     4ee:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <_ZN11Dev_Manager4instE>
     4f2:	08 95       	ret

000004f4 <_ZN11Dev_Manager11getInstanceEv>:
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <_ZN11Dev_Manager4instE>
     4fc:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     500:	89 2b       	or	r24, r25
     502:	51 f4       	brne	.+20     	; 0x518 <_ZN11Dev_Manager11getInstanceEv+0x24>
     504:	80 e1       	ldi	r24, 0x10	; 16
     506:	90 e0       	ldi	r25, 0x00	; 0
     508:	0e 94 bd 0d 	call	0x1b7a	; 0x1b7a <pvPortMalloc>
     50c:	ec 01       	movw	r28, r24
     50e:	e1 df       	rcall	.-62     	; 0x4d2 <_ZN11Dev_ManagerC1Ev>
     510:	d0 93 cb 01 	sts	0x01CB, r29	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     514:	c0 93 ca 01 	sts	0x01CA, r28	; 0x8001ca <_ZN11Dev_Manager4instE>
     518:	80 91 ca 01 	lds	r24, 0x01CA	; 0x8001ca <_ZN11Dev_Manager4instE>
     51c:	90 91 cb 01 	lds	r25, 0x01CB	; 0x8001cb <_ZN11Dev_Manager4instE+0x1>
     520:	df 91       	pop	r29
     522:	cf 91       	pop	r28
     524:	08 95       	ret

00000526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     526:	50 e0       	ldi	r21, 0x00	; 0
     528:	44 0f       	add	r20, r20
     52a:	55 1f       	adc	r21, r21
     52c:	84 0f       	add	r24, r20
     52e:	95 1f       	adc	r25, r21
     530:	fc 01       	movw	r30, r24
     532:	71 83       	std	Z+1, r23	; 0x01
     534:	60 83       	st	Z, r22
     536:	08 95       	ret

00000538 <_ZN11Dev_ManagernwEj>:
     538:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
     53c:	08 95       	ret

0000053e <_ZN11Dev_Manager5WriteE8Dev_typec>:
     53e:	26 2f       	mov	r18, r22
     540:	30 e0       	ldi	r19, 0x00	; 0
     542:	22 0f       	add	r18, r18
     544:	33 1f       	adc	r19, r19
     546:	82 0f       	add	r24, r18
     548:	93 1f       	adc	r25, r19
     54a:	dc 01       	movw	r26, r24
     54c:	8d 91       	ld	r24, X+
     54e:	9c 91       	ld	r25, X
     550:	00 97       	sbiw	r24, 0x00	; 0
     552:	41 f0       	breq	.+16     	; 0x564 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     554:	64 2f       	mov	r22, r20
     556:	dc 01       	movw	r26, r24
     558:	ed 91       	ld	r30, X+
     55a:	fc 91       	ld	r31, X
     55c:	06 80       	ldd	r0, Z+6	; 0x06
     55e:	f7 81       	ldd	r31, Z+7	; 0x07
     560:	e0 2d       	mov	r30, r0
     562:	09 95       	icall
     564:	08 95       	ret

00000566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     566:	26 2f       	mov	r18, r22
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	22 0f       	add	r18, r18
     56c:	33 1f       	adc	r19, r19
     56e:	82 0f       	add	r24, r18
     570:	93 1f       	adc	r25, r19
     572:	dc 01       	movw	r26, r24
     574:	8d 91       	ld	r24, X+
     576:	9c 91       	ld	r25, X
     578:	00 97       	sbiw	r24, 0x00	; 0
     57a:	41 f0       	breq	.+16     	; 0x58c <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     57c:	ba 01       	movw	r22, r20
     57e:	dc 01       	movw	r26, r24
     580:	ed 91       	ld	r30, X+
     582:	fc 91       	ld	r31, X
     584:	04 80       	ldd	r0, Z+4	; 0x04
     586:	f5 81       	ldd	r31, Z+5	; 0x05
     588:	e0 2d       	mov	r30, r0
     58a:	09 95       	icall
     58c:	08 95       	ret

0000058e <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     58e:	70 e0       	ldi	r23, 0x00	; 0
     590:	66 0f       	add	r22, r22
     592:	77 1f       	adc	r23, r23
     594:	86 0f       	add	r24, r22
     596:	97 1f       	adc	r25, r23
     598:	dc 01       	movw	r26, r24
     59a:	8d 91       	ld	r24, X+
     59c:	9c 91       	ld	r25, X
     59e:	00 97       	sbiw	r24, 0x00	; 0
     5a0:	39 f0       	breq	.+14     	; 0x5b0 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     5a2:	dc 01       	movw	r26, r24
     5a4:	ed 91       	ld	r30, X+
     5a6:	fc 91       	ld	r31, X
     5a8:	01 90       	ld	r0, Z+
     5aa:	f0 81       	ld	r31, Z
     5ac:	e0 2d       	mov	r30, r0
     5ae:	09 95       	icall
     5b0:	08 95       	ret

000005b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     5b2:	e6 2f       	mov	r30, r22
     5b4:	f0 e0       	ldi	r31, 0x00	; 0
     5b6:	ee 0f       	add	r30, r30
     5b8:	ff 1f       	adc	r31, r31
     5ba:	e8 0f       	add	r30, r24
     5bc:	f9 1f       	adc	r31, r25
     5be:	80 81       	ld	r24, Z
     5c0:	91 81       	ldd	r25, Z+1	; 0x01
     5c2:	89 2b       	or	r24, r25
     5c4:	11 f0       	breq	.+4      	; 0x5ca <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     5c6:	51 87       	std	Z+9, r21	; 0x09
     5c8:	40 87       	std	Z+8, r20	; 0x08
     5ca:	08 95       	ret

000005cc <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     5cc:	70 e0       	ldi	r23, 0x00	; 0
     5ce:	66 0f       	add	r22, r22
     5d0:	77 1f       	adc	r23, r23
     5d2:	fc 01       	movw	r30, r24
     5d4:	e6 0f       	add	r30, r22
     5d6:	f7 1f       	adc	r31, r23
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	20 81       	ld	r18, Z
     5dc:	31 81       	ldd	r19, Z+1	; 0x01
     5de:	23 2b       	or	r18, r19
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     5e2:	80 e0       	ldi	r24, 0x00	; 0
     5e4:	08 95       	ret

000005e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* const Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     5e6:	70 e0       	ldi	r23, 0x00	; 0
     5e8:	66 0f       	add	r22, r22
     5ea:	77 1f       	adc	r23, r23
     5ec:	86 0f       	add	r24, r22
     5ee:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     5f0:	fc 01       	movw	r30, r24
     5f2:	80 81       	ld	r24, Z
     5f4:	91 81       	ldd	r25, Z+1	; 0x01
     5f6:	08 95       	ret

000005f8 <__vector_18>:
ISR(USART0_RX_vect)
{
     5f8:	1f 92       	push	r1
     5fa:	0f 92       	push	r0
     5fc:	0f b6       	in	r0, 0x3f	; 63
     5fe:	0f 92       	push	r0
     600:	11 24       	eor	r1, r1
     602:	0b b6       	in	r0, 0x3b	; 59
     604:	0f 92       	push	r0
     606:	2f 93       	push	r18
     608:	3f 93       	push	r19
     60a:	4f 93       	push	r20
     60c:	5f 93       	push	r21
     60e:	6f 93       	push	r22
     610:	7f 93       	push	r23
     612:	8f 93       	push	r24
     614:	9f 93       	push	r25
     616:	af 93       	push	r26
     618:	bf 93       	push	r27
     61a:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     61c:	ff 93       	push	r31
     61e:	6a df       	rcall	.-300    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     620:	6c b1       	in	r22, 0x0c	; 12
     622:	70 e0       	ldi	r23, 0x00	; 0
     624:	dc 01       	movw	r26, r24
     626:	18 96       	adiw	r26, 0x08	; 8
     628:	ed 91       	ld	r30, X+
     62a:	fc 91       	ld	r31, X
     62c:	19 97       	sbiw	r26, 0x09	; 9
     62e:	80 e0       	ldi	r24, 0x00	; 0
}
     630:	09 95       	icall
     632:	ff 91       	pop	r31
     634:	ef 91       	pop	r30
     636:	bf 91       	pop	r27
     638:	af 91       	pop	r26
     63a:	9f 91       	pop	r25
     63c:	8f 91       	pop	r24
     63e:	7f 91       	pop	r23
     640:	6f 91       	pop	r22
     642:	5f 91       	pop	r21
     644:	4f 91       	pop	r20
     646:	3f 91       	pop	r19
     648:	2f 91       	pop	r18
     64a:	0f 90       	pop	r0
     64c:	0b be       	out	0x3b, r0	; 59
     64e:	0f 90       	pop	r0
     650:	0f be       	out	0x3f, r0	; 63
     652:	0f 90       	pop	r0
     654:	1f 90       	pop	r1
     656:	18 95       	reti

00000658 <__vector_30>:
ISR(USART1_RX_vect)
{
     658:	1f 92       	push	r1
     65a:	0f 92       	push	r0
     65c:	0f b6       	in	r0, 0x3f	; 63
     65e:	0f 92       	push	r0
     660:	11 24       	eor	r1, r1
     662:	0b b6       	in	r0, 0x3b	; 59
     664:	0f 92       	push	r0
     666:	2f 93       	push	r18
     668:	3f 93       	push	r19
     66a:	4f 93       	push	r20
     66c:	5f 93       	push	r21
     66e:	6f 93       	push	r22
     670:	7f 93       	push	r23
     672:	8f 93       	push	r24
     674:	9f 93       	push	r25
     676:	af 93       	push	r26
     678:	bf 93       	push	r27
     67a:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     67c:	ff 93       	push	r31
     67e:	3a df       	rcall	.-396    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     680:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     684:	70 e0       	ldi	r23, 0x00	; 0
     686:	dc 01       	movw	r26, r24
     688:	1a 96       	adiw	r26, 0x0a	; 10
     68a:	ed 91       	ld	r30, X+
     68c:	fc 91       	ld	r31, X
     68e:	1b 97       	sbiw	r26, 0x0b	; 11
     690:	81 e0       	ldi	r24, 0x01	; 1
}
     692:	09 95       	icall
     694:	ff 91       	pop	r31
     696:	ef 91       	pop	r30
     698:	bf 91       	pop	r27
     69a:	af 91       	pop	r26
     69c:	9f 91       	pop	r25
     69e:	8f 91       	pop	r24
     6a0:	7f 91       	pop	r23
     6a2:	6f 91       	pop	r22
     6a4:	5f 91       	pop	r21
     6a6:	4f 91       	pop	r20
     6a8:	3f 91       	pop	r19
     6aa:	2f 91       	pop	r18
     6ac:	0f 90       	pop	r0
     6ae:	0b be       	out	0x3b, r0	; 59
     6b0:	0f 90       	pop	r0
     6b2:	0f be       	out	0x3f, r0	; 63
     6b4:	0f 90       	pop	r0
     6b6:	1f 90       	pop	r1
     6b8:	18 95       	reti

000006ba <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     6ba:	1f 92       	push	r1
     6bc:	0f 92       	push	r0
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	0f 92       	push	r0
     6c2:	11 24       	eor	r1, r1
     6c4:	0b b6       	in	r0, 0x3b	; 59
     6c6:	0f 92       	push	r0
     6c8:	2f 93       	push	r18
     6ca:	3f 93       	push	r19
     6cc:	4f 93       	push	r20
     6ce:	5f 93       	push	r21
     6d0:	6f 93       	push	r22
     6d2:	7f 93       	push	r23
     6d4:	8f 93       	push	r24
     6d6:	9f 93       	push	r25
     6d8:	af 93       	push	r26
     6da:	bf 93       	push	r27
     6dc:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
     6de:	ff 93       	push	r31
     6e0:	09 df       	rcall	.-494    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     6e2:	dc 01       	movw	r26, r24
     6e4:	1c 96       	adiw	r26, 0x0c	; 12
     6e6:	ed 91       	ld	r30, X+
     6e8:	fc 91       	ld	r31, X
     6ea:	1d 97       	sbiw	r26, 0x0d	; 13
     6ec:	60 e0       	ldi	r22, 0x00	; 0
     6ee:	70 e0       	ldi	r23, 0x00	; 0
     6f0:	82 e0       	ldi	r24, 0x02	; 2
}
     6f2:	09 95       	icall
     6f4:	ff 91       	pop	r31
     6f6:	ef 91       	pop	r30
     6f8:	bf 91       	pop	r27
     6fa:	af 91       	pop	r26
     6fc:	9f 91       	pop	r25
     6fe:	8f 91       	pop	r24
     700:	7f 91       	pop	r23
     702:	6f 91       	pop	r22
     704:	5f 91       	pop	r21
     706:	4f 91       	pop	r20
     708:	3f 91       	pop	r19
     70a:	2f 91       	pop	r18
     70c:	0f 90       	pop	r0
     70e:	0b be       	out	0x3b, r0	; 59
     710:	0f 90       	pop	r0
     712:	0f be       	out	0x3f, r0	; 63
     714:	0f 90       	pop	r0
     716:	1f 90       	pop	r1
     718:	18 95       	reti

0000071a <__vector_1>:
ISR(INT0_vect)
{
     71a:	1f 92       	push	r1
     71c:	0f 92       	push	r0
     71e:	0f b6       	in	r0, 0x3f	; 63
     720:	0f 92       	push	r0
     722:	11 24       	eor	r1, r1
     724:	0b b6       	in	r0, 0x3b	; 59
     726:	0f 92       	push	r0
     728:	2f 93       	push	r18
     72a:	3f 93       	push	r19
     72c:	4f 93       	push	r20
     72e:	5f 93       	push	r21
     730:	6f 93       	push	r22
     732:	7f 93       	push	r23
     734:	8f 93       	push	r24
     736:	9f 93       	push	r25
     738:	af 93       	push	r26
     73a:	bf 93       	push	r27
     73c:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
     73e:	ff 93       	push	r31
     740:	d9 de       	rcall	.-590    	; 0x4f4 <_ZN11Dev_Manager11getInstanceEv>
     742:	dc 01       	movw	r26, r24
     744:	1e 96       	adiw	r26, 0x0e	; 14
     746:	ed 91       	ld	r30, X+
     748:	fc 91       	ld	r31, X
     74a:	1f 97       	sbiw	r26, 0x0f	; 15
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	83 e0       	ldi	r24, 0x03	; 3
     752:	09 95       	icall
     754:	ff 91       	pop	r31
     756:	ef 91       	pop	r30
     758:	bf 91       	pop	r27
     75a:	af 91       	pop	r26
     75c:	9f 91       	pop	r25
     75e:	8f 91       	pop	r24
     760:	7f 91       	pop	r23
     762:	6f 91       	pop	r22
     764:	5f 91       	pop	r21
     766:	4f 91       	pop	r20
     768:	3f 91       	pop	r19
     76a:	2f 91       	pop	r18
     76c:	0f 90       	pop	r0
     76e:	0b be       	out	0x3b, r0	; 59
     770:	0f 90       	pop	r0
     772:	0f be       	out	0x3f, r0	; 63
     774:	0f 90       	pop	r0
     776:	1f 90       	pop	r1
     778:	18 95       	reti

0000077a <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
     77a:	80 e4       	ldi	r24, 0x40	; 64
     77c:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
     780:	84 e0       	ldi	r24, 0x04	; 4
     782:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
     786:	88 e0       	ldi	r24, 0x08	; 8
     788:	9d e3       	ldi	r25, 0x3D	; 61
     78a:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     78e:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
     792:	82 e0       	ldi	r24, 0x02	; 2
     794:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     798:	08 95       	ret

0000079a <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
     79a:	2b e1       	ldi	r18, 0x1B	; 27
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	fc 01       	movw	r30, r24
     7a0:	31 83       	std	Z+1, r19	; 0x01
     7a2:	20 83       	st	Z, r18
     7a4:	08 95       	ret

000007a6 <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
     7a6:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
}
     7aa:	08 95       	ret

000007ac <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
     7b0:	ec 01       	movw	r28, r24
     7b2:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     7b6:	88 e9       	ldi	r24, 0x98	; 152
     7b8:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     7bc:	86 e0       	ldi	r24, 0x06	; 6
     7be:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     7c2:	be 01       	movw	r22, r28
     7c4:	6e 5f       	subi	r22, 0xFE	; 254
     7c6:	7f 4f       	sbci	r23, 0xFF	; 255
     7c8:	ce 01       	movw	r24, r28
     7ca:	19 d1       	rcall	.+562    	; 0x9fe <_ZN4Ubbr10Ubbr_ValueERKj>
     7cc:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     7d0:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     7d4:	81 e0       	ldi	r24, 0x01	; 1
     7d6:	0e 94 86 11 	call	0x230c	; 0x230c <xQueueCreateMutex>
     7da:	9f 83       	std	Y+7, r25	; 0x07
     7dc:	8e 83       	std	Y+6, r24	; 0x06
     7de:	81 e0       	ldi	r24, 0x01	; 1
     7e0:	0e 94 86 11 	call	0x230c	; 0x230c <xQueueCreateMutex>
     7e4:	9d 83       	std	Y+5, r25	; 0x05
     7e6:	8c 83       	std	Y+4, r24	; 0x04
     7e8:	df 91       	pop	r29
     7ea:	cf 91       	pop	r28
     7ec:	08 95       	ret

000007ee <_ZN11RS485DriverC1Ev>:
     7ee:	2b e2       	ldi	r18, 0x2B	; 43
     7f0:	31 e0       	ldi	r19, 0x01	; 1
     7f2:	fc 01       	movw	r30, r24
     7f4:	31 83       	std	Z+1, r19	; 0x01
     7f6:	20 83       	st	Z, r18
     7f8:	20 e8       	ldi	r18, 0x80	; 128
     7fa:	35 e2       	ldi	r19, 0x25	; 37
     7fc:	33 83       	std	Z+3, r19	; 0x03
     7fe:	22 83       	std	Z+2, r18	; 0x02
     800:	20 91 cc 01 	lds	r18, 0x01CC	; 0x8001cc <_ZN11RS485Driver4instE>
     804:	30 91 cd 01 	lds	r19, 0x01CD	; 0x8001cd <_ZN11RS485Driver4instE+0x1>
     808:	23 2b       	or	r18, r19
     80a:	21 f4       	brne	.+8      	; 0x814 <_ZN11RS485DriverC1Ev+0x26>
     80c:	90 93 cd 01 	sts	0x01CD, r25	; 0x8001cd <_ZN11RS485Driver4instE+0x1>
     810:	80 93 cc 01 	sts	0x01CC, r24	; 0x8001cc <_ZN11RS485Driver4instE>
     814:	08 95       	ret

00000816 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     816:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
}
     81a:	08 95       	ret

0000081c <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     81c:	1f 93       	push	r17
     81e:	cf 93       	push	r28
     820:	df 93       	push	r29
     822:	ec 01       	movw	r28, r24
     824:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	44 e6       	ldi	r20, 0x64	; 100
     82a:	50 e0       	ldi	r21, 0x00	; 0
     82c:	60 e0       	ldi	r22, 0x00	; 0
     82e:	70 e0       	ldi	r23, 0x00	; 0
     830:	8c 81       	ldd	r24, Y+4	; 0x04
     832:	9d 81       	ldd	r25, Y+5	; 0x05
     834:	0e 94 9e 11 	call	0x233c	; 0x233c <xQueueGenericReceive>
     838:	81 30       	cpi	r24, 0x01	; 1
     83a:	81 f4       	brne	.+32     	; 0x85c <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     83c:	eb e9       	ldi	r30, 0x9B	; 155
     83e:	f0 e0       	ldi	r31, 0x00	; 0
     840:	80 81       	ld	r24, Z
     842:	85 ff       	sbrs	r24, 5
     844:	fd cf       	rjmp	.-6      	; 0x840 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     846:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     84a:	20 e0       	ldi	r18, 0x00	; 0
     84c:	40 e0       	ldi	r20, 0x00	; 0
     84e:	50 e0       	ldi	r21, 0x00	; 0
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	8c 81       	ldd	r24, Y+4	; 0x04
     856:	9d 81       	ldd	r25, Y+5	; 0x05
     858:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <xQueueGenericSend>
	}
}
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	08 95       	ret

00000864 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     864:	db cf       	rjmp	.-74     	; 0x81c <_ZN11RS485Driver12UART_PutcharEc>
     866:	08 95       	ret

00000868 <_ZN11RS485Driver14UART_PutStringEPKc>:
     868:	0f 93       	push	r16
     86a:	1f 93       	push	r17
     86c:	cf 93       	push	r28
     86e:	df 93       	push	r29
     870:	8c 01       	movw	r16, r24
     872:	eb 01       	movw	r28, r22
     874:	20 e0       	ldi	r18, 0x00	; 0
     876:	44 e6       	ldi	r20, 0x64	; 100
     878:	50 e0       	ldi	r21, 0x00	; 0
     87a:	60 e0       	ldi	r22, 0x00	; 0
     87c:	70 e0       	ldi	r23, 0x00	; 0
     87e:	fc 01       	movw	r30, r24
     880:	86 81       	ldd	r24, Z+6	; 0x06
     882:	97 81       	ldd	r25, Z+7	; 0x07
     884:	0e 94 9e 11 	call	0x233c	; 0x233c <xQueueGenericReceive>
     888:	81 30       	cpi	r24, 0x01	; 1
     88a:	99 f4       	brne	.+38     	; 0x8b2 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     88c:	68 81       	ld	r22, Y
     88e:	66 23       	and	r22, r22
     890:	31 f0       	breq	.+12     	; 0x89e <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     892:	21 96       	adiw	r28, 0x01	; 1
     894:	c8 01       	movw	r24, r16
     896:	c2 df       	rcall	.-124    	; 0x81c <_ZN11RS485Driver12UART_PutcharEc>
     898:	69 91       	ld	r22, Y+
     89a:	61 11       	cpse	r22, r1
     89c:	fb cf       	rjmp	.-10     	; 0x894 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     89e:	20 e0       	ldi	r18, 0x00	; 0
     8a0:	40 e0       	ldi	r20, 0x00	; 0
     8a2:	50 e0       	ldi	r21, 0x00	; 0
     8a4:	60 e0       	ldi	r22, 0x00	; 0
     8a6:	70 e0       	ldi	r23, 0x00	; 0
     8a8:	f8 01       	movw	r30, r16
     8aa:	86 81       	ldd	r24, Z+6	; 0x06
     8ac:	97 81       	ldd	r25, Z+7	; 0x07
     8ae:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <xQueueGenericSend>
     8b2:	df 91       	pop	r29
     8b4:	cf 91       	pop	r28
     8b6:	1f 91       	pop	r17
     8b8:	0f 91       	pop	r16
     8ba:	08 95       	ret

000008bc <_ZN11RS485Driver13Device_WritesEPKc>:
     8bc:	d5 cf       	rjmp	.-86     	; 0x868 <_ZN11RS485Driver14UART_PutStringEPKc>
     8be:	08 95       	ret

000008c0 <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
     8c0:	1f 92       	push	r1
     8c2:	0f 92       	push	r0
     8c4:	0f b6       	in	r0, 0x3f	; 63
     8c6:	0f 92       	push	r0
     8c8:	11 24       	eor	r1, r1
     8ca:	0b b6       	in	r0, 0x3b	; 59
     8cc:	0f 92       	push	r0
     8ce:	8f 93       	push	r24
     8d0:	9f 93       	push	r25
     8d2:	ef 93       	push	r30
     8d4:	ff 93       	push	r31
	mem4[3]++;
     8d6:	ef eb       	ldi	r30, 0xBF	; 191
     8d8:	f2 e0       	ldi	r31, 0x02	; 2
     8da:	86 81       	ldd	r24, Z+6	; 0x06
     8dc:	97 81       	ldd	r25, Z+7	; 0x07
     8de:	01 96       	adiw	r24, 0x01	; 1
     8e0:	97 83       	std	Z+7, r25	; 0x07
     8e2:	86 83       	std	Z+6, r24	; 0x06
}
     8e4:	ff 91       	pop	r31
     8e6:	ef 91       	pop	r30
     8e8:	9f 91       	pop	r25
     8ea:	8f 91       	pop	r24
     8ec:	0f 90       	pop	r0
     8ee:	0b be       	out	0x3b, r0	; 59
     8f0:	0f 90       	pop	r0
     8f2:	0f be       	out	0x3f, r0	; 63
     8f4:	0f 90       	pop	r0
     8f6:	1f 90       	pop	r1
     8f8:	18 95       	reti

000008fa <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
     8fe:	ec 01       	movw	r28, r24
     900:	88 e9       	ldi	r24, 0x98	; 152
     902:	8a b9       	out	0x0a, r24	; 10
     904:	86 e0       	ldi	r24, 0x06	; 6
     906:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     90a:	be 01       	movw	r22, r28
     90c:	6e 5f       	subi	r22, 0xFE	; 254
     90e:	7f 4f       	sbci	r23, 0xFF	; 255
     910:	ce 01       	movw	r24, r28
     912:	75 d0       	rcall	.+234    	; 0x9fe <_ZN4Ubbr10Ubbr_ValueERKj>
     914:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     918:	99 b9       	out	0x09, r25	; 9
     91a:	81 e0       	ldi	r24, 0x01	; 1
     91c:	0e 94 86 11 	call	0x230c	; 0x230c <xQueueCreateMutex>
     920:	9f 83       	std	Y+7, r25	; 0x07
     922:	8e 83       	std	Y+6, r24	; 0x06
     924:	81 e0       	ldi	r24, 0x01	; 1
     926:	0e 94 86 11 	call	0x230c	; 0x230c <xQueueCreateMutex>
     92a:	9d 83       	std	Y+5, r25	; 0x05
     92c:	8c 83       	std	Y+4, r24	; 0x04
     92e:	df 91       	pop	r29
     930:	cf 91       	pop	r28
     932:	08 95       	ret

00000934 <_ZN10UartDriverC1Ev>:
     934:	2b e3       	ldi	r18, 0x3B	; 59
     936:	31 e0       	ldi	r19, 0x01	; 1
     938:	fc 01       	movw	r30, r24
     93a:	31 83       	std	Z+1, r19	; 0x01
     93c:	20 83       	st	Z, r18
     93e:	20 e4       	ldi	r18, 0x40	; 64
     940:	38 e3       	ldi	r19, 0x38	; 56
     942:	33 83       	std	Z+3, r19	; 0x03
     944:	22 83       	std	Z+2, r18	; 0x02
     946:	20 91 ce 01 	lds	r18, 0x01CE	; 0x8001ce <_ZN10UartDriver4instE>
     94a:	30 91 cf 01 	lds	r19, 0x01CF	; 0x8001cf <_ZN10UartDriver4instE+0x1>
     94e:	23 2b       	or	r18, r19
     950:	21 f4       	brne	.+8      	; 0x95a <_ZN10UartDriverC1Ev+0x26>
     952:	90 93 cf 01 	sts	0x01CF, r25	; 0x8001cf <_ZN10UartDriver4instE+0x1>
     956:	80 93 ce 01 	sts	0x01CE, r24	; 0x8001ce <_ZN10UartDriver4instE>
     95a:	08 95       	ret

0000095c <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     95c:	0c 94 bd 0d 	jmp	0x1b7a	; 0x1b7a <pvPortMalloc>
}
     960:	08 95       	ret

00000962 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     962:	1f 93       	push	r17
     964:	cf 93       	push	r28
     966:	df 93       	push	r29
     968:	ec 01       	movw	r28, r24
     96a:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     96c:	20 e0       	ldi	r18, 0x00	; 0
     96e:	44 e6       	ldi	r20, 0x64	; 100
     970:	50 e0       	ldi	r21, 0x00	; 0
     972:	60 e0       	ldi	r22, 0x00	; 0
     974:	70 e0       	ldi	r23, 0x00	; 0
     976:	8c 81       	ldd	r24, Y+4	; 0x04
     978:	9d 81       	ldd	r25, Y+5	; 0x05
     97a:	0e 94 9e 11 	call	0x233c	; 0x233c <xQueueGenericReceive>
     97e:	81 30       	cpi	r24, 0x01	; 1
     980:	61 f4       	brne	.+24     	; 0x99a <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     982:	5d 9b       	sbis	0x0b, 5	; 11
     984:	fe cf       	rjmp	.-4      	; 0x982 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     986:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     988:	20 e0       	ldi	r18, 0x00	; 0
     98a:	40 e0       	ldi	r20, 0x00	; 0
     98c:	50 e0       	ldi	r21, 0x00	; 0
     98e:	60 e0       	ldi	r22, 0x00	; 0
     990:	70 e0       	ldi	r23, 0x00	; 0
     992:	8c 81       	ldd	r24, Y+4	; 0x04
     994:	9d 81       	ldd	r25, Y+5	; 0x05
     996:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <xQueueGenericSend>
	}
}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	1f 91       	pop	r17
     9a0:	08 95       	ret

000009a2 <_ZN10UartDriver12Device_WriteEc>:
     9a2:	df cf       	rjmp	.-66     	; 0x962 <_ZN10UartDriver12UART_PutcharEc>
     9a4:	08 95       	ret

000009a6 <_ZN10UartDriver14UART_PutStringEPKc>:
     9a6:	0f 93       	push	r16
     9a8:	1f 93       	push	r17
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	8c 01       	movw	r16, r24
     9b0:	eb 01       	movw	r28, r22
     9b2:	20 e0       	ldi	r18, 0x00	; 0
     9b4:	44 e6       	ldi	r20, 0x64	; 100
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	fc 01       	movw	r30, r24
     9be:	86 81       	ldd	r24, Z+6	; 0x06
     9c0:	97 81       	ldd	r25, Z+7	; 0x07
     9c2:	0e 94 9e 11 	call	0x233c	; 0x233c <xQueueGenericReceive>
     9c6:	81 30       	cpi	r24, 0x01	; 1
     9c8:	99 f4       	brne	.+38     	; 0x9f0 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     9ca:	68 81       	ld	r22, Y
     9cc:	66 23       	and	r22, r22
     9ce:	31 f0       	breq	.+12     	; 0x9dc <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     9d0:	21 96       	adiw	r28, 0x01	; 1
     9d2:	c8 01       	movw	r24, r16
     9d4:	c6 df       	rcall	.-116    	; 0x962 <_ZN10UartDriver12UART_PutcharEc>
     9d6:	69 91       	ld	r22, Y+
     9d8:	61 11       	cpse	r22, r1
     9da:	fb cf       	rjmp	.-10     	; 0x9d2 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     9dc:	20 e0       	ldi	r18, 0x00	; 0
     9de:	40 e0       	ldi	r20, 0x00	; 0
     9e0:	50 e0       	ldi	r21, 0x00	; 0
     9e2:	60 e0       	ldi	r22, 0x00	; 0
     9e4:	70 e0       	ldi	r23, 0x00	; 0
     9e6:	f8 01       	movw	r30, r16
     9e8:	86 81       	ldd	r24, Z+6	; 0x06
     9ea:	97 81       	ldd	r25, Z+7	; 0x07
     9ec:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <xQueueGenericSend>
     9f0:	df 91       	pop	r29
     9f2:	cf 91       	pop	r28
     9f4:	1f 91       	pop	r17
     9f6:	0f 91       	pop	r16
     9f8:	08 95       	ret

000009fa <_ZN10UartDriver13Device_WritesEPKc>:
     9fa:	d5 cf       	rjmp	.-86     	; 0x9a6 <_ZN10UartDriver14UART_PutStringEPKc>
     9fc:	08 95       	ret

000009fe <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     9fe:	cf 92       	push	r12
     a00:	df 92       	push	r13
     a02:	ef 92       	push	r14
     a04:	ff 92       	push	r15
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
     a0a:	fb 01       	movw	r30, r22
     a0c:	20 81       	ld	r18, Z
     a0e:	31 81       	ldd	r19, Z+1	; 0x01
     a10:	c9 01       	movw	r24, r18
     a12:	a0 e0       	ldi	r26, 0x00	; 0
     a14:	b0 e0       	ldi	r27, 0x00	; 0
     a16:	88 0f       	add	r24, r24
     a18:	99 1f       	adc	r25, r25
     a1a:	aa 1f       	adc	r26, r26
     a1c:	bb 1f       	adc	r27, r27
     a1e:	88 0f       	add	r24, r24
     a20:	99 1f       	adc	r25, r25
     a22:	aa 1f       	adc	r26, r26
     a24:	bb 1f       	adc	r27, r27
     a26:	9c 01       	movw	r18, r24
     a28:	ad 01       	movw	r20, r26
     a2a:	22 0f       	add	r18, r18
     a2c:	33 1f       	adc	r19, r19
     a2e:	44 1f       	adc	r20, r20
     a30:	55 1f       	adc	r21, r21
     a32:	22 0f       	add	r18, r18
     a34:	33 1f       	adc	r19, r19
     a36:	44 1f       	adc	r20, r20
     a38:	55 1f       	adc	r21, r21
     a3a:	60 e0       	ldi	r22, 0x00	; 0
     a3c:	74 e2       	ldi	r23, 0x24	; 36
     a3e:	84 ef       	ldi	r24, 0xF4	; 244
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	0e 94 5e 18 	call	0x30bc	; 0x30bc <__udivmodsi4>
     a46:	ca 01       	movw	r24, r20
     a48:	b9 01       	movw	r22, r18
     a4a:	61 50       	subi	r22, 0x01	; 1
     a4c:	71 09       	sbc	r23, r1
     a4e:	81 09       	sbc	r24, r1
     a50:	91 09       	sbc	r25, r1
     a52:	0e 94 d0 17 	call	0x2fa0	; 0x2fa0 <__floatunsisf>
     a56:	20 e0       	ldi	r18, 0x00	; 0
     a58:	30 e0       	ldi	r19, 0x00	; 0
     a5a:	40 e0       	ldi	r20, 0x00	; 0
     a5c:	5f e3       	ldi	r21, 0x3F	; 63
     a5e:	0e 94 40 17 	call	0x2e80	; 0x2e80 <__addsf3>
     a62:	6b 01       	movw	r12, r22
     a64:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     a66:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <__fixunssfsi>
     a6a:	d6 2f       	mov	r29, r22
     a6c:	f0 e0       	ldi	r31, 0x00	; 0
     a6e:	cf 2f       	mov	r28, r31
     a70:	c7 01       	movw	r24, r14
     a72:	b6 01       	movw	r22, r12
     a74:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <__fixunssfsi>
}
     a78:	ce 01       	movw	r24, r28
     a7a:	86 2b       	or	r24, r22
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	ff 90       	pop	r15
     a82:	ef 90       	pop	r14
     a84:	df 90       	pop	r13
     a86:	cf 90       	pop	r12
     a88:	08 95       	ret

00000a8a <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     a8a:	c0 98       	cbi	0x18, 0	; 24
     a8c:	96 2f       	mov	r25, r22
     a8e:	6f 71       	andi	r22, 0x1F	; 31
     a90:	86 2b       	or	r24, r22
     a92:	8f b9       	out	0x0f, r24	; 15
     a94:	77 9b       	sbis	0x0e, 7	; 14
     a96:	fe cf       	rjmp	.-4      	; 0xa94 <_Z14enc28j60ReadOphh+0xa>
     a98:	1f b8       	out	0x0f, r1	; 15
     a9a:	77 9b       	sbis	0x0e, 7	; 14
     a9c:	fe cf       	rjmp	.-4      	; 0xa9a <_Z14enc28j60ReadOphh+0x10>
     a9e:	99 23       	and	r25, r25
     aa0:	1c f4       	brge	.+6      	; 0xaa8 <_Z14enc28j60ReadOphh+0x1e>
     aa2:	1f b8       	out	0x0f, r1	; 15
     aa4:	77 9b       	sbis	0x0e, 7	; 14
     aa6:	fe cf       	rjmp	.-4      	; 0xaa4 <_Z14enc28j60ReadOphh+0x1a>
     aa8:	c0 9a       	sbi	0x18, 0	; 24
     aaa:	8f b1       	in	r24, 0x0f	; 15
     aac:	08 95       	ret

00000aae <_Z15enc28j60WriteOphhh>:
     aae:	c0 98       	cbi	0x18, 0	; 24
     ab0:	6f 71       	andi	r22, 0x1F	; 31
     ab2:	86 2b       	or	r24, r22
     ab4:	8f b9       	out	0x0f, r24	; 15
     ab6:	77 9b       	sbis	0x0e, 7	; 14
     ab8:	fe cf       	rjmp	.-4      	; 0xab6 <_Z15enc28j60WriteOphhh+0x8>
     aba:	4f b9       	out	0x0f, r20	; 15
     abc:	77 9b       	sbis	0x0e, 7	; 14
     abe:	fe cf       	rjmp	.-4      	; 0xabc <_Z15enc28j60WriteOphhh+0xe>
     ac0:	c0 9a       	sbi	0x18, 0	; 24
     ac2:	08 95       	ret

00000ac4 <_Z18enc28j60ReadBufferjPh>:
     ac4:	fb 01       	movw	r30, r22
     ac6:	c0 98       	cbi	0x18, 0	; 24
     ac8:	2a e3       	ldi	r18, 0x3A	; 58
     aca:	2f b9       	out	0x0f, r18	; 15
     acc:	77 9b       	sbis	0x0e, 7	; 14
     ace:	fe cf       	rjmp	.-4      	; 0xacc <_Z18enc28j60ReadBufferjPh+0x8>
     ad0:	00 97       	sbiw	r24, 0x00	; 0
     ad2:	61 f0       	breq	.+24     	; 0xaec <_Z18enc28j60ReadBufferjPh+0x28>
     ad4:	df 01       	movw	r26, r30
     ad6:	a8 0f       	add	r26, r24
     ad8:	b9 1f       	adc	r27, r25
     ada:	1f b8       	out	0x0f, r1	; 15
     adc:	77 9b       	sbis	0x0e, 7	; 14
     ade:	fe cf       	rjmp	.-4      	; 0xadc <_Z18enc28j60ReadBufferjPh+0x18>
     ae0:	9f b1       	in	r25, 0x0f	; 15
     ae2:	91 93       	st	Z+, r25
     ae4:	ae 17       	cp	r26, r30
     ae6:	bf 07       	cpc	r27, r31
     ae8:	c1 f7       	brne	.-16     	; 0xada <_Z18enc28j60ReadBufferjPh+0x16>
     aea:	01 c0       	rjmp	.+2      	; 0xaee <_Z18enc28j60ReadBufferjPh+0x2a>
     aec:	df 01       	movw	r26, r30
     aee:	1c 92       	st	X, r1
     af0:	c0 9a       	sbi	0x18, 0	; 24
     af2:	08 95       	ret

00000af4 <_Z19enc28j60WriteBufferjPh>:
     af4:	fb 01       	movw	r30, r22
     af6:	c0 98       	cbi	0x18, 0	; 24
     af8:	2a e7       	ldi	r18, 0x7A	; 122
     afa:	2f b9       	out	0x0f, r18	; 15
     afc:	77 9b       	sbis	0x0e, 7	; 14
     afe:	fe cf       	rjmp	.-4      	; 0xafc <_Z19enc28j60WriteBufferjPh+0x8>
     b00:	00 97       	sbiw	r24, 0x00	; 0
     b02:	61 f0       	breq	.+24     	; 0xb1c <_Z19enc28j60WriteBufferjPh+0x28>
     b04:	9f 01       	movw	r18, r30
     b06:	28 0f       	add	r18, r24
     b08:	39 1f       	adc	r19, r25
     b0a:	03 c0       	rjmp	.+6      	; 0xb12 <_Z19enc28j60WriteBufferjPh+0x1e>
     b0c:	2e 17       	cp	r18, r30
     b0e:	3f 07       	cpc	r19, r31
     b10:	29 f0       	breq	.+10     	; 0xb1c <_Z19enc28j60WriteBufferjPh+0x28>
     b12:	91 91       	ld	r25, Z+
     b14:	9f b9       	out	0x0f, r25	; 15
     b16:	77 9b       	sbis	0x0e, 7	; 14
     b18:	fe cf       	rjmp	.-4      	; 0xb16 <_Z19enc28j60WriteBufferjPh+0x22>
     b1a:	f8 cf       	rjmp	.-16     	; 0xb0c <_Z19enc28j60WriteBufferjPh+0x18>
     b1c:	c0 9a       	sbi	0x18, 0	; 24
     b1e:	08 95       	ret

00000b20 <_Z15enc28j60SetBankh>:
     b20:	1f 93       	push	r17
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
     b26:	18 2f       	mov	r17, r24
     b28:	10 76       	andi	r17, 0x60	; 96
     b2a:	c1 2f       	mov	r28, r17
     b2c:	d0 e0       	ldi	r29, 0x00	; 0
     b2e:	80 91 d2 01 	lds	r24, 0x01D2	; 0x8001d2 <_ZL12Enc28j60Bank>
     b32:	90 e0       	ldi	r25, 0x00	; 0
     b34:	c8 17       	cp	r28, r24
     b36:	d9 07       	cpc	r29, r25
     b38:	a1 f0       	breq	.+40     	; 0xb62 <_Z15enc28j60SetBankh+0x42>
     b3a:	43 e0       	ldi	r20, 0x03	; 3
     b3c:	6f e1       	ldi	r22, 0x1F	; 31
     b3e:	80 ea       	ldi	r24, 0xA0	; 160
     b40:	b6 df       	rcall	.-148    	; 0xaae <_Z15enc28j60WriteOphhh>
     b42:	ae 01       	movw	r20, r28
     b44:	55 95       	asr	r21
     b46:	47 95       	ror	r20
     b48:	55 95       	asr	r21
     b4a:	47 95       	ror	r20
     b4c:	55 95       	asr	r21
     b4e:	47 95       	ror	r20
     b50:	55 95       	asr	r21
     b52:	47 95       	ror	r20
     b54:	55 95       	asr	r21
     b56:	47 95       	ror	r20
     b58:	6f e1       	ldi	r22, 0x1F	; 31
     b5a:	80 e8       	ldi	r24, 0x80	; 128
     b5c:	a8 df       	rcall	.-176    	; 0xaae <_Z15enc28j60WriteOphhh>
     b5e:	10 93 d2 01 	sts	0x01D2, r17	; 0x8001d2 <_ZL12Enc28j60Bank>
     b62:	df 91       	pop	r29
     b64:	cf 91       	pop	r28
     b66:	1f 91       	pop	r17
     b68:	08 95       	ret

00000b6a <_Z12enc28j60Readh>:
     b6a:	cf 93       	push	r28
     b6c:	c8 2f       	mov	r28, r24
     b6e:	d8 df       	rcall	.-80     	; 0xb20 <_Z15enc28j60SetBankh>
     b70:	6c 2f       	mov	r22, r28
     b72:	80 e0       	ldi	r24, 0x00	; 0
     b74:	8a df       	rcall	.-236    	; 0xa8a <_Z14enc28j60ReadOphh>
     b76:	cf 91       	pop	r28
     b78:	08 95       	ret

00000b7a <_Z13enc28j60Writehh>:
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	c8 2f       	mov	r28, r24
     b80:	d6 2f       	mov	r29, r22
     b82:	ce df       	rcall	.-100    	; 0xb20 <_Z15enc28j60SetBankh>
     b84:	4d 2f       	mov	r20, r29
     b86:	6c 2f       	mov	r22, r28
     b88:	80 e4       	ldi	r24, 0x40	; 64
     b8a:	91 df       	rcall	.-222    	; 0xaae <_Z15enc28j60WriteOphhh>
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
     b90:	08 95       	ret

00000b92 <_Z16enc28j60PhyWritehj>:
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
     b96:	d6 2f       	mov	r29, r22
     b98:	c7 2f       	mov	r28, r23
     b9a:	68 2f       	mov	r22, r24
     b9c:	84 ed       	ldi	r24, 0xD4	; 212
     b9e:	ed df       	rcall	.-38     	; 0xb7a <_Z13enc28j60Writehh>
     ba0:	6d 2f       	mov	r22, r29
     ba2:	86 ed       	ldi	r24, 0xD6	; 214
     ba4:	ea df       	rcall	.-44     	; 0xb7a <_Z13enc28j60Writehh>
     ba6:	6c 2f       	mov	r22, r28
     ba8:	87 ed       	ldi	r24, 0xD7	; 215
     baa:	e7 df       	rcall	.-50     	; 0xb7a <_Z13enc28j60Writehh>
     bac:	8a ee       	ldi	r24, 0xEA	; 234
     bae:	dd df       	rcall	.-70     	; 0xb6a <_Z12enc28j60Readh>
     bb0:	80 ff       	sbrs	r24, 0
     bb2:	04 c0       	rjmp	.+8      	; 0xbbc <_Z16enc28j60PhyWritehj+0x2a>
     bb4:	85 e0       	ldi	r24, 0x05	; 5
     bb6:	8a 95       	dec	r24
     bb8:	f1 f7       	brne	.-4      	; 0xbb6 <_Z16enc28j60PhyWritehj+0x24>
     bba:	f8 cf       	rjmp	.-16     	; 0xbac <_Z16enc28j60PhyWritehj+0x1a>
     bbc:	df 91       	pop	r29
     bbe:	cf 91       	pop	r28
     bc0:	08 95       	ret

00000bc2 <_Z14enc28j60clkouth>:
     bc2:	68 2f       	mov	r22, r24
     bc4:	67 70       	andi	r22, 0x07	; 7
     bc6:	85 e7       	ldi	r24, 0x75	; 117
     bc8:	d8 cf       	rjmp	.-80     	; 0xb7a <_Z13enc28j60Writehh>
     bca:	08 95       	ret

00000bcc <_Z12enc28j60InitPh>:
     bcc:	cf 93       	push	r28
     bce:	df 93       	push	r29
     bd0:	ec 01       	movw	r28, r24
     bd2:	b8 9a       	sbi	0x17, 0	; 23
     bd4:	c0 9a       	sbi	0x18, 0	; 24
     bd6:	a6 d2       	rcall	.+1356   	; 0x1124 <_Z8spi_initv>
     bd8:	4f ef       	ldi	r20, 0xFF	; 255
     bda:	60 e0       	ldi	r22, 0x00	; 0
     bdc:	8f ef       	ldi	r24, 0xFF	; 255
     bde:	67 df       	rcall	.-306    	; 0xaae <_Z15enc28j60WriteOphhh>
     be0:	82 e3       	ldi	r24, 0x32	; 50
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	a9 d2       	rcall	.+1362   	; 0x1138 <_Z8delay_msj>
     be6:	10 92 d1 01 	sts	0x01D1, r1	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
     bea:	10 92 d0 01 	sts	0x01D0, r1	; 0x8001d0 <_ZL13NextPacketPtr>
     bee:	60 e0       	ldi	r22, 0x00	; 0
     bf0:	88 e0       	ldi	r24, 0x08	; 8
     bf2:	c3 df       	rcall	.-122    	; 0xb7a <_Z13enc28j60Writehh>
     bf4:	60 e0       	ldi	r22, 0x00	; 0
     bf6:	89 e0       	ldi	r24, 0x09	; 9
     bf8:	c0 df       	rcall	.-128    	; 0xb7a <_Z13enc28j60Writehh>
     bfa:	60 e0       	ldi	r22, 0x00	; 0
     bfc:	8c e0       	ldi	r24, 0x0C	; 12
     bfe:	bd df       	rcall	.-134    	; 0xb7a <_Z13enc28j60Writehh>
     c00:	60 e0       	ldi	r22, 0x00	; 0
     c02:	8d e0       	ldi	r24, 0x0D	; 13
     c04:	ba df       	rcall	.-140    	; 0xb7a <_Z13enc28j60Writehh>
     c06:	6e ef       	ldi	r22, 0xFE	; 254
     c08:	8a e0       	ldi	r24, 0x0A	; 10
     c0a:	b7 df       	rcall	.-146    	; 0xb7a <_Z13enc28j60Writehh>
     c0c:	69 e1       	ldi	r22, 0x19	; 25
     c0e:	8b e0       	ldi	r24, 0x0B	; 11
     c10:	b4 df       	rcall	.-152    	; 0xb7a <_Z13enc28j60Writehh>
     c12:	6f ef       	ldi	r22, 0xFF	; 255
     c14:	84 e0       	ldi	r24, 0x04	; 4
     c16:	b1 df       	rcall	.-158    	; 0xb7a <_Z13enc28j60Writehh>
     c18:	69 e1       	ldi	r22, 0x19	; 25
     c1a:	85 e0       	ldi	r24, 0x05	; 5
     c1c:	ae df       	rcall	.-164    	; 0xb7a <_Z13enc28j60Writehh>
     c1e:	6f ef       	ldi	r22, 0xFF	; 255
     c20:	86 e0       	ldi	r24, 0x06	; 6
     c22:	ab df       	rcall	.-170    	; 0xb7a <_Z13enc28j60Writehh>
     c24:	6f e1       	ldi	r22, 0x1F	; 31
     c26:	87 e0       	ldi	r24, 0x07	; 7
     c28:	a8 df       	rcall	.-176    	; 0xb7a <_Z13enc28j60Writehh>
     c2a:	60 eb       	ldi	r22, 0xB0	; 176
     c2c:	88 e3       	ldi	r24, 0x38	; 56
     c2e:	a5 df       	rcall	.-182    	; 0xb7a <_Z13enc28j60Writehh>
     c30:	6f e3       	ldi	r22, 0x3F	; 63
     c32:	88 e2       	ldi	r24, 0x28	; 40
     c34:	a2 df       	rcall	.-188    	; 0xb7a <_Z13enc28j60Writehh>
     c36:	60 e3       	ldi	r22, 0x30	; 48
     c38:	89 e2       	ldi	r24, 0x29	; 41
     c3a:	9f df       	rcall	.-194    	; 0xb7a <_Z13enc28j60Writehh>
     c3c:	69 ef       	ldi	r22, 0xF9	; 249
     c3e:	80 e3       	ldi	r24, 0x30	; 48
     c40:	9c df       	rcall	.-200    	; 0xb7a <_Z13enc28j60Writehh>
     c42:	67 ef       	ldi	r22, 0xF7	; 247
     c44:	81 e3       	ldi	r24, 0x31	; 49
     c46:	99 df       	rcall	.-206    	; 0xb7a <_Z13enc28j60Writehh>
     c48:	6d e0       	ldi	r22, 0x0D	; 13
     c4a:	80 ec       	ldi	r24, 0xC0	; 192
     c4c:	96 df       	rcall	.-212    	; 0xb7a <_Z13enc28j60Writehh>
     c4e:	60 e0       	ldi	r22, 0x00	; 0
     c50:	81 ec       	ldi	r24, 0xC1	; 193
     c52:	93 df       	rcall	.-218    	; 0xb7a <_Z13enc28j60Writehh>
     c54:	42 e3       	ldi	r20, 0x32	; 50
     c56:	62 ec       	ldi	r22, 0xC2	; 194
     c58:	80 e8       	ldi	r24, 0x80	; 128
     c5a:	29 df       	rcall	.-430    	; 0xaae <_Z15enc28j60WriteOphhh>
     c5c:	62 e1       	ldi	r22, 0x12	; 18
     c5e:	86 ec       	ldi	r24, 0xC6	; 198
     c60:	8c df       	rcall	.-232    	; 0xb7a <_Z13enc28j60Writehh>
     c62:	6c e0       	ldi	r22, 0x0C	; 12
     c64:	87 ec       	ldi	r24, 0xC7	; 199
     c66:	89 df       	rcall	.-238    	; 0xb7a <_Z13enc28j60Writehh>
     c68:	62 e1       	ldi	r22, 0x12	; 18
     c6a:	84 ec       	ldi	r24, 0xC4	; 196
     c6c:	86 df       	rcall	.-244    	; 0xb7a <_Z13enc28j60Writehh>
     c6e:	6c ed       	ldi	r22, 0xDC	; 220
     c70:	8a ec       	ldi	r24, 0xCA	; 202
     c72:	83 df       	rcall	.-250    	; 0xb7a <_Z13enc28j60Writehh>
     c74:	65 e0       	ldi	r22, 0x05	; 5
     c76:	8b ec       	ldi	r24, 0xCB	; 203
     c78:	80 df       	rcall	.-256    	; 0xb7a <_Z13enc28j60Writehh>
     c7a:	68 81       	ld	r22, Y
     c7c:	84 ee       	ldi	r24, 0xE4	; 228
     c7e:	7d df       	rcall	.-262    	; 0xb7a <_Z13enc28j60Writehh>
     c80:	69 81       	ldd	r22, Y+1	; 0x01
     c82:	85 ee       	ldi	r24, 0xE5	; 229
     c84:	7a df       	rcall	.-268    	; 0xb7a <_Z13enc28j60Writehh>
     c86:	6a 81       	ldd	r22, Y+2	; 0x02
     c88:	82 ee       	ldi	r24, 0xE2	; 226
     c8a:	77 df       	rcall	.-274    	; 0xb7a <_Z13enc28j60Writehh>
     c8c:	6b 81       	ldd	r22, Y+3	; 0x03
     c8e:	83 ee       	ldi	r24, 0xE3	; 227
     c90:	74 df       	rcall	.-280    	; 0xb7a <_Z13enc28j60Writehh>
     c92:	6c 81       	ldd	r22, Y+4	; 0x04
     c94:	80 ee       	ldi	r24, 0xE0	; 224
     c96:	71 df       	rcall	.-286    	; 0xb7a <_Z13enc28j60Writehh>
     c98:	6d 81       	ldd	r22, Y+5	; 0x05
     c9a:	81 ee       	ldi	r24, 0xE1	; 225
     c9c:	6e df       	rcall	.-292    	; 0xb7a <_Z13enc28j60Writehh>
     c9e:	60 e0       	ldi	r22, 0x00	; 0
     ca0:	71 e0       	ldi	r23, 0x01	; 1
     ca2:	80 e1       	ldi	r24, 0x10	; 16
     ca4:	76 df       	rcall	.-276    	; 0xb92 <_Z16enc28j60PhyWritehj>
     ca6:	8f e1       	ldi	r24, 0x1F	; 31
     ca8:	3b df       	rcall	.-394    	; 0xb20 <_Z15enc28j60SetBankh>
     caa:	40 ec       	ldi	r20, 0xC0	; 192
     cac:	6b e1       	ldi	r22, 0x1B	; 27
     cae:	80 e8       	ldi	r24, 0x80	; 128
     cb0:	fe de       	rcall	.-516    	; 0xaae <_Z15enc28j60WriteOphhh>
     cb2:	44 e0       	ldi	r20, 0x04	; 4
     cb4:	6f e1       	ldi	r22, 0x1F	; 31
     cb6:	80 e8       	ldi	r24, 0x80	; 128
     cb8:	fa de       	rcall	.-524    	; 0xaae <_Z15enc28j60WriteOphhh>
     cba:	df 91       	pop	r29
     cbc:	cf 91       	pop	r28
     cbe:	08 95       	ret

00000cc0 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     cc0:	0f 93       	push	r16
     cc2:	1f 93       	push	r17
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
     cc8:	ec 01       	movw	r28, r24
     cca:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     ccc:	6f ef       	ldi	r22, 0xFF	; 255
     cce:	82 e0       	ldi	r24, 0x02	; 2
     cd0:	54 df       	rcall	.-344    	; 0xb7a <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     cd2:	69 e1       	ldi	r22, 0x19	; 25
     cd4:	83 e0       	ldi	r24, 0x03	; 3
     cd6:	51 df       	rcall	.-350    	; 0xb7a <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     cd8:	6c 2f       	mov	r22, r28
     cda:	61 50       	subi	r22, 0x01	; 1
     cdc:	86 e0       	ldi	r24, 0x06	; 6
     cde:	4d df       	rcall	.-358    	; 0xb7a <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     ce0:	ce 01       	movw	r24, r28
     ce2:	81 50       	subi	r24, 0x01	; 1
     ce4:	96 4e       	sbci	r25, 0xE6	; 230
     ce6:	69 2f       	mov	r22, r25
     ce8:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     cea:	47 df       	rcall	.-370    	; 0xb7a <_Z13enc28j60Writehh>
     cec:	40 e0       	ldi	r20, 0x00	; 0
     cee:	60 e0       	ldi	r22, 0x00	; 0
     cf0:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     cf2:	dd de       	rcall	.-582    	; 0xaae <_Z15enc28j60WriteOphhh>
     cf4:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     cf6:	ce 01       	movw	r24, r28
     cf8:	fd de       	rcall	.-518    	; 0xaf4 <_Z19enc28j60WriteBufferjPh>
     cfa:	48 e0       	ldi	r20, 0x08	; 8
     cfc:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     cfe:	80 e8       	ldi	r24, 0x80	; 128
     d00:	d6 de       	rcall	.-596    	; 0xaae <_Z15enc28j60WriteOphhh>
     d02:	8c e1       	ldi	r24, 0x1C	; 28
     d04:	32 df       	rcall	.-412    	; 0xb6a <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     d06:	81 ff       	sbrs	r24, 1
     d08:	04 c0       	rjmp	.+8      	; 0xd12 <_Z18enc28j60PacketSendjPh+0x52>
     d0a:	48 e0       	ldi	r20, 0x08	; 8
     d0c:	6f e1       	ldi	r22, 0x1F	; 31
     d0e:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     d10:	ce de       	rcall	.-612    	; 0xaae <_Z15enc28j60WriteOphhh>
     d12:	df 91       	pop	r29
     d14:	cf 91       	pop	r28
     d16:	1f 91       	pop	r17
     d18:	0f 91       	pop	r16
     d1a:	08 95       	ret

00000d1c <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     d1c:	9f 92       	push	r9
     d1e:	af 92       	push	r10
     d20:	bf 92       	push	r11
     d22:	cf 92       	push	r12
     d24:	df 92       	push	r13
     d26:	ef 92       	push	r14
     d28:	ff 92       	push	r15
     d2a:	0f 93       	push	r16
     d2c:	1f 93       	push	r17
     d2e:	cf 93       	push	r28
     d30:	df 93       	push	r29
     d32:	5c 01       	movw	r10, r24
     d34:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     d36:	89 e3       	ldi	r24, 0x39	; 57
     d38:	18 df       	rcall	.-464    	; 0xb6a <_Z12enc28j60Readh>
     d3a:	88 23       	and	r24, r24
     d3c:	09 f4       	brne	.+2      	; 0xd40 <_Z21enc28j60PacketReceivejPh+0x24>
     d3e:	45 c0       	rjmp	.+138    	; 0xdca <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     d40:	60 91 d0 01 	lds	r22, 0x01D0	; 0x8001d0 <_ZL13NextPacketPtr>
     d44:	c0 91 d1 01 	lds	r28, 0x01D1	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
     d48:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     d4a:	17 df       	rcall	.-466    	; 0xb7a <_Z13enc28j60Writehh>
     d4c:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	14 df       	rcall	.-472    	; 0xb7a <_Z13enc28j60Writehh>
     d52:	60 e0       	ldi	r22, 0x00	; 0
     d54:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d56:	99 de       	rcall	.-718    	; 0xa8a <_Z14enc28j60ReadOphh>
     d58:	c8 2f       	mov	r28, r24
     d5a:	60 e0       	ldi	r22, 0x00	; 0
     d5c:	8a e3       	ldi	r24, 0x3A	; 58
     d5e:	95 de       	rcall	.-726    	; 0xa8a <_Z14enc28j60ReadOphh>
     d60:	d0 e0       	ldi	r29, 0x00	; 0
     d62:	d8 2b       	or	r29, r24
     d64:	d0 93 d1 01 	sts	0x01D1, r29	; 0x8001d1 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d68:	c0 93 d0 01 	sts	0x01D0, r28	; 0x8001d0 <_ZL13NextPacketPtr>
     d6c:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d6e:	8a e3       	ldi	r24, 0x3A	; 58
     d70:	8c de       	rcall	.-744    	; 0xa8a <_Z14enc28j60ReadOphh>
     d72:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     d74:	60 e0       	ldi	r22, 0x00	; 0
     d76:	8a e3       	ldi	r24, 0x3A	; 58
     d78:	88 de       	rcall	.-752    	; 0xa8a <_Z14enc28j60ReadOphh>
     d7a:	98 2e       	mov	r9, r24
     d7c:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     d7e:	8a e3       	ldi	r24, 0x3A	; 58
     d80:	84 de       	rcall	.-760    	; 0xa8a <_Z14enc28j60ReadOphh>
     d82:	c8 2e       	mov	r12, r24
     d84:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     d86:	8a e3       	ldi	r24, 0x3A	; 58
     d88:	80 de       	rcall	.-768    	; 0xa8a <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     d8a:	c7 fe       	sbrs	r12, 7
     d8c:	0f c0       	rjmp	.+30     	; 0xdac <_Z21enc28j60PacketReceivejPh+0x90>
     d8e:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     d90:	a8 1a       	sub	r10, r24
     d92:	b1 08       	sbc	r11, r1
     d94:	10 e0       	ldi	r17, 0x00	; 0
     d96:	19 29       	or	r17, r9
     d98:	04 50       	subi	r16, 0x04	; 4
     d9a:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     d9c:	a0 16       	cp	r10, r16
     d9e:	b1 06       	cpc	r11, r17
     da0:	08 f4       	brcc	.+2      	; 0xda4 <_Z21enc28j60PacketReceivejPh+0x88>
     da2:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     da4:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     da6:	c8 01       	movw	r24, r16
     da8:	8d de       	rcall	.-742    	; 0xac4 <_Z18enc28j60ReadBufferjPh>
     daa:	02 c0       	rjmp	.+4      	; 0xdb0 <_Z21enc28j60PacketReceivejPh+0x94>
     dac:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     dae:	10 e0       	ldi	r17, 0x00	; 0
     db0:	6c 2f       	mov	r22, r28
     db2:	8c e0       	ldi	r24, 0x0C	; 12
     db4:	e2 de       	rcall	.-572    	; 0xb7a <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     db6:	6d 2f       	mov	r22, r29
     db8:	8d e0       	ldi	r24, 0x0D	; 13
     dba:	df de       	rcall	.-578    	; 0xb7a <_Z13enc28j60Writehh>
     dbc:	40 e4       	ldi	r20, 0x40	; 64
     dbe:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     dc0:	80 e8       	ldi	r24, 0x80	; 128
     dc2:	75 de       	rcall	.-790    	; 0xaae <_Z15enc28j60WriteOphhh>
     dc4:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     dc6:	91 2f       	mov	r25, r17
     dc8:	02 c0       	rjmp	.+4      	; 0xdce <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	df 91       	pop	r29
     dd0:	cf 91       	pop	r28
     dd2:	1f 91       	pop	r17
     dd4:	0f 91       	pop	r16
     dd6:	ff 90       	pop	r15
     dd8:	ef 90       	pop	r14
     dda:	df 90       	pop	r13
     ddc:	cf 90       	pop	r12
     dde:	bf 90       	pop	r11
     de0:	af 90       	pop	r10
     de2:	9f 90       	pop	r9
     de4:	08 95       	ret

00000de6 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     de6:	cf 92       	push	r12
     de8:	df 92       	push	r13
     dea:	ef 92       	push	r14
     dec:	ff 92       	push	r15
     dee:	cf 93       	push	r28
     df0:	df 93       	push	r29
     df2:	ec 01       	movw	r28, r24
     df4:	db 01       	movw	r26, r22
     df6:	41 30       	cpi	r20, 0x01	; 1
     df8:	61 f4       	brne	.+24     	; 0xe12 <_Z8checksumPhjh+0x2c>
     dfa:	6b 01       	movw	r12, r22
     dfc:	88 e0       	ldi	r24, 0x08	; 8
     dfe:	c8 1a       	sub	r12, r24
     e00:	d1 08       	sbc	r13, r1
     e02:	e1 2c       	mov	r14, r1
     e04:	f1 2c       	mov	r15, r1
     e06:	81 e1       	ldi	r24, 0x11	; 17
     e08:	c8 0e       	add	r12, r24
     e0a:	d1 1c       	adc	r13, r1
     e0c:	e1 1c       	adc	r14, r1
     e0e:	f1 1c       	adc	r15, r1
     e10:	11 c0       	rjmp	.+34     	; 0xe34 <_Z8checksumPhjh+0x4e>
     e12:	42 30       	cpi	r20, 0x02	; 2
     e14:	61 f4       	brne	.+24     	; 0xe2e <_Z8checksumPhjh+0x48>
     e16:	6b 01       	movw	r12, r22
     e18:	88 e0       	ldi	r24, 0x08	; 8
     e1a:	c8 1a       	sub	r12, r24
     e1c:	d1 08       	sbc	r13, r1
     e1e:	e1 2c       	mov	r14, r1
     e20:	f1 2c       	mov	r15, r1
     e22:	86 e0       	ldi	r24, 0x06	; 6
     e24:	c8 0e       	add	r12, r24
     e26:	d1 1c       	adc	r13, r1
     e28:	e1 1c       	adc	r14, r1
     e2a:	f1 1c       	adc	r15, r1
     e2c:	03 c0       	rjmp	.+6      	; 0xe34 <_Z8checksumPhjh+0x4e>
     e2e:	c1 2c       	mov	r12, r1
     e30:	d1 2c       	mov	r13, r1
     e32:	76 01       	movw	r14, r12
     e34:	a2 30       	cpi	r26, 0x02	; 2
     e36:	b1 05       	cpc	r27, r1
     e38:	f0 f0       	brcs	.+60     	; 0xe76 <_Z8checksumPhjh+0x90>
     e3a:	9d 01       	movw	r18, r26
     e3c:	fe 01       	movw	r30, r28
     e3e:	40 81       	ld	r20, Z
     e40:	50 e0       	ldi	r21, 0x00	; 0
     e42:	60 e0       	ldi	r22, 0x00	; 0
     e44:	70 e0       	ldi	r23, 0x00	; 0
     e46:	76 2f       	mov	r23, r22
     e48:	65 2f       	mov	r22, r21
     e4a:	54 2f       	mov	r21, r20
     e4c:	44 27       	eor	r20, r20
     e4e:	81 81       	ldd	r24, Z+1	; 0x01
     e50:	48 2b       	or	r20, r24
     e52:	c4 0e       	add	r12, r20
     e54:	d5 1e       	adc	r13, r21
     e56:	e6 1e       	adc	r14, r22
     e58:	f7 1e       	adc	r15, r23
     e5a:	32 96       	adiw	r30, 0x02	; 2
     e5c:	22 50       	subi	r18, 0x02	; 2
     e5e:	31 09       	sbc	r19, r1
     e60:	22 30       	cpi	r18, 0x02	; 2
     e62:	31 05       	cpc	r19, r1
     e64:	60 f7       	brcc	.-40     	; 0xe3e <_Z8checksumPhjh+0x58>
     e66:	cd 01       	movw	r24, r26
     e68:	02 97       	sbiw	r24, 0x02	; 2
     e6a:	8e 7f       	andi	r24, 0xFE	; 254
     e6c:	02 96       	adiw	r24, 0x02	; 2
     e6e:	c8 0f       	add	r28, r24
     e70:	d9 1f       	adc	r29, r25
     e72:	a1 70       	andi	r26, 0x01	; 1
     e74:	bb 27       	eor	r27, r27
     e76:	ab 2b       	or	r26, r27
     e78:	61 f0       	breq	.+24     	; 0xe92 <_Z8checksumPhjh+0xac>
     e7a:	88 81       	ld	r24, Y
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	a0 e0       	ldi	r26, 0x00	; 0
     e80:	b0 e0       	ldi	r27, 0x00	; 0
     e82:	ba 2f       	mov	r27, r26
     e84:	a9 2f       	mov	r26, r25
     e86:	98 2f       	mov	r25, r24
     e88:	88 27       	eor	r24, r24
     e8a:	c8 0e       	add	r12, r24
     e8c:	d9 1e       	adc	r13, r25
     e8e:	ea 1e       	adc	r14, r26
     e90:	fb 1e       	adc	r15, r27
     e92:	a7 01       	movw	r20, r14
     e94:	66 27       	eor	r22, r22
     e96:	77 27       	eor	r23, r23
     e98:	41 15       	cp	r20, r1
     e9a:	51 05       	cpc	r21, r1
     e9c:	61 05       	cpc	r22, r1
     e9e:	71 05       	cpc	r23, r1
     ea0:	71 f0       	breq	.+28     	; 0xebe <_Z8checksumPhjh+0xd8>
     ea2:	ee 24       	eor	r14, r14
     ea4:	ff 24       	eor	r15, r15
     ea6:	c4 0e       	add	r12, r20
     ea8:	d5 1e       	adc	r13, r21
     eaa:	e6 1e       	adc	r14, r22
     eac:	f7 1e       	adc	r15, r23
     eae:	a7 01       	movw	r20, r14
     eb0:	66 27       	eor	r22, r22
     eb2:	77 27       	eor	r23, r23
     eb4:	41 15       	cp	r20, r1
     eb6:	51 05       	cpc	r21, r1
     eb8:	61 05       	cpc	r22, r1
     eba:	71 05       	cpc	r23, r1
     ebc:	91 f7       	brne	.-28     	; 0xea2 <_Z8checksumPhjh+0xbc>
     ebe:	c6 01       	movw	r24, r12
     ec0:	80 95       	com	r24
     ec2:	90 95       	com	r25
     ec4:	df 91       	pop	r29
     ec6:	cf 91       	pop	r28
     ec8:	ff 90       	pop	r15
     eca:	ef 90       	pop	r14
     ecc:	df 90       	pop	r13
     ece:	cf 90       	pop	r12
     ed0:	08 95       	ret

00000ed2 <_Z19init_ip_arp_udp_tcpPhS_h>:
     ed2:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     ed6:	a6 2f       	mov	r26, r22
     ed8:	b7 2f       	mov	r27, r23
     eda:	e3 ed       	ldi	r30, 0xD3	; 211
     edc:	f1 e0       	ldi	r31, 0x01	; 1
     ede:	47 ed       	ldi	r20, 0xD7	; 215
     ee0:	51 e0       	ldi	r21, 0x01	; 1
     ee2:	2d 91       	ld	r18, X+
     ee4:	21 93       	st	Z+, r18
     ee6:	e4 17       	cp	r30, r20
     ee8:	f5 07       	cpc	r31, r21
     eea:	d9 f7       	brne	.-10     	; 0xee2 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     eec:	a8 2f       	mov	r26, r24
     eee:	b9 2f       	mov	r27, r25
     ef0:	e7 ed       	ldi	r30, 0xD7	; 215
     ef2:	f1 e0       	ldi	r31, 0x01	; 1
     ef4:	2d ed       	ldi	r18, 0xDD	; 221
     ef6:	31 e0       	ldi	r19, 0x01	; 1
     ef8:	8d 91       	ld	r24, X+
     efa:	81 93       	st	Z+, r24
     efc:	e2 17       	cp	r30, r18
     efe:	f3 07       	cpc	r31, r19
     f00:	d9 f7       	brne	.-10     	; 0xef8 <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     f02:	08 95       	ret

00000f04 <_Z25eth_type_is_arp_and_my_ipPhj>:
     f04:	69 32       	cpi	r22, 0x29	; 41
     f06:	71 05       	cpc	r23, r1
     f08:	c8 f0       	brcs	.+50     	; 0xf3c <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     f0a:	fc 01       	movw	r30, r24
     f0c:	24 85       	ldd	r18, Z+12	; 0x0c
     f0e:	28 30       	cpi	r18, 0x08	; 8
     f10:	b9 f4       	brne	.+46     	; 0xf40 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     f12:	25 85       	ldd	r18, Z+13	; 0x0d
     f14:	26 30       	cpi	r18, 0x06	; 6
     f16:	b1 f4       	brne	.+44     	; 0xf44 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     f18:	36 a1       	ldd	r19, Z+38	; 0x26
     f1a:	20 91 d3 01 	lds	r18, 0x01D3	; 0x8001d3 <_ZL6ipaddr>
     f1e:	32 13       	cpse	r19, r18
     f20:	13 c0       	rjmp	.+38     	; 0xf48 <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     f22:	b7 96       	adiw	r30, 0x27	; 39
     f24:	a4 ed       	ldi	r26, 0xD4	; 212
     f26:	b1 e0       	ldi	r27, 0x01	; 1
     f28:	8a 96       	adiw	r24, 0x2a	; 42
     f2a:	31 91       	ld	r19, Z+
     f2c:	2d 91       	ld	r18, X+
     f2e:	32 13       	cpse	r19, r18
     f30:	0d c0       	rjmp	.+26     	; 0xf4c <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     f32:	e8 17       	cp	r30, r24
     f34:	f9 07       	cpc	r31, r25
     f36:	c9 f7       	brne	.-14     	; 0xf2a <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	08 95       	ret
     f3c:	80 e0       	ldi	r24, 0x00	; 0
     f3e:	08 95       	ret
     f40:	80 e0       	ldi	r24, 0x00	; 0
     f42:	08 95       	ret
     f44:	80 e0       	ldi	r24, 0x00	; 0
     f46:	08 95       	ret
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	08 95       	ret
     f4c:	80 e0       	ldi	r24, 0x00	; 0
     f4e:	08 95       	ret

00000f50 <_Z24eth_type_is_ip_and_my_ipPhj>:
     f50:	cf 93       	push	r28
     f52:	df 93       	push	r29
     f54:	fc 01       	movw	r30, r24
     f56:	6a 32       	cpi	r22, 0x2A	; 42
     f58:	71 05       	cpc	r23, r1
     f5a:	e0 f0       	brcs	.+56     	; 0xf94 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     f5c:	84 85       	ldd	r24, Z+12	; 0x0c
     f5e:	88 30       	cpi	r24, 0x08	; 8
     f60:	d9 f4       	brne	.+54     	; 0xf98 <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     f62:	85 85       	ldd	r24, Z+13	; 0x0d
     f64:	81 11       	cpse	r24, r1
     f66:	1a c0       	rjmp	.+52     	; 0xf9c <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     f68:	96 85       	ldd	r25, Z+14	; 0x0e
     f6a:	95 34       	cpi	r25, 0x45	; 69
     f6c:	c1 f4       	brne	.+48     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f6e:	26 8d       	ldd	r18, Z+30	; 0x1e
     f70:	90 91 d3 01 	lds	r25, 0x01D3	; 0x8001d3 <_ZL6ipaddr>
     f74:	29 13       	cpse	r18, r25
     f76:	13 c0       	rjmp	.+38     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f78:	df 01       	movw	r26, r30
     f7a:	5f 96       	adiw	r26, 0x1f	; 31
     f7c:	c4 ed       	ldi	r28, 0xD4	; 212
     f7e:	d1 e0       	ldi	r29, 0x01	; 1
     f80:	b2 96       	adiw	r30, 0x22	; 34
     f82:	2d 91       	ld	r18, X+
     f84:	99 91       	ld	r25, Y+
     f86:	29 13       	cpse	r18, r25
     f88:	0a c0       	rjmp	.+20     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f8a:	ae 17       	cp	r26, r30
     f8c:	bf 07       	cpc	r27, r31
     f8e:	c9 f7       	brne	.-14     	; 0xf82 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     f90:	81 e0       	ldi	r24, 0x01	; 1
     f92:	05 c0       	rjmp	.+10     	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f94:	80 e0       	ldi	r24, 0x00	; 0
     f96:	03 c0       	rjmp	.+6      	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	01 c0       	rjmp	.+2      	; 0xf9e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     f9c:	80 e0       	ldi	r24, 0x00	; 0
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret

00000fa4 <_Z8make_ethPh>:
     fa4:	fc 01       	movw	r30, r24
     fa6:	a7 ed       	ldi	r26, 0xD7	; 215
     fa8:	b1 e0       	ldi	r27, 0x01	; 1
     faa:	9c 01       	movw	r18, r24
     fac:	2a 5f       	subi	r18, 0xFA	; 250
     fae:	3f 4f       	sbci	r19, 0xFF	; 255
     fb0:	86 81       	ldd	r24, Z+6	; 0x06
     fb2:	81 93       	st	Z+, r24
     fb4:	8d 91       	ld	r24, X+
     fb6:	85 83       	std	Z+5, r24	; 0x05
     fb8:	e2 17       	cp	r30, r18
     fba:	f3 07       	cpc	r31, r19
     fbc:	c9 f7       	brne	.-14     	; 0xfb0 <_Z8make_ethPh+0xc>
     fbe:	08 95       	ret

00000fc0 <_Z20fill_ip_hdr_checksumPh>:
     fc0:	cf 93       	push	r28
     fc2:	df 93       	push	r29
     fc4:	ec 01       	movw	r28, r24
     fc6:	18 8e       	std	Y+24, r1	; 0x18
     fc8:	19 8e       	std	Y+25, r1	; 0x19
     fca:	80 e4       	ldi	r24, 0x40	; 64
     fcc:	8c 8b       	std	Y+20, r24	; 0x14
     fce:	1d 8a       	std	Y+21, r1	; 0x15
     fd0:	8e 8b       	std	Y+22, r24	; 0x16
     fd2:	40 e0       	ldi	r20, 0x00	; 0
     fd4:	64 e1       	ldi	r22, 0x14	; 20
     fd6:	70 e0       	ldi	r23, 0x00	; 0
     fd8:	ce 01       	movw	r24, r28
     fda:	0e 96       	adiw	r24, 0x0e	; 14
     fdc:	04 df       	rcall	.-504    	; 0xde6 <_Z8checksumPhjh>
     fde:	98 8f       	std	Y+24, r25	; 0x18
     fe0:	89 8f       	std	Y+25, r24	; 0x19
     fe2:	df 91       	pop	r29
     fe4:	cf 91       	pop	r28
     fe6:	08 95       	ret

00000fe8 <_Z7make_ipPh>:
     fe8:	ac 01       	movw	r20, r24
     fea:	a3 ed       	ldi	r26, 0xD3	; 211
     fec:	b1 e0       	ldi	r27, 0x01	; 1
     fee:	fc 01       	movw	r30, r24
     ff0:	7a 96       	adiw	r30, 0x1a	; 26
     ff2:	27 ed       	ldi	r18, 0xD7	; 215
     ff4:	31 e0       	ldi	r19, 0x01	; 1
     ff6:	90 81       	ld	r25, Z
     ff8:	94 83       	std	Z+4, r25	; 0x04
     ffa:	9d 91       	ld	r25, X+
     ffc:	91 93       	st	Z+, r25
     ffe:	a2 17       	cp	r26, r18
    1000:	b3 07       	cpc	r27, r19
    1002:	c9 f7       	brne	.-14     	; 0xff6 <_Z7make_ipPh+0xe>
    1004:	ca 01       	movw	r24, r20
    1006:	dc cf       	rjmp	.-72     	; 0xfc0 <_Z20fill_ip_hdr_checksumPh>
    1008:	08 95       	ret

0000100a <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
    100a:	cf 93       	push	r28
    100c:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    100e:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    1010:	c9 df       	rcall	.-110    	; 0xfa4 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    1012:	1c 8a       	std	Y+20, r1	; 0x14
    1014:	82 e0       	ldi	r24, 0x02	; 2
    1016:	8d 8b       	std	Y+21, r24	; 0x15
    1018:	a7 ed       	ldi	r26, 0xD7	; 215
    101a:	b1 e0       	ldi	r27, 0x01	; 1
    101c:	fe 01       	movw	r30, r28
    101e:	76 96       	adiw	r30, 0x16	; 22
    1020:	2d ed       	ldi	r18, 0xDD	; 221
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    1022:	31 e0       	ldi	r19, 0x01	; 1
    1024:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    1026:	82 87       	std	Z+10, r24	; 0x0a
    1028:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    102a:	81 93       	st	Z+, r24
    102c:	a2 17       	cp	r26, r18
    102e:	b3 07       	cpc	r27, r19
    1030:	c9 f7       	brne	.-14     	; 0x1024 <_Z28make_arp_answer_from_requestPh+0x1a>
    1032:	a3 ed       	ldi	r26, 0xD3	; 211
    1034:	b1 e0       	ldi	r27, 0x01	; 1
    1036:	fe 01       	movw	r30, r28
    1038:	7c 96       	adiw	r30, 0x1c	; 28
    103a:	27 ed       	ldi	r18, 0xD7	; 215
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    103c:	31 e0       	ldi	r19, 0x01	; 1
    103e:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    1040:	82 87       	std	Z+10, r24	; 0x0a
    1042:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    1044:	81 93       	st	Z+, r24
    1046:	a2 17       	cp	r26, r18
    1048:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    104a:	c9 f7       	brne	.-14     	; 0x103e <_Z28make_arp_answer_from_requestPh+0x34>
    104c:	be 01       	movw	r22, r28
    104e:	8a e2       	ldi	r24, 0x2A	; 42
    1050:	90 e0       	ldi	r25, 0x00	; 0
}
    1052:	36 de       	rcall	.-916    	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1054:	df 91       	pop	r29
    1056:	cf 91       	pop	r28
    1058:	08 95       	ret

0000105a <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    1064:	8b 01       	movw	r16, r22
    1066:	9e df       	rcall	.-196    	; 0xfa4 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    1068:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    106a:	be df       	rcall	.-132    	; 0xfe8 <_Z7make_ipPh>
    106c:	1a a2       	std	Y+34, r1	; 0x22
    106e:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    1070:	88 3f       	cpi	r24, 0xF8	; 248
    1072:	18 f0       	brcs	.+6      	; 0x107a <_Z28make_echo_reply_from_requestPhj+0x20>
    1074:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    1076:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
    1078:	9d a3       	std	Y+37, r25	; 0x25
    107a:	88 5f       	subi	r24, 0xF8	; 248
    107c:	8c a3       	std	Y+36, r24	; 0x24
}
    107e:	be 01       	movw	r22, r28
    1080:	c8 01       	movw	r24, r16
    1082:	1e de       	rcall	.-964    	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1084:	df 91       	pop	r29
    1086:	cf 91       	pop	r28
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	08 95       	ret

0000108e <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    108e:	df 92       	push	r13
    1090:	ef 92       	push	r14
    1092:	ff 92       	push	r15
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	ec 01       	movw	r28, r24
    109e:	d6 2e       	mov	r13, r22
    10a0:	e7 2e       	mov	r14, r23
    10a2:	04 2f       	mov	r16, r20
    10a4:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    10a6:	f3 2e       	mov	r15, r19
    10a8:	7d df       	rcall	.-262    	; 0xfa4 <_Z8make_ethPh>
    10aa:	0d 3d       	cpi	r16, 0xDD	; 221
    10ac:	08 f0       	brcs	.+2      	; 0x10b0 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    10ae:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    10b0:	18 8a       	std	Y+16, r1	; 0x10
    10b2:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    10b4:	80 0f       	add	r24, r16
    10b6:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    10b8:	ce 01       	movw	r24, r28
    10ba:	96 df       	rcall	.-212    	; 0xfe8 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    10bc:	8a a1       	ldd	r24, Y+34	; 0x22
    10be:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    10c0:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    10c2:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    10c4:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    10c6:	1b a3       	std	Y+35, r17	; 0x23
    10c8:	1e a2       	std	Y+38, r1	; 0x26
    10ca:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    10cc:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    10ce:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
    10d0:	18 a6       	std	Y+40, r1	; 0x28
    10d2:	19 a6       	std	Y+41, r1	; 0x29
    10d4:	00 23       	and	r16, r16
    10d6:	81 f0       	breq	.+32     	; 0x10f8 <_Z27make_udp_reply_from_requestPhPchj+0x6a>
    10d8:	ad 2d       	mov	r26, r13
    10da:	be 2d       	mov	r27, r14
    10dc:	fe 01       	movw	r30, r28
    10de:	ba 96       	adiw	r30, 0x2a	; 42
    10e0:	2f ef       	ldi	r18, 0xFF	; 255
    10e2:	20 0f       	add	r18, r16
    10e4:	30 e0       	ldi	r19, 0x00	; 0
    10e6:	25 5d       	subi	r18, 0xD5	; 213
    10e8:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
    10ea:	2c 0f       	add	r18, r28
    10ec:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    10ee:	9d 91       	ld	r25, X+
    10f0:	91 93       	st	Z+, r25
    10f2:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    10f4:	f3 07       	cpc	r31, r19
    10f6:	d9 f7       	brne	.-10     	; 0x10ee <_Z27make_udp_reply_from_requestPhPchj+0x60>
    10f8:	10 e0       	ldi	r17, 0x00	; 0
    10fa:	b8 01       	movw	r22, r16
    10fc:	60 5f       	subi	r22, 0xF0	; 240
    10fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1100:	41 e0       	ldi	r20, 0x01	; 1
    1102:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1104:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    1106:	6f de       	rcall	.-802    	; 0xde6 <_Z8checksumPhjh>
    1108:	98 a7       	std	Y+40, r25	; 0x28
    110a:	89 a7       	std	Y+41, r24	; 0x29
    110c:	be 01       	movw	r22, r28
}
    110e:	c8 01       	movw	r24, r16
    1110:	8a 96       	adiw	r24, 0x2a	; 42
    1112:	d6 dd       	rcall	.-1108   	; 0xcc0 <_Z18enc28j60PacketSendjPh>
    1114:	df 91       	pop	r29
    1116:	cf 91       	pop	r28
    1118:	1f 91       	pop	r17
    111a:	0f 91       	pop	r16
    111c:	ff 90       	pop	r15
    111e:	ef 90       	pop	r14
    1120:	df 90       	pop	r13
    1122:	08 95       	ret

00001124 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1124:	87 b3       	in	r24, 0x17	; 23
    1126:	86 60       	ori	r24, 0x06	; 6
    1128:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    112a:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    112c:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    112e:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    1130:	80 e5       	ldi	r24, 0x50	; 80
    1132:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    1134:	70 9a       	sbi	0x0e, 0	; 14
    1136:	08 95       	ret

00001138 <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    1138:	00 97       	sbiw	r24, 0x00	; 0
    113a:	41 f0       	breq	.+16     	; 0x114c <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    113c:	ef eb       	ldi	r30, 0xBF	; 191
    113e:	f0 e0       	ldi	r31, 0x00	; 0
    1140:	31 97       	sbiw	r30, 0x01	; 1
    1142:	f1 f7       	brne	.-4      	; 0x1140 <_Z8delay_msj+0x8>
    1144:	00 c0       	rjmp	.+0      	; 0x1146 <_Z8delay_msj+0xe>
    1146:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    1148:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    114a:	c1 f7       	brne	.-16     	; 0x113c <_Z8delay_msj+0x4>
    114c:	08 95       	ret

0000114e <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    114e:	ef eb       	ldi	r30, 0xBF	; 191
    1150:	f2 e0       	ldi	r31, 0x02	; 2
    1152:	84 85       	ldd	r24, Z+12	; 0x0c
    1154:	95 85       	ldd	r25, Z+13	; 0x0d
    1156:	01 96       	adiw	r24, 0x01	; 1
    1158:	95 87       	std	Z+13, r25	; 0x0d
    115a:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
    115c:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
    115e:	c6 98       	cbi	0x18, 6	; 24
    1160:	08 95       	ret

00001162 <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,20,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    1162:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <chatter_flag>
    1166:	81 11       	cpse	r24, r1
    1168:	03 c0       	rjmp	.+6      	; 0x1170 <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    116a:	81 e0       	ldi	r24, 0x01	; 1
    116c:	80 93 ba 02 	sts	0x02BA, r24	; 0x8002ba <chatter_flag>
    1170:	08 95       	ret

00001172 <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
    1172:	cf 93       	push	r28
    1174:	df 93       	push	r29
    1176:	cd b7       	in	r28, 0x3d	; 61
    1178:	de b7       	in	r29, 0x3e	; 62
    117a:	a2 97       	sbiw	r28, 0x22	; 34
    117c:	0f b6       	in	r0, 0x3f	; 63
    117e:	f8 94       	cli
    1180:	de bf       	out	0x3e, r29	; 62
    1182:	0f be       	out	0x3f, r0	; 63
    1184:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1186:	0b eb       	ldi	r16, 0xBB	; 187
    1188:	12 e0       	ldi	r17, 0x02	; 2
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    118a:	0f 2e       	mov	r0, r31
    118c:	ff ef       	ldi	r31, 0xFF	; 255
    118e:	4f 2e       	mov	r4, r31
    1190:	f2 e0       	ldi	r31, 0x02	; 2
    1192:	5f 2e       	mov	r5, r31
    1194:	f0 2d       	mov	r31, r0
    1196:	0f 2e       	mov	r0, r31
    1198:	f1 e0       	ldi	r31, 0x01	; 1
    119a:	cf 2e       	mov	r12, r31
    119c:	f3 e0       	ldi	r31, 0x03	; 3
    119e:	df 2e       	mov	r13, r31
    11a0:	f0 2d       	mov	r31, r0
    11a2:	0f 2e       	mov	r0, r31
    11a4:	f3 e0       	ldi	r31, 0x03	; 3
    11a6:	ef 2e       	mov	r14, r31
    11a8:	f3 e0       	ldi	r31, 0x03	; 3
    11aa:	ff 2e       	mov	r15, r31
    11ac:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
    11ae:	ce 01       	movw	r24, r28
    11b0:	01 96       	adiw	r24, 0x01	; 1
    11b2:	9f 8f       	std	Y+31, r25	; 0x1f
    11b4:	8e 8f       	std	Y+30, r24	; 0x1e
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    11b6:	33 24       	eor	r3, r3
    11b8:	33 94       	inc	r3
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    11ba:	f8 01       	movw	r30, r16
    11bc:	80 81       	ld	r24, Z
    11be:	91 81       	ldd	r25, Z+1	; 0x01
    11c0:	a2 81       	ldd	r26, Z+2	; 0x02
    11c2:	b3 81       	ldd	r27, Z+3	; 0x03
    11c4:	80 93 b6 02 	sts	0x02B6, r24	; 0x8002b6 <_ZZL5proc2PvE4myip>
    11c8:	90 93 b7 02 	sts	0x02B7, r25	; 0x8002b7 <_ZZL5proc2PvE4myip+0x1>
    11cc:	a0 93 b8 02 	sts	0x02B8, r26	; 0x8002b8 <_ZZL5proc2PvE4myip+0x2>
    11d0:	b0 93 b9 02 	sts	0x02B9, r27	; 0x8002b9 <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
    11d4:	8f ef       	ldi	r24, 0xFF	; 255
    11d6:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    11d8:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    11de:	f6 dc       	rcall	.-1556   	; 0xbcc <_Z12enc28j60InitPh>
    11e0:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    11e2:	ef dc       	rcall	.-1570   	; 0xbc2 <_Z14enc28j60clkouth>
    11e4:	8a e0       	ldi	r24, 0x0A	; 10
    11e6:	90 e0       	ldi	r25, 0x00	; 0
    11e8:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    11ec:	66 e7       	ldi	r22, 0x76	; 118
    11ee:	74 e0       	ldi	r23, 0x04	; 4
    11f0:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    11f2:	cf dc       	rcall	.-1634   	; 0xb92 <_Z16enc28j60PhyWritehj>
    11f4:	84 e1       	ldi	r24, 0x14	; 20
    11f6:	90 e0       	ldi	r25, 0x00	; 0
    11f8:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    11fc:	40 e5       	ldi	r20, 0x50	; 80
    11fe:	66 eb       	ldi	r22, 0xB6	; 182
    1200:	72 e0       	ldi	r23, 0x02	; 2
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	91 e0       	ldi	r25, 0x01	; 1

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
    1206:	65 de       	rcall	.-822    	; 0xed2 <_Z19init_ip_arp_udp_tcpPhS_h>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1208:	18 a2       	std	Y+32, r1	; 0x20
    120a:	21 2c       	mov	r2, r1
    120c:	0f 2e       	mov	r0, r31
    120e:	f5 e0       	ldi	r31, 0x05	; 5
    1210:	af 2e       	mov	r10, r31
    1212:	f3 e0       	ldi	r31, 0x03	; 3
    1214:	bf 2e       	mov	r11, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    1216:	f0 2d       	mov	r31, r0
    1218:	0f 2e       	mov	r0, r31
    121a:	fd ed       	ldi	r31, 0xDD	; 221
    121c:	6f 2e       	mov	r6, r31
    121e:	f1 e0       	ldi	r31, 0x01	; 1
    1220:	7f 2e       	mov	r7, r31
    1222:	f0 2d       	mov	r31, r0
    1224:	0f 2e       	mov	r0, r31
    1226:	ff eb       	ldi	r31, 0xBF	; 191
    1228:	8f 2e       	mov	r8, r31
    122a:	f2 e0       	ldi	r31, 0x02	; 2
    122c:	9f 2e       	mov	r9, r31
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    122e:	f0 2d       	mov	r31, r0
    1230:	d8 01       	movw	r26, r16
    1232:	8c 91       	ld	r24, X
    1234:	90 e0       	ldi	r25, 0x00	; 0
    1236:	f2 01       	movw	r30, r4
    1238:	60 81       	ld	r22, Z
    123a:	71 81       	ldd	r23, Z+1	; 0x01
    123c:	11 96       	adiw	r26, 0x01	; 1
    123e:	4c 91       	ld	r20, X
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	33 2d       	mov	r19, r3
    1244:	f6 01       	movw	r30, r12
    1246:	a0 81       	ld	r26, Z
    1248:	b1 81       	ldd	r27, Z+1	; 0x01
    124a:	4a 17       	cp	r20, r26
    124c:	5b 07       	cpc	r21, r27
    124e:	09 f4       	brne	.+2      	; 0x1252 <_ZL5proc2Pv+0xe0>
    1250:	32 2d       	mov	r19, r2
    1252:	23 2d       	mov	r18, r3
    1254:	86 17       	cp	r24, r22
    1256:	97 07       	cpc	r25, r23
    1258:	09 f4       	brne	.+2      	; 0x125c <_ZL5proc2Pv+0xea>
    125a:	22 2d       	mov	r18, r2
    125c:	f3 2f       	mov	r31, r19
    125e:	f2 2b       	or	r31, r18
    1260:	d8 01       	movw	r26, r16
    1262:	12 96       	adiw	r26, 0x02	; 2
    1264:	2c 91       	ld	r18, X
    1266:	30 e0       	ldi	r19, 0x00	; 0
    1268:	e3 2d       	mov	r30, r3
    126a:	d7 01       	movw	r26, r14
    126c:	4d 91       	ld	r20, X+
    126e:	5c 91       	ld	r21, X
    1270:	24 17       	cp	r18, r20
    1272:	35 07       	cpc	r19, r21
    1274:	09 f4       	brne	.+2      	; 0x1278 <_ZL5proc2Pv+0x106>
    1276:	e2 2d       	mov	r30, r2
    1278:	ef 2b       	or	r30, r31
    127a:	71 f4       	brne	.+28     	; 0x1298 <_ZL5proc2Pv+0x126>
    127c:	f8 01       	movw	r30, r16
    127e:	23 81       	ldd	r18, Z+3	; 0x03
    1280:	30 e0       	ldi	r19, 0x00	; 0
    1282:	e3 2d       	mov	r30, r3
    1284:	d5 01       	movw	r26, r10
    1286:	4d 91       	ld	r20, X+
    1288:	5c 91       	ld	r21, X
    128a:	24 17       	cp	r18, r20
    128c:	35 07       	cpc	r19, r21
    128e:	09 f4       	brne	.+2      	; 0x1292 <_ZL5proc2Pv+0x120>
    1290:	e2 2d       	mov	r30, r2
    1292:	ee 23       	and	r30, r30
    1294:	09 f4       	brne	.+2      	; 0x1298 <_ZL5proc2Pv+0x126>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    1296:	46 c0       	rjmp	.+140    	; 0x1324 <_ZL5proc2Pv+0x1b2>
    1298:	86 17       	cp	r24, r22
    129a:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    129c:	41 f0       	breq	.+16     	; 0x12ae <_ZL5proc2Pv+0x13c>
    129e:	80 e0       	ldi	r24, 0x00	; 0
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	0e 94 91 18 	call	0x3122	; 0x3122 <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    12a6:	f2 01       	movw	r30, r4
    12a8:	80 81       	ld	r24, Z
    12aa:	d8 01       	movw	r26, r16
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    12ac:	8c 93       	st	X, r24
    12ae:	f6 01       	movw	r30, r12
    12b0:	60 81       	ld	r22, Z
    12b2:	71 81       	ldd	r23, Z+1	; 0x01
    12b4:	d8 01       	movw	r26, r16
    12b6:	11 96       	adiw	r26, 0x01	; 1
    12b8:	8c 91       	ld	r24, X
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	86 17       	cp	r24, r22
    12be:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    12c0:	49 f0       	breq	.+18     	; 0x12d4 <_ZL5proc2Pv+0x162>
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	90 e0       	ldi	r25, 0x00	; 0
    12c6:	0e 94 91 18 	call	0x3122	; 0x3122 <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    12ca:	f6 01       	movw	r30, r12
    12cc:	80 81       	ld	r24, Z
    12ce:	d8 01       	movw	r26, r16
    12d0:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    12d2:	8c 93       	st	X, r24
    12d4:	f7 01       	movw	r30, r14
    12d6:	60 81       	ld	r22, Z
    12d8:	71 81       	ldd	r23, Z+1	; 0x01
    12da:	d8 01       	movw	r26, r16
    12dc:	12 96       	adiw	r26, 0x02	; 2
    12de:	8c 91       	ld	r24, X
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	86 17       	cp	r24, r22
    12e4:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    12e6:	49 f0       	breq	.+18     	; 0x12fa <_ZL5proc2Pv+0x188>
    12e8:	82 e0       	ldi	r24, 0x02	; 2
    12ea:	90 e0       	ldi	r25, 0x00	; 0
    12ec:	0e 94 91 18 	call	0x3122	; 0x3122 <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    12f0:	f7 01       	movw	r30, r14
    12f2:	80 81       	ld	r24, Z
    12f4:	d8 01       	movw	r26, r16
    12f6:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    12f8:	8c 93       	st	X, r24
    12fa:	60 91 05 03 	lds	r22, 0x0305	; 0x800305 <mem4+0x46>
    12fe:	70 91 06 03 	lds	r23, 0x0306	; 0x800306 <mem4+0x47>
    1302:	f8 01       	movw	r30, r16
    1304:	83 81       	ldd	r24, Z+3	; 0x03
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	86 17       	cp	r24, r22
    130a:	97 07       	cpc	r25, r23
    130c:	09 f4       	brne	.+2      	; 0x1310 <_ZL5proc2Pv+0x19e>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    130e:	55 cf       	rjmp	.-342    	; 0x11ba <_ZL5proc2Pv+0x48>
    1310:	83 e0       	ldi	r24, 0x03	; 3
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	0e 94 91 18 	call	0x3122	; 0x3122 <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    1318:	80 91 05 03 	lds	r24, 0x0305	; 0x800305 <mem4+0x46>
    131c:	d8 01       	movw	r26, r16
    131e:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    1320:	8c 93       	st	X, r24
    1322:	49 cf       	rjmp	.-366    	; 0x11b6 <_ZL5proc2Pv+0x44>
    1324:	6d ee       	ldi	r22, 0xED	; 237
    1326:	71 e0       	ldi	r23, 0x01	; 1
    1328:	88 ec       	ldi	r24, 0xC8	; 200
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	f7 dc       	rcall	.-1554   	; 0xd1c <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    132e:	9a a3       	std	Y+34, r25	; 0x22
    1330:	89 a3       	std	Y+33, r24	; 0x21
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    1332:	00 97       	sbiw	r24, 0x00	; 0
    1334:	09 f4       	brne	.+2      	; 0x1338 <_ZL5proc2Pv+0x1c6>
    1336:	70 c0       	rjmp	.+224    	; 0x1418 <_ZL5proc2Pv+0x2a6>
    1338:	bc 01       	movw	r22, r24
    133a:	8d ee       	ldi	r24, 0xED	; 237
    133c:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
    133e:	e2 dd       	rcall	.-1084   	; 0xf04 <_Z25eth_type_is_arp_and_my_ipPhj>
    1340:	88 23       	and	r24, r24
    1342:	21 f0       	breq	.+8      	; 0x134c <_ZL5proc2Pv+0x1da>
			 continue;
    1344:	8d ee       	ldi	r24, 0xED	; 237
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    1346:	91 e0       	ldi	r25, 0x01	; 1
    1348:	60 de       	rcall	.-832    	; 0x100a <_Z28make_arp_answer_from_requestPh>
    134a:	72 cf       	rjmp	.-284    	; 0x1230 <_ZL5proc2Pv+0xbe>
    134c:	69 a1       	ldd	r22, Y+33	; 0x21
    134e:	7a a1       	ldd	r23, Y+34	; 0x22
    1350:	8d ee       	ldi	r24, 0xED	; 237
    1352:	91 e0       	ldi	r25, 0x01	; 1
    1354:	fd dd       	rcall	.-1030   	; 0xf50 <_Z24eth_type_is_ip_and_my_ipPhj>
    1356:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    1358:	09 f4       	brne	.+2      	; 0x135c <_ZL5proc2Pv+0x1ea>
    135a:	6a cf       	rjmp	.-300    	; 0x1230 <_ZL5proc2Pv+0xbe>
    135c:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <_ZZL5proc2PvE3buf+0x17>
    1360:	81 30       	cpi	r24, 0x01	; 1
    1362:	51 f4       	brne	.+20     	; 0x1378 <_ZL5proc2Pv+0x206>
		 {
			make_echo_reply_from_request(buf,plen);
    1364:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <_ZZL5proc2PvE3buf+0x22>
    1368:	88 30       	cpi	r24, 0x08	; 8
    136a:	31 f4       	brne	.+12     	; 0x1378 <_ZL5proc2Pv+0x206>
    136c:	69 a1       	ldd	r22, Y+33	; 0x21
    136e:	7a a1       	ldd	r23, Y+34	; 0x22
			continue;
    1370:	8d ee       	ldi	r24, 0xED	; 237
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    1372:	91 e0       	ldi	r25, 0x01	; 1
    1374:	72 de       	rcall	.-796    	; 0x105a <_Z28make_echo_reply_from_requestPhj>
    1376:	5c cf       	rjmp	.-328    	; 0x1230 <_ZL5proc2Pv+0xbe>
    1378:	80 91 17 02 	lds	r24, 0x0217	; 0x800217 <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
    137c:	81 33       	cpi	r24, 0x31	; 49
    137e:	09 f0       	breq	.+2      	; 0x1382 <_ZL5proc2Pv+0x210>
    1380:	4b c0       	rjmp	.+150    	; 0x1418 <_ZL5proc2Pv+0x2a6>
    1382:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1384:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1386:	8d e1       	ldi	r24, 0x1D	; 29
			 char loop = buf[UDP_DATA_P + 1];
    1388:	11 92       	st	Z+, r1
    138a:	8a 95       	dec	r24
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    138c:	e9 f7       	brne	.-6      	; 0x1388 <_ZL5proc2Pv+0x216>
    138e:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <_ZZL5proc2PvE3buf+0x2b>
    1392:	80 53       	subi	r24, 0x30	; 48
    1394:	90 e0       	ldi	r25, 0x00	; 0
    1396:	01 96       	adiw	r24, 0x01	; 1
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	91 05       	cpc	r25, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    139c:	0c f0       	brlt	.+2      	; 0x13a0 <_ZL5proc2Pv+0x22e>
    139e:	84 c0       	rjmp	.+264    	; 0x14a8 <_ZL5proc2Pv+0x336>
    13a0:	22 c0       	rjmp	.+68     	; 0x13e6 <_ZL5proc2Pv+0x274>
    13a2:	f9 01       	movw	r30, r18
    13a4:	e3 51       	subi	r30, 0x13	; 19
    13a6:	fe 4f       	sbci	r31, 0xFE	; 254
    13a8:	63 a5       	ldd	r22, Z+43	; 0x2b
    13aa:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    13ac:	e2 0f       	add	r30, r18
    13ae:	f3 1f       	adc	r31, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    13b0:	60 83       	st	Z, r22
    13b2:	40 fd       	sbrc	r20, 0
    13b4:	12 c0       	rjmp	.+36     	; 0x13da <_ZL5proc2Pv+0x268>
    13b6:	e5 2f       	mov	r30, r21
    13b8:	f0 e0       	ldi	r31, 0x00	; 0
    13ba:	ee 0f       	add	r30, r30
    13bc:	ff 1f       	adc	r31, r31
    13be:	ed 52       	subi	r30, 0x2D	; 45
    13c0:	fd 4f       	sbci	r31, 0xFD	; 253
    13c2:	af ef       	ldi	r26, 0xFF	; 255
    13c4:	bf ef       	ldi	r27, 0xFF	; 255
    13c6:	ac 0f       	add	r26, r28
    13c8:	bd 1f       	adc	r27, r29
    13ca:	a2 0f       	add	r26, r18
    13cc:	b3 1f       	adc	r27, r19
    13ce:	2c 91       	ld	r18, X
    13d0:	30 e0       	ldi	r19, 0x00	; 0
					num++;
    13d2:	36 2b       	or	r19, r22
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    13d4:	31 83       	std	Z+1, r19	; 0x01
    13d6:	20 83       	st	Z, r18
    13d8:	5f 5f       	subi	r21, 0xFF	; 255
    13da:	4f 5f       	subi	r20, 0xFF	; 255
    13dc:	24 2f       	mov	r18, r20
    13de:	30 e0       	ldi	r19, 0x00	; 0
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    13e0:	28 17       	cp	r18, r24
    13e2:	39 07       	cpc	r19, r25
    13e4:	f4 f2       	brlt	.-68     	; 0x13a2 <_ZL5proc2Pv+0x230>
    13e6:	d4 01       	movw	r26, r8
    13e8:	d0 96       	adiw	r26, 0x30	; 48
    13ea:	8d 91       	ld	r24, X+
    13ec:	9c 91       	ld	r25, X
    13ee:	d1 97       	sbiw	r26, 0x31	; 49
    13f0:	51 96       	adiw	r26, 0x11	; 17
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    13f2:	9c 93       	st	X, r25
    13f4:	8e 93       	st	-X, r24
    13f6:	50 97       	sbiw	r26, 0x10	; 16
    13f8:	dd 96       	adiw	r26, 0x3d	; 61
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    13fa:	9c 93       	st	X, r25
    13fc:	8e 93       	st	-X, r24
    13fe:	dc 97       	sbiw	r26, 0x3c	; 60
    1400:	d9 96       	adiw	r26, 0x39	; 57
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1402:	9c 93       	st	X, r25
    1404:	8e 93       	st	-X, r24
    1406:	d8 97       	sbiw	r26, 0x38	; 56
    1408:	d7 96       	adiw	r26, 0x37	; 55
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    140a:	9c 93       	st	X, r25
    140c:	8e 93       	st	-X, r24
    140e:	d6 97       	sbiw	r26, 0x36	; 54
    1410:	df 96       	adiw	r26, 0x3f	; 63
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    1412:	9c 93       	st	X, r25
    1414:	8e 93       	st	-X, r24
    1416:	de 97       	sbiw	r26, 0x3e	; 62
			 if(led_flag)
    1418:	b8 a1       	ldd	r27, Y+32	; 0x20
    141a:	b0 95       	com	r27
			 {
				 PORTB = sbi(PORTB,4);
    141c:	b8 a3       	std	Y+32, r27	; 0x20
    141e:	bb 23       	and	r27, r27
    1420:	29 f0       	breq	.+10     	; 0x142c <_ZL5proc2Pv+0x2ba>
    1422:	88 b3       	in	r24, 0x18	; 24
    1424:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    1426:	88 bb       	out	0x18, r24	; 24
    1428:	88 bb       	out	0x18, r24	; 24
    142a:	04 c0       	rjmp	.+8      	; 0x1434 <_ZL5proc2Pv+0x2c2>
    142c:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    142e:	8f 7e       	andi	r24, 0xEF	; 239
    1430:	88 bb       	out	0x18, r24	; 24
    1432:	88 bb       	out	0x18, r24	; 24
    1434:	f4 01       	movw	r30, r8
    1436:	82 81       	ldd	r24, Z+2	; 0x02
    1438:	93 81       	ldd	r25, Z+3	; 0x03
    143a:	d3 01       	movw	r26, r6
			 data[1] = mem4[COUNT];
    143c:	11 96       	adiw	r26, 0x01	; 1
    143e:	9c 93       	st	X, r25
    1440:	8e 93       	st	-X, r24
    1442:	86 81       	ldd	r24, Z+6	; 0x06
    1444:	97 81       	ldd	r25, Z+7	; 0x07
    1446:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    1448:	9c 93       	st	X, r25
    144a:	8e 93       	st	-X, r24
    144c:	12 97       	sbiw	r26, 0x02	; 2
    144e:	84 81       	ldd	r24, Z+4	; 0x04
    1450:	95 81       	ldd	r25, Z+5	; 0x05
    1452:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    1454:	9c 93       	st	X, r25
    1456:	8e 93       	st	-X, r24
    1458:	14 97       	sbiw	r26, 0x04	; 4
    145a:	80 89       	ldd	r24, Z+16	; 0x10
    145c:	91 89       	ldd	r25, Z+17	; 0x11
    145e:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    1460:	9c 93       	st	X, r25
    1462:	8e 93       	st	-X, r24
    1464:	16 97       	sbiw	r26, 0x06	; 6
    1466:	82 89       	ldd	r24, Z+18	; 0x12
    1468:	93 89       	ldd	r25, Z+19	; 0x13
    146a:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    146c:	9c 93       	st	X, r25
    146e:	8e 93       	st	-X, r24
    1470:	18 97       	sbiw	r26, 0x08	; 8
    1472:	84 85       	ldd	r24, Z+12	; 0x0c
    1474:	95 85       	ldd	r25, Z+13	; 0x0d
    1476:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    1478:	9c 93       	st	X, r25
    147a:	8e 93       	st	-X, r24
    147c:	1a 97       	sbiw	r26, 0x0a	; 10
    147e:	82 85       	ldd	r24, Z+10	; 0x0a
    1480:	93 85       	ldd	r25, Z+11	; 0x0b
    1482:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    1484:	9c 93       	st	X, r25
    1486:	8e 93       	st	-X, r24
    1488:	1c 97       	sbiw	r26, 0x0c	; 12
    148a:	80 85       	ldd	r24, Z+8	; 0x08
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    148c:	91 85       	ldd	r25, Z+9	; 0x09
    148e:	1f 96       	adiw	r26, 0x0f	; 15
    1490:	9c 93       	st	X, r25
    1492:	8e 93       	st	-X, r24
    1494:	1e 97       	sbiw	r26, 0x0e	; 14
    1496:	2f e0       	ldi	r18, 0x0F	; 15
    1498:	37 e2       	ldi	r19, 0x27	; 39
    149a:	40 e1       	ldi	r20, 0x10	; 16
			// memcpy(buf,data,sizeof(data));
			 //enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+sizeof(data),buf);
			 //vTaskDelay(500);
			 //memset(buf,0,sizeof(buf));
			// vTaskDelay(100);
			taskYIELD();
    149c:	b3 01       	movw	r22, r6
    149e:	8d ee       	ldi	r24, 0xED	; 237
    14a0:	91 e0       	ldi	r25, 0x01	; 1
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    14a2:	f5 dd       	rcall	.-1046   	; 0x108e <_Z27make_udp_reply_from_requestPhPchj>
    14a4:	c9 d4       	rcall	.+2450   	; 0x1e38 <vPortYield>
    14a6:	c4 ce       	rjmp	.-632    	; 0x1230 <_ZL5proc2Pv+0xbe>
    14a8:	20 91 19 02 	lds	r18, 0x0219	; 0x800219 <_ZZL5proc2PvE3buf+0x2c>
    14ac:	29 83       	std	Y+1, r18	; 0x01
    14ae:	41 e0       	ldi	r20, 0x01	; 1
    14b0:	50 e0       	ldi	r21, 0x00	; 0
    14b2:	93 cf       	rjmp	.-218    	; 0x13da <_ZL5proc2Pv+0x268>

000014b4 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    14b4:	cf 93       	push	r28
    14b6:	df 93       	push	r29
    14b8:	cd b7       	in	r28, 0x3d	; 61
    14ba:	de b7       	in	r29, 0x3e	; 62
    14bc:	2f 97       	sbiw	r28, 0x0f	; 15
    14be:	0f b6       	in	r0, 0x3f	; 63
    14c0:	f8 94       	cli
    14c2:	de bf       	out	0x3e, r29	; 62
    14c4:	0f be       	out	0x3f, r0	; 63
    14c6:	cd bf       	out	0x3d, r28	; 61
    14c8:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    14ca:	fe 01       	movw	r30, r28
    14cc:	31 96       	adiw	r30, 0x01	; 1
    14ce:	8f e0       	ldi	r24, 0x0F	; 15
    14d0:	df 01       	movw	r26, r30
    14d2:	1d 92       	st	X+, r1
    14d4:	8a 95       	dec	r24
    14d6:	e9 f7       	brne	.-6      	; 0x14d2 <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    14d8:	0f eb       	ldi	r16, 0xBF	; 191
    14da:	12 e0       	ldi	r17, 0x02	; 2
    14dc:	5e 01       	movw	r10, r28
    14de:	b0 e1       	ldi	r27, 0x10	; 16
    14e0:	ab 0e       	add	r10, r27
    14e2:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    14e4:	0f 2e       	mov	r0, r31
    14e6:	fa e9       	ldi	r31, 0x9A	; 154
    14e8:	8f 2e       	mov	r8, r31
    14ea:	91 2c       	mov	r9, r1
    14ec:	f0 2d       	mov	r31, r0
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    14ee:	0f 2e       	mov	r0, r31
    14f0:	f7 e0       	ldi	r31, 0x07	; 7
    14f2:	6f 2e       	mov	r6, r31
    14f4:	f3 e0       	ldi	r31, 0x03	; 3
    14f6:	7f 2e       	mov	r7, r31
    14f8:	f0 2d       	mov	r31, r0
					mem4[COUNT] = count_number;
				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    14fa:	0f 2e       	mov	r0, r31
    14fc:	f3 e0       	ldi	r31, 0x03	; 3
    14fe:	4f 2e       	mov	r4, r31
    1500:	51 2c       	mov	r5, r1
    1502:	f0 2d       	mov	r31, r0
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1504:	f8 01       	movw	r30, r16
    1506:	80 89       	ldd	r24, Z+16	; 0x10
    1508:	91 89       	ldd	r25, Z+17	; 0x11
    150a:	26 ad       	ldd	r18, Z+62	; 0x3e
    150c:	37 ad       	ldd	r19, Z+63	; 0x3f
    150e:	28 17       	cp	r18, r24
    1510:	39 07       	cpc	r19, r25
    1512:	41 f0       	breq	.+16     	; 0x1524 <_ZL5proc1Pv+0x70>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1514:	95 af       	std	Z+61, r25	; 0x3d
    1516:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    1518:	91 af       	std	Z+57, r25	; 0x39
    151a:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    151c:	97 ab       	std	Z+55, r25	; 0x37
    151e:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    1520:	97 af       	std	Z+63, r25	; 0x3f
    1522:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    1524:	c6 01       	movw	r24, r12
    1526:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    152a:	8f 30       	cpi	r24, 0x0F	; 15
    152c:	58 f3       	brcs	.-42     	; 0x1504 <_ZL5proc1Pv+0x50>
    152e:	ce 01       	movw	r24, r28
    1530:	01 96       	adiw	r24, 0x01	; 1
    1532:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    1534:	c6 01       	movw	r24, r12
    1536:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    153a:	d7 01       	movw	r26, r14
    153c:	8d 93       	st	X+, r24
    153e:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1540:	aa 15       	cp	r26, r10
    1542:	bb 05       	cpc	r27, r11
    1544:	b9 f7       	brne	.-18     	; 0x1534 <_ZL5proc1Pv+0x80>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	82 30       	cpi	r24, 0x02	; 2
    154a:	09 f0       	breq	.+2      	; 0x154e <_ZL5proc1Pv+0x9a>
    154c:	53 c0       	rjmp	.+166    	; 0x15f4 <_ZL5proc1Pv+0x140>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    154e:	88 85       	ldd	r24, Y+8	; 0x08
    1550:	90 e0       	ldi	r25, 0x00	; 0
    1552:	98 2f       	mov	r25, r24
    1554:	88 27       	eor	r24, r24
    1556:	29 85       	ldd	r18, Y+9	; 0x09
    1558:	82 2b       	or	r24, r18
    155a:	90 93 10 03 	sts	0x0310, r25	; 0x800310 <count_number+0x1>
    155e:	80 93 0f 03 	sts	0x030F, r24	; 0x80030f <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    1562:	8a 85       	ldd	r24, Y+10	; 0x0a
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	98 2f       	mov	r25, r24
    1568:	88 27       	eor	r24, r24
    156a:	2b 85       	ldd	r18, Y+11	; 0x0b
    156c:	82 2b       	or	r24, r18
    156e:	90 93 0e 03 	sts	0x030E, r25	; 0x80030e <current_temp+0x1>
    1572:	80 93 0d 03 	sts	0x030D, r24	; 0x80030d <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    1576:	2c 85       	ldd	r18, Y+12	; 0x0c
    1578:	30 e0       	ldi	r19, 0x00	; 0
    157a:	32 2f       	mov	r19, r18
    157c:	22 27       	eor	r18, r18
    157e:	4d 85       	ldd	r20, Y+13	; 0x0d
    1580:	24 2b       	or	r18, r20
    1582:	30 93 0c 03 	sts	0x030C, r19	; 0x80030c <current_pressure+0x1>
    1586:	20 93 0b 03 	sts	0x030B, r18	; 0x80030b <current_pressure>
				mem4[TEMP] = current_temp;
    158a:	f8 01       	movw	r30, r16
    158c:	93 83       	std	Z+3, r25	; 0x03
    158e:	82 83       	std	Z+2, r24	; 0x02
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    1590:	d3 01       	movw	r26, r6
    1592:	8d 91       	ld	r24, X+
    1594:	9c 91       	ld	r25, X
    1596:	89 2b       	or	r24, r25
    1598:	19 f0       	breq	.+6      	; 0x15a0 <_ZL5proc1Pv+0xec>
				{
					Alarm_Start();
    159a:	0e 94 e6 01 	call	0x3cc	; 0x3cc <Alarm_Start>
    159e:	09 c0       	rjmp	.+18     	; 0x15b2 <_ZL5proc1Pv+0xfe>
				}
				else //PLC
				{
					Alarm_Stop();
    15a0:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <Alarm_Stop>
					mem4[COUNT] = count_number;
    15a4:	80 91 0f 03 	lds	r24, 0x030F	; 0x80030f <count_number>
    15a8:	90 91 10 03 	lds	r25, 0x0310	; 0x800310 <count_number+0x1>
    15ac:	f8 01       	movw	r30, r16
    15ae:	97 83       	std	Z+7, r25	; 0x07
    15b0:	86 83       	std	Z+6, r24	; 0x06
				}
				mem4[PRESSURE] = current_pressure;
    15b2:	80 91 0b 03 	lds	r24, 0x030B	; 0x80030b <current_pressure>
    15b6:	90 91 0c 03 	lds	r25, 0x030C	; 0x80030c <current_pressure+0x1>
    15ba:	d8 01       	movw	r26, r16
    15bc:	15 96       	adiw	r26, 0x05	; 5
    15be:	9c 93       	st	X, r25
    15c0:	8e 93       	st	-X, r24
    15c2:	14 97       	sbiw	r26, 0x04	; 4
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    15c4:	50 96       	adiw	r26, 0x10	; 16
    15c6:	2d 91       	ld	r18, X+
    15c8:	3c 91       	ld	r19, X
    15ca:	51 97       	sbiw	r26, 0x11	; 17
    15cc:	16 96       	adiw	r26, 0x06	; 6
    15ce:	8d 91       	ld	r24, X+
    15d0:	9c 91       	ld	r25, X
    15d2:	17 97       	sbiw	r26, 0x07	; 7
    15d4:	28 17       	cp	r18, r24
    15d6:	39 07       	cpc	r19, r25
    15d8:	09 f0       	breq	.+2      	; 0x15dc <_ZL5proc1Pv+0x128>
    15da:	94 cf       	rjmp	.-216    	; 0x1504 <_ZL5proc1Pv+0x50>
    15dc:	52 96       	adiw	r26, 0x12	; 18
    15de:	8d 91       	ld	r24, X+
    15e0:	9c 91       	ld	r25, X
    15e2:	53 97       	sbiw	r26, 0x13	; 19
    15e4:	89 2b       	or	r24, r25
    15e6:	09 f0       	breq	.+2      	; 0x15ea <_ZL5proc1Pv+0x136>
    15e8:	8d cf       	rjmp	.-230    	; 0x1504 <_ZL5proc1Pv+0x50>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    15ea:	53 96       	adiw	r26, 0x13	; 19
    15ec:	5c 92       	st	X, r5
    15ee:	4e 92       	st	-X, r4
    15f0:	52 97       	sbiw	r26, 0x12	; 18
    15f2:	88 cf       	rjmp	.-240    	; 0x1504 <_ZL5proc1Pv+0x50>
				}
			}
			else
			{
				cbi(PORTB,7);
    15f4:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    15f6:	46 e0       	ldi	r20, 0x06	; 6
    15f8:	61 e0       	ldi	r22, 0x01	; 1
    15fa:	89 e1       	ldi	r24, 0x19	; 25
    15fc:	93 e0       	ldi	r25, 0x03	; 3
    15fe:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    1602:	45 e0       	ldi	r20, 0x05	; 5
    1604:	50 e0       	ldi	r21, 0x00	; 0
    1606:	69 e1       	ldi	r22, 0x19	; 25
    1608:	73 e0       	ldi	r23, 0x03	; 3
    160a:	c6 01       	movw	r24, r12
    160c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    1610:	f4 01       	movw	r30, r8
    1612:	80 81       	ld	r24, Z
    1614:	8f 77       	andi	r24, 0x7F	; 127
    1616:	80 83       	st	Z, r24
				sb->SerialFlush();
    1618:	c6 01       	movw	r24, r12
    161a:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    161e:	d4 01       	movw	r26, r8
    1620:	8c 91       	ld	r24, X
    1622:	80 68       	ori	r24, 0x80	; 128
    1624:	8c 93       	st	X, r24
				sbi(PORTB,7);
    1626:	c7 9a       	sbi	0x18, 7	; 24
    1628:	6d cf       	rjmp	.-294    	; 0x1504 <_ZL5proc1Pv+0x50>

0000162a <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    162a:	cf 93       	push	r28
    162c:	df 93       	push	r29
    162e:	cd b7       	in	r28, 0x3d	; 61
    1630:	de b7       	in	r29, 0x3e	; 62
    1632:	2a 97       	sbiw	r28, 0x0a	; 10
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	de bf       	out	0x3e, r29	; 62
    163a:	0f be       	out	0x3f, r0	; 63
    163c:	cd bf       	out	0x3d, r28	; 61
    163e:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    1640:	d1 2c       	mov	r13, r1
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1642:	0f eb       	ldi	r16, 0xBF	; 191
    1644:	12 e0       	ldi	r17, 0x02	; 2
			chatter_flag = 2;
    1646:	68 94       	set
    1648:	77 24       	eor	r7, r7
    164a:	71 f8       	bld	r7, 1
    164c:	4e 01       	movw	r8, r28
    164e:	8c e0       	ldi	r24, 0x0C	; 12
    1650:	88 0e       	add	r8, r24
    1652:	91 1c       	adc	r9, r1
    1654:	68 94       	set
    1656:	33 24       	eor	r3, r3
    1658:	34 f8       	bld	r3, 4
    165a:	66 24       	eor	r6, r6
    165c:	63 94       	inc	r6
    165e:	5e 01       	movw	r10, r28
    1660:	a9 e0       	ldi	r26, 0x09	; 9
    1662:	aa 0e       	add	r10, r26
    1664:	b1 1c       	adc	r11, r1
    1666:	0f 2e       	mov	r0, r31
    1668:	f5 e0       	ldi	r31, 0x05	; 5
    166a:	4f 2e       	mov	r4, r31
    166c:	f0 2d       	mov	r31, r0
							sb->SerialWrite((char*)&exception,sizeof(exception));
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
							sb->SerialWrite((char*)&func04,sizeof(func04));
    166e:	68 94       	set
    1670:	55 24       	eor	r5, r5
    1672:	52 f8       	bld	r5, 2
    1674:	0e c0       	rjmp	.+28     	; 0x1692 <_ZL4procPv+0x68>
    1676:	c6 2c       	mov	r12, r6
    1678:	d6 2c       	mov	r13, r6
    167a:	0b c0       	rjmp	.+22     	; 0x1692 <_ZL4procPv+0x68>
    167c:	c6 2c       	mov	r12, r6
    167e:	d6 2c       	mov	r13, r6
    1680:	08 c0       	rjmp	.+16     	; 0x1692 <_ZL4procPv+0x68>
    1682:	c5 2c       	mov	r12, r5
    1684:	d6 2c       	mov	r13, r6
    1686:	05 c0       	rjmp	.+10     	; 0x1692 <_ZL4procPv+0x68>
    1688:	c4 2c       	mov	r12, r4
    168a:	d6 2c       	mov	r13, r6
    168c:	02 c0       	rjmp	.+4      	; 0x1692 <_ZL4procPv+0x68>
    168e:	c3 2c       	mov	r12, r3
    1690:	d6 2c       	mov	r13, r6
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    1692:	80 b3       	in	r24, 0x10	; 16
    1694:	8e 3f       	cpi	r24, 0xFE	; 254
    1696:	29 f4       	brne	.+10     	; 0x16a2 <_ZL4procPv+0x78>
    1698:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <chatter_flag>
    169c:	81 30       	cpi	r24, 0x01	; 1
    169e:	09 f4       	brne	.+2      	; 0x16a2 <_ZL4procPv+0x78>
    16a0:	15 c1       	rjmp	.+554    	; 0x18cc <_ZL4procPv+0x2a2>
		{
			mem4[COUNT]++;                // Remove Chattering 
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
    16a2:	80 b3       	in	r24, 0x10	; 16
    16a4:	8f 3f       	cpi	r24, 0xFF	; 255
    16a6:	29 f4       	brne	.+10     	; 0x16b2 <_ZL4procPv+0x88>
    16a8:	80 91 ba 02 	lds	r24, 0x02BA	; 0x8002ba <chatter_flag>
    16ac:	82 30       	cpi	r24, 0x02	; 2
    16ae:	09 f4       	brne	.+2      	; 0x16b2 <_ZL4procPv+0x88>
    16b0:	19 c1       	rjmp	.+562    	; 0x18e4 <_ZL4procPv+0x2ba>
		{
			vTaskDelay(20);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    16b2:	f8 01       	movw	r30, r16
    16b4:	84 85       	ldd	r24, Z+12	; 0x0c
    16b6:	95 85       	ldd	r25, Z+13	; 0x0d
    16b8:	cc 97       	sbiw	r24, 0x3c	; 60
    16ba:	94 f0       	brlt	.+36     	; 0x16e0 <_ZL4procPv+0xb6>
		{
			mem4[SEC] = 0;
    16bc:	15 86       	std	Z+13, r1	; 0x0d
    16be:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    16c0:	82 85       	ldd	r24, Z+10	; 0x0a
    16c2:	93 85       	ldd	r25, Z+11	; 0x0b
    16c4:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    16c6:	8c 33       	cpi	r24, 0x3C	; 60
    16c8:	91 05       	cpc	r25, r1
    16ca:	1c f4       	brge	.+6      	; 0x16d2 <_ZL4procPv+0xa8>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    16cc:	93 87       	std	Z+11, r25	; 0x0b
    16ce:	82 87       	std	Z+10, r24	; 0x0a
    16d0:	07 c0       	rjmp	.+14     	; 0x16e0 <_ZL4procPv+0xb6>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    16d2:	13 86       	std	Z+11, r1	; 0x0b
    16d4:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    16d6:	80 85       	ldd	r24, Z+8	; 0x08
    16d8:	91 85       	ldd	r25, Z+9	; 0x09
    16da:	01 96       	adiw	r24, 0x01	; 1
    16dc:	91 87       	std	Z+9, r25	; 0x09
    16de:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    16e0:	d1 10       	cpse	r13, r1
    16e2:	4d c0       	rjmp	.+154    	; 0x177e <_ZL4procPv+0x154>
		{
			if(sb->SerialAvailable() >= 2)
    16e4:	c7 01       	movw	r24, r14
    16e6:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    16ea:	82 30       	cpi	r24, 0x02	; 2
    16ec:	90 f2       	brcs	.-92     	; 0x1692 <_ZL4procPv+0x68>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    16ee:	c7 01       	movw	r24, r14
    16f0:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    16f4:	89 83       	std	Y+1, r24	; 0x01
    16f6:	c7 01       	movw	r24, r14
    16f8:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    16fc:	8a 83       	std	Y+2, r24	; 0x02
					#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
					#endif
				}
				if(buf1[0] != 0x01)
    16fe:	99 81       	ldd	r25, Y+1	; 0x01
    1700:	91 30       	cpi	r25, 0x01	; 1
    1702:	61 f4       	brne	.+24     	; 0x171c <_ZL4procPv+0xf2>
				{
				//	read_Flag = 0;
					goto FREAM_ERROR;
				}
				if(buf1[1] == 0x01)
    1704:	81 30       	cpi	r24, 0x01	; 1
    1706:	09 f4       	brne	.+2      	; 0x170a <_ZL4procPv+0xe0>
    1708:	3f c0       	rjmp	.+126    	; 0x1788 <_ZL4procPv+0x15e>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    170a:	84 30       	cpi	r24, 0x04	; 4
    170c:	09 f4       	brne	.+2      	; 0x1710 <_ZL4procPv+0xe6>
    170e:	53 c0       	rjmp	.+166    	; 0x17b6 <_ZL4procPv+0x18c>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1710:	85 30       	cpi	r24, 0x05	; 5
    1712:	09 f4       	brne	.+2      	; 0x1716 <_ZL4procPv+0xec>
    1714:	8b c0       	rjmp	.+278    	; 0x182c <_ZL4procPv+0x202>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1716:	80 31       	cpi	r24, 0x10	; 16
    1718:	09 f4       	brne	.+2      	; 0x171c <_ZL4procPv+0xf2>
    171a:	ae c0       	rjmp	.+348    	; 0x1878 <_ZL4procPv+0x24e>
				{
					FREAM_ERROR:
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    171c:	46 2d       	mov	r20, r6
    171e:	66 2d       	mov	r22, r6
    1720:	89 e1       	ldi	r24, 0x19	; 25
    1722:	93 e0       	ldi	r25, 0x03	; 3
    1724:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    1728:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);
    172a:	57 98       	cbi	0x0a, 7	; 10
					dev->getInterfaceAddr(UART0)->Stop_Device();                                                                                                                                                                                                                
    172c:	60 e0       	ldi	r22, 0x00	; 0
    172e:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1732:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1736:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    173a:	dc 01       	movw	r26, r24
    173c:	ed 91       	ld	r30, X+
    173e:	fc 91       	ld	r31, X
    1740:	00 84       	ldd	r0, Z+8	; 0x08
    1742:	f1 85       	ldd	r31, Z+9	; 0x09
    1744:	e0 2d       	mov	r30, r0
    1746:	09 95       	icall
					sb->SerialFlush();
    1748:	c7 01       	movw	r24, r14
    174a:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
					dev->getInterfaceAddr(UART0)->Start_Device();
    174e:	60 e0       	ldi	r22, 0x00	; 0
    1750:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1754:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1758:	0e 94 f3 02 	call	0x5e6	; 0x5e6 <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    175c:	dc 01       	movw	r26, r24
    175e:	ed 91       	ld	r30, X+
    1760:	fc 91       	ld	r31, X
    1762:	02 84       	ldd	r0, Z+10	; 0x0a
    1764:	f3 85       	ldd	r31, Z+11	; 0x0b
    1766:	e0 2d       	mov	r30, r0
    1768:	09 95       	icall
					sbi(UCSR0B,RXCIE0);
    176a:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    176c:	45 e0       	ldi	r20, 0x05	; 5
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	69 e1       	ldi	r22, 0x19	; 25
    1772:	73 e0       	ldi	r23, 0x03	; 3
    1774:	c7 01       	movw	r24, r14
    1776:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    177a:	c7 9a       	sbi	0x18, 7	; 24
    177c:	8a cf       	rjmp	.-236    	; 0x1692 <_ZL4procPv+0x68>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    177e:	b1 e0       	ldi	r27, 0x01	; 1
    1780:	db 12       	cpse	r13, r27
    1782:	87 cf       	rjmp	.-242    	; 0x1692 <_ZL4procPv+0x68>
		{
			if(function_code == 0x01)  
    1784:	cb 12       	cpse	r12, r27
    1786:	14 c0       	rjmp	.+40     	; 0x17b0 <_ZL4procPv+0x186>
			{
				if(sb->SerialAvailable() >= 6)
    1788:	c7 01       	movw	r24, r14
    178a:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    178e:	86 30       	cpi	r24, 0x06	; 6
    1790:	08 f4       	brcc	.+2      	; 0x1794 <_ZL4procPv+0x16a>
    1792:	71 cf       	rjmp	.-286    	; 0x1676 <_ZL4procPv+0x4c>
    1794:	6e 01       	movw	r12, r28
    1796:	e3 e0       	ldi	r30, 0x03	; 3
    1798:	ce 0e       	add	r12, r30
    179a:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    179c:	c7 01       	movw	r24, r14
    179e:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    17a2:	d6 01       	movw	r26, r12
    17a4:	8d 93       	st	X+, r24
    17a6:	6d 01       	movw	r12, r26
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    17a8:	aa 16       	cp	r10, r26
    17aa:	bb 06       	cpc	r11, r27
    17ac:	b9 f7       	brne	.-18     	; 0x179c <_ZL4procPv+0x172>
    17ae:	66 cf       	rjmp	.-308    	; 0x167c <_ZL4procPv+0x52>
						#endif
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    17b0:	b4 e0       	ldi	r27, 0x04	; 4
    17b2:	cb 12       	cpse	r12, r27
    17b4:	38 c0       	rjmp	.+112    	; 0x1826 <_ZL4procPv+0x1fc>
			{
				if(sb->SerialAvailable() >= 6)
    17b6:	c7 01       	movw	r24, r14
    17b8:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    17bc:	86 30       	cpi	r24, 0x06	; 6
    17be:	08 f4       	brcc	.+2      	; 0x17c2 <_ZL4procPv+0x198>
    17c0:	60 cf       	rjmp	.-320    	; 0x1682 <_ZL4procPv+0x58>
    17c2:	6e 01       	movw	r12, r28
    17c4:	e3 e0       	ldi	r30, 0x03	; 3
    17c6:	ce 0e       	add	r12, r30
    17c8:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    17ca:	c7 01       	movw	r24, r14
    17cc:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    17d0:	d6 01       	movw	r26, r12
    17d2:	8d 93       	st	X+, r24
    17d4:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    17d6:	aa 16       	cp	r10, r26
    17d8:	bb 06       	cpc	r11, r27
    17da:	b9 f7       	brne	.-18     	; 0x17ca <_ZL4procPv+0x1a0>
						#if PACKET_DEBUG
							sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr > MAX_ENUM)  //주소 사이즈 체크 
    17dc:	8c 81       	ldd	r24, Y+4	; 0x04
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	87 97       	sbiw	r24, 0x27	; 39
    17e2:	84 f0       	brlt	.+32     	; 0x1804 <_ZL4procPv+0x1da>
					{
							GetExceptionCode(&exception,0x01,0x02);
    17e4:	47 2d       	mov	r20, r7
    17e6:	66 2d       	mov	r22, r6
    17e8:	89 e1       	ldi	r24, 0x19	; 25
    17ea:	93 e0       	ldi	r25, 0x03	; 3
    17ec:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
							sb->SerialWrite((char*)&exception,sizeof(exception));
    17f0:	45 e0       	ldi	r20, 0x05	; 5
    17f2:	50 e0       	ldi	r21, 0x00	; 0
    17f4:	69 e1       	ldi	r22, 0x19	; 25
    17f6:	73 e0       	ldi	r23, 0x03	; 3
    17f8:	c7 01       	movw	r24, r14
    17fa:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    17fe:	c5 2c       	mov	r12, r5
    1800:	d6 2c       	mov	r13, r6
    1802:	47 cf       	rjmp	.-370    	; 0x1692 <_ZL4procPv+0x68>
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
    1804:	a8 01       	movw	r20, r16
    1806:	69 e2       	ldi	r22, 0x29	; 41
    1808:	73 e0       	ldi	r23, 0x03	; 3
    180a:	ce 01       	movw	r24, r28
    180c:	01 96       	adiw	r24, 0x01	; 1
    180e:	0e 94 82 00 	call	0x104	; 0x104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1812:	47 e0       	ldi	r20, 0x07	; 7
    1814:	50 e0       	ldi	r21, 0x00	; 0
    1816:	69 e2       	ldi	r22, 0x29	; 41
    1818:	73 e0       	ldi	r23, 0x03	; 3
    181a:	c7 01       	movw	r24, r14
    181c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1820:	c5 2c       	mov	r12, r5
							read_Flag = 0;
    1822:	d1 2c       	mov	r13, r1
    1824:	36 cf       	rjmp	.-404    	; 0x1692 <_ZL4procPv+0x68>
					}

				}
			}
			else if(function_code == 0x05) //터치 버튼 
    1826:	b5 e0       	ldi	r27, 0x05	; 5
    1828:	cb 12       	cpse	r12, r27
    182a:	23 c0       	rjmp	.+70     	; 0x1872 <_ZL4procPv+0x248>
			{
				if(sb->SerialAvailable() >= 6)
    182c:	c7 01       	movw	r24, r14
    182e:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1832:	86 30       	cpi	r24, 0x06	; 6
    1834:	08 f4       	brcc	.+2      	; 0x1838 <_ZL4procPv+0x20e>
    1836:	28 cf       	rjmp	.-432    	; 0x1688 <_ZL4procPv+0x5e>
    1838:	6e 01       	movw	r12, r28
    183a:	e3 e0       	ldi	r30, 0x03	; 3
    183c:	ce 0e       	add	r12, r30
    183e:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1840:	c7 01       	movw	r24, r14
    1842:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1846:	d6 01       	movw	r26, r12
    1848:	8d 93       	st	X+, r24
    184a:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    184c:	aa 16       	cp	r10, r26
    184e:	bb 06       	cpc	r11, r27
    1850:	b9 f7       	brne	.-18     	; 0x1840 <_ZL4procPv+0x216>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFunc05Data(buf1,&func05);
    1852:	60 e3       	ldi	r22, 0x30	; 48
    1854:	73 e0       	ldi	r23, 0x03	; 3
    1856:	ce 01       	movw	r24, r28
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	0e 94 a3 00 	call	0x146	; 0x146 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    185e:	48 e0       	ldi	r20, 0x08	; 8
    1860:	50 e0       	ldi	r21, 0x00	; 0
    1862:	60 e3       	ldi	r22, 0x30	; 48
    1864:	73 e0       	ldi	r23, 0x03	; 3
    1866:	c7 01       	movw	r24, r14
    1868:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    186c:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    186e:	d1 2c       	mov	r13, r1
    1870:	10 cf       	rjmp	.-480    	; 0x1692 <_ZL4procPv+0x68>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1872:	b0 e1       	ldi	r27, 0x10	; 16
    1874:	cb 12       	cpse	r12, r27
    1876:	0d cf       	rjmp	.-486    	; 0x1692 <_ZL4procPv+0x68>
			{
				if(sb->SerialAvailable() >= 9)
    1878:	c7 01       	movw	r24, r14
    187a:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    187e:	89 30       	cpi	r24, 0x09	; 9
    1880:	08 f4       	brcc	.+2      	; 0x1884 <_ZL4procPv+0x25a>
    1882:	05 cf       	rjmp	.-502    	; 0x168e <_ZL4procPv+0x64>
    1884:	6e 01       	movw	r12, r28
    1886:	e3 e0       	ldi	r30, 0x03	; 3
    1888:	ce 0e       	add	r12, r30
    188a:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    188c:	c7 01       	movw	r24, r14
    188e:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1892:	d6 01       	movw	r26, r12
    1894:	8d 93       	st	X+, r24
    1896:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    1898:	8a 16       	cp	r8, r26
    189a:	9b 06       	cpc	r9, r27
    189c:	b9 f7       	brne	.-18     	; 0x188c <_ZL4procPv+0x262>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    189e:	a8 01       	movw	r20, r16
    18a0:	6e e1       	ldi	r22, 0x1E	; 30
    18a2:	73 e0       	ldi	r23, 0x03	; 3
    18a4:	ce 01       	movw	r24, r28
    18a6:	01 96       	adiw	r24, 0x01	; 1
    18a8:	0e 94 bc 00 	call	0x178	; 0x178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    18ac:	61 e1       	ldi	r22, 0x11	; 17
    18ae:	73 e0       	ldi	r23, 0x03	; 3
    18b0:	ce 01       	movw	r24, r28
    18b2:	01 96       	adiw	r24, 0x01	; 1
    18b4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    18b8:	48 e0       	ldi	r20, 0x08	; 8
    18ba:	50 e0       	ldi	r21, 0x00	; 0
    18bc:	61 e1       	ldi	r22, 0x11	; 17
    18be:	73 e0       	ldi	r23, 0x03	; 3
    18c0:	c7 01       	movw	r24, r14
    18c2:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    18c6:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    18c8:	d1 2c       	mov	r13, r1
    18ca:	e3 ce       	rjmp	.-570    	; 0x1692 <_ZL4procPv+0x68>
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    18cc:	f8 01       	movw	r30, r16
    18ce:	86 81       	ldd	r24, Z+6	; 0x06
    18d0:	97 81       	ldd	r25, Z+7	; 0x07
    18d2:	01 96       	adiw	r24, 0x01	; 1
    18d4:	97 83       	std	Z+7, r25	; 0x07
    18d6:	86 83       	std	Z+6, r24	; 0x06
			chatter_flag = 2;
    18d8:	70 92 ba 02 	sts	0x02BA, r7	; 0x8002ba <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    18dc:	80 b3       	in	r24, 0x10	; 16
    18de:	8f 3f       	cpi	r24, 0xFF	; 255
    18e0:	09 f0       	breq	.+2      	; 0x18e4 <_ZL4procPv+0x2ba>
    18e2:	e7 ce       	rjmp	.-562    	; 0x16b2 <_ZL4procPv+0x88>
		{
			vTaskDelay(20);
    18e4:	84 e1       	ldi	r24, 0x14	; 20
    18e6:	90 e0       	ldi	r25, 0x00	; 0
    18e8:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <vTaskDelay>
			chatter_flag = 0;
    18ec:	10 92 ba 02 	sts	0x02BA, r1	; 0x8002ba <chatter_flag>
    18f0:	e0 ce       	rjmp	.-576    	; 0x16b2 <_ZL4procPv+0x88>

000018f2 <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    18f2:	80 91 38 03 	lds	r24, 0x0338	; 0x800338 <DataStruct>
    18f6:	90 91 39 03 	lds	r25, 0x0339	; 0x800339 <DataStruct+0x1>
    18fa:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    18fe:	c5 9a       	sbi	0x18, 5	; 24
    1900:	08 95       	ret

00001902 <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    1902:	80 91 3a 03 	lds	r24, 0x033A	; 0x80033a <DataStruct+0x2>
    1906:	90 91 3b 03 	lds	r25, 0x033B	; 0x80033b <DataStruct+0x3>
    190a:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    190e:	c6 9a       	sbi	0x18, 6	; 24
    1910:	08 95       	ret

00001912 <_Z16Count_Sensor_ISR8Dev_typej>:
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,20,Set_Alarm);
    1912:	41 eb       	ldi	r20, 0xB1	; 177
    1914:	58 e0       	ldi	r21, 0x08	; 8
    1916:	64 e1       	ldi	r22, 0x14	; 20
    1918:	70 e0       	ldi	r23, 0x00	; 0
    191a:	80 e0       	ldi	r24, 0x00	; 0
    191c:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <Alarm_Open>
    1920:	08 95       	ret

00001922 <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
	dev = new Dev_Manager();
    1926:	80 e1       	ldi	r24, 0x10	; 16
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	0e 94 9c 02 	call	0x538	; 0x538 <_ZN11Dev_ManagernwEj>
    192e:	ec 01       	movw	r28, r24
    1930:	0e 94 69 02 	call	0x4d2	; 0x4d2 <_ZN11Dev_ManagerC1Ev>
    1934:	d0 93 41 03 	sts	0x0341, r29	; 0x800341 <dev+0x1>
    1938:	c0 93 40 03 	sts	0x0340, r28	; 0x800340 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    193c:	88 e0       	ldi	r24, 0x08	; 8
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	0d d8       	rcall	.-4070   	; 0x95c <_ZN10UartDrivernwEj>
    1942:	ec 01       	movw	r28, r24
    1944:	0e 94 9a 04 	call	0x934	; 0x934 <_ZN10UartDriverC1Ev>
    1948:	40 e0       	ldi	r20, 0x00	; 0
    194a:	be 01       	movw	r22, r28
    194c:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1950:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1954:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    1958:	88 e0       	ldi	r24, 0x08	; 8
    195a:	90 e0       	ldi	r25, 0x00	; 0
    195c:	0e 94 0b 04 	call	0x816	; 0x816 <_ZN11RS485DrivernwEj>
    1960:	ec 01       	movw	r28, r24
    1962:	0e 94 f7 03 	call	0x7ee	; 0x7ee <_ZN11RS485DriverC1Ev>
    1966:	41 e0       	ldi	r20, 0x01	; 1
    1968:	be 01       	movw	r22, r28
    196a:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    196e:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1972:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    1976:	82 e0       	ldi	r24, 0x02	; 2
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	0e 94 d3 03 	call	0x7a6	; 0x7a6 <_ZN5TimernwEj>
    197e:	ec 01       	movw	r28, r24
    1980:	0e 94 cd 03 	call	0x79a	; 0x79a <_ZN5TimerC1Ev>
    1984:	42 e0       	ldi	r20, 0x02	; 2
    1986:	be 01       	movw	r22, r28
    1988:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    198c:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1990:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    1994:	82 e0       	ldi	r24, 0x02	; 2
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	0e 94 66 02 	call	0x4cc	; 0x4cc <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    199c:	2b e0       	ldi	r18, 0x0B	; 11
    199e:	31 e0       	ldi	r19, 0x01	; 1
    19a0:	fc 01       	movw	r30, r24
    19a2:	31 83       	std	Z+1, r19	; 0x01
    19a4:	20 83       	st	Z, r18
    19a6:	43 e0       	ldi	r20, 0x03	; 3
    19a8:	bc 01       	movw	r22, r24
    19aa:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19ae:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19b2:	0e 94 93 02 	call	0x526	; 0x526 <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Device_Init(UART0);
    19b6:	60 e0       	ldi	r22, 0x00	; 0
    19b8:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19bc:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19c0:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    19c4:	61 e0       	ldi	r22, 0x01	; 1
    19c6:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19ca:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19ce:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    19d2:	62 e0       	ldi	r22, 0x02	; 2
    19d4:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19d8:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19dc:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    19e0:	63 e0       	ldi	r22, 0x03	; 3
    19e2:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19e6:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19ea:	0e 94 c7 02 	call	0x58e	; 0x58e <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    19ee:	47 e4       	ldi	r20, 0x47	; 71
    19f0:	51 e0       	ldi	r21, 0x01	; 1
    19f2:	60 e0       	ldi	r22, 0x00	; 0
    19f4:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    19f8:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    19fc:	0e 94 b3 02 	call	0x566	; 0x566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1a00:	4d e6       	ldi	r20, 0x6D	; 109
    1a02:	51 e0       	ldi	r21, 0x01	; 1
    1a04:	61 e0       	ldi	r22, 0x01	; 1
    1a06:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1a0a:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1a0e:	0e 94 b3 02 	call	0x566	; 0x566 <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    1a12:	df 91       	pop	r29
    1a14:	cf 91       	pop	r28
    1a16:	08 95       	ret

00001a18 <main>:

uint8_t chatter_flag = 0; //채터링 방지 플래그 변수
//uint8_t use_external_count_sensor = 0; // 0 PLC  1 EXTERNAL COUTN SENSOR

int main( void )
{
    1a18:	cf 92       	push	r12
    1a1a:	df 92       	push	r13
    1a1c:	ef 92       	push	r14
    1a1e:	ff 92       	push	r15
    1a20:	0f 93       	push	r16
    1a22:	cf 93       	push	r28
    1a24:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    1a26:	80 e0       	ldi	r24, 0x00	; 0
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	0e 94 89 18 	call	0x3112	; 0x3112 <eeprom_read_byte>
    1a2e:	d8 2e       	mov	r13, r24
    1a30:	90 e0       	ldi	r25, 0x00	; 0
    1a32:	90 93 00 03 	sts	0x0300, r25	; 0x800300 <mem4+0x41>
    1a36:	80 93 ff 02 	sts	0x02FF, r24	; 0x8002ff <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
    1a3c:	90 e0       	ldi	r25, 0x00	; 0
    1a3e:	0e 94 89 18 	call	0x3112	; 0x3112 <eeprom_read_byte>
    1a42:	d8 2f       	mov	r29, r24
    1a44:	90 e0       	ldi	r25, 0x00	; 0
    1a46:	90 93 02 03 	sts	0x0302, r25	; 0x800302 <mem4+0x43>
    1a4a:	80 93 01 03 	sts	0x0301, r24	; 0x800301 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    1a4e:	82 e0       	ldi	r24, 0x02	; 2
    1a50:	90 e0       	ldi	r25, 0x00	; 0
    1a52:	0e 94 89 18 	call	0x3112	; 0x3112 <eeprom_read_byte>
    1a56:	c8 2f       	mov	r28, r24
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	90 93 04 03 	sts	0x0304, r25	; 0x800304 <mem4+0x45>
    1a5e:	80 93 03 03 	sts	0x0303, r24	; 0x800303 <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    1a62:	83 e0       	ldi	r24, 0x03	; 3
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	0e 94 89 18 	call	0x3112	; 0x3112 <eeprom_read_byte>
    1a6a:	28 2f       	mov	r18, r24
    1a6c:	30 e0       	ldi	r19, 0x00	; 0
    1a6e:	30 93 06 03 	sts	0x0306, r19	; 0x800306 <mem4+0x47>
    1a72:	20 93 05 03 	sts	0x0305, r18	; 0x800305 <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    1a76:	eb eb       	ldi	r30, 0xBB	; 187
    1a78:	f2 e0       	ldi	r31, 0x02	; 2
    1a7a:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    1a7c:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    1a7e:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    1a80:	83 83       	std	Z+3, r24	; 0x03

int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1a82:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1a84:	4e df       	rcall	.-356    	; 0x1922 <_Z8Init_Devv>
    1a86:	49 e7       	ldi	r20, 0x79	; 121
    1a88:	5c e0       	ldi	r21, 0x0C	; 12
    1a8a:	60 e0       	ldi	r22, 0x00	; 0
    1a8c:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1a90:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1a94:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1a98:	41 e8       	ldi	r20, 0x81	; 129
    1a9a:	5c e0       	ldi	r21, 0x0C	; 12
    1a9c:	61 e0       	ldi	r22, 0x01	; 1
    1a9e:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1aa2:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1aa6:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    1aaa:	47 ea       	ldi	r20, 0xA7	; 167
    1aac:	58 e0       	ldi	r21, 0x08	; 8
    1aae:	62 e0       	ldi	r22, 0x02	; 2
    1ab0:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1ab4:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1ab8:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    1abc:	49 e8       	ldi	r20, 0x89	; 137
    1abe:	5c e0       	ldi	r21, 0x0C	; 12
    1ac0:	63 e0       	ldi	r22, 0x03	; 3
    1ac2:	80 91 40 03 	lds	r24, 0x0340	; 0x800340 <dev>
    1ac6:	90 91 41 03 	lds	r25, 0x0341	; 0x800341 <dev+0x1>
    1aca:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    1ace:	88 e8       	ldi	r24, 0x88	; 136
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1ad6:	6c 01       	movw	r12, r24
    1ad8:	60 91 40 03 	lds	r22, 0x0340	; 0x800340 <dev>
    1adc:	70 91 41 03 	lds	r23, 0x0341	; 0x800341 <dev+0x1>
    1ae0:	40 e0       	ldi	r20, 0x00	; 0
    1ae2:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1ae6:	c1 14       	cp	r12, r1
    1ae8:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1aea:	21 f4       	brne	.+8      	; 0x1af4 <main+0xdc>
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	90 e0       	ldi	r25, 0x00	; 0
    1af0:	0e 94 a2 18 	call	0x3144	; 0x3144 <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1af4:	88 e8       	ldi	r24, 0x88	; 136
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1afc:	ec 01       	movw	r28, r24
    1afe:	60 91 40 03 	lds	r22, 0x0340	; 0x800340 <dev>
    1b02:	70 91 41 03 	lds	r23, 0x0341	; 0x800341 <dev+0x1>
    1b06:	41 e0       	ldi	r20, 0x01	; 1
    1b08:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    1b0c:	20 97       	sbiw	r28, 0x00	; 0
	{
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1b0e:	21 f4       	brne	.+8      	; 0x1b18 <main+0x100>
    1b10:	81 e0       	ldi	r24, 0x01	; 1
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	0e 94 a2 18 	call	0x3144	; 0x3144 <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    1b18:	e8 e3       	ldi	r30, 0x38	; 56
    1b1a:	f3 e0       	ldi	r31, 0x03	; 3
    1b1c:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    1b1e:	c0 82       	st	Z, r12
    1b20:	d3 83       	std	Z+3, r29	; 0x03
				else if(i == RS485)
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			}
		}
	}
	Alarm_Init(); //알람 초기화
    1b22:	c2 83       	std	Z+2, r28	; 0x02
    1b24:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Alarm_Init>
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1b28:	78 94       	sei
    1b2a:	e1 2c       	mov	r14, r1
    1b2c:	f1 2c       	mov	r15, r1
    1b2e:	02 e0       	ldi	r16, 0x02	; 2
    1b30:	96 01       	movw	r18, r12
    1b32:	4e e5       	ldi	r20, 0x5E	; 94
    1b34:	51 e0       	ldi	r21, 0x01	; 1
    1b36:	64 e9       	ldi	r22, 0x94	; 148
    1b38:	71 e0       	ldi	r23, 0x01	; 1
    1b3a:	85 e1       	ldi	r24, 0x15	; 21
    1b3c:	9b e0       	ldi	r25, 0x0B	; 11
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    1b3e:	2b d5       	rcall	.+2646   	; 0x2596 <xTaskCreate>
    1b40:	9e 01       	movw	r18, r28
    1b42:	4e e5       	ldi	r20, 0x5E	; 94
    1b44:	51 e0       	ldi	r21, 0x01	; 1
    1b46:	6a e9       	ldi	r22, 0x9A	; 154
    1b48:	71 e0       	ldi	r23, 0x01	; 1
    1b4a:	8a e5       	ldi	r24, 0x5A	; 90
    1b4c:	9a e0       	ldi	r25, 0x0A	; 10
				"Task3",      //테스크 이름
				500,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    1b4e:	23 d5       	rcall	.+2630   	; 0x2596 <xTaskCreate>
    1b50:	20 e0       	ldi	r18, 0x00	; 0
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	44 ef       	ldi	r20, 0xF4	; 244
    1b56:	51 e0       	ldi	r21, 0x01	; 1
    1b58:	60 ea       	ldi	r22, 0xA0	; 160
    1b5a:	71 e0       	ldi	r23, 0x01	; 1
    1b5c:	89 eb       	ldi	r24, 0xB9	; 185
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    1b5e:	98 e0       	ldi	r25, 0x08	; 8
    1b60:	1a d5       	rcall	.+2612   	; 0x2596 <xTaskCreate>
	return 0;
}
    1b62:	17 d6       	rcall	.+3118   	; 0x2792 <vTaskStartScheduler>
    1b64:	80 e0       	ldi	r24, 0x00	; 0
    1b66:	90 e0       	ldi	r25, 0x00	; 0
    1b68:	df 91       	pop	r29
    1b6a:	cf 91       	pop	r28
    1b6c:	0f 91       	pop	r16
    1b6e:	ff 90       	pop	r15
    1b70:	ef 90       	pop	r14
    1b72:	df 90       	pop	r13
    1b74:	cf 90       	pop	r12
    1b76:	08 95       	ret

00001b78 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1b78:	08 95       	ret

00001b7a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1b7a:	cf 93       	push	r28
    1b7c:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1b7e:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    1b80:	30 d6       	rcall	.+3168   	; 0x27e2 <vTaskSuspendAll>
    1b82:	80 91 42 03 	lds	r24, 0x0342	; 0x800342 <pucAlignedHeap.2069>
    1b86:	90 91 43 03 	lds	r25, 0x0343	; 0x800343 <pucAlignedHeap.2069+0x1>
    1b8a:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1b8c:	31 f4       	brne	.+12     	; 0x1b9a <pvPortMalloc+0x20>
    1b8e:	87 e4       	ldi	r24, 0x47	; 71
    1b90:	93 e0       	ldi	r25, 0x03	; 3
    1b92:	90 93 43 03 	sts	0x0343, r25	; 0x800343 <pucAlignedHeap.2069+0x1>
    1b96:	80 93 42 03 	sts	0x0342, r24	; 0x800342 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1b9a:	20 91 44 03 	lds	r18, 0x0344	; 0x800344 <xNextFreeByte>
    1b9e:	30 91 45 03 	lds	r19, 0x0345	; 0x800345 <xNextFreeByte+0x1>
    1ba2:	c9 01       	movw	r24, r18
    1ba4:	8c 0f       	add	r24, r28
    1ba6:	9d 1f       	adc	r25, r29
    1ba8:	8b 3f       	cpi	r24, 0xFB	; 251
    1baa:	48 e0       	ldi	r20, 0x08	; 8
    1bac:	94 07       	cpc	r25, r20
    1bae:	70 f4       	brcc	.+28     	; 0x1bcc <pvPortMalloc+0x52>
    1bb0:	28 17       	cp	r18, r24
    1bb2:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1bb4:	70 f4       	brcc	.+28     	; 0x1bd2 <pvPortMalloc+0x58>
    1bb6:	c0 91 42 03 	lds	r28, 0x0342	; 0x800342 <pucAlignedHeap.2069>
    1bba:	d0 91 43 03 	lds	r29, 0x0343	; 0x800343 <pucAlignedHeap.2069+0x1>
    1bbe:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    1bc0:	d3 1f       	adc	r29, r19
    1bc2:	90 93 45 03 	sts	0x0345, r25	; 0x800345 <xNextFreeByte+0x1>
    1bc6:	80 93 44 03 	sts	0x0344, r24	; 0x800344 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1bca:	05 c0       	rjmp	.+10     	; 0x1bd6 <pvPortMalloc+0x5c>
    1bcc:	c0 e0       	ldi	r28, 0x00	; 0
    1bce:	d0 e0       	ldi	r29, 0x00	; 0
    1bd0:	02 c0       	rjmp	.+4      	; 0x1bd6 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1bd2:	c0 e0       	ldi	r28, 0x00	; 0
    1bd4:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1bd6:	c2 d6       	rcall	.+3460   	; 0x295c <xTaskResumeAll>
    1bd8:	ce 01       	movw	r24, r28
    1bda:	df 91       	pop	r29
    1bdc:	cf 91       	pop	r28
    1bde:	08 95       	ret

00001be0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1be0:	08 95       	ret

00001be2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1be2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1be4:	03 96       	adiw	r24, 0x03	; 3
    1be6:	92 83       	std	Z+2, r25	; 0x02
    1be8:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bea:	2f ef       	ldi	r18, 0xFF	; 255
    1bec:	3f ef       	ldi	r19, 0xFF	; 255
    1bee:	34 83       	std	Z+4, r19	; 0x04
    1bf0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf2:	96 83       	std	Z+6, r25	; 0x06
    1bf4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bf6:	90 87       	std	Z+8, r25	; 0x08
    1bf8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1bfa:	10 82       	st	Z, r1
    1bfc:	08 95       	ret

00001bfe <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1bfe:	fc 01       	movw	r30, r24
    1c00:	11 86       	std	Z+9, r1	; 0x09
    1c02:	10 86       	std	Z+8, r1	; 0x08
    1c04:	08 95       	ret

00001c06 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c06:	cf 93       	push	r28
    1c08:	df 93       	push	r29
    1c0a:	9c 01       	movw	r18, r24
    1c0c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c0e:	dc 01       	movw	r26, r24
    1c10:	11 96       	adiw	r26, 0x01	; 1
    1c12:	cd 91       	ld	r28, X+
    1c14:	dc 91       	ld	r29, X
    1c16:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c18:	d3 83       	std	Z+3, r29	; 0x03
    1c1a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c1c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c1e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c20:	95 83       	std	Z+5, r25	; 0x05
    1c22:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c24:	8c 81       	ldd	r24, Y+4	; 0x04
    1c26:	9d 81       	ldd	r25, Y+5	; 0x05
    1c28:	dc 01       	movw	r26, r24
    1c2a:	13 96       	adiw	r26, 0x03	; 3
    1c2c:	7c 93       	st	X, r23
    1c2e:	6e 93       	st	-X, r22
    1c30:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1c32:	7d 83       	std	Y+5, r23	; 0x05
    1c34:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c36:	31 87       	std	Z+9, r19	; 0x09
    1c38:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1c3a:	f9 01       	movw	r30, r18
    1c3c:	80 81       	ld	r24, Z
    1c3e:	8f 5f       	subi	r24, 0xFF	; 255
    1c40:	80 83       	st	Z, r24
}
    1c42:	df 91       	pop	r29
    1c44:	cf 91       	pop	r28
    1c46:	08 95       	ret

00001c48 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c48:	cf 93       	push	r28
    1c4a:	df 93       	push	r29
    1c4c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c4e:	48 81       	ld	r20, Y
    1c50:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c52:	4f 3f       	cpi	r20, 0xFF	; 255
    1c54:	2f ef       	ldi	r18, 0xFF	; 255
    1c56:	52 07       	cpc	r21, r18
    1c58:	21 f4       	brne	.+8      	; 0x1c62 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	a7 81       	ldd	r26, Z+7	; 0x07
    1c5e:	b0 85       	ldd	r27, Z+8	; 0x08
    1c60:	0d c0       	rjmp	.+26     	; 0x1c7c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c62:	dc 01       	movw	r26, r24
    1c64:	13 96       	adiw	r26, 0x03	; 3
    1c66:	01 c0       	rjmp	.+2      	; 0x1c6a <vListInsert+0x22>
    1c68:	df 01       	movw	r26, r30
    1c6a:	12 96       	adiw	r26, 0x02	; 2
    1c6c:	ed 91       	ld	r30, X+
    1c6e:	fc 91       	ld	r31, X
    1c70:	13 97       	sbiw	r26, 0x03	; 3
    1c72:	20 81       	ld	r18, Z
    1c74:	31 81       	ldd	r19, Z+1	; 0x01
    1c76:	42 17       	cp	r20, r18
    1c78:	53 07       	cpc	r21, r19
    1c7a:	b0 f7       	brcc	.-20     	; 0x1c68 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c7c:	12 96       	adiw	r26, 0x02	; 2
    1c7e:	ed 91       	ld	r30, X+
    1c80:	fc 91       	ld	r31, X
    1c82:	13 97       	sbiw	r26, 0x03	; 3
    1c84:	fb 83       	std	Y+3, r31	; 0x03
    1c86:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c88:	d5 83       	std	Z+5, r29	; 0x05
    1c8a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1c8c:	bd 83       	std	Y+5, r27	; 0x05
    1c8e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1c90:	13 96       	adiw	r26, 0x03	; 3
    1c92:	dc 93       	st	X, r29
    1c94:	ce 93       	st	-X, r28
    1c96:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c98:	99 87       	std	Y+9, r25	; 0x09
    1c9a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1c9c:	fc 01       	movw	r30, r24
    1c9e:	20 81       	ld	r18, Z
    1ca0:	2f 5f       	subi	r18, 0xFF	; 255
    1ca2:	20 83       	st	Z, r18
}
    1ca4:	df 91       	pop	r29
    1ca6:	cf 91       	pop	r28
    1ca8:	08 95       	ret

00001caa <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1caa:	cf 93       	push	r28
    1cac:	df 93       	push	r29
    1cae:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cb0:	a0 85       	ldd	r26, Z+8	; 0x08
    1cb2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cb4:	c2 81       	ldd	r28, Z+2	; 0x02
    1cb6:	d3 81       	ldd	r29, Z+3	; 0x03
    1cb8:	84 81       	ldd	r24, Z+4	; 0x04
    1cba:	95 81       	ldd	r25, Z+5	; 0x05
    1cbc:	9d 83       	std	Y+5, r25	; 0x05
    1cbe:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cc0:	c4 81       	ldd	r28, Z+4	; 0x04
    1cc2:	d5 81       	ldd	r29, Z+5	; 0x05
    1cc4:	82 81       	ldd	r24, Z+2	; 0x02
    1cc6:	93 81       	ldd	r25, Z+3	; 0x03
    1cc8:	9b 83       	std	Y+3, r25	; 0x03
    1cca:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1ccc:	11 96       	adiw	r26, 0x01	; 1
    1cce:	8d 91       	ld	r24, X+
    1cd0:	9c 91       	ld	r25, X
    1cd2:	12 97       	sbiw	r26, 0x02	; 2
    1cd4:	e8 17       	cp	r30, r24
    1cd6:	f9 07       	cpc	r31, r25
    1cd8:	31 f4       	brne	.+12     	; 0x1ce6 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1cda:	84 81       	ldd	r24, Z+4	; 0x04
    1cdc:	95 81       	ldd	r25, Z+5	; 0x05
    1cde:	12 96       	adiw	r26, 0x02	; 2
    1ce0:	9c 93       	st	X, r25
    1ce2:	8e 93       	st	-X, r24
    1ce4:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1ce6:	11 86       	std	Z+9, r1	; 0x09
    1ce8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1cea:	8c 91       	ld	r24, X
    1cec:	81 50       	subi	r24, 0x01	; 1
    1cee:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1cf0:	df 91       	pop	r29
    1cf2:	cf 91       	pop	r28
    1cf4:	08 95       	ret

00001cf6 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1cf6:	31 e1       	ldi	r19, 0x11	; 17
    1cf8:	fc 01       	movw	r30, r24
    1cfa:	30 83       	st	Z, r19
    1cfc:	31 97       	sbiw	r30, 0x01	; 1
    1cfe:	22 e2       	ldi	r18, 0x22	; 34
    1d00:	20 83       	st	Z, r18
    1d02:	31 97       	sbiw	r30, 0x01	; 1
    1d04:	a3 e3       	ldi	r26, 0x33	; 51
    1d06:	a0 83       	st	Z, r26
    1d08:	31 97       	sbiw	r30, 0x01	; 1
    1d0a:	60 83       	st	Z, r22
    1d0c:	31 97       	sbiw	r30, 0x01	; 1
    1d0e:	70 83       	st	Z, r23
    1d10:	31 97       	sbiw	r30, 0x01	; 1
    1d12:	10 82       	st	Z, r1
    1d14:	31 97       	sbiw	r30, 0x01	; 1
    1d16:	60 e8       	ldi	r22, 0x80	; 128
    1d18:	60 83       	st	Z, r22
    1d1a:	31 97       	sbiw	r30, 0x01	; 1
    1d1c:	10 82       	st	Z, r1
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	62 e0       	ldi	r22, 0x02	; 2
    1d22:	60 83       	st	Z, r22
    1d24:	31 97       	sbiw	r30, 0x01	; 1
    1d26:	63 e0       	ldi	r22, 0x03	; 3
    1d28:	60 83       	st	Z, r22
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	64 e0       	ldi	r22, 0x04	; 4
    1d2e:	60 83       	st	Z, r22
    1d30:	31 97       	sbiw	r30, 0x01	; 1
    1d32:	65 e0       	ldi	r22, 0x05	; 5
    1d34:	60 83       	st	Z, r22
    1d36:	31 97       	sbiw	r30, 0x01	; 1
    1d38:	66 e0       	ldi	r22, 0x06	; 6
    1d3a:	60 83       	st	Z, r22
    1d3c:	31 97       	sbiw	r30, 0x01	; 1
    1d3e:	67 e0       	ldi	r22, 0x07	; 7
    1d40:	60 83       	st	Z, r22
    1d42:	31 97       	sbiw	r30, 0x01	; 1
    1d44:	68 e0       	ldi	r22, 0x08	; 8
    1d46:	60 83       	st	Z, r22
    1d48:	31 97       	sbiw	r30, 0x01	; 1
    1d4a:	69 e0       	ldi	r22, 0x09	; 9
    1d4c:	60 83       	st	Z, r22
    1d4e:	31 97       	sbiw	r30, 0x01	; 1
    1d50:	60 e1       	ldi	r22, 0x10	; 16
    1d52:	60 83       	st	Z, r22
    1d54:	31 97       	sbiw	r30, 0x01	; 1
    1d56:	30 83       	st	Z, r19
    1d58:	31 97       	sbiw	r30, 0x01	; 1
    1d5a:	32 e1       	ldi	r19, 0x12	; 18
    1d5c:	30 83       	st	Z, r19
    1d5e:	31 97       	sbiw	r30, 0x01	; 1
    1d60:	33 e1       	ldi	r19, 0x13	; 19
    1d62:	30 83       	st	Z, r19
    1d64:	31 97       	sbiw	r30, 0x01	; 1
    1d66:	34 e1       	ldi	r19, 0x14	; 20
    1d68:	30 83       	st	Z, r19
    1d6a:	31 97       	sbiw	r30, 0x01	; 1
    1d6c:	35 e1       	ldi	r19, 0x15	; 21
    1d6e:	30 83       	st	Z, r19
    1d70:	31 97       	sbiw	r30, 0x01	; 1
    1d72:	36 e1       	ldi	r19, 0x16	; 22
    1d74:	30 83       	st	Z, r19
    1d76:	31 97       	sbiw	r30, 0x01	; 1
    1d78:	37 e1       	ldi	r19, 0x17	; 23
    1d7a:	30 83       	st	Z, r19
    1d7c:	31 97       	sbiw	r30, 0x01	; 1
    1d7e:	38 e1       	ldi	r19, 0x18	; 24
    1d80:	30 83       	st	Z, r19
    1d82:	31 97       	sbiw	r30, 0x01	; 1
    1d84:	39 e1       	ldi	r19, 0x19	; 25
    1d86:	30 83       	st	Z, r19
    1d88:	31 97       	sbiw	r30, 0x01	; 1
    1d8a:	30 e2       	ldi	r19, 0x20	; 32
    1d8c:	30 83       	st	Z, r19
    1d8e:	31 97       	sbiw	r30, 0x01	; 1
    1d90:	31 e2       	ldi	r19, 0x21	; 33
    1d92:	30 83       	st	Z, r19
    1d94:	31 97       	sbiw	r30, 0x01	; 1
    1d96:	20 83       	st	Z, r18
    1d98:	31 97       	sbiw	r30, 0x01	; 1
    1d9a:	23 e2       	ldi	r18, 0x23	; 35
    1d9c:	20 83       	st	Z, r18
    1d9e:	31 97       	sbiw	r30, 0x01	; 1
    1da0:	40 83       	st	Z, r20
    1da2:	31 97       	sbiw	r30, 0x01	; 1
    1da4:	50 83       	st	Z, r21
    1da6:	31 97       	sbiw	r30, 0x01	; 1
    1da8:	26 e2       	ldi	r18, 0x26	; 38
    1daa:	20 83       	st	Z, r18
    1dac:	31 97       	sbiw	r30, 0x01	; 1
    1dae:	27 e2       	ldi	r18, 0x27	; 39
    1db0:	20 83       	st	Z, r18
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	28 e2       	ldi	r18, 0x28	; 40
    1db6:	20 83       	st	Z, r18
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	29 e2       	ldi	r18, 0x29	; 41
    1dbc:	20 83       	st	Z, r18
    1dbe:	31 97       	sbiw	r30, 0x01	; 1
    1dc0:	20 e3       	ldi	r18, 0x30	; 48
    1dc2:	20 83       	st	Z, r18
    1dc4:	31 97       	sbiw	r30, 0x01	; 1
    1dc6:	21 e3       	ldi	r18, 0x31	; 49
    1dc8:	20 83       	st	Z, r18
    1dca:	86 97       	sbiw	r24, 0x26	; 38
    1dcc:	08 95       	ret

00001dce <xPortStartScheduler>:
    1dce:	1b bc       	out	0x2b, r1	; 43
    1dd0:	89 ef       	ldi	r24, 0xF9	; 249
    1dd2:	8a bd       	out	0x2a, r24	; 42
    1dd4:	8b e0       	ldi	r24, 0x0B	; 11
    1dd6:	8e bd       	out	0x2e, r24	; 46
    1dd8:	87 b7       	in	r24, 0x37	; 55
    1dda:	80 61       	ori	r24, 0x10	; 16
    1ddc:	87 bf       	out	0x37, r24	; 55
    1dde:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    1de2:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    1de6:	cd 91       	ld	r28, X+
    1de8:	cd bf       	out	0x3d, r28	; 61
    1dea:	dd 91       	ld	r29, X+
    1dec:	de bf       	out	0x3e, r29	; 62
    1dee:	ff 91       	pop	r31
    1df0:	ef 91       	pop	r30
    1df2:	df 91       	pop	r29
    1df4:	cf 91       	pop	r28
    1df6:	bf 91       	pop	r27
    1df8:	af 91       	pop	r26
    1dfa:	9f 91       	pop	r25
    1dfc:	8f 91       	pop	r24
    1dfe:	7f 91       	pop	r23
    1e00:	6f 91       	pop	r22
    1e02:	5f 91       	pop	r21
    1e04:	4f 91       	pop	r20
    1e06:	3f 91       	pop	r19
    1e08:	2f 91       	pop	r18
    1e0a:	1f 91       	pop	r17
    1e0c:	0f 91       	pop	r16
    1e0e:	ff 90       	pop	r15
    1e10:	ef 90       	pop	r14
    1e12:	df 90       	pop	r13
    1e14:	cf 90       	pop	r12
    1e16:	bf 90       	pop	r11
    1e18:	af 90       	pop	r10
    1e1a:	9f 90       	pop	r9
    1e1c:	8f 90       	pop	r8
    1e1e:	7f 90       	pop	r7
    1e20:	6f 90       	pop	r6
    1e22:	5f 90       	pop	r5
    1e24:	4f 90       	pop	r4
    1e26:	3f 90       	pop	r3
    1e28:	2f 90       	pop	r2
    1e2a:	1f 90       	pop	r1
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	0f 90       	pop	r0
    1e32:	08 95       	ret
    1e34:	81 e0       	ldi	r24, 0x01	; 1
    1e36:	08 95       	ret

00001e38 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1e38:	0f 92       	push	r0
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	f8 94       	cli
    1e3e:	0f 92       	push	r0
    1e40:	1f 92       	push	r1
    1e42:	11 24       	eor	r1, r1
    1e44:	2f 92       	push	r2
    1e46:	3f 92       	push	r3
    1e48:	4f 92       	push	r4
    1e4a:	5f 92       	push	r5
    1e4c:	6f 92       	push	r6
    1e4e:	7f 92       	push	r7
    1e50:	8f 92       	push	r8
    1e52:	9f 92       	push	r9
    1e54:	af 92       	push	r10
    1e56:	bf 92       	push	r11
    1e58:	cf 92       	push	r12
    1e5a:	df 92       	push	r13
    1e5c:	ef 92       	push	r14
    1e5e:	ff 92       	push	r15
    1e60:	0f 93       	push	r16
    1e62:	1f 93       	push	r17
    1e64:	2f 93       	push	r18
    1e66:	3f 93       	push	r19
    1e68:	4f 93       	push	r20
    1e6a:	5f 93       	push	r21
    1e6c:	6f 93       	push	r22
    1e6e:	7f 93       	push	r23
    1e70:	8f 93       	push	r24
    1e72:	9f 93       	push	r25
    1e74:	af 93       	push	r26
    1e76:	bf 93       	push	r27
    1e78:	cf 93       	push	r28
    1e7a:	df 93       	push	r29
    1e7c:	ef 93       	push	r30
    1e7e:	ff 93       	push	r31
    1e80:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    1e84:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    1e88:	0d b6       	in	r0, 0x3d	; 61
    1e8a:	0d 92       	st	X+, r0
    1e8c:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1e8e:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    1e90:	25 d6       	rcall	.+3146   	; 0x2adc <vTaskSwitchContext>
    1e92:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    1e96:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    1e9a:	cd 91       	ld	r28, X+
    1e9c:	cd bf       	out	0x3d, r28	; 61
    1e9e:	dd 91       	ld	r29, X+
    1ea0:	de bf       	out	0x3e, r29	; 62
    1ea2:	ff 91       	pop	r31
    1ea4:	ef 91       	pop	r30
    1ea6:	df 91       	pop	r29
    1ea8:	cf 91       	pop	r28
    1eaa:	bf 91       	pop	r27
    1eac:	af 91       	pop	r26
    1eae:	9f 91       	pop	r25
    1eb0:	8f 91       	pop	r24
    1eb2:	7f 91       	pop	r23
    1eb4:	6f 91       	pop	r22
    1eb6:	5f 91       	pop	r21
    1eb8:	4f 91       	pop	r20
    1eba:	3f 91       	pop	r19
    1ebc:	2f 91       	pop	r18
    1ebe:	1f 91       	pop	r17
    1ec0:	0f 91       	pop	r16
    1ec2:	ff 90       	pop	r15
    1ec4:	ef 90       	pop	r14
    1ec6:	df 90       	pop	r13
    1ec8:	cf 90       	pop	r12
    1eca:	bf 90       	pop	r11
    1ecc:	af 90       	pop	r10
    1ece:	9f 90       	pop	r9
    1ed0:	8f 90       	pop	r8
    1ed2:	7f 90       	pop	r7
    1ed4:	6f 90       	pop	r6
    1ed6:	5f 90       	pop	r5
    1ed8:	4f 90       	pop	r4
    1eda:	3f 90       	pop	r3
    1edc:	2f 90       	pop	r2
    1ede:	1f 90       	pop	r1
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1ee4:	0f 90       	pop	r0
    1ee6:	08 95       	ret

00001ee8 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1ee8:	0f 92       	push	r0
    1eea:	0f b6       	in	r0, 0x3f	; 63
    1eec:	f8 94       	cli
    1eee:	0f 92       	push	r0
    1ef0:	1f 92       	push	r1
    1ef2:	11 24       	eor	r1, r1
    1ef4:	2f 92       	push	r2
    1ef6:	3f 92       	push	r3
    1ef8:	4f 92       	push	r4
    1efa:	5f 92       	push	r5
    1efc:	6f 92       	push	r6
    1efe:	7f 92       	push	r7
    1f00:	8f 92       	push	r8
    1f02:	9f 92       	push	r9
    1f04:	af 92       	push	r10
    1f06:	bf 92       	push	r11
    1f08:	cf 92       	push	r12
    1f0a:	df 92       	push	r13
    1f0c:	ef 92       	push	r14
    1f0e:	ff 92       	push	r15
    1f10:	0f 93       	push	r16
    1f12:	1f 93       	push	r17
    1f14:	2f 93       	push	r18
    1f16:	3f 93       	push	r19
    1f18:	4f 93       	push	r20
    1f1a:	5f 93       	push	r21
    1f1c:	6f 93       	push	r22
    1f1e:	7f 93       	push	r23
    1f20:	8f 93       	push	r24
    1f22:	9f 93       	push	r25
    1f24:	af 93       	push	r26
    1f26:	bf 93       	push	r27
    1f28:	cf 93       	push	r28
    1f2a:	df 93       	push	r29
    1f2c:	ef 93       	push	r30
    1f2e:	ff 93       	push	r31
    1f30:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    1f34:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    1f38:	0d b6       	in	r0, 0x3d	; 61
    1f3a:	0d 92       	st	X+, r0
    1f3c:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    1f3e:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    1f40:	56 d4       	rcall	.+2220   	; 0x27ee <xTaskIncrementTick>
    1f42:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    1f44:	cb d5       	rcall	.+2966   	; 0x2adc <vTaskSwitchContext>
    1f46:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    1f4a:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    1f4e:	cd 91       	ld	r28, X+
    1f50:	cd bf       	out	0x3d, r28	; 61
    1f52:	dd 91       	ld	r29, X+
    1f54:	de bf       	out	0x3e, r29	; 62
    1f56:	ff 91       	pop	r31
    1f58:	ef 91       	pop	r30
    1f5a:	df 91       	pop	r29
    1f5c:	cf 91       	pop	r28
    1f5e:	bf 91       	pop	r27
    1f60:	af 91       	pop	r26
    1f62:	9f 91       	pop	r25
    1f64:	8f 91       	pop	r24
    1f66:	7f 91       	pop	r23
    1f68:	6f 91       	pop	r22
    1f6a:	5f 91       	pop	r21
    1f6c:	4f 91       	pop	r20
    1f6e:	3f 91       	pop	r19
    1f70:	2f 91       	pop	r18
    1f72:	1f 91       	pop	r17
    1f74:	0f 91       	pop	r16
    1f76:	ff 90       	pop	r15
    1f78:	ef 90       	pop	r14
    1f7a:	df 90       	pop	r13
    1f7c:	cf 90       	pop	r12
    1f7e:	bf 90       	pop	r11
    1f80:	af 90       	pop	r10
    1f82:	9f 90       	pop	r9
    1f84:	8f 90       	pop	r8
    1f86:	7f 90       	pop	r7
    1f88:	6f 90       	pop	r6
    1f8a:	5f 90       	pop	r5
    1f8c:	4f 90       	pop	r4
    1f8e:	3f 90       	pop	r3
    1f90:	2f 90       	pop	r2
    1f92:	1f 90       	pop	r1
    1f94:	0f 90       	pop	r0
    1f96:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1f98:	0f 90       	pop	r0
    1f9a:	08 95       	ret

00001f9c <__vector_12>:
    1f9c:	a5 df       	rcall	.-182    	; 0x1ee8 <vPortYieldFromTick>
    1f9e:	18 95       	reti

00001fa0 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1fa0:	0f 93       	push	r16
    1fa2:	1f 93       	push	r17
    1fa4:	cf 93       	push	r28
    1fa6:	df 93       	push	r29
    1fa8:	ec 01       	movw	r28, r24
    1faa:	04 2f       	mov	r16, r20
    1fac:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1fae:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1fb0:	41 11       	cpse	r20, r1
    1fb2:	0b c0       	rjmp	.+22     	; 0x1fca <prvCopyDataToQueue+0x2a>
    1fb4:	88 81       	ld	r24, Y
    1fb6:	99 81       	ldd	r25, Y+1	; 0x01
    1fb8:	89 2b       	or	r24, r25
    1fba:	09 f0       	breq	.+2      	; 0x1fbe <prvCopyDataToQueue+0x1e>
    1fbc:	41 c0       	rjmp	.+130    	; 0x2040 <prvCopyDataToQueue+0xa0>
    1fbe:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc2:	0b d7       	rcall	.+3606   	; 0x2dda <xTaskPriorityDisinherit>
    1fc4:	1b 82       	std	Y+3, r1	; 0x03
    1fc6:	1a 82       	std	Y+2, r1	; 0x02
    1fc8:	42 c0       	rjmp	.+132    	; 0x204e <prvCopyDataToQueue+0xae>
    1fca:	01 11       	cpse	r16, r1
    1fcc:	17 c0       	rjmp	.+46     	; 0x1ffc <prvCopyDataToQueue+0x5c>
    1fce:	50 e0       	ldi	r21, 0x00	; 0
    1fd0:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd2:	9d 81       	ldd	r25, Y+5	; 0x05
    1fd4:	0e 94 80 18 	call	0x3100	; 0x3100 <memcpy>
    1fd8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1fda:	8c 81       	ldd	r24, Y+4	; 0x04
    1fdc:	9d 81       	ldd	r25, Y+5	; 0x05
    1fde:	82 0f       	add	r24, r18
    1fe0:	91 1d       	adc	r25, r1
    1fe2:	9d 83       	std	Y+5, r25	; 0x05
    1fe4:	8c 83       	std	Y+4, r24	; 0x04
    1fe6:	2a 81       	ldd	r18, Y+2	; 0x02
    1fe8:	3b 81       	ldd	r19, Y+3	; 0x03
    1fea:	82 17       	cp	r24, r18
    1fec:	93 07       	cpc	r25, r19
    1fee:	50 f1       	brcs	.+84     	; 0x2044 <prvCopyDataToQueue+0xa4>
    1ff0:	88 81       	ld	r24, Y
    1ff2:	99 81       	ldd	r25, Y+1	; 0x01
    1ff4:	9d 83       	std	Y+5, r25	; 0x05
    1ff6:	8c 83       	std	Y+4, r24	; 0x04
    1ff8:	80 e0       	ldi	r24, 0x00	; 0
    1ffa:	29 c0       	rjmp	.+82     	; 0x204e <prvCopyDataToQueue+0xae>
    1ffc:	50 e0       	ldi	r21, 0x00	; 0
    1ffe:	8e 81       	ldd	r24, Y+6	; 0x06
    2000:	9f 81       	ldd	r25, Y+7	; 0x07
    2002:	0e 94 80 18 	call	0x3100	; 0x3100 <memcpy>
    2006:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	91 95       	neg	r25
    200c:	81 95       	neg	r24
    200e:	91 09       	sbc	r25, r1
    2010:	2e 81       	ldd	r18, Y+6	; 0x06
    2012:	3f 81       	ldd	r19, Y+7	; 0x07
    2014:	28 0f       	add	r18, r24
    2016:	39 1f       	adc	r19, r25
    2018:	3f 83       	std	Y+7, r19	; 0x07
    201a:	2e 83       	std	Y+6, r18	; 0x06
    201c:	48 81       	ld	r20, Y
    201e:	59 81       	ldd	r21, Y+1	; 0x01
    2020:	24 17       	cp	r18, r20
    2022:	35 07       	cpc	r19, r21
    2024:	30 f4       	brcc	.+12     	; 0x2032 <prvCopyDataToQueue+0x92>
    2026:	2a 81       	ldd	r18, Y+2	; 0x02
    2028:	3b 81       	ldd	r19, Y+3	; 0x03
    202a:	82 0f       	add	r24, r18
    202c:	93 1f       	adc	r25, r19
    202e:	9f 83       	std	Y+7, r25	; 0x07
    2030:	8e 83       	std	Y+6, r24	; 0x06
    2032:	02 30       	cpi	r16, 0x02	; 2
    2034:	49 f4       	brne	.+18     	; 0x2048 <prvCopyDataToQueue+0xa8>
    2036:	11 23       	and	r17, r17
    2038:	49 f0       	breq	.+18     	; 0x204c <prvCopyDataToQueue+0xac>
    203a:	11 50       	subi	r17, 0x01	; 1
    203c:	80 e0       	ldi	r24, 0x00	; 0
    203e:	07 c0       	rjmp	.+14     	; 0x204e <prvCopyDataToQueue+0xae>
    2040:	80 e0       	ldi	r24, 0x00	; 0
    2042:	05 c0       	rjmp	.+10     	; 0x204e <prvCopyDataToQueue+0xae>
    2044:	80 e0       	ldi	r24, 0x00	; 0
    2046:	03 c0       	rjmp	.+6      	; 0x204e <prvCopyDataToQueue+0xae>
    2048:	80 e0       	ldi	r24, 0x00	; 0
    204a:	01 c0       	rjmp	.+2      	; 0x204e <prvCopyDataToQueue+0xae>
    204c:	80 e0       	ldi	r24, 0x00	; 0
    204e:	1f 5f       	subi	r17, 0xFF	; 255
    2050:	1a 8f       	std	Y+26, r17	; 0x1a
    2052:	df 91       	pop	r29
    2054:	cf 91       	pop	r28
    2056:	1f 91       	pop	r17
    2058:	0f 91       	pop	r16
    205a:	08 95       	ret

0000205c <prvCopyDataFromQueue>:
    205c:	fc 01       	movw	r30, r24
    205e:	44 8d       	ldd	r20, Z+28	; 0x1c
    2060:	44 23       	and	r20, r20
    2062:	a9 f0       	breq	.+42     	; 0x208e <prvCopyDataFromQueue+0x32>
    2064:	50 e0       	ldi	r21, 0x00	; 0
    2066:	26 81       	ldd	r18, Z+6	; 0x06
    2068:	37 81       	ldd	r19, Z+7	; 0x07
    206a:	24 0f       	add	r18, r20
    206c:	35 1f       	adc	r19, r21
    206e:	37 83       	std	Z+7, r19	; 0x07
    2070:	26 83       	std	Z+6, r18	; 0x06
    2072:	82 81       	ldd	r24, Z+2	; 0x02
    2074:	93 81       	ldd	r25, Z+3	; 0x03
    2076:	28 17       	cp	r18, r24
    2078:	39 07       	cpc	r19, r25
    207a:	20 f0       	brcs	.+8      	; 0x2084 <prvCopyDataFromQueue+0x28>
    207c:	80 81       	ld	r24, Z
    207e:	91 81       	ldd	r25, Z+1	; 0x01
    2080:	97 83       	std	Z+7, r25	; 0x07
    2082:	86 83       	std	Z+6, r24	; 0x06
    2084:	cb 01       	movw	r24, r22
    2086:	66 81       	ldd	r22, Z+6	; 0x06
    2088:	77 81       	ldd	r23, Z+7	; 0x07
    208a:	0c 94 80 18 	jmp	0x3100	; 0x3100 <memcpy>
    208e:	08 95       	ret

00002090 <prvUnlockQueue>:
    2090:	ef 92       	push	r14
    2092:	ff 92       	push	r15
    2094:	0f 93       	push	r16
    2096:	1f 93       	push	r17
    2098:	cf 93       	push	r28
    209a:	8c 01       	movw	r16, r24
    209c:	0f b6       	in	r0, 0x3f	; 63
    209e:	f8 94       	cli
    20a0:	0f 92       	push	r0
    20a2:	fc 01       	movw	r30, r24
    20a4:	c6 8d       	ldd	r28, Z+30	; 0x1e
    20a6:	1c 16       	cp	r1, r28
    20a8:	9c f4       	brge	.+38     	; 0x20d0 <prvUnlockQueue+0x40>
    20aa:	81 89       	ldd	r24, Z+17	; 0x11
    20ac:	81 11       	cpse	r24, r1
    20ae:	06 c0       	rjmp	.+12     	; 0x20bc <prvUnlockQueue+0x2c>
    20b0:	0f c0       	rjmp	.+30     	; 0x20d0 <prvUnlockQueue+0x40>
    20b2:	f8 01       	movw	r30, r16
    20b4:	81 89       	ldd	r24, Z+17	; 0x11
    20b6:	81 11       	cpse	r24, r1
    20b8:	05 c0       	rjmp	.+10     	; 0x20c4 <prvUnlockQueue+0x34>
    20ba:	0a c0       	rjmp	.+20     	; 0x20d0 <prvUnlockQueue+0x40>
    20bc:	78 01       	movw	r14, r16
    20be:	f1 e1       	ldi	r31, 0x11	; 17
    20c0:	ef 0e       	add	r14, r31
    20c2:	f1 1c       	adc	r15, r1
    20c4:	c7 01       	movw	r24, r14
    20c6:	9a d5       	rcall	.+2868   	; 0x2bfc <xTaskRemoveFromEventList>
    20c8:	81 11       	cpse	r24, r1
    20ca:	21 d6       	rcall	.+3138   	; 0x2d0e <vTaskMissedYield>
    20cc:	c1 50       	subi	r28, 0x01	; 1
    20ce:	89 f7       	brne	.-30     	; 0x20b2 <prvUnlockQueue+0x22>
    20d0:	8f ef       	ldi	r24, 0xFF	; 255
    20d2:	f8 01       	movw	r30, r16
    20d4:	86 8f       	std	Z+30, r24	; 0x1e
    20d6:	0f 90       	pop	r0
    20d8:	0f be       	out	0x3f, r0	; 63
    20da:	0f b6       	in	r0, 0x3f	; 63
    20dc:	f8 94       	cli
    20de:	0f 92       	push	r0
    20e0:	c5 8d       	ldd	r28, Z+29	; 0x1d
    20e2:	1c 16       	cp	r1, r28
    20e4:	9c f4       	brge	.+38     	; 0x210c <prvUnlockQueue+0x7c>
    20e6:	80 85       	ldd	r24, Z+8	; 0x08
    20e8:	81 11       	cpse	r24, r1
    20ea:	06 c0       	rjmp	.+12     	; 0x20f8 <prvUnlockQueue+0x68>
    20ec:	0f c0       	rjmp	.+30     	; 0x210c <prvUnlockQueue+0x7c>
    20ee:	f8 01       	movw	r30, r16
    20f0:	80 85       	ldd	r24, Z+8	; 0x08
    20f2:	81 11       	cpse	r24, r1
    20f4:	05 c0       	rjmp	.+10     	; 0x2100 <prvUnlockQueue+0x70>
    20f6:	0a c0       	rjmp	.+20     	; 0x210c <prvUnlockQueue+0x7c>
    20f8:	78 01       	movw	r14, r16
    20fa:	f8 e0       	ldi	r31, 0x08	; 8
    20fc:	ef 0e       	add	r14, r31
    20fe:	f1 1c       	adc	r15, r1
    2100:	c7 01       	movw	r24, r14
    2102:	7c d5       	rcall	.+2808   	; 0x2bfc <xTaskRemoveFromEventList>
    2104:	81 11       	cpse	r24, r1
    2106:	03 d6       	rcall	.+3078   	; 0x2d0e <vTaskMissedYield>
    2108:	c1 50       	subi	r28, 0x01	; 1
    210a:	89 f7       	brne	.-30     	; 0x20ee <prvUnlockQueue+0x5e>
    210c:	8f ef       	ldi	r24, 0xFF	; 255
    210e:	f8 01       	movw	r30, r16
    2110:	85 8f       	std	Z+29, r24	; 0x1d
    2112:	0f 90       	pop	r0
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	cf 91       	pop	r28
    2118:	1f 91       	pop	r17
    211a:	0f 91       	pop	r16
    211c:	ff 90       	pop	r15
    211e:	ef 90       	pop	r14
    2120:	08 95       	ret

00002122 <xQueueGenericReset>:
    2122:	cf 93       	push	r28
    2124:	df 93       	push	r29
    2126:	ec 01       	movw	r28, r24
    2128:	0f b6       	in	r0, 0x3f	; 63
    212a:	f8 94       	cli
    212c:	0f 92       	push	r0
    212e:	48 81       	ld	r20, Y
    2130:	59 81       	ldd	r21, Y+1	; 0x01
    2132:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	7b 8d       	ldd	r23, Y+27	; 0x1b
    2138:	72 9f       	mul	r23, r18
    213a:	c0 01       	movw	r24, r0
    213c:	73 9f       	mul	r23, r19
    213e:	90 0d       	add	r25, r0
    2140:	11 24       	eor	r1, r1
    2142:	fa 01       	movw	r30, r20
    2144:	e8 0f       	add	r30, r24
    2146:	f9 1f       	adc	r31, r25
    2148:	fb 83       	std	Y+3, r31	; 0x03
    214a:	ea 83       	std	Y+2, r30	; 0x02
    214c:	1a 8e       	std	Y+26, r1	; 0x1a
    214e:	5d 83       	std	Y+5, r21	; 0x05
    2150:	4c 83       	std	Y+4, r20	; 0x04
    2152:	82 1b       	sub	r24, r18
    2154:	93 0b       	sbc	r25, r19
    2156:	84 0f       	add	r24, r20
    2158:	95 1f       	adc	r25, r21
    215a:	9f 83       	std	Y+7, r25	; 0x07
    215c:	8e 83       	std	Y+6, r24	; 0x06
    215e:	8f ef       	ldi	r24, 0xFF	; 255
    2160:	8d 8f       	std	Y+29, r24	; 0x1d
    2162:	8e 8f       	std	Y+30, r24	; 0x1e
    2164:	61 11       	cpse	r22, r1
    2166:	0a c0       	rjmp	.+20     	; 0x217c <xQueueGenericReset+0x5a>
    2168:	88 85       	ldd	r24, Y+8	; 0x08
    216a:	88 23       	and	r24, r24
    216c:	69 f0       	breq	.+26     	; 0x2188 <xQueueGenericReset+0x66>
    216e:	ce 01       	movw	r24, r28
    2170:	08 96       	adiw	r24, 0x08	; 8
    2172:	44 d5       	rcall	.+2696   	; 0x2bfc <xTaskRemoveFromEventList>
    2174:	88 23       	and	r24, r24
    2176:	41 f0       	breq	.+16     	; 0x2188 <xQueueGenericReset+0x66>
    2178:	5f de       	rcall	.-834    	; 0x1e38 <vPortYield>
    217a:	06 c0       	rjmp	.+12     	; 0x2188 <xQueueGenericReset+0x66>
    217c:	ce 01       	movw	r24, r28
    217e:	08 96       	adiw	r24, 0x08	; 8
    2180:	30 dd       	rcall	.-1440   	; 0x1be2 <vListInitialise>
    2182:	ce 01       	movw	r24, r28
    2184:	41 96       	adiw	r24, 0x11	; 17
    2186:	2d dd       	rcall	.-1446   	; 0x1be2 <vListInitialise>
    2188:	0f 90       	pop	r0
    218a:	0f be       	out	0x3f, r0	; 63
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	df 91       	pop	r29
    2190:	cf 91       	pop	r28
    2192:	08 95       	ret

00002194 <xQueueGenericCreate>:
    2194:	0f 93       	push	r16
    2196:	1f 93       	push	r17
    2198:	cf 93       	push	r28
    219a:	df 93       	push	r29
    219c:	08 2f       	mov	r16, r24
    219e:	16 2f       	mov	r17, r22
    21a0:	66 23       	and	r22, r22
    21a2:	b1 f0       	breq	.+44     	; 0x21d0 <xQueueGenericCreate+0x3c>
    21a4:	86 9f       	mul	r24, r22
    21a6:	c0 01       	movw	r24, r0
    21a8:	11 24       	eor	r1, r1
    21aa:	4f 96       	adiw	r24, 0x1f	; 31
    21ac:	e6 dc       	rcall	.-1588   	; 0x1b7a <pvPortMalloc>
    21ae:	ec 01       	movw	r28, r24
    21b0:	00 97       	sbiw	r24, 0x00	; 0
    21b2:	39 f4       	brne	.+14     	; 0x21c2 <xQueueGenericCreate+0x2e>
    21b4:	13 c0       	rjmp	.+38     	; 0x21dc <xQueueGenericCreate+0x48>
    21b6:	0b 8f       	std	Y+27, r16	; 0x1b
    21b8:	1c 8f       	std	Y+28, r17	; 0x1c
    21ba:	61 e0       	ldi	r22, 0x01	; 1
    21bc:	ce 01       	movw	r24, r28
    21be:	b1 df       	rcall	.-158    	; 0x2122 <xQueueGenericReset>
    21c0:	0d c0       	rjmp	.+26     	; 0x21dc <xQueueGenericCreate+0x48>
    21c2:	4f 96       	adiw	r24, 0x1f	; 31
    21c4:	99 83       	std	Y+1, r25	; 0x01
    21c6:	88 83       	st	Y, r24
    21c8:	f6 cf       	rjmp	.-20     	; 0x21b6 <xQueueGenericCreate+0x22>
    21ca:	d9 83       	std	Y+1, r29	; 0x01
    21cc:	c8 83       	st	Y, r28
    21ce:	f3 cf       	rjmp	.-26     	; 0x21b6 <xQueueGenericCreate+0x22>
    21d0:	8f e1       	ldi	r24, 0x1F	; 31
    21d2:	90 e0       	ldi	r25, 0x00	; 0
    21d4:	d2 dc       	rcall	.-1628   	; 0x1b7a <pvPortMalloc>
    21d6:	ec 01       	movw	r28, r24
    21d8:	89 2b       	or	r24, r25
    21da:	b9 f7       	brne	.-18     	; 0x21ca <xQueueGenericCreate+0x36>
    21dc:	ce 01       	movw	r24, r28
    21de:	df 91       	pop	r29
    21e0:	cf 91       	pop	r28
    21e2:	1f 91       	pop	r17
    21e4:	0f 91       	pop	r16
    21e6:	08 95       	ret

000021e8 <xQueueGenericSend>:
    21e8:	9f 92       	push	r9
    21ea:	af 92       	push	r10
    21ec:	bf 92       	push	r11
    21ee:	cf 92       	push	r12
    21f0:	df 92       	push	r13
    21f2:	ef 92       	push	r14
    21f4:	ff 92       	push	r15
    21f6:	0f 93       	push	r16
    21f8:	1f 93       	push	r17
    21fa:	cf 93       	push	r28
    21fc:	df 93       	push	r29
    21fe:	00 d0       	rcall	.+0      	; 0x2200 <xQueueGenericSend+0x18>
    2200:	00 d0       	rcall	.+0      	; 0x2202 <xQueueGenericSend+0x1a>
    2202:	1f 92       	push	r1
    2204:	cd b7       	in	r28, 0x3d	; 61
    2206:	de b7       	in	r29, 0x3e	; 62
    2208:	8c 01       	movw	r16, r24
    220a:	6b 01       	movw	r12, r22
    220c:	5d 83       	std	Y+5, r21	; 0x05
    220e:	4c 83       	std	Y+4, r20	; 0x04
    2210:	a2 2e       	mov	r10, r18
    2212:	b1 2c       	mov	r11, r1
    2214:	99 24       	eor	r9, r9
    2216:	93 94       	inc	r9
    2218:	7c 01       	movw	r14, r24
    221a:	88 e0       	ldi	r24, 0x08	; 8
    221c:	e8 0e       	add	r14, r24
    221e:	f1 1c       	adc	r15, r1
    2220:	0f b6       	in	r0, 0x3f	; 63
    2222:	f8 94       	cli
    2224:	0f 92       	push	r0
    2226:	f8 01       	movw	r30, r16
    2228:	92 8d       	ldd	r25, Z+26	; 0x1a
    222a:	83 8d       	ldd	r24, Z+27	; 0x1b
    222c:	98 17       	cp	r25, r24
    222e:	18 f0       	brcs	.+6      	; 0x2236 <xQueueGenericSend+0x4e>
    2230:	f2 e0       	ldi	r31, 0x02	; 2
    2232:	af 12       	cpse	r10, r31
    2234:	15 c0       	rjmp	.+42     	; 0x2260 <xQueueGenericSend+0x78>
    2236:	4a 2d       	mov	r20, r10
    2238:	b6 01       	movw	r22, r12
    223a:	c8 01       	movw	r24, r16
    223c:	b1 de       	rcall	.-670    	; 0x1fa0 <prvCopyDataToQueue>
    223e:	f8 01       	movw	r30, r16
    2240:	91 89       	ldd	r25, Z+17	; 0x11
    2242:	99 23       	and	r25, r25
    2244:	39 f0       	breq	.+14     	; 0x2254 <xQueueGenericSend+0x6c>
    2246:	c8 01       	movw	r24, r16
    2248:	41 96       	adiw	r24, 0x11	; 17
    224a:	d8 d4       	rcall	.+2480   	; 0x2bfc <xTaskRemoveFromEventList>
    224c:	88 23       	and	r24, r24
    224e:	21 f0       	breq	.+8      	; 0x2258 <xQueueGenericSend+0x70>
    2250:	f3 dd       	rcall	.-1050   	; 0x1e38 <vPortYield>
    2252:	02 c0       	rjmp	.+4      	; 0x2258 <xQueueGenericSend+0x70>
    2254:	81 11       	cpse	r24, r1
    2256:	f0 dd       	rcall	.-1056   	; 0x1e38 <vPortYield>
    2258:	0f 90       	pop	r0
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	81 e0       	ldi	r24, 0x01	; 1
    225e:	45 c0       	rjmp	.+138    	; 0x22ea <xQueueGenericSend+0x102>
    2260:	8c 81       	ldd	r24, Y+4	; 0x04
    2262:	9d 81       	ldd	r25, Y+5	; 0x05
    2264:	89 2b       	or	r24, r25
    2266:	21 f4       	brne	.+8      	; 0x2270 <xQueueGenericSend+0x88>
    2268:	0f 90       	pop	r0
    226a:	0f be       	out	0x3f, r0	; 63
    226c:	80 e0       	ldi	r24, 0x00	; 0
    226e:	3d c0       	rjmp	.+122    	; 0x22ea <xQueueGenericSend+0x102>
    2270:	b1 10       	cpse	r11, r1
    2272:	04 c0       	rjmp	.+8      	; 0x227c <xQueueGenericSend+0x94>
    2274:	ce 01       	movw	r24, r28
    2276:	01 96       	adiw	r24, 0x01	; 1
    2278:	07 d5       	rcall	.+2574   	; 0x2c88 <vTaskSetTimeOutState>
    227a:	b9 2c       	mov	r11, r9
    227c:	0f 90       	pop	r0
    227e:	0f be       	out	0x3f, r0	; 63
    2280:	b0 d2       	rcall	.+1376   	; 0x27e2 <vTaskSuspendAll>
    2282:	0f b6       	in	r0, 0x3f	; 63
    2284:	f8 94       	cli
    2286:	0f 92       	push	r0
    2288:	f8 01       	movw	r30, r16
    228a:	85 8d       	ldd	r24, Z+29	; 0x1d
    228c:	8f 3f       	cpi	r24, 0xFF	; 255
    228e:	09 f4       	brne	.+2      	; 0x2292 <xQueueGenericSend+0xaa>
    2290:	15 8e       	std	Z+29, r1	; 0x1d
    2292:	f8 01       	movw	r30, r16
    2294:	86 8d       	ldd	r24, Z+30	; 0x1e
    2296:	8f 3f       	cpi	r24, 0xFF	; 255
    2298:	09 f4       	brne	.+2      	; 0x229c <xQueueGenericSend+0xb4>
    229a:	16 8e       	std	Z+30, r1	; 0x1e
    229c:	0f 90       	pop	r0
    229e:	0f be       	out	0x3f, r0	; 63
    22a0:	be 01       	movw	r22, r28
    22a2:	6c 5f       	subi	r22, 0xFC	; 252
    22a4:	7f 4f       	sbci	r23, 0xFF	; 255
    22a6:	ce 01       	movw	r24, r28
    22a8:	01 96       	adiw	r24, 0x01	; 1
    22aa:	f9 d4       	rcall	.+2546   	; 0x2c9e <xTaskCheckForTimeOut>
    22ac:	81 11       	cpse	r24, r1
    22ae:	19 c0       	rjmp	.+50     	; 0x22e2 <xQueueGenericSend+0xfa>
    22b0:	0f b6       	in	r0, 0x3f	; 63
    22b2:	f8 94       	cli
    22b4:	0f 92       	push	r0
    22b6:	f8 01       	movw	r30, r16
    22b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    22ba:	0f 90       	pop	r0
    22bc:	0f be       	out	0x3f, r0	; 63
    22be:	83 8d       	ldd	r24, Z+27	; 0x1b
    22c0:	98 13       	cpse	r25, r24
    22c2:	0b c0       	rjmp	.+22     	; 0x22da <xQueueGenericSend+0xf2>
    22c4:	6c 81       	ldd	r22, Y+4	; 0x04
    22c6:	7d 81       	ldd	r23, Y+5	; 0x05
    22c8:	c7 01       	movw	r24, r14
    22ca:	88 d4       	rcall	.+2320   	; 0x2bdc <vTaskPlaceOnEventList>
    22cc:	c8 01       	movw	r24, r16
    22ce:	e0 de       	rcall	.-576    	; 0x2090 <prvUnlockQueue>
    22d0:	45 d3       	rcall	.+1674   	; 0x295c <xTaskResumeAll>
    22d2:	81 11       	cpse	r24, r1
    22d4:	a5 cf       	rjmp	.-182    	; 0x2220 <xQueueGenericSend+0x38>
    22d6:	b0 dd       	rcall	.-1184   	; 0x1e38 <vPortYield>
    22d8:	a3 cf       	rjmp	.-186    	; 0x2220 <xQueueGenericSend+0x38>
    22da:	c8 01       	movw	r24, r16
    22dc:	d9 de       	rcall	.-590    	; 0x2090 <prvUnlockQueue>
    22de:	3e d3       	rcall	.+1660   	; 0x295c <xTaskResumeAll>
    22e0:	9f cf       	rjmp	.-194    	; 0x2220 <xQueueGenericSend+0x38>
    22e2:	c8 01       	movw	r24, r16
    22e4:	d5 de       	rcall	.-598    	; 0x2090 <prvUnlockQueue>
    22e6:	3a d3       	rcall	.+1652   	; 0x295c <xTaskResumeAll>
    22e8:	80 e0       	ldi	r24, 0x00	; 0
    22ea:	0f 90       	pop	r0
    22ec:	0f 90       	pop	r0
    22ee:	0f 90       	pop	r0
    22f0:	0f 90       	pop	r0
    22f2:	0f 90       	pop	r0
    22f4:	df 91       	pop	r29
    22f6:	cf 91       	pop	r28
    22f8:	1f 91       	pop	r17
    22fa:	0f 91       	pop	r16
    22fc:	ff 90       	pop	r15
    22fe:	ef 90       	pop	r14
    2300:	df 90       	pop	r13
    2302:	cf 90       	pop	r12
    2304:	bf 90       	pop	r11
    2306:	af 90       	pop	r10
    2308:	9f 90       	pop	r9
    230a:	08 95       	ret

0000230c <xQueueCreateMutex>:
    230c:	cf 93       	push	r28
    230e:	df 93       	push	r29
    2310:	48 2f       	mov	r20, r24
    2312:	60 e0       	ldi	r22, 0x00	; 0
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	3e df       	rcall	.-388    	; 0x2194 <xQueueGenericCreate>
    2318:	ec 01       	movw	r28, r24
    231a:	00 97       	sbiw	r24, 0x00	; 0
    231c:	59 f0       	breq	.+22     	; 0x2334 <xQueueCreateMutex+0x28>
    231e:	1b 82       	std	Y+3, r1	; 0x03
    2320:	1a 82       	std	Y+2, r1	; 0x02
    2322:	19 82       	std	Y+1, r1	; 0x01
    2324:	18 82       	st	Y, r1
    2326:	1e 82       	std	Y+6, r1	; 0x06
    2328:	20 e0       	ldi	r18, 0x00	; 0
    232a:	40 e0       	ldi	r20, 0x00	; 0
    232c:	50 e0       	ldi	r21, 0x00	; 0
    232e:	60 e0       	ldi	r22, 0x00	; 0
    2330:	70 e0       	ldi	r23, 0x00	; 0
    2332:	5a df       	rcall	.-332    	; 0x21e8 <xQueueGenericSend>
    2334:	ce 01       	movw	r24, r28
    2336:	df 91       	pop	r29
    2338:	cf 91       	pop	r28
    233a:	08 95       	ret

0000233c <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    233c:	8f 92       	push	r8
    233e:	9f 92       	push	r9
    2340:	af 92       	push	r10
    2342:	bf 92       	push	r11
    2344:	cf 92       	push	r12
    2346:	df 92       	push	r13
    2348:	ef 92       	push	r14
    234a:	ff 92       	push	r15
    234c:	0f 93       	push	r16
    234e:	1f 93       	push	r17
    2350:	cf 93       	push	r28
    2352:	df 93       	push	r29
    2354:	00 d0       	rcall	.+0      	; 0x2356 <xQueueGenericReceive+0x1a>
    2356:	00 d0       	rcall	.+0      	; 0x2358 <xQueueGenericReceive+0x1c>
    2358:	1f 92       	push	r1
    235a:	cd b7       	in	r28, 0x3d	; 61
    235c:	de b7       	in	r29, 0x3e	; 62
    235e:	8c 01       	movw	r16, r24
    2360:	5b 01       	movw	r10, r22
    2362:	5d 83       	std	Y+5, r21	; 0x05
    2364:	4c 83       	std	Y+4, r20	; 0x04
    2366:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2368:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    236a:	99 24       	eor	r9, r9
    236c:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    236e:	6c 01       	movw	r12, r24
    2370:	81 e1       	ldi	r24, 0x11	; 17
    2372:	c8 0e       	add	r12, r24
    2374:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2376:	0f b6       	in	r0, 0x3f	; 63
    2378:	f8 94       	cli
    237a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    237c:	f8 01       	movw	r30, r16
    237e:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2380:	ff 20       	and	r15, r15
    2382:	61 f1       	breq	.+88     	; 0x23dc <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2384:	c6 80       	ldd	r12, Z+6	; 0x06
    2386:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2388:	b5 01       	movw	r22, r10
    238a:	c8 01       	movw	r24, r16
    238c:	67 de       	rcall	.-818    	; 0x205c <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    238e:	81 10       	cpse	r8, r1
    2390:	16 c0       	rjmp	.+44     	; 0x23be <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    2392:	fa 94       	dec	r15
    2394:	f8 01       	movw	r30, r16
    2396:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2398:	80 81       	ld	r24, Z
    239a:	91 81       	ldd	r25, Z+1	; 0x01
    239c:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    239e:	21 f4       	brne	.+8      	; 0x23a8 <xQueueGenericReceive+0x6c>
    23a0:	5c d5       	rcall	.+2744   	; 0x2e5a <pvTaskIncrementMutexHeldCount>
    23a2:	f8 01       	movw	r30, r16
    23a4:	93 83       	std	Z+3, r25	; 0x03
    23a6:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    23a8:	f8 01       	movw	r30, r16
    23aa:	80 85       	ldd	r24, Z+8	; 0x08
    23ac:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    23ae:	91 f0       	breq	.+36     	; 0x23d4 <xQueueGenericReceive+0x98>
    23b0:	c8 01       	movw	r24, r16
    23b2:	08 96       	adiw	r24, 0x08	; 8
    23b4:	23 d4       	rcall	.+2118   	; 0x2bfc <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    23b6:	88 23       	and	r24, r24
    23b8:	69 f0       	breq	.+26     	; 0x23d4 <xQueueGenericReceive+0x98>
    23ba:	3e dd       	rcall	.-1412   	; 0x1e38 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    23bc:	0b c0       	rjmp	.+22     	; 0x23d4 <xQueueGenericReceive+0x98>
    23be:	f8 01       	movw	r30, r16
    23c0:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    23c2:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    23c4:	81 89       	ldd	r24, Z+17	; 0x11
    23c6:	88 23       	and	r24, r24
    23c8:	29 f0       	breq	.+10     	; 0x23d4 <xQueueGenericReceive+0x98>
    23ca:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    23cc:	41 96       	adiw	r24, 0x11	; 17
    23ce:	16 d4       	rcall	.+2092   	; 0x2bfc <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    23d0:	81 11       	cpse	r24, r1
    23d2:	32 dd       	rcall	.-1436   	; 0x1e38 <vPortYield>
				return pdPASS;
    23d4:	0f 90       	pop	r0
    23d6:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    23d8:	81 e0       	ldi	r24, 0x01	; 1
    23da:	58 c0       	rjmp	.+176    	; 0x248c <xQueueGenericReceive+0x150>
    23dc:	8c 81       	ldd	r24, Y+4	; 0x04
    23de:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    23e0:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    23e2:	21 f4       	brne	.+8      	; 0x23ec <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    23e4:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    23e6:	0f be       	out	0x3f, r0	; 63
    23e8:	80 e0       	ldi	r24, 0x00	; 0
    23ea:	50 c0       	rjmp	.+160    	; 0x248c <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    23ec:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    23ee:	04 c0       	rjmp	.+8      	; 0x23f8 <xQueueGenericReceive+0xbc>
    23f0:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    23f2:	01 96       	adiw	r24, 0x01	; 1
    23f4:	49 d4       	rcall	.+2194   	; 0x2c88 <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    23f6:	e9 2c       	mov	r14, r9
    23f8:	0f 90       	pop	r0
    23fa:	0f be       	out	0x3f, r0	; 63
    23fc:	f2 d1       	rcall	.+996    	; 0x27e2 <vTaskSuspendAll>
    23fe:	0f b6       	in	r0, 0x3f	; 63
    2400:	f8 94       	cli
    2402:	0f 92       	push	r0
    2404:	f8 01       	movw	r30, r16
    2406:	85 8d       	ldd	r24, Z+29	; 0x1d
    2408:	8f 3f       	cpi	r24, 0xFF	; 255
    240a:	09 f4       	brne	.+2      	; 0x240e <xQueueGenericReceive+0xd2>
    240c:	15 8e       	std	Z+29, r1	; 0x1d
    240e:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2410:	86 8d       	ldd	r24, Z+30	; 0x1e
    2412:	8f 3f       	cpi	r24, 0xFF	; 255
    2414:	09 f4       	brne	.+2      	; 0x2418 <xQueueGenericReceive+0xdc>
    2416:	16 8e       	std	Z+30, r1	; 0x1e
    2418:	0f 90       	pop	r0
    241a:	0f be       	out	0x3f, r0	; 63
    241c:	be 01       	movw	r22, r28
    241e:	6c 5f       	subi	r22, 0xFC	; 252
    2420:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2422:	ce 01       	movw	r24, r28
    2424:	01 96       	adiw	r24, 0x01	; 1
    2426:	3b d4       	rcall	.+2166   	; 0x2c9e <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2428:	81 11       	cpse	r24, r1
    242a:	24 c0       	rjmp	.+72     	; 0x2474 <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    242c:	0f b6       	in	r0, 0x3f	; 63
    242e:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2430:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2432:	f8 01       	movw	r30, r16
    2434:	82 8d       	ldd	r24, Z+26	; 0x1a
    2436:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    2438:	0f be       	out	0x3f, r0	; 63
    243a:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    243c:	17 c0       	rjmp	.+46     	; 0x246c <xQueueGenericReceive+0x130>
    243e:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    2440:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2442:	89 2b       	or	r24, r25
    2444:	41 f4       	brne	.+16     	; 0x2456 <xQueueGenericReceive+0x11a>
    2446:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    2448:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    244a:	0f 92       	push	r0
    244c:	82 81       	ldd	r24, Z+2	; 0x02
    244e:	93 81       	ldd	r25, Z+3	; 0x03
    2450:	62 d4       	rcall	.+2244   	; 0x2d16 <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    2452:	0f 90       	pop	r0
    2454:	0f be       	out	0x3f, r0	; 63
    2456:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2458:	7d 81       	ldd	r23, Y+5	; 0x05
    245a:	c6 01       	movw	r24, r12
    245c:	bf d3       	rcall	.+1918   	; 0x2bdc <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    245e:	c8 01       	movw	r24, r16
    2460:	17 de       	rcall	.-978    	; 0x2090 <prvUnlockQueue>
    2462:	7c d2       	rcall	.+1272   	; 0x295c <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2464:	81 11       	cpse	r24, r1
    2466:	87 cf       	rjmp	.-242    	; 0x2376 <xQueueGenericReceive+0x3a>
    2468:	e7 dc       	rcall	.-1586   	; 0x1e38 <vPortYield>
			( void ) xTaskResumeAll();
    246a:	85 cf       	rjmp	.-246    	; 0x2376 <xQueueGenericReceive+0x3a>
    246c:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    246e:	10 de       	rcall	.-992    	; 0x2090 <prvUnlockQueue>
    2470:	75 d2       	rcall	.+1258   	; 0x295c <xTaskResumeAll>
    2472:	81 cf       	rjmp	.-254    	; 0x2376 <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2474:	c8 01       	movw	r24, r16
    2476:	0c de       	rcall	.-1000   	; 0x2090 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2478:	71 d2       	rcall	.+1250   	; 0x295c <xTaskResumeAll>
    247a:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    247c:	f8 94       	cli
    247e:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    2480:	f8 01       	movw	r30, r16
    2482:	82 8d       	ldd	r24, Z+26	; 0x1a
    2484:	0f 90       	pop	r0
    2486:	0f be       	out	0x3f, r0	; 63
    2488:	81 11       	cpse	r24, r1
    248a:	75 cf       	rjmp	.-278    	; 0x2376 <xQueueGenericReceive+0x3a>
    248c:	0f 90       	pop	r0
    248e:	0f 90       	pop	r0
    2490:	0f 90       	pop	r0
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	df 91       	pop	r29
    2498:	cf 91       	pop	r28
    249a:	1f 91       	pop	r17
    249c:	0f 91       	pop	r16
    249e:	ff 90       	pop	r15
    24a0:	ef 90       	pop	r14
    24a2:	df 90       	pop	r13
    24a4:	cf 90       	pop	r12
    24a6:	bf 90       	pop	r11
    24a8:	af 90       	pop	r10
    24aa:	9f 90       	pop	r9
    24ac:	8f 90       	pop	r8
    24ae:	08 95       	ret

000024b0 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    24b0:	e0 91 6e 0c 	lds	r30, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    24b4:	f0 91 6f 0c 	lds	r31, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    24b8:	80 81       	ld	r24, Z
    24ba:	81 11       	cpse	r24, r1
    24bc:	07 c0       	rjmp	.+14     	; 0x24cc <prvResetNextTaskUnblockTime+0x1c>
    24be:	8f ef       	ldi	r24, 0xFF	; 255
    24c0:	9f ef       	ldi	r25, 0xFF	; 255
    24c2:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <xNextTaskUnblockTime+0x1>
    24c6:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <xNextTaskUnblockTime>
    24ca:	08 95       	ret
    24cc:	e0 91 6e 0c 	lds	r30, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    24d0:	f0 91 6f 0c 	lds	r31, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    24d4:	05 80       	ldd	r0, Z+5	; 0x05
    24d6:	f6 81       	ldd	r31, Z+6	; 0x06
    24d8:	e0 2d       	mov	r30, r0
    24da:	06 80       	ldd	r0, Z+6	; 0x06
    24dc:	f7 81       	ldd	r31, Z+7	; 0x07
    24de:	e0 2d       	mov	r30, r0
    24e0:	82 81       	ldd	r24, Z+2	; 0x02
    24e2:	93 81       	ldd	r25, Z+3	; 0x03
    24e4:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <xNextTaskUnblockTime+0x1>
    24e8:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <xNextTaskUnblockTime>
    24ec:	08 95       	ret

000024ee <prvAddCurrentTaskToDelayedList>:
    24ee:	ff 92       	push	r15
    24f0:	0f 93       	push	r16
    24f2:	1f 93       	push	r17
    24f4:	cf 93       	push	r28
    24f6:	df 93       	push	r29
    24f8:	ec 01       	movw	r28, r24
    24fa:	f6 2e       	mov	r15, r22
    24fc:	00 91 4d 0c 	lds	r16, 0x0C4D	; 0x800c4d <xTickCount>
    2500:	10 91 4e 0c 	lds	r17, 0x0C4E	; 0x800c4e <xTickCount+0x1>
    2504:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2508:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    250c:	02 96       	adiw	r24, 0x02	; 2
    250e:	cd db       	rcall	.-2150   	; 0x1caa <uxListRemove>
    2510:	cf 3f       	cpi	r28, 0xFF	; 255
    2512:	8f ef       	ldi	r24, 0xFF	; 255
    2514:	d8 07       	cpc	r29, r24
    2516:	61 f4       	brne	.+24     	; 0x2530 <prvAddCurrentTaskToDelayedList+0x42>
    2518:	ff 20       	and	r15, r15
    251a:	51 f0       	breq	.+20     	; 0x2530 <prvAddCurrentTaskToDelayedList+0x42>
    251c:	60 91 a6 0c 	lds	r22, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2520:	70 91 a7 0c 	lds	r23, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2524:	6e 5f       	subi	r22, 0xFE	; 254
    2526:	7f 4f       	sbci	r23, 0xFF	; 255
    2528:	80 e5       	ldi	r24, 0x50	; 80
    252a:	9c e0       	ldi	r25, 0x0C	; 12
    252c:	6c db       	rcall	.-2344   	; 0x1c06 <vListInsertEnd>
    252e:	2d c0       	rjmp	.+90     	; 0x258a <prvAddCurrentTaskToDelayedList+0x9c>
    2530:	c0 0f       	add	r28, r16
    2532:	d1 1f       	adc	r29, r17
    2534:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2538:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    253c:	d3 83       	std	Z+3, r29	; 0x03
    253e:	c2 83       	std	Z+2, r28	; 0x02
    2540:	c0 17       	cp	r28, r16
    2542:	d1 07       	cpc	r29, r17
    2544:	60 f4       	brcc	.+24     	; 0x255e <prvAddCurrentTaskToDelayedList+0x70>
    2546:	60 91 a6 0c 	lds	r22, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    254a:	70 91 a7 0c 	lds	r23, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    254e:	80 91 6c 0c 	lds	r24, 0x0C6C	; 0x800c6c <pxOverflowDelayedTaskList>
    2552:	90 91 6d 0c 	lds	r25, 0x0C6D	; 0x800c6d <pxOverflowDelayedTaskList+0x1>
    2556:	6e 5f       	subi	r22, 0xFE	; 254
    2558:	7f 4f       	sbci	r23, 0xFF	; 255
    255a:	76 db       	rcall	.-2324   	; 0x1c48 <vListInsert>
    255c:	16 c0       	rjmp	.+44     	; 0x258a <prvAddCurrentTaskToDelayedList+0x9c>
    255e:	60 91 a6 0c 	lds	r22, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2562:	70 91 a7 0c 	lds	r23, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2566:	80 91 6e 0c 	lds	r24, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    256a:	90 91 6f 0c 	lds	r25, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    256e:	6e 5f       	subi	r22, 0xFE	; 254
    2570:	7f 4f       	sbci	r23, 0xFF	; 255
    2572:	6a db       	rcall	.-2348   	; 0x1c48 <vListInsert>
    2574:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <xNextTaskUnblockTime>
    2578:	90 91 46 0c 	lds	r25, 0x0C46	; 0x800c46 <xNextTaskUnblockTime+0x1>
    257c:	c8 17       	cp	r28, r24
    257e:	d9 07       	cpc	r29, r25
    2580:	20 f4       	brcc	.+8      	; 0x258a <prvAddCurrentTaskToDelayedList+0x9c>
    2582:	d0 93 46 0c 	sts	0x0C46, r29	; 0x800c46 <xNextTaskUnblockTime+0x1>
    2586:	c0 93 45 0c 	sts	0x0C45, r28	; 0x800c45 <xNextTaskUnblockTime>
    258a:	df 91       	pop	r29
    258c:	cf 91       	pop	r28
    258e:	1f 91       	pop	r17
    2590:	0f 91       	pop	r16
    2592:	ff 90       	pop	r15
    2594:	08 95       	ret

00002596 <xTaskCreate>:
    2596:	4f 92       	push	r4
    2598:	5f 92       	push	r5
    259a:	6f 92       	push	r6
    259c:	7f 92       	push	r7
    259e:	8f 92       	push	r8
    25a0:	9f 92       	push	r9
    25a2:	af 92       	push	r10
    25a4:	bf 92       	push	r11
    25a6:	cf 92       	push	r12
    25a8:	df 92       	push	r13
    25aa:	ef 92       	push	r14
    25ac:	ff 92       	push	r15
    25ae:	0f 93       	push	r16
    25b0:	cf 93       	push	r28
    25b2:	df 93       	push	r29
    25b4:	4c 01       	movw	r8, r24
    25b6:	6b 01       	movw	r12, r22
    25b8:	5a 01       	movw	r10, r20
    25ba:	29 01       	movw	r4, r18
    25bc:	ca 01       	movw	r24, r20
    25be:	dd da       	rcall	.-2630   	; 0x1b7a <pvPortMalloc>
    25c0:	3c 01       	movw	r6, r24
    25c2:	89 2b       	or	r24, r25
    25c4:	09 f4       	brne	.+2      	; 0x25c8 <xTaskCreate+0x32>
    25c6:	d4 c0       	rjmp	.+424    	; 0x2770 <xTaskCreate+0x1da>
    25c8:	88 e2       	ldi	r24, 0x28	; 40
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	d6 da       	rcall	.-2644   	; 0x1b7a <pvPortMalloc>
    25ce:	ec 01       	movw	r28, r24
    25d0:	89 2b       	or	r24, r25
    25d2:	71 f0       	breq	.+28     	; 0x25f0 <xTaskCreate+0x5a>
    25d4:	78 8e       	std	Y+24, r7	; 0x18
    25d6:	6f 8a       	std	Y+23, r6	; 0x17
    25d8:	81 e0       	ldi	r24, 0x01	; 1
    25da:	a8 1a       	sub	r10, r24
    25dc:	b1 08       	sbc	r11, r1
    25de:	6a 0c       	add	r6, r10
    25e0:	7b 1c       	adc	r7, r11
    25e2:	d6 01       	movw	r26, r12
    25e4:	8c 91       	ld	r24, X
    25e6:	89 8f       	std	Y+25, r24	; 0x19
    25e8:	8c 91       	ld	r24, X
    25ea:	81 11       	cpse	r24, r1
    25ec:	04 c0       	rjmp	.+8      	; 0x25f6 <xTaskCreate+0x60>
    25ee:	17 c0       	rjmp	.+46     	; 0x261e <xTaskCreate+0x88>
    25f0:	c3 01       	movw	r24, r6
    25f2:	f6 da       	rcall	.-2580   	; 0x1be0 <vPortFree>
    25f4:	bd c0       	rjmp	.+378    	; 0x2770 <xTaskCreate+0x1da>
    25f6:	ae 01       	movw	r20, r28
    25f8:	46 5e       	subi	r20, 0xE6	; 230
    25fa:	5f 4f       	sbci	r21, 0xFF	; 255
    25fc:	f6 01       	movw	r30, r12
    25fe:	31 96       	adiw	r30, 0x01	; 1
    2600:	b8 e0       	ldi	r27, 0x08	; 8
    2602:	cb 0e       	add	r12, r27
    2604:	d1 1c       	adc	r13, r1
    2606:	cf 01       	movw	r24, r30
    2608:	21 91       	ld	r18, Z+
    260a:	da 01       	movw	r26, r20
    260c:	2d 93       	st	X+, r18
    260e:	ad 01       	movw	r20, r26
    2610:	dc 01       	movw	r26, r24
    2612:	8c 91       	ld	r24, X
    2614:	88 23       	and	r24, r24
    2616:	19 f0       	breq	.+6      	; 0x261e <xTaskCreate+0x88>
    2618:	ec 15       	cp	r30, r12
    261a:	fd 05       	cpc	r31, r13
    261c:	a1 f7       	brne	.-24     	; 0x2606 <xTaskCreate+0x70>
    261e:	18 a2       	std	Y+32, r1	; 0x20
    2620:	04 30       	cpi	r16, 0x04	; 4
    2622:	08 f0       	brcs	.+2      	; 0x2626 <xTaskCreate+0x90>
    2624:	03 e0       	ldi	r16, 0x03	; 3
    2626:	0e 8b       	std	Y+22, r16	; 0x16
    2628:	09 a3       	std	Y+33, r16	; 0x21
    262a:	1a a2       	std	Y+34, r1	; 0x22
    262c:	6e 01       	movw	r12, r28
    262e:	b2 e0       	ldi	r27, 0x02	; 2
    2630:	cb 0e       	add	r12, r27
    2632:	d1 1c       	adc	r13, r1
    2634:	c6 01       	movw	r24, r12
    2636:	e3 da       	rcall	.-2618   	; 0x1bfe <vListInitialiseItem>
    2638:	ce 01       	movw	r24, r28
    263a:	0c 96       	adiw	r24, 0x0c	; 12
    263c:	e0 da       	rcall	.-2624   	; 0x1bfe <vListInitialiseItem>
    263e:	d9 87       	std	Y+9, r29	; 0x09
    2640:	c8 87       	std	Y+8, r28	; 0x08
    2642:	84 e0       	ldi	r24, 0x04	; 4
    2644:	90 e0       	ldi	r25, 0x00	; 0
    2646:	80 1b       	sub	r24, r16
    2648:	91 09       	sbc	r25, r1
    264a:	9d 87       	std	Y+13, r25	; 0x0d
    264c:	8c 87       	std	Y+12, r24	; 0x0c
    264e:	db 8b       	std	Y+19, r29	; 0x13
    2650:	ca 8b       	std	Y+18, r28	; 0x12
    2652:	1b a2       	std	Y+35, r1	; 0x23
    2654:	1c a2       	std	Y+36, r1	; 0x24
    2656:	1d a2       	std	Y+37, r1	; 0x25
    2658:	1e a2       	std	Y+38, r1	; 0x26
    265a:	1f a2       	std	Y+39, r1	; 0x27
    265c:	a2 01       	movw	r20, r4
    265e:	b4 01       	movw	r22, r8
    2660:	c3 01       	movw	r24, r6
    2662:	49 db       	rcall	.-2414   	; 0x1cf6 <pxPortInitialiseStack>
    2664:	99 83       	std	Y+1, r25	; 0x01
    2666:	88 83       	st	Y, r24
    2668:	e1 14       	cp	r14, r1
    266a:	f1 04       	cpc	r15, r1
    266c:	19 f0       	breq	.+6      	; 0x2674 <xTaskCreate+0xde>
    266e:	f7 01       	movw	r30, r14
    2670:	d1 83       	std	Z+1, r29	; 0x01
    2672:	c0 83       	st	Z, r28
    2674:	0f b6       	in	r0, 0x3f	; 63
    2676:	f8 94       	cli
    2678:	0f 92       	push	r0
    267a:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <uxCurrentNumberOfTasks>
    267e:	8f 5f       	subi	r24, 0xFF	; 255
    2680:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <uxCurrentNumberOfTasks>
    2684:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2688:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    268c:	89 2b       	or	r24, r25
    268e:	89 f5       	brne	.+98     	; 0x26f2 <xTaskCreate+0x15c>
    2690:	d0 93 a7 0c 	sts	0x0CA7, r29	; 0x800ca7 <pxCurrentTCB+0x1>
    2694:	c0 93 a6 0c 	sts	0x0CA6, r28	; 0x800ca6 <pxCurrentTCB>
    2698:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <uxCurrentNumberOfTasks>
    269c:	81 30       	cpi	r24, 0x01	; 1
    269e:	09 f0       	breq	.+2      	; 0x26a2 <xTaskCreate+0x10c>
    26a0:	38 c0       	rjmp	.+112    	; 0x2712 <xTaskCreate+0x17c>
    26a2:	82 e8       	ldi	r24, 0x82	; 130
    26a4:	9c e0       	ldi	r25, 0x0C	; 12
    26a6:	9d da       	rcall	.-2758   	; 0x1be2 <vListInitialise>
    26a8:	8b e8       	ldi	r24, 0x8B	; 139
    26aa:	9c e0       	ldi	r25, 0x0C	; 12
    26ac:	9a da       	rcall	.-2764   	; 0x1be2 <vListInitialise>
    26ae:	84 e9       	ldi	r24, 0x94	; 148
    26b0:	9c e0       	ldi	r25, 0x0C	; 12
    26b2:	97 da       	rcall	.-2770   	; 0x1be2 <vListInitialise>
    26b4:	8d e9       	ldi	r24, 0x9D	; 157
    26b6:	9c e0       	ldi	r25, 0x0C	; 12
    26b8:	94 da       	rcall	.-2776   	; 0x1be2 <vListInitialise>
    26ba:	89 e7       	ldi	r24, 0x79	; 121
    26bc:	9c e0       	ldi	r25, 0x0C	; 12
    26be:	91 da       	rcall	.-2782   	; 0x1be2 <vListInitialise>
    26c0:	80 e7       	ldi	r24, 0x70	; 112
    26c2:	9c e0       	ldi	r25, 0x0C	; 12
    26c4:	8e da       	rcall	.-2788   	; 0x1be2 <vListInitialise>
    26c6:	83 e6       	ldi	r24, 0x63	; 99
    26c8:	9c e0       	ldi	r25, 0x0C	; 12
    26ca:	8b da       	rcall	.-2794   	; 0x1be2 <vListInitialise>
    26cc:	8a e5       	ldi	r24, 0x5A	; 90
    26ce:	9c e0       	ldi	r25, 0x0C	; 12
    26d0:	88 da       	rcall	.-2800   	; 0x1be2 <vListInitialise>
    26d2:	80 e5       	ldi	r24, 0x50	; 80
    26d4:	9c e0       	ldi	r25, 0x0C	; 12
    26d6:	85 da       	rcall	.-2806   	; 0x1be2 <vListInitialise>
    26d8:	89 e7       	ldi	r24, 0x79	; 121
    26da:	9c e0       	ldi	r25, 0x0C	; 12
    26dc:	90 93 6f 0c 	sts	0x0C6F, r25	; 0x800c6f <pxDelayedTaskList+0x1>
    26e0:	80 93 6e 0c 	sts	0x0C6E, r24	; 0x800c6e <pxDelayedTaskList>
    26e4:	80 e7       	ldi	r24, 0x70	; 112
    26e6:	9c e0       	ldi	r25, 0x0C	; 12
    26e8:	90 93 6d 0c 	sts	0x0C6D, r25	; 0x800c6d <pxOverflowDelayedTaskList+0x1>
    26ec:	80 93 6c 0c 	sts	0x0C6C, r24	; 0x800c6c <pxOverflowDelayedTaskList>
    26f0:	10 c0       	rjmp	.+32     	; 0x2712 <xTaskCreate+0x17c>
    26f2:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <xSchedulerRunning>
    26f6:	81 11       	cpse	r24, r1
    26f8:	0c c0       	rjmp	.+24     	; 0x2712 <xTaskCreate+0x17c>
    26fa:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    26fe:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2702:	96 89       	ldd	r25, Z+22	; 0x16
    2704:	8e 89       	ldd	r24, Y+22	; 0x16
    2706:	89 17       	cp	r24, r25
    2708:	20 f0       	brcs	.+8      	; 0x2712 <xTaskCreate+0x17c>
    270a:	d0 93 a7 0c 	sts	0x0CA7, r29	; 0x800ca7 <pxCurrentTCB+0x1>
    270e:	c0 93 a6 0c 	sts	0x0CA6, r28	; 0x800ca6 <pxCurrentTCB>
    2712:	80 91 47 0c 	lds	r24, 0x0C47	; 0x800c47 <uxTaskNumber>
    2716:	8f 5f       	subi	r24, 0xFF	; 255
    2718:	80 93 47 0c 	sts	0x0C47, r24	; 0x800c47 <uxTaskNumber>
    271c:	8e 89       	ldd	r24, Y+22	; 0x16
    271e:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    2722:	98 17       	cp	r25, r24
    2724:	10 f4       	brcc	.+4      	; 0x272a <xTaskCreate+0x194>
    2726:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	9c 01       	movw	r18, r24
    272e:	22 0f       	add	r18, r18
    2730:	33 1f       	adc	r19, r19
    2732:	22 0f       	add	r18, r18
    2734:	33 1f       	adc	r19, r19
    2736:	22 0f       	add	r18, r18
    2738:	33 1f       	adc	r19, r19
    273a:	82 0f       	add	r24, r18
    273c:	93 1f       	adc	r25, r19
    273e:	b6 01       	movw	r22, r12
    2740:	8e 57       	subi	r24, 0x7E	; 126
    2742:	93 4f       	sbci	r25, 0xF3	; 243
    2744:	60 da       	rcall	.-2880   	; 0x1c06 <vListInsertEnd>
    2746:	0f 90       	pop	r0
    2748:	0f be       	out	0x3f, r0	; 63
    274a:	80 91 4b 0c 	lds	r24, 0x0C4B	; 0x800c4b <xSchedulerRunning>
    274e:	88 23       	and	r24, r24
    2750:	59 f0       	breq	.+22     	; 0x2768 <xTaskCreate+0x1d2>
    2752:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2756:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    275a:	96 89       	ldd	r25, Z+22	; 0x16
    275c:	8e 89       	ldd	r24, Y+22	; 0x16
    275e:	98 17       	cp	r25, r24
    2760:	28 f4       	brcc	.+10     	; 0x276c <xTaskCreate+0x1d6>
    2762:	6a db       	rcall	.-2348   	; 0x1e38 <vPortYield>
    2764:	81 e0       	ldi	r24, 0x01	; 1
    2766:	05 c0       	rjmp	.+10     	; 0x2772 <xTaskCreate+0x1dc>
    2768:	81 e0       	ldi	r24, 0x01	; 1
    276a:	03 c0       	rjmp	.+6      	; 0x2772 <xTaskCreate+0x1dc>
    276c:	81 e0       	ldi	r24, 0x01	; 1
    276e:	01 c0       	rjmp	.+2      	; 0x2772 <xTaskCreate+0x1dc>
    2770:	8f ef       	ldi	r24, 0xFF	; 255
    2772:	df 91       	pop	r29
    2774:	cf 91       	pop	r28
    2776:	0f 91       	pop	r16
    2778:	ff 90       	pop	r15
    277a:	ef 90       	pop	r14
    277c:	df 90       	pop	r13
    277e:	cf 90       	pop	r12
    2780:	bf 90       	pop	r11
    2782:	af 90       	pop	r10
    2784:	9f 90       	pop	r9
    2786:	8f 90       	pop	r8
    2788:	7f 90       	pop	r7
    278a:	6f 90       	pop	r6
    278c:	5f 90       	pop	r5
    278e:	4f 90       	pop	r4
    2790:	08 95       	ret

00002792 <vTaskStartScheduler>:
    2792:	ef 92       	push	r14
    2794:	ff 92       	push	r15
    2796:	0f 93       	push	r16
    2798:	0f 2e       	mov	r0, r31
    279a:	f3 e4       	ldi	r31, 0x43	; 67
    279c:	ef 2e       	mov	r14, r31
    279e:	fc e0       	ldi	r31, 0x0C	; 12
    27a0:	ff 2e       	mov	r15, r31
    27a2:	f0 2d       	mov	r31, r0
    27a4:	00 e0       	ldi	r16, 0x00	; 0
    27a6:	20 e0       	ldi	r18, 0x00	; 0
    27a8:	30 e0       	ldi	r19, 0x00	; 0
    27aa:	45 e5       	ldi	r20, 0x55	; 85
    27ac:	50 e0       	ldi	r21, 0x00	; 0
    27ae:	66 ea       	ldi	r22, 0xA6	; 166
    27b0:	71 e0       	ldi	r23, 0x01	; 1
    27b2:	87 e3       	ldi	r24, 0x37	; 55
    27b4:	95 e1       	ldi	r25, 0x15	; 21
    27b6:	ef de       	rcall	.-546    	; 0x2596 <xTaskCreate>
    27b8:	81 30       	cpi	r24, 0x01	; 1
    27ba:	79 f4       	brne	.+30     	; 0x27da <vTaskStartScheduler+0x48>
    27bc:	f8 94       	cli
    27be:	8f ef       	ldi	r24, 0xFF	; 255
    27c0:	9f ef       	ldi	r25, 0xFF	; 255
    27c2:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <xNextTaskUnblockTime+0x1>
    27c6:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <xNextTaskUnblockTime>
    27ca:	81 e0       	ldi	r24, 0x01	; 1
    27cc:	80 93 4b 0c 	sts	0x0C4B, r24	; 0x800c4b <xSchedulerRunning>
    27d0:	10 92 4e 0c 	sts	0x0C4E, r1	; 0x800c4e <xTickCount+0x1>
    27d4:	10 92 4d 0c 	sts	0x0C4D, r1	; 0x800c4d <xTickCount>
    27d8:	fa da       	rcall	.-2572   	; 0x1dce <xPortStartScheduler>
    27da:	0f 91       	pop	r16
    27dc:	ff 90       	pop	r15
    27de:	ef 90       	pop	r14
    27e0:	08 95       	ret

000027e2 <vTaskSuspendAll>:
    27e2:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    27e6:	8f 5f       	subi	r24, 0xFF	; 255
    27e8:	80 93 42 0c 	sts	0x0C42, r24	; 0x800c42 <uxSchedulerSuspended>
    27ec:	08 95       	ret

000027ee <xTaskIncrementTick>:
    27ee:	cf 92       	push	r12
    27f0:	df 92       	push	r13
    27f2:	ef 92       	push	r14
    27f4:	ff 92       	push	r15
    27f6:	0f 93       	push	r16
    27f8:	1f 93       	push	r17
    27fa:	cf 93       	push	r28
    27fc:	df 93       	push	r29
    27fe:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    2802:	81 11       	cpse	r24, r1
    2804:	95 c0       	rjmp	.+298    	; 0x2930 <xTaskIncrementTick+0x142>
    2806:	e0 90 4d 0c 	lds	r14, 0x0C4D	; 0x800c4d <xTickCount>
    280a:	f0 90 4e 0c 	lds	r15, 0x0C4E	; 0x800c4e <xTickCount+0x1>
    280e:	8f ef       	ldi	r24, 0xFF	; 255
    2810:	e8 1a       	sub	r14, r24
    2812:	f8 0a       	sbc	r15, r24
    2814:	f0 92 4e 0c 	sts	0x0C4E, r15	; 0x800c4e <xTickCount+0x1>
    2818:	e0 92 4d 0c 	sts	0x0C4D, r14	; 0x800c4d <xTickCount>
    281c:	e1 14       	cp	r14, r1
    281e:	f1 04       	cpc	r15, r1
    2820:	b1 f4       	brne	.+44     	; 0x284e <xTaskIncrementTick+0x60>
    2822:	80 91 6e 0c 	lds	r24, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    2826:	90 91 6f 0c 	lds	r25, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    282a:	20 91 6c 0c 	lds	r18, 0x0C6C	; 0x800c6c <pxOverflowDelayedTaskList>
    282e:	30 91 6d 0c 	lds	r19, 0x0C6D	; 0x800c6d <pxOverflowDelayedTaskList+0x1>
    2832:	30 93 6f 0c 	sts	0x0C6F, r19	; 0x800c6f <pxDelayedTaskList+0x1>
    2836:	20 93 6e 0c 	sts	0x0C6E, r18	; 0x800c6e <pxDelayedTaskList>
    283a:	90 93 6d 0c 	sts	0x0C6D, r25	; 0x800c6d <pxOverflowDelayedTaskList+0x1>
    283e:	80 93 6c 0c 	sts	0x0C6C, r24	; 0x800c6c <pxOverflowDelayedTaskList>
    2842:	80 91 48 0c 	lds	r24, 0x0C48	; 0x800c48 <xNumOfOverflows>
    2846:	8f 5f       	subi	r24, 0xFF	; 255
    2848:	80 93 48 0c 	sts	0x0C48, r24	; 0x800c48 <xNumOfOverflows>
    284c:	31 de       	rcall	.-926    	; 0x24b0 <prvResetNextTaskUnblockTime>
    284e:	80 91 45 0c 	lds	r24, 0x0C45	; 0x800c45 <xNextTaskUnblockTime>
    2852:	90 91 46 0c 	lds	r25, 0x0C46	; 0x800c46 <xNextTaskUnblockTime+0x1>
    2856:	e8 16       	cp	r14, r24
    2858:	f9 06       	cpc	r15, r25
    285a:	10 f4       	brcc	.+4      	; 0x2860 <xTaskIncrementTick+0x72>
    285c:	d1 2c       	mov	r13, r1
    285e:	50 c0       	rjmp	.+160    	; 0x2900 <xTaskIncrementTick+0x112>
    2860:	d1 2c       	mov	r13, r1
    2862:	cc 24       	eor	r12, r12
    2864:	c3 94       	inc	r12
    2866:	e0 91 6e 0c 	lds	r30, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    286a:	f0 91 6f 0c 	lds	r31, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    286e:	80 81       	ld	r24, Z
    2870:	81 11       	cpse	r24, r1
    2872:	07 c0       	rjmp	.+14     	; 0x2882 <xTaskIncrementTick+0x94>
    2874:	8f ef       	ldi	r24, 0xFF	; 255
    2876:	9f ef       	ldi	r25, 0xFF	; 255
    2878:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <xNextTaskUnblockTime+0x1>
    287c:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <xNextTaskUnblockTime>
    2880:	3f c0       	rjmp	.+126    	; 0x2900 <xTaskIncrementTick+0x112>
    2882:	e0 91 6e 0c 	lds	r30, 0x0C6E	; 0x800c6e <pxDelayedTaskList>
    2886:	f0 91 6f 0c 	lds	r31, 0x0C6F	; 0x800c6f <pxDelayedTaskList+0x1>
    288a:	05 80       	ldd	r0, Z+5	; 0x05
    288c:	f6 81       	ldd	r31, Z+6	; 0x06
    288e:	e0 2d       	mov	r30, r0
    2890:	c6 81       	ldd	r28, Z+6	; 0x06
    2892:	d7 81       	ldd	r29, Z+7	; 0x07
    2894:	8a 81       	ldd	r24, Y+2	; 0x02
    2896:	9b 81       	ldd	r25, Y+3	; 0x03
    2898:	e8 16       	cp	r14, r24
    289a:	f9 06       	cpc	r15, r25
    289c:	28 f4       	brcc	.+10     	; 0x28a8 <xTaskIncrementTick+0xba>
    289e:	90 93 46 0c 	sts	0x0C46, r25	; 0x800c46 <xNextTaskUnblockTime+0x1>
    28a2:	80 93 45 0c 	sts	0x0C45, r24	; 0x800c45 <xNextTaskUnblockTime>
    28a6:	2c c0       	rjmp	.+88     	; 0x2900 <xTaskIncrementTick+0x112>
    28a8:	8e 01       	movw	r16, r28
    28aa:	0e 5f       	subi	r16, 0xFE	; 254
    28ac:	1f 4f       	sbci	r17, 0xFF	; 255
    28ae:	c8 01       	movw	r24, r16
    28b0:	fc d9       	rcall	.-3080   	; 0x1caa <uxListRemove>
    28b2:	8c 89       	ldd	r24, Y+20	; 0x14
    28b4:	9d 89       	ldd	r25, Y+21	; 0x15
    28b6:	89 2b       	or	r24, r25
    28b8:	19 f0       	breq	.+6      	; 0x28c0 <xTaskIncrementTick+0xd2>
    28ba:	ce 01       	movw	r24, r28
    28bc:	0c 96       	adiw	r24, 0x0c	; 12
    28be:	f5 d9       	rcall	.-3094   	; 0x1caa <uxListRemove>
    28c0:	8e 89       	ldd	r24, Y+22	; 0x16
    28c2:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    28c6:	98 17       	cp	r25, r24
    28c8:	10 f4       	brcc	.+4      	; 0x28ce <xTaskIncrementTick+0xe0>
    28ca:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    28ce:	90 e0       	ldi	r25, 0x00	; 0
    28d0:	9c 01       	movw	r18, r24
    28d2:	22 0f       	add	r18, r18
    28d4:	33 1f       	adc	r19, r19
    28d6:	22 0f       	add	r18, r18
    28d8:	33 1f       	adc	r19, r19
    28da:	22 0f       	add	r18, r18
    28dc:	33 1f       	adc	r19, r19
    28de:	82 0f       	add	r24, r18
    28e0:	93 1f       	adc	r25, r19
    28e2:	b8 01       	movw	r22, r16
    28e4:	8e 57       	subi	r24, 0x7E	; 126
    28e6:	93 4f       	sbci	r25, 0xF3	; 243
    28e8:	8e d9       	rcall	.-3300   	; 0x1c06 <vListInsertEnd>
    28ea:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    28ee:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    28f2:	9e 89       	ldd	r25, Y+22	; 0x16
    28f4:	86 89       	ldd	r24, Z+22	; 0x16
    28f6:	98 17       	cp	r25, r24
    28f8:	08 f4       	brcc	.+2      	; 0x28fc <xTaskIncrementTick+0x10e>
    28fa:	b5 cf       	rjmp	.-150    	; 0x2866 <xTaskIncrementTick+0x78>
    28fc:	dc 2c       	mov	r13, r12
    28fe:	b3 cf       	rjmp	.-154    	; 0x2866 <xTaskIncrementTick+0x78>
    2900:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2904:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2908:	86 89       	ldd	r24, Z+22	; 0x16
    290a:	90 e0       	ldi	r25, 0x00	; 0
    290c:	fc 01       	movw	r30, r24
    290e:	ee 0f       	add	r30, r30
    2910:	ff 1f       	adc	r31, r31
    2912:	ee 0f       	add	r30, r30
    2914:	ff 1f       	adc	r31, r31
    2916:	ee 0f       	add	r30, r30
    2918:	ff 1f       	adc	r31, r31
    291a:	8e 0f       	add	r24, r30
    291c:	9f 1f       	adc	r25, r31
    291e:	fc 01       	movw	r30, r24
    2920:	ee 57       	subi	r30, 0x7E	; 126
    2922:	f3 4f       	sbci	r31, 0xF3	; 243
    2924:	80 81       	ld	r24, Z
    2926:	82 30       	cpi	r24, 0x02	; 2
    2928:	48 f0       	brcs	.+18     	; 0x293c <xTaskIncrementTick+0x14e>
    292a:	dd 24       	eor	r13, r13
    292c:	d3 94       	inc	r13
    292e:	06 c0       	rjmp	.+12     	; 0x293c <xTaskIncrementTick+0x14e>
    2930:	80 91 4a 0c 	lds	r24, 0x0C4A	; 0x800c4a <uxPendedTicks>
    2934:	8f 5f       	subi	r24, 0xFF	; 255
    2936:	80 93 4a 0c 	sts	0x0C4A, r24	; 0x800c4a <uxPendedTicks>
    293a:	d1 2c       	mov	r13, r1
    293c:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <xYieldPending>
    2940:	88 23       	and	r24, r24
    2942:	11 f0       	breq	.+4      	; 0x2948 <xTaskIncrementTick+0x15a>
    2944:	dd 24       	eor	r13, r13
    2946:	d3 94       	inc	r13
    2948:	8d 2d       	mov	r24, r13
    294a:	df 91       	pop	r29
    294c:	cf 91       	pop	r28
    294e:	1f 91       	pop	r17
    2950:	0f 91       	pop	r16
    2952:	ff 90       	pop	r15
    2954:	ef 90       	pop	r14
    2956:	df 90       	pop	r13
    2958:	cf 90       	pop	r12
    295a:	08 95       	ret

0000295c <xTaskResumeAll>:
    295c:	df 92       	push	r13
    295e:	ef 92       	push	r14
    2960:	ff 92       	push	r15
    2962:	0f 93       	push	r16
    2964:	1f 93       	push	r17
    2966:	cf 93       	push	r28
    2968:	df 93       	push	r29
    296a:	0f b6       	in	r0, 0x3f	; 63
    296c:	f8 94       	cli
    296e:	0f 92       	push	r0
    2970:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    2974:	81 50       	subi	r24, 0x01	; 1
    2976:	80 93 42 0c 	sts	0x0C42, r24	; 0x800c42 <uxSchedulerSuspended>
    297a:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    297e:	81 11       	cpse	r24, r1
    2980:	59 c0       	rjmp	.+178    	; 0x2a34 <xTaskResumeAll+0xd8>
    2982:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <uxCurrentNumberOfTasks>
    2986:	81 11       	cpse	r24, r1
    2988:	30 c0       	rjmp	.+96     	; 0x29ea <xTaskResumeAll+0x8e>
    298a:	57 c0       	rjmp	.+174    	; 0x2a3a <xTaskResumeAll+0xde>
    298c:	d7 01       	movw	r26, r14
    298e:	15 96       	adiw	r26, 0x05	; 5
    2990:	ed 91       	ld	r30, X+
    2992:	fc 91       	ld	r31, X
    2994:	16 97       	sbiw	r26, 0x06	; 6
    2996:	c6 81       	ldd	r28, Z+6	; 0x06
    2998:	d7 81       	ldd	r29, Z+7	; 0x07
    299a:	ce 01       	movw	r24, r28
    299c:	0c 96       	adiw	r24, 0x0c	; 12
    299e:	85 d9       	rcall	.-3318   	; 0x1caa <uxListRemove>
    29a0:	8e 01       	movw	r16, r28
    29a2:	0e 5f       	subi	r16, 0xFE	; 254
    29a4:	1f 4f       	sbci	r17, 0xFF	; 255
    29a6:	c8 01       	movw	r24, r16
    29a8:	80 d9       	rcall	.-3328   	; 0x1caa <uxListRemove>
    29aa:	8e 89       	ldd	r24, Y+22	; 0x16
    29ac:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    29b0:	98 17       	cp	r25, r24
    29b2:	10 f4       	brcc	.+4      	; 0x29b8 <xTaskResumeAll+0x5c>
    29b4:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    29b8:	90 e0       	ldi	r25, 0x00	; 0
    29ba:	9c 01       	movw	r18, r24
    29bc:	22 0f       	add	r18, r18
    29be:	33 1f       	adc	r19, r19
    29c0:	22 0f       	add	r18, r18
    29c2:	33 1f       	adc	r19, r19
    29c4:	22 0f       	add	r18, r18
    29c6:	33 1f       	adc	r19, r19
    29c8:	82 0f       	add	r24, r18
    29ca:	93 1f       	adc	r25, r19
    29cc:	b8 01       	movw	r22, r16
    29ce:	8e 57       	subi	r24, 0x7E	; 126
    29d0:	93 4f       	sbci	r25, 0xF3	; 243
    29d2:	19 d9       	rcall	.-3534   	; 0x1c06 <vListInsertEnd>
    29d4:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    29d8:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    29dc:	9e 89       	ldd	r25, Y+22	; 0x16
    29de:	86 89       	ldd	r24, Z+22	; 0x16
    29e0:	98 17       	cp	r25, r24
    29e2:	68 f0       	brcs	.+26     	; 0x29fe <xTaskResumeAll+0xa2>
    29e4:	d0 92 49 0c 	sts	0x0C49, r13	; 0x800c49 <xYieldPending>
    29e8:	0a c0       	rjmp	.+20     	; 0x29fe <xTaskResumeAll+0xa2>
    29ea:	c0 e0       	ldi	r28, 0x00	; 0
    29ec:	d0 e0       	ldi	r29, 0x00	; 0
    29ee:	0f 2e       	mov	r0, r31
    29f0:	f3 e6       	ldi	r31, 0x63	; 99
    29f2:	ef 2e       	mov	r14, r31
    29f4:	fc e0       	ldi	r31, 0x0C	; 12
    29f6:	ff 2e       	mov	r15, r31
    29f8:	f0 2d       	mov	r31, r0
    29fa:	dd 24       	eor	r13, r13
    29fc:	d3 94       	inc	r13
    29fe:	f7 01       	movw	r30, r14
    2a00:	80 81       	ld	r24, Z
    2a02:	81 11       	cpse	r24, r1
    2a04:	c3 cf       	rjmp	.-122    	; 0x298c <xTaskResumeAll+0x30>
    2a06:	cd 2b       	or	r28, r29
    2a08:	09 f0       	breq	.+2      	; 0x2a0c <xTaskResumeAll+0xb0>
    2a0a:	52 dd       	rcall	.-1372   	; 0x24b0 <prvResetNextTaskUnblockTime>
    2a0c:	c0 91 4a 0c 	lds	r28, 0x0C4A	; 0x800c4a <uxPendedTicks>
    2a10:	cc 23       	and	r28, r28
    2a12:	49 f0       	breq	.+18     	; 0x2a26 <xTaskResumeAll+0xca>
    2a14:	d1 e0       	ldi	r29, 0x01	; 1
    2a16:	eb de       	rcall	.-554    	; 0x27ee <xTaskIncrementTick>
    2a18:	81 11       	cpse	r24, r1
    2a1a:	d0 93 49 0c 	sts	0x0C49, r29	; 0x800c49 <xYieldPending>
    2a1e:	c1 50       	subi	r28, 0x01	; 1
    2a20:	d1 f7       	brne	.-12     	; 0x2a16 <xTaskResumeAll+0xba>
    2a22:	10 92 4a 0c 	sts	0x0C4A, r1	; 0x800c4a <uxPendedTicks>
    2a26:	80 91 49 0c 	lds	r24, 0x0C49	; 0x800c49 <xYieldPending>
    2a2a:	88 23       	and	r24, r24
    2a2c:	29 f0       	breq	.+10     	; 0x2a38 <xTaskResumeAll+0xdc>
    2a2e:	04 da       	rcall	.-3064   	; 0x1e38 <vPortYield>
    2a30:	81 e0       	ldi	r24, 0x01	; 1
    2a32:	03 c0       	rjmp	.+6      	; 0x2a3a <xTaskResumeAll+0xde>
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	01 c0       	rjmp	.+2      	; 0x2a3a <xTaskResumeAll+0xde>
    2a38:	80 e0       	ldi	r24, 0x00	; 0
    2a3a:	0f 90       	pop	r0
    2a3c:	0f be       	out	0x3f, r0	; 63
    2a3e:	df 91       	pop	r29
    2a40:	cf 91       	pop	r28
    2a42:	1f 91       	pop	r17
    2a44:	0f 91       	pop	r16
    2a46:	ff 90       	pop	r15
    2a48:	ef 90       	pop	r14
    2a4a:	df 90       	pop	r13
    2a4c:	08 95       	ret

00002a4e <vTaskDelay>:
    2a4e:	cf 93       	push	r28
    2a50:	df 93       	push	r29
    2a52:	ec 01       	movw	r28, r24
    2a54:	89 2b       	or	r24, r25
    2a56:	39 f0       	breq	.+14     	; 0x2a66 <vTaskDelay+0x18>
    2a58:	c4 de       	rcall	.-632    	; 0x27e2 <vTaskSuspendAll>
    2a5a:	60 e0       	ldi	r22, 0x00	; 0
    2a5c:	ce 01       	movw	r24, r28
    2a5e:	47 dd       	rcall	.-1394   	; 0x24ee <prvAddCurrentTaskToDelayedList>
    2a60:	7d df       	rcall	.-262    	; 0x295c <xTaskResumeAll>
    2a62:	81 11       	cpse	r24, r1
    2a64:	01 c0       	rjmp	.+2      	; 0x2a68 <vTaskDelay+0x1a>
    2a66:	e8 d9       	rcall	.-3120   	; 0x1e38 <vPortYield>
    2a68:	df 91       	pop	r29
    2a6a:	cf 91       	pop	r28
    2a6c:	08 95       	ret

00002a6e <prvIdleTask>:
    2a6e:	0a e5       	ldi	r16, 0x5A	; 90
    2a70:	1c e0       	ldi	r17, 0x0C	; 12
    2a72:	0f 2e       	mov	r0, r31
    2a74:	f2 e8       	ldi	r31, 0x82	; 130
    2a76:	ef 2e       	mov	r14, r31
    2a78:	fc e0       	ldi	r31, 0x0C	; 12
    2a7a:	ff 2e       	mov	r15, r31
    2a7c:	f0 2d       	mov	r31, r0
    2a7e:	24 c0       	rjmp	.+72     	; 0x2ac8 <prvIdleTask+0x5a>
    2a80:	b0 de       	rcall	.-672    	; 0x27e2 <vTaskSuspendAll>
    2a82:	d8 01       	movw	r26, r16
    2a84:	cc 91       	ld	r28, X
    2a86:	6a df       	rcall	.-300    	; 0x295c <xTaskResumeAll>
    2a88:	cc 23       	and	r28, r28
    2a8a:	f1 f0       	breq	.+60     	; 0x2ac8 <prvIdleTask+0x5a>
    2a8c:	0f b6       	in	r0, 0x3f	; 63
    2a8e:	f8 94       	cli
    2a90:	0f 92       	push	r0
    2a92:	d8 01       	movw	r26, r16
    2a94:	15 96       	adiw	r26, 0x05	; 5
    2a96:	ed 91       	ld	r30, X+
    2a98:	fc 91       	ld	r31, X
    2a9a:	16 97       	sbiw	r26, 0x06	; 6
    2a9c:	c6 81       	ldd	r28, Z+6	; 0x06
    2a9e:	d7 81       	ldd	r29, Z+7	; 0x07
    2aa0:	ce 01       	movw	r24, r28
    2aa2:	02 96       	adiw	r24, 0x02	; 2
    2aa4:	02 d9       	rcall	.-3580   	; 0x1caa <uxListRemove>
    2aa6:	80 91 4f 0c 	lds	r24, 0x0C4F	; 0x800c4f <uxCurrentNumberOfTasks>
    2aaa:	81 50       	subi	r24, 0x01	; 1
    2aac:	80 93 4f 0c 	sts	0x0C4F, r24	; 0x800c4f <uxCurrentNumberOfTasks>
    2ab0:	80 91 59 0c 	lds	r24, 0x0C59	; 0x800c59 <uxDeletedTasksWaitingCleanUp>
    2ab4:	81 50       	subi	r24, 0x01	; 1
    2ab6:	80 93 59 0c 	sts	0x0C59, r24	; 0x800c59 <uxDeletedTasksWaitingCleanUp>
    2aba:	0f 90       	pop	r0
    2abc:	0f be       	out	0x3f, r0	; 63
    2abe:	8f 89       	ldd	r24, Y+23	; 0x17
    2ac0:	98 8d       	ldd	r25, Y+24	; 0x18
    2ac2:	8e d8       	rcall	.-3812   	; 0x1be0 <vPortFree>
    2ac4:	ce 01       	movw	r24, r28
    2ac6:	8c d8       	rcall	.-3816   	; 0x1be0 <vPortFree>
    2ac8:	80 91 59 0c 	lds	r24, 0x0C59	; 0x800c59 <uxDeletedTasksWaitingCleanUp>
    2acc:	81 11       	cpse	r24, r1
    2ace:	d8 cf       	rjmp	.-80     	; 0x2a80 <prvIdleTask+0x12>
    2ad0:	f7 01       	movw	r30, r14
    2ad2:	80 81       	ld	r24, Z
    2ad4:	82 30       	cpi	r24, 0x02	; 2
    2ad6:	c0 f3       	brcs	.-16     	; 0x2ac8 <prvIdleTask+0x5a>
    2ad8:	af d9       	rcall	.-3234   	; 0x1e38 <vPortYield>
    2ada:	f6 cf       	rjmp	.-20     	; 0x2ac8 <prvIdleTask+0x5a>

00002adc <vTaskSwitchContext>:
    2adc:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    2ae0:	88 23       	and	r24, r24
    2ae2:	21 f0       	breq	.+8      	; 0x2aec <vTaskSwitchContext+0x10>
    2ae4:	81 e0       	ldi	r24, 0x01	; 1
    2ae6:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <xYieldPending>
    2aea:	08 95       	ret
    2aec:	10 92 49 0c 	sts	0x0C49, r1	; 0x800c49 <xYieldPending>
    2af0:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2af4:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2af8:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2afc:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2b00:	2d 91       	ld	r18, X+
    2b02:	3c 91       	ld	r19, X
    2b04:	87 89       	ldd	r24, Z+23	; 0x17
    2b06:	90 8d       	ldd	r25, Z+24	; 0x18
    2b08:	82 17       	cp	r24, r18
    2b0a:	93 07       	cpc	r25, r19
    2b0c:	58 f0       	brcs	.+22     	; 0x2b24 <vTaskSwitchContext+0x48>
    2b0e:	60 91 a6 0c 	lds	r22, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2b12:	70 91 a7 0c 	lds	r23, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2b16:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2b1a:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2b1e:	67 5e       	subi	r22, 0xE7	; 231
    2b20:	7f 4f       	sbci	r23, 0xFF	; 255
    2b22:	2a d8       	rcall	.-4012   	; 0x1b78 <vApplicationStackOverflowHook>
    2b24:	20 91 4c 0c 	lds	r18, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    2b28:	82 2f       	mov	r24, r18
    2b2a:	90 e0       	ldi	r25, 0x00	; 0
    2b2c:	fc 01       	movw	r30, r24
    2b2e:	ee 0f       	add	r30, r30
    2b30:	ff 1f       	adc	r31, r31
    2b32:	ee 0f       	add	r30, r30
    2b34:	ff 1f       	adc	r31, r31
    2b36:	ee 0f       	add	r30, r30
    2b38:	ff 1f       	adc	r31, r31
    2b3a:	e8 0f       	add	r30, r24
    2b3c:	f9 1f       	adc	r31, r25
    2b3e:	ee 57       	subi	r30, 0x7E	; 126
    2b40:	f3 4f       	sbci	r31, 0xF3	; 243
    2b42:	30 81       	ld	r19, Z
    2b44:	31 11       	cpse	r19, r1
    2b46:	11 c0       	rjmp	.+34     	; 0x2b6a <vTaskSwitchContext+0x8e>
    2b48:	21 50       	subi	r18, 0x01	; 1
    2b4a:	82 2f       	mov	r24, r18
    2b4c:	90 e0       	ldi	r25, 0x00	; 0
    2b4e:	fc 01       	movw	r30, r24
    2b50:	ee 0f       	add	r30, r30
    2b52:	ff 1f       	adc	r31, r31
    2b54:	ee 0f       	add	r30, r30
    2b56:	ff 1f       	adc	r31, r31
    2b58:	ee 0f       	add	r30, r30
    2b5a:	ff 1f       	adc	r31, r31
    2b5c:	e8 0f       	add	r30, r24
    2b5e:	f9 1f       	adc	r31, r25
    2b60:	ee 57       	subi	r30, 0x7E	; 126
    2b62:	f3 4f       	sbci	r31, 0xF3	; 243
    2b64:	30 81       	ld	r19, Z
    2b66:	33 23       	and	r19, r19
    2b68:	79 f3       	breq	.-34     	; 0x2b48 <vTaskSwitchContext+0x6c>
    2b6a:	ac 01       	movw	r20, r24
    2b6c:	44 0f       	add	r20, r20
    2b6e:	55 1f       	adc	r21, r21
    2b70:	44 0f       	add	r20, r20
    2b72:	55 1f       	adc	r21, r21
    2b74:	44 0f       	add	r20, r20
    2b76:	55 1f       	adc	r21, r21
    2b78:	48 0f       	add	r20, r24
    2b7a:	59 1f       	adc	r21, r25
    2b7c:	da 01       	movw	r26, r20
    2b7e:	ae 57       	subi	r26, 0x7E	; 126
    2b80:	b3 4f       	sbci	r27, 0xF3	; 243
    2b82:	11 96       	adiw	r26, 0x01	; 1
    2b84:	ed 91       	ld	r30, X+
    2b86:	fc 91       	ld	r31, X
    2b88:	12 97       	sbiw	r26, 0x02	; 2
    2b8a:	02 80       	ldd	r0, Z+2	; 0x02
    2b8c:	f3 81       	ldd	r31, Z+3	; 0x03
    2b8e:	e0 2d       	mov	r30, r0
    2b90:	12 96       	adiw	r26, 0x02	; 2
    2b92:	fc 93       	st	X, r31
    2b94:	ee 93       	st	-X, r30
    2b96:	11 97       	sbiw	r26, 0x01	; 1
    2b98:	4b 57       	subi	r20, 0x7B	; 123
    2b9a:	53 4f       	sbci	r21, 0xF3	; 243
    2b9c:	e4 17       	cp	r30, r20
    2b9e:	f5 07       	cpc	r31, r21
    2ba0:	29 f4       	brne	.+10     	; 0x2bac <vTaskSwitchContext+0xd0>
    2ba2:	42 81       	ldd	r20, Z+2	; 0x02
    2ba4:	53 81       	ldd	r21, Z+3	; 0x03
    2ba6:	fd 01       	movw	r30, r26
    2ba8:	52 83       	std	Z+2, r21	; 0x02
    2baa:	41 83       	std	Z+1, r20	; 0x01
    2bac:	fc 01       	movw	r30, r24
    2bae:	ee 0f       	add	r30, r30
    2bb0:	ff 1f       	adc	r31, r31
    2bb2:	ee 0f       	add	r30, r30
    2bb4:	ff 1f       	adc	r31, r31
    2bb6:	ee 0f       	add	r30, r30
    2bb8:	ff 1f       	adc	r31, r31
    2bba:	8e 0f       	add	r24, r30
    2bbc:	9f 1f       	adc	r25, r31
    2bbe:	fc 01       	movw	r30, r24
    2bc0:	ee 57       	subi	r30, 0x7E	; 126
    2bc2:	f3 4f       	sbci	r31, 0xF3	; 243
    2bc4:	01 80       	ldd	r0, Z+1	; 0x01
    2bc6:	f2 81       	ldd	r31, Z+2	; 0x02
    2bc8:	e0 2d       	mov	r30, r0
    2bca:	86 81       	ldd	r24, Z+6	; 0x06
    2bcc:	97 81       	ldd	r25, Z+7	; 0x07
    2bce:	90 93 a7 0c 	sts	0x0CA7, r25	; 0x800ca7 <pxCurrentTCB+0x1>
    2bd2:	80 93 a6 0c 	sts	0x0CA6, r24	; 0x800ca6 <pxCurrentTCB>
    2bd6:	20 93 4c 0c 	sts	0x0C4C, r18	; 0x800c4c <uxTopReadyPriority>
    2bda:	08 95       	ret

00002bdc <vTaskPlaceOnEventList>:
    2bdc:	cf 93       	push	r28
    2bde:	df 93       	push	r29
    2be0:	eb 01       	movw	r28, r22
    2be2:	60 91 a6 0c 	lds	r22, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2be6:	70 91 a7 0c 	lds	r23, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2bea:	64 5f       	subi	r22, 0xF4	; 244
    2bec:	7f 4f       	sbci	r23, 0xFF	; 255
    2bee:	2c d8       	rcall	.-4008   	; 0x1c48 <vListInsert>
    2bf0:	61 e0       	ldi	r22, 0x01	; 1
    2bf2:	ce 01       	movw	r24, r28
    2bf4:	7c dc       	rcall	.-1800   	; 0x24ee <prvAddCurrentTaskToDelayedList>
    2bf6:	df 91       	pop	r29
    2bf8:	cf 91       	pop	r28
    2bfa:	08 95       	ret

00002bfc <xTaskRemoveFromEventList>:
    2bfc:	0f 93       	push	r16
    2bfe:	1f 93       	push	r17
    2c00:	cf 93       	push	r28
    2c02:	df 93       	push	r29
    2c04:	dc 01       	movw	r26, r24
    2c06:	15 96       	adiw	r26, 0x05	; 5
    2c08:	ed 91       	ld	r30, X+
    2c0a:	fc 91       	ld	r31, X
    2c0c:	16 97       	sbiw	r26, 0x06	; 6
    2c0e:	c6 81       	ldd	r28, Z+6	; 0x06
    2c10:	d7 81       	ldd	r29, Z+7	; 0x07
    2c12:	8e 01       	movw	r16, r28
    2c14:	04 5f       	subi	r16, 0xF4	; 244
    2c16:	1f 4f       	sbci	r17, 0xFF	; 255
    2c18:	c8 01       	movw	r24, r16
    2c1a:	47 d8       	rcall	.-3954   	; 0x1caa <uxListRemove>
    2c1c:	80 91 42 0c 	lds	r24, 0x0C42	; 0x800c42 <uxSchedulerSuspended>
    2c20:	81 11       	cpse	r24, r1
    2c22:	1b c0       	rjmp	.+54     	; 0x2c5a <xTaskRemoveFromEventList+0x5e>
    2c24:	0a 50       	subi	r16, 0x0A	; 10
    2c26:	11 09       	sbc	r17, r1
    2c28:	c8 01       	movw	r24, r16
    2c2a:	3f d8       	rcall	.-3970   	; 0x1caa <uxListRemove>
    2c2c:	8e 89       	ldd	r24, Y+22	; 0x16
    2c2e:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    2c32:	98 17       	cp	r25, r24
    2c34:	10 f4       	brcc	.+4      	; 0x2c3a <xTaskRemoveFromEventList+0x3e>
    2c36:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	9c 01       	movw	r18, r24
    2c3e:	22 0f       	add	r18, r18
    2c40:	33 1f       	adc	r19, r19
    2c42:	22 0f       	add	r18, r18
    2c44:	33 1f       	adc	r19, r19
    2c46:	22 0f       	add	r18, r18
    2c48:	33 1f       	adc	r19, r19
    2c4a:	82 0f       	add	r24, r18
    2c4c:	93 1f       	adc	r25, r19
    2c4e:	b8 01       	movw	r22, r16
    2c50:	8e 57       	subi	r24, 0x7E	; 126
    2c52:	93 4f       	sbci	r25, 0xF3	; 243
    2c54:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListInsertEnd>
    2c58:	05 c0       	rjmp	.+10     	; 0x2c64 <xTaskRemoveFromEventList+0x68>
    2c5a:	b8 01       	movw	r22, r16
    2c5c:	83 e6       	ldi	r24, 0x63	; 99
    2c5e:	9c e0       	ldi	r25, 0x0C	; 12
    2c60:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListInsertEnd>
    2c64:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2c68:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2c6c:	9e 89       	ldd	r25, Y+22	; 0x16
    2c6e:	86 89       	ldd	r24, Z+22	; 0x16
    2c70:	89 17       	cp	r24, r25
    2c72:	20 f4       	brcc	.+8      	; 0x2c7c <xTaskRemoveFromEventList+0x80>
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <xYieldPending>
    2c7a:	01 c0       	rjmp	.+2      	; 0x2c7e <xTaskRemoveFromEventList+0x82>
    2c7c:	80 e0       	ldi	r24, 0x00	; 0
    2c7e:	df 91       	pop	r29
    2c80:	cf 91       	pop	r28
    2c82:	1f 91       	pop	r17
    2c84:	0f 91       	pop	r16
    2c86:	08 95       	ret

00002c88 <vTaskSetTimeOutState>:
    2c88:	20 91 48 0c 	lds	r18, 0x0C48	; 0x800c48 <xNumOfOverflows>
    2c8c:	fc 01       	movw	r30, r24
    2c8e:	20 83       	st	Z, r18
    2c90:	20 91 4d 0c 	lds	r18, 0x0C4D	; 0x800c4d <xTickCount>
    2c94:	30 91 4e 0c 	lds	r19, 0x0C4E	; 0x800c4e <xTickCount+0x1>
    2c98:	32 83       	std	Z+2, r19	; 0x02
    2c9a:	21 83       	std	Z+1, r18	; 0x01
    2c9c:	08 95       	ret

00002c9e <xTaskCheckForTimeOut>:
    2c9e:	0f b6       	in	r0, 0x3f	; 63
    2ca0:	f8 94       	cli
    2ca2:	0f 92       	push	r0
    2ca4:	40 91 4d 0c 	lds	r20, 0x0C4D	; 0x800c4d <xTickCount>
    2ca8:	50 91 4e 0c 	lds	r21, 0x0C4E	; 0x800c4e <xTickCount+0x1>
    2cac:	db 01       	movw	r26, r22
    2cae:	2d 91       	ld	r18, X+
    2cb0:	3c 91       	ld	r19, X
    2cb2:	2f 3f       	cpi	r18, 0xFF	; 255
    2cb4:	bf ef       	ldi	r27, 0xFF	; 255
    2cb6:	3b 07       	cpc	r19, r27
    2cb8:	11 f1       	breq	.+68     	; 0x2cfe <xTaskCheckForTimeOut+0x60>
    2cba:	e0 91 48 0c 	lds	r30, 0x0C48	; 0x800c48 <xNumOfOverflows>
    2cbe:	dc 01       	movw	r26, r24
    2cc0:	fc 91       	ld	r31, X
    2cc2:	fe 17       	cp	r31, r30
    2cc4:	39 f0       	breq	.+14     	; 0x2cd4 <xTaskCheckForTimeOut+0x36>
    2cc6:	11 96       	adiw	r26, 0x01	; 1
    2cc8:	ed 91       	ld	r30, X+
    2cca:	fc 91       	ld	r31, X
    2ccc:	12 97       	sbiw	r26, 0x02	; 2
    2cce:	4e 17       	cp	r20, r30
    2cd0:	5f 07       	cpc	r21, r31
    2cd2:	b8 f4       	brcc	.+46     	; 0x2d02 <xTaskCheckForTimeOut+0x64>
    2cd4:	dc 01       	movw	r26, r24
    2cd6:	11 96       	adiw	r26, 0x01	; 1
    2cd8:	ed 91       	ld	r30, X+
    2cda:	fc 91       	ld	r31, X
    2cdc:	12 97       	sbiw	r26, 0x02	; 2
    2cde:	da 01       	movw	r26, r20
    2ce0:	ae 1b       	sub	r26, r30
    2ce2:	bf 0b       	sbc	r27, r31
    2ce4:	a2 17       	cp	r26, r18
    2ce6:	b3 07       	cpc	r27, r19
    2ce8:	70 f4       	brcc	.+28     	; 0x2d06 <xTaskCheckForTimeOut+0x68>
    2cea:	db 01       	movw	r26, r22
    2cec:	e4 1b       	sub	r30, r20
    2cee:	f5 0b       	sbc	r31, r21
    2cf0:	2e 0f       	add	r18, r30
    2cf2:	3f 1f       	adc	r19, r31
    2cf4:	2d 93       	st	X+, r18
    2cf6:	3c 93       	st	X, r19
    2cf8:	c7 df       	rcall	.-114    	; 0x2c88 <vTaskSetTimeOutState>
    2cfa:	80 e0       	ldi	r24, 0x00	; 0
    2cfc:	05 c0       	rjmp	.+10     	; 0x2d08 <xTaskCheckForTimeOut+0x6a>
    2cfe:	80 e0       	ldi	r24, 0x00	; 0
    2d00:	03 c0       	rjmp	.+6      	; 0x2d08 <xTaskCheckForTimeOut+0x6a>
    2d02:	81 e0       	ldi	r24, 0x01	; 1
    2d04:	01 c0       	rjmp	.+2      	; 0x2d08 <xTaskCheckForTimeOut+0x6a>
    2d06:	81 e0       	ldi	r24, 0x01	; 1
    2d08:	0f 90       	pop	r0
    2d0a:	0f be       	out	0x3f, r0	; 63
    2d0c:	08 95       	ret

00002d0e <vTaskMissedYield>:
    2d0e:	81 e0       	ldi	r24, 0x01	; 1
    2d10:	80 93 49 0c 	sts	0x0C49, r24	; 0x800c49 <xYieldPending>
    2d14:	08 95       	ret

00002d16 <vTaskPriorityInherit>:
    2d16:	0f 93       	push	r16
    2d18:	1f 93       	push	r17
    2d1a:	cf 93       	push	r28
    2d1c:	df 93       	push	r29
    2d1e:	fc 01       	movw	r30, r24
    2d20:	89 2b       	or	r24, r25
    2d22:	09 f4       	brne	.+2      	; 0x2d26 <vTaskPriorityInherit+0x10>
    2d24:	55 c0       	rjmp	.+170    	; 0x2dd0 <vTaskPriorityInherit+0xba>
    2d26:	26 89       	ldd	r18, Z+22	; 0x16
    2d28:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2d2c:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2d30:	56 96       	adiw	r26, 0x16	; 22
    2d32:	8c 91       	ld	r24, X
    2d34:	28 17       	cp	r18, r24
    2d36:	08 f0       	brcs	.+2      	; 0x2d3a <vTaskPriorityInherit+0x24>
    2d38:	4b c0       	rjmp	.+150    	; 0x2dd0 <vTaskPriorityInherit+0xba>
    2d3a:	84 85       	ldd	r24, Z+12	; 0x0c
    2d3c:	95 85       	ldd	r25, Z+13	; 0x0d
    2d3e:	99 23       	and	r25, r25
    2d40:	64 f0       	brlt	.+24     	; 0x2d5a <vTaskPriorityInherit+0x44>
    2d42:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2d46:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2d4a:	56 96       	adiw	r26, 0x16	; 22
    2d4c:	3c 91       	ld	r19, X
    2d4e:	84 e0       	ldi	r24, 0x04	; 4
    2d50:	90 e0       	ldi	r25, 0x00	; 0
    2d52:	83 1b       	sub	r24, r19
    2d54:	91 09       	sbc	r25, r1
    2d56:	95 87       	std	Z+13, r25	; 0x0d
    2d58:	84 87       	std	Z+12, r24	; 0x0c
    2d5a:	30 e0       	ldi	r19, 0x00	; 0
    2d5c:	c9 01       	movw	r24, r18
    2d5e:	88 0f       	add	r24, r24
    2d60:	99 1f       	adc	r25, r25
    2d62:	88 0f       	add	r24, r24
    2d64:	99 1f       	adc	r25, r25
    2d66:	88 0f       	add	r24, r24
    2d68:	99 1f       	adc	r25, r25
    2d6a:	28 0f       	add	r18, r24
    2d6c:	39 1f       	adc	r19, r25
    2d6e:	2e 57       	subi	r18, 0x7E	; 126
    2d70:	33 4f       	sbci	r19, 0xF3	; 243
    2d72:	82 85       	ldd	r24, Z+10	; 0x0a
    2d74:	93 85       	ldd	r25, Z+11	; 0x0b
    2d76:	82 17       	cp	r24, r18
    2d78:	93 07       	cpc	r25, r19
    2d7a:	19 f5       	brne	.+70     	; 0x2dc2 <vTaskPriorityInherit+0xac>
    2d7c:	8f 01       	movw	r16, r30
    2d7e:	ef 01       	movw	r28, r30
    2d80:	22 96       	adiw	r28, 0x02	; 2
    2d82:	ce 01       	movw	r24, r28
    2d84:	0e 94 55 0e 	call	0x1caa	; 0x1caa <uxListRemove>
    2d88:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2d8c:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2d90:	86 89       	ldd	r24, Z+22	; 0x16
    2d92:	f8 01       	movw	r30, r16
    2d94:	86 8b       	std	Z+22, r24	; 0x16
    2d96:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    2d9a:	98 17       	cp	r25, r24
    2d9c:	10 f4       	brcc	.+4      	; 0x2da2 <vTaskPriorityInherit+0x8c>
    2d9e:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	9c 01       	movw	r18, r24
    2da6:	22 0f       	add	r18, r18
    2da8:	33 1f       	adc	r19, r19
    2daa:	22 0f       	add	r18, r18
    2dac:	33 1f       	adc	r19, r19
    2dae:	22 0f       	add	r18, r18
    2db0:	33 1f       	adc	r19, r19
    2db2:	82 0f       	add	r24, r18
    2db4:	93 1f       	adc	r25, r19
    2db6:	be 01       	movw	r22, r28
    2db8:	8e 57       	subi	r24, 0x7E	; 126
    2dba:	93 4f       	sbci	r25, 0xF3	; 243
    2dbc:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListInsertEnd>
    2dc0:	07 c0       	rjmp	.+14     	; 0x2dd0 <vTaskPriorityInherit+0xba>
    2dc2:	a0 91 a6 0c 	lds	r26, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2dc6:	b0 91 a7 0c 	lds	r27, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2dca:	56 96       	adiw	r26, 0x16	; 22
    2dcc:	8c 91       	ld	r24, X
    2dce:	86 8b       	std	Z+22, r24	; 0x16
    2dd0:	df 91       	pop	r29
    2dd2:	cf 91       	pop	r28
    2dd4:	1f 91       	pop	r17
    2dd6:	0f 91       	pop	r16
    2dd8:	08 95       	ret

00002dda <xTaskPriorityDisinherit>:
    2dda:	0f 93       	push	r16
    2ddc:	1f 93       	push	r17
    2dde:	cf 93       	push	r28
    2de0:	df 93       	push	r29
    2de2:	fc 01       	movw	r30, r24
    2de4:	89 2b       	or	r24, r25
    2de6:	79 f1       	breq	.+94     	; 0x2e46 <xTaskPriorityDisinherit+0x6c>
    2de8:	82 a1       	ldd	r24, Z+34	; 0x22
    2dea:	81 50       	subi	r24, 0x01	; 1
    2dec:	82 a3       	std	Z+34, r24	; 0x22
    2dee:	26 89       	ldd	r18, Z+22	; 0x16
    2df0:	91 a1       	ldd	r25, Z+33	; 0x21
    2df2:	29 17       	cp	r18, r25
    2df4:	51 f1       	breq	.+84     	; 0x2e4a <xTaskPriorityDisinherit+0x70>
    2df6:	81 11       	cpse	r24, r1
    2df8:	2a c0       	rjmp	.+84     	; 0x2e4e <xTaskPriorityDisinherit+0x74>
    2dfa:	ef 01       	movw	r28, r30
    2dfc:	8f 01       	movw	r16, r30
    2dfe:	0e 5f       	subi	r16, 0xFE	; 254
    2e00:	1f 4f       	sbci	r17, 0xFF	; 255
    2e02:	c8 01       	movw	r24, r16
    2e04:	0e 94 55 0e 	call	0x1caa	; 0x1caa <uxListRemove>
    2e08:	89 a1       	ldd	r24, Y+33	; 0x21
    2e0a:	8e 8b       	std	Y+22, r24	; 0x16
    2e0c:	24 e0       	ldi	r18, 0x04	; 4
    2e0e:	30 e0       	ldi	r19, 0x00	; 0
    2e10:	28 1b       	sub	r18, r24
    2e12:	31 09       	sbc	r19, r1
    2e14:	3d 87       	std	Y+13, r19	; 0x0d
    2e16:	2c 87       	std	Y+12, r18	; 0x0c
    2e18:	90 91 4c 0c 	lds	r25, 0x0C4C	; 0x800c4c <uxTopReadyPriority>
    2e1c:	98 17       	cp	r25, r24
    2e1e:	10 f4       	brcc	.+4      	; 0x2e24 <xTaskPriorityDisinherit+0x4a>
    2e20:	80 93 4c 0c 	sts	0x0C4C, r24	; 0x800c4c <uxTopReadyPriority>
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	9c 01       	movw	r18, r24
    2e28:	22 0f       	add	r18, r18
    2e2a:	33 1f       	adc	r19, r19
    2e2c:	22 0f       	add	r18, r18
    2e2e:	33 1f       	adc	r19, r19
    2e30:	22 0f       	add	r18, r18
    2e32:	33 1f       	adc	r19, r19
    2e34:	82 0f       	add	r24, r18
    2e36:	93 1f       	adc	r25, r19
    2e38:	b8 01       	movw	r22, r16
    2e3a:	8e 57       	subi	r24, 0x7E	; 126
    2e3c:	93 4f       	sbci	r25, 0xF3	; 243
    2e3e:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListInsertEnd>
    2e42:	81 e0       	ldi	r24, 0x01	; 1
    2e44:	05 c0       	rjmp	.+10     	; 0x2e50 <xTaskPriorityDisinherit+0x76>
    2e46:	80 e0       	ldi	r24, 0x00	; 0
    2e48:	03 c0       	rjmp	.+6      	; 0x2e50 <xTaskPriorityDisinherit+0x76>
    2e4a:	80 e0       	ldi	r24, 0x00	; 0
    2e4c:	01 c0       	rjmp	.+2      	; 0x2e50 <xTaskPriorityDisinherit+0x76>
    2e4e:	80 e0       	ldi	r24, 0x00	; 0
    2e50:	df 91       	pop	r29
    2e52:	cf 91       	pop	r28
    2e54:	1f 91       	pop	r17
    2e56:	0f 91       	pop	r16
    2e58:	08 95       	ret

00002e5a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2e5a:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2e5e:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2e62:	89 2b       	or	r24, r25
    2e64:	39 f0       	breq	.+14     	; 0x2e74 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2e66:	e0 91 a6 0c 	lds	r30, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2e6a:	f0 91 a7 0c 	lds	r31, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
    2e6e:	82 a1       	ldd	r24, Z+34	; 0x22
    2e70:	8f 5f       	subi	r24, 0xFF	; 255
    2e72:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2e74:	80 91 a6 0c 	lds	r24, 0x0CA6	; 0x800ca6 <pxCurrentTCB>
    2e78:	90 91 a7 0c 	lds	r25, 0x0CA7	; 0x800ca7 <pxCurrentTCB+0x1>
	}
    2e7c:	08 95       	ret

00002e7e <__subsf3>:
    2e7e:	50 58       	subi	r21, 0x80	; 128

00002e80 <__addsf3>:
    2e80:	bb 27       	eor	r27, r27
    2e82:	aa 27       	eor	r26, r26
    2e84:	0e d0       	rcall	.+28     	; 0x2ea2 <__addsf3x>
    2e86:	e0 c0       	rjmp	.+448    	; 0x3048 <__fp_round>
    2e88:	d1 d0       	rcall	.+418    	; 0x302c <__fp_pscA>
    2e8a:	30 f0       	brcs	.+12     	; 0x2e98 <__addsf3+0x18>
    2e8c:	d6 d0       	rcall	.+428    	; 0x303a <__fp_pscB>
    2e8e:	20 f0       	brcs	.+8      	; 0x2e98 <__addsf3+0x18>
    2e90:	31 f4       	brne	.+12     	; 0x2e9e <__addsf3+0x1e>
    2e92:	9f 3f       	cpi	r25, 0xFF	; 255
    2e94:	11 f4       	brne	.+4      	; 0x2e9a <__addsf3+0x1a>
    2e96:	1e f4       	brtc	.+6      	; 0x2e9e <__addsf3+0x1e>
    2e98:	c6 c0       	rjmp	.+396    	; 0x3026 <__fp_nan>
    2e9a:	0e f4       	brtc	.+2      	; 0x2e9e <__addsf3+0x1e>
    2e9c:	e0 95       	com	r30
    2e9e:	e7 fb       	bst	r30, 7
    2ea0:	bc c0       	rjmp	.+376    	; 0x301a <__fp_inf>

00002ea2 <__addsf3x>:
    2ea2:	e9 2f       	mov	r30, r25
    2ea4:	e2 d0       	rcall	.+452    	; 0x306a <__fp_split3>
    2ea6:	80 f3       	brcs	.-32     	; 0x2e88 <__addsf3+0x8>
    2ea8:	ba 17       	cp	r27, r26
    2eaa:	62 07       	cpc	r22, r18
    2eac:	73 07       	cpc	r23, r19
    2eae:	84 07       	cpc	r24, r20
    2eb0:	95 07       	cpc	r25, r21
    2eb2:	18 f0       	brcs	.+6      	; 0x2eba <__addsf3x+0x18>
    2eb4:	71 f4       	brne	.+28     	; 0x2ed2 <__addsf3x+0x30>
    2eb6:	9e f5       	brtc	.+102    	; 0x2f1e <__addsf3x+0x7c>
    2eb8:	fa c0       	rjmp	.+500    	; 0x30ae <__fp_zero>
    2eba:	0e f4       	brtc	.+2      	; 0x2ebe <__addsf3x+0x1c>
    2ebc:	e0 95       	com	r30
    2ebe:	0b 2e       	mov	r0, r27
    2ec0:	ba 2f       	mov	r27, r26
    2ec2:	a0 2d       	mov	r26, r0
    2ec4:	0b 01       	movw	r0, r22
    2ec6:	b9 01       	movw	r22, r18
    2ec8:	90 01       	movw	r18, r0
    2eca:	0c 01       	movw	r0, r24
    2ecc:	ca 01       	movw	r24, r20
    2ece:	a0 01       	movw	r20, r0
    2ed0:	11 24       	eor	r1, r1
    2ed2:	ff 27       	eor	r31, r31
    2ed4:	59 1b       	sub	r21, r25
    2ed6:	99 f0       	breq	.+38     	; 0x2efe <__addsf3x+0x5c>
    2ed8:	59 3f       	cpi	r21, 0xF9	; 249
    2eda:	50 f4       	brcc	.+20     	; 0x2ef0 <__addsf3x+0x4e>
    2edc:	50 3e       	cpi	r21, 0xE0	; 224
    2ede:	68 f1       	brcs	.+90     	; 0x2f3a <__addsf3x+0x98>
    2ee0:	1a 16       	cp	r1, r26
    2ee2:	f0 40       	sbci	r31, 0x00	; 0
    2ee4:	a2 2f       	mov	r26, r18
    2ee6:	23 2f       	mov	r18, r19
    2ee8:	34 2f       	mov	r19, r20
    2eea:	44 27       	eor	r20, r20
    2eec:	58 5f       	subi	r21, 0xF8	; 248
    2eee:	f3 cf       	rjmp	.-26     	; 0x2ed6 <__addsf3x+0x34>
    2ef0:	46 95       	lsr	r20
    2ef2:	37 95       	ror	r19
    2ef4:	27 95       	ror	r18
    2ef6:	a7 95       	ror	r26
    2ef8:	f0 40       	sbci	r31, 0x00	; 0
    2efa:	53 95       	inc	r21
    2efc:	c9 f7       	brne	.-14     	; 0x2ef0 <__addsf3x+0x4e>
    2efe:	7e f4       	brtc	.+30     	; 0x2f1e <__addsf3x+0x7c>
    2f00:	1f 16       	cp	r1, r31
    2f02:	ba 0b       	sbc	r27, r26
    2f04:	62 0b       	sbc	r22, r18
    2f06:	73 0b       	sbc	r23, r19
    2f08:	84 0b       	sbc	r24, r20
    2f0a:	ba f0       	brmi	.+46     	; 0x2f3a <__addsf3x+0x98>
    2f0c:	91 50       	subi	r25, 0x01	; 1
    2f0e:	a1 f0       	breq	.+40     	; 0x2f38 <__addsf3x+0x96>
    2f10:	ff 0f       	add	r31, r31
    2f12:	bb 1f       	adc	r27, r27
    2f14:	66 1f       	adc	r22, r22
    2f16:	77 1f       	adc	r23, r23
    2f18:	88 1f       	adc	r24, r24
    2f1a:	c2 f7       	brpl	.-16     	; 0x2f0c <__addsf3x+0x6a>
    2f1c:	0e c0       	rjmp	.+28     	; 0x2f3a <__addsf3x+0x98>
    2f1e:	ba 0f       	add	r27, r26
    2f20:	62 1f       	adc	r22, r18
    2f22:	73 1f       	adc	r23, r19
    2f24:	84 1f       	adc	r24, r20
    2f26:	48 f4       	brcc	.+18     	; 0x2f3a <__addsf3x+0x98>
    2f28:	87 95       	ror	r24
    2f2a:	77 95       	ror	r23
    2f2c:	67 95       	ror	r22
    2f2e:	b7 95       	ror	r27
    2f30:	f7 95       	ror	r31
    2f32:	9e 3f       	cpi	r25, 0xFE	; 254
    2f34:	08 f0       	brcs	.+2      	; 0x2f38 <__addsf3x+0x96>
    2f36:	b3 cf       	rjmp	.-154    	; 0x2e9e <__addsf3+0x1e>
    2f38:	93 95       	inc	r25
    2f3a:	88 0f       	add	r24, r24
    2f3c:	08 f0       	brcs	.+2      	; 0x2f40 <__addsf3x+0x9e>
    2f3e:	99 27       	eor	r25, r25
    2f40:	ee 0f       	add	r30, r30
    2f42:	97 95       	ror	r25
    2f44:	87 95       	ror	r24
    2f46:	08 95       	ret

00002f48 <__fixunssfsi>:
    2f48:	98 d0       	rcall	.+304    	; 0x307a <__fp_splitA>
    2f4a:	88 f0       	brcs	.+34     	; 0x2f6e <__fixunssfsi+0x26>
    2f4c:	9f 57       	subi	r25, 0x7F	; 127
    2f4e:	90 f0       	brcs	.+36     	; 0x2f74 <__fixunssfsi+0x2c>
    2f50:	b9 2f       	mov	r27, r25
    2f52:	99 27       	eor	r25, r25
    2f54:	b7 51       	subi	r27, 0x17	; 23
    2f56:	a0 f0       	brcs	.+40     	; 0x2f80 <__fixunssfsi+0x38>
    2f58:	d1 f0       	breq	.+52     	; 0x2f8e <__fixunssfsi+0x46>
    2f5a:	66 0f       	add	r22, r22
    2f5c:	77 1f       	adc	r23, r23
    2f5e:	88 1f       	adc	r24, r24
    2f60:	99 1f       	adc	r25, r25
    2f62:	1a f0       	brmi	.+6      	; 0x2f6a <__fixunssfsi+0x22>
    2f64:	ba 95       	dec	r27
    2f66:	c9 f7       	brne	.-14     	; 0x2f5a <__fixunssfsi+0x12>
    2f68:	12 c0       	rjmp	.+36     	; 0x2f8e <__fixunssfsi+0x46>
    2f6a:	b1 30       	cpi	r27, 0x01	; 1
    2f6c:	81 f0       	breq	.+32     	; 0x2f8e <__fixunssfsi+0x46>
    2f6e:	9f d0       	rcall	.+318    	; 0x30ae <__fp_zero>
    2f70:	b1 e0       	ldi	r27, 0x01	; 1
    2f72:	08 95       	ret
    2f74:	9c c0       	rjmp	.+312    	; 0x30ae <__fp_zero>
    2f76:	67 2f       	mov	r22, r23
    2f78:	78 2f       	mov	r23, r24
    2f7a:	88 27       	eor	r24, r24
    2f7c:	b8 5f       	subi	r27, 0xF8	; 248
    2f7e:	39 f0       	breq	.+14     	; 0x2f8e <__fixunssfsi+0x46>
    2f80:	b9 3f       	cpi	r27, 0xF9	; 249
    2f82:	cc f3       	brlt	.-14     	; 0x2f76 <__fixunssfsi+0x2e>
    2f84:	86 95       	lsr	r24
    2f86:	77 95       	ror	r23
    2f88:	67 95       	ror	r22
    2f8a:	b3 95       	inc	r27
    2f8c:	d9 f7       	brne	.-10     	; 0x2f84 <__fixunssfsi+0x3c>
    2f8e:	3e f4       	brtc	.+14     	; 0x2f9e <__fixunssfsi+0x56>
    2f90:	90 95       	com	r25
    2f92:	80 95       	com	r24
    2f94:	70 95       	com	r23
    2f96:	61 95       	neg	r22
    2f98:	7f 4f       	sbci	r23, 0xFF	; 255
    2f9a:	8f 4f       	sbci	r24, 0xFF	; 255
    2f9c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f9e:	08 95       	ret

00002fa0 <__floatunsisf>:
    2fa0:	e8 94       	clt
    2fa2:	09 c0       	rjmp	.+18     	; 0x2fb6 <__floatsisf+0x12>

00002fa4 <__floatsisf>:
    2fa4:	97 fb       	bst	r25, 7
    2fa6:	3e f4       	brtc	.+14     	; 0x2fb6 <__floatsisf+0x12>
    2fa8:	90 95       	com	r25
    2faa:	80 95       	com	r24
    2fac:	70 95       	com	r23
    2fae:	61 95       	neg	r22
    2fb0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb2:	8f 4f       	sbci	r24, 0xFF	; 255
    2fb4:	9f 4f       	sbci	r25, 0xFF	; 255
    2fb6:	99 23       	and	r25, r25
    2fb8:	a9 f0       	breq	.+42     	; 0x2fe4 <__floatsisf+0x40>
    2fba:	f9 2f       	mov	r31, r25
    2fbc:	96 e9       	ldi	r25, 0x96	; 150
    2fbe:	bb 27       	eor	r27, r27
    2fc0:	93 95       	inc	r25
    2fc2:	f6 95       	lsr	r31
    2fc4:	87 95       	ror	r24
    2fc6:	77 95       	ror	r23
    2fc8:	67 95       	ror	r22
    2fca:	b7 95       	ror	r27
    2fcc:	f1 11       	cpse	r31, r1
    2fce:	f8 cf       	rjmp	.-16     	; 0x2fc0 <__floatsisf+0x1c>
    2fd0:	fa f4       	brpl	.+62     	; 0x3010 <__floatsisf+0x6c>
    2fd2:	bb 0f       	add	r27, r27
    2fd4:	11 f4       	brne	.+4      	; 0x2fda <__floatsisf+0x36>
    2fd6:	60 ff       	sbrs	r22, 0
    2fd8:	1b c0       	rjmp	.+54     	; 0x3010 <__floatsisf+0x6c>
    2fda:	6f 5f       	subi	r22, 0xFF	; 255
    2fdc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fde:	8f 4f       	sbci	r24, 0xFF	; 255
    2fe0:	9f 4f       	sbci	r25, 0xFF	; 255
    2fe2:	16 c0       	rjmp	.+44     	; 0x3010 <__floatsisf+0x6c>
    2fe4:	88 23       	and	r24, r24
    2fe6:	11 f0       	breq	.+4      	; 0x2fec <__floatsisf+0x48>
    2fe8:	96 e9       	ldi	r25, 0x96	; 150
    2fea:	11 c0       	rjmp	.+34     	; 0x300e <__floatsisf+0x6a>
    2fec:	77 23       	and	r23, r23
    2fee:	21 f0       	breq	.+8      	; 0x2ff8 <__floatsisf+0x54>
    2ff0:	9e e8       	ldi	r25, 0x8E	; 142
    2ff2:	87 2f       	mov	r24, r23
    2ff4:	76 2f       	mov	r23, r22
    2ff6:	05 c0       	rjmp	.+10     	; 0x3002 <__floatsisf+0x5e>
    2ff8:	66 23       	and	r22, r22
    2ffa:	71 f0       	breq	.+28     	; 0x3018 <__floatsisf+0x74>
    2ffc:	96 e8       	ldi	r25, 0x86	; 134
    2ffe:	86 2f       	mov	r24, r22
    3000:	70 e0       	ldi	r23, 0x00	; 0
    3002:	60 e0       	ldi	r22, 0x00	; 0
    3004:	2a f0       	brmi	.+10     	; 0x3010 <__floatsisf+0x6c>
    3006:	9a 95       	dec	r25
    3008:	66 0f       	add	r22, r22
    300a:	77 1f       	adc	r23, r23
    300c:	88 1f       	adc	r24, r24
    300e:	da f7       	brpl	.-10     	; 0x3006 <__floatsisf+0x62>
    3010:	88 0f       	add	r24, r24
    3012:	96 95       	lsr	r25
    3014:	87 95       	ror	r24
    3016:	97 f9       	bld	r25, 7
    3018:	08 95       	ret

0000301a <__fp_inf>:
    301a:	97 f9       	bld	r25, 7
    301c:	9f 67       	ori	r25, 0x7F	; 127
    301e:	80 e8       	ldi	r24, 0x80	; 128
    3020:	70 e0       	ldi	r23, 0x00	; 0
    3022:	60 e0       	ldi	r22, 0x00	; 0
    3024:	08 95       	ret

00003026 <__fp_nan>:
    3026:	9f ef       	ldi	r25, 0xFF	; 255
    3028:	80 ec       	ldi	r24, 0xC0	; 192
    302a:	08 95       	ret

0000302c <__fp_pscA>:
    302c:	00 24       	eor	r0, r0
    302e:	0a 94       	dec	r0
    3030:	16 16       	cp	r1, r22
    3032:	17 06       	cpc	r1, r23
    3034:	18 06       	cpc	r1, r24
    3036:	09 06       	cpc	r0, r25
    3038:	08 95       	ret

0000303a <__fp_pscB>:
    303a:	00 24       	eor	r0, r0
    303c:	0a 94       	dec	r0
    303e:	12 16       	cp	r1, r18
    3040:	13 06       	cpc	r1, r19
    3042:	14 06       	cpc	r1, r20
    3044:	05 06       	cpc	r0, r21
    3046:	08 95       	ret

00003048 <__fp_round>:
    3048:	09 2e       	mov	r0, r25
    304a:	03 94       	inc	r0
    304c:	00 0c       	add	r0, r0
    304e:	11 f4       	brne	.+4      	; 0x3054 <__fp_round+0xc>
    3050:	88 23       	and	r24, r24
    3052:	52 f0       	brmi	.+20     	; 0x3068 <__fp_round+0x20>
    3054:	bb 0f       	add	r27, r27
    3056:	40 f4       	brcc	.+16     	; 0x3068 <__fp_round+0x20>
    3058:	bf 2b       	or	r27, r31
    305a:	11 f4       	brne	.+4      	; 0x3060 <__fp_round+0x18>
    305c:	60 ff       	sbrs	r22, 0
    305e:	04 c0       	rjmp	.+8      	; 0x3068 <__fp_round+0x20>
    3060:	6f 5f       	subi	r22, 0xFF	; 255
    3062:	7f 4f       	sbci	r23, 0xFF	; 255
    3064:	8f 4f       	sbci	r24, 0xFF	; 255
    3066:	9f 4f       	sbci	r25, 0xFF	; 255
    3068:	08 95       	ret

0000306a <__fp_split3>:
    306a:	57 fd       	sbrc	r21, 7
    306c:	90 58       	subi	r25, 0x80	; 128
    306e:	44 0f       	add	r20, r20
    3070:	55 1f       	adc	r21, r21
    3072:	59 f0       	breq	.+22     	; 0x308a <__fp_splitA+0x10>
    3074:	5f 3f       	cpi	r21, 0xFF	; 255
    3076:	71 f0       	breq	.+28     	; 0x3094 <__fp_splitA+0x1a>
    3078:	47 95       	ror	r20

0000307a <__fp_splitA>:
    307a:	88 0f       	add	r24, r24
    307c:	97 fb       	bst	r25, 7
    307e:	99 1f       	adc	r25, r25
    3080:	61 f0       	breq	.+24     	; 0x309a <__fp_splitA+0x20>
    3082:	9f 3f       	cpi	r25, 0xFF	; 255
    3084:	79 f0       	breq	.+30     	; 0x30a4 <__fp_splitA+0x2a>
    3086:	87 95       	ror	r24
    3088:	08 95       	ret
    308a:	12 16       	cp	r1, r18
    308c:	13 06       	cpc	r1, r19
    308e:	14 06       	cpc	r1, r20
    3090:	55 1f       	adc	r21, r21
    3092:	f2 cf       	rjmp	.-28     	; 0x3078 <__fp_split3+0xe>
    3094:	46 95       	lsr	r20
    3096:	f1 df       	rcall	.-30     	; 0x307a <__fp_splitA>
    3098:	08 c0       	rjmp	.+16     	; 0x30aa <__fp_splitA+0x30>
    309a:	16 16       	cp	r1, r22
    309c:	17 06       	cpc	r1, r23
    309e:	18 06       	cpc	r1, r24
    30a0:	99 1f       	adc	r25, r25
    30a2:	f1 cf       	rjmp	.-30     	; 0x3086 <__fp_splitA+0xc>
    30a4:	86 95       	lsr	r24
    30a6:	71 05       	cpc	r23, r1
    30a8:	61 05       	cpc	r22, r1
    30aa:	08 94       	sec
    30ac:	08 95       	ret

000030ae <__fp_zero>:
    30ae:	e8 94       	clt

000030b0 <__fp_szero>:
    30b0:	bb 27       	eor	r27, r27
    30b2:	66 27       	eor	r22, r22
    30b4:	77 27       	eor	r23, r23
    30b6:	cb 01       	movw	r24, r22
    30b8:	97 f9       	bld	r25, 7
    30ba:	08 95       	ret

000030bc <__udivmodsi4>:
    30bc:	a1 e2       	ldi	r26, 0x21	; 33
    30be:	1a 2e       	mov	r1, r26
    30c0:	aa 1b       	sub	r26, r26
    30c2:	bb 1b       	sub	r27, r27
    30c4:	fd 01       	movw	r30, r26
    30c6:	0d c0       	rjmp	.+26     	; 0x30e2 <__udivmodsi4_ep>

000030c8 <__udivmodsi4_loop>:
    30c8:	aa 1f       	adc	r26, r26
    30ca:	bb 1f       	adc	r27, r27
    30cc:	ee 1f       	adc	r30, r30
    30ce:	ff 1f       	adc	r31, r31
    30d0:	a2 17       	cp	r26, r18
    30d2:	b3 07       	cpc	r27, r19
    30d4:	e4 07       	cpc	r30, r20
    30d6:	f5 07       	cpc	r31, r21
    30d8:	20 f0       	brcs	.+8      	; 0x30e2 <__udivmodsi4_ep>
    30da:	a2 1b       	sub	r26, r18
    30dc:	b3 0b       	sbc	r27, r19
    30de:	e4 0b       	sbc	r30, r20
    30e0:	f5 0b       	sbc	r31, r21

000030e2 <__udivmodsi4_ep>:
    30e2:	66 1f       	adc	r22, r22
    30e4:	77 1f       	adc	r23, r23
    30e6:	88 1f       	adc	r24, r24
    30e8:	99 1f       	adc	r25, r25
    30ea:	1a 94       	dec	r1
    30ec:	69 f7       	brne	.-38     	; 0x30c8 <__udivmodsi4_loop>
    30ee:	60 95       	com	r22
    30f0:	70 95       	com	r23
    30f2:	80 95       	com	r24
    30f4:	90 95       	com	r25
    30f6:	9b 01       	movw	r18, r22
    30f8:	ac 01       	movw	r20, r24
    30fa:	bd 01       	movw	r22, r26
    30fc:	cf 01       	movw	r24, r30
    30fe:	08 95       	ret

00003100 <memcpy>:
    3100:	fb 01       	movw	r30, r22
    3102:	dc 01       	movw	r26, r24
    3104:	02 c0       	rjmp	.+4      	; 0x310a <memcpy+0xa>
    3106:	01 90       	ld	r0, Z+
    3108:	0d 92       	st	X+, r0
    310a:	41 50       	subi	r20, 0x01	; 1
    310c:	50 40       	sbci	r21, 0x00	; 0
    310e:	d8 f7       	brcc	.-10     	; 0x3106 <memcpy+0x6>
    3110:	08 95       	ret

00003112 <eeprom_read_byte>:
    3112:	e1 99       	sbic	0x1c, 1	; 28
    3114:	fe cf       	rjmp	.-4      	; 0x3112 <eeprom_read_byte>
    3116:	9f bb       	out	0x1f, r25	; 31
    3118:	8e bb       	out	0x1e, r24	; 30
    311a:	e0 9a       	sbi	0x1c, 0	; 28
    311c:	99 27       	eor	r25, r25
    311e:	8d b3       	in	r24, 0x1d	; 29
    3120:	08 95       	ret

00003122 <eeprom_update_byte>:
    3122:	26 2f       	mov	r18, r22

00003124 <eeprom_update_r18>:
    3124:	e1 99       	sbic	0x1c, 1	; 28
    3126:	fe cf       	rjmp	.-4      	; 0x3124 <eeprom_update_r18>
    3128:	9f bb       	out	0x1f, r25	; 31
    312a:	8e bb       	out	0x1e, r24	; 30
    312c:	e0 9a       	sbi	0x1c, 0	; 28
    312e:	01 97       	sbiw	r24, 0x01	; 1
    3130:	0d b2       	in	r0, 0x1d	; 29
    3132:	02 16       	cp	r0, r18
    3134:	31 f0       	breq	.+12     	; 0x3142 <eeprom_update_r18+0x1e>
    3136:	2d bb       	out	0x1d, r18	; 29
    3138:	0f b6       	in	r0, 0x3f	; 63
    313a:	f8 94       	cli
    313c:	e2 9a       	sbi	0x1c, 2	; 28
    313e:	e1 9a       	sbi	0x1c, 1	; 28
    3140:	0f be       	out	0x3f, r0	; 63
    3142:	08 95       	ret

00003144 <_exit>:
    3144:	f8 94       	cli

00003146 <__stop_program>:
    3146:	ff cf       	rjmp	.-2      	; 0x3146 <__stop_program>
