
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f0  00800100  00003ba6  00003c3a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003ba6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000afe  008001f0  008001f0  00003d2a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003d2a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00003d88  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000a10  00000000  00000000  00003dc8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000cdbe  00000000  00000000  000047d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000357b  00000000  00000000  00011596  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000059b9  00000000  00000000  00014b11  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001aac  00000000  00000000  0001a4cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000380b  00000000  00000000  0001bf78  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00008ac9  00000000  00000000  0001f783  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000009f8  00000000  00000000  0002824c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	34 c4       	rjmp	.+2152   	; 0x86e <__vector_1>
       6:	00 00       	nop
       8:	60 c0       	rjmp	.+192    	; 0xca <__bad_interrupt>
       a:	00 00       	nop
       c:	5e c0       	rjmp	.+188    	; 0xca <__bad_interrupt>
       e:	00 00       	nop
      10:	5c c0       	rjmp	.+184    	; 0xca <__bad_interrupt>
      12:	00 00       	nop
      14:	5a c0       	rjmp	.+180    	; 0xca <__bad_interrupt>
      16:	00 00       	nop
      18:	58 c0       	rjmp	.+176    	; 0xca <__bad_interrupt>
      1a:	00 00       	nop
      1c:	56 c0       	rjmp	.+172    	; 0xca <__bad_interrupt>
      1e:	00 00       	nop
      20:	54 c0       	rjmp	.+168    	; 0xca <__bad_interrupt>
      22:	00 00       	nop
      24:	f7 c4       	rjmp	.+2542   	; 0xa14 <__vector_9>
      26:	00 00       	nop
      28:	50 c0       	rjmp	.+160    	; 0xca <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4e c0       	rjmp	.+156    	; 0xca <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 22 12 	jmp	0x2444	; 0x2444 <__vector_12>
      34:	4a c0       	rjmp	.+148    	; 0xca <__bad_interrupt>
      36:	00 00       	nop
      38:	48 c0       	rjmp	.+144    	; 0xca <__bad_interrupt>
      3a:	00 00       	nop
      3c:	e1 c1       	rjmp	.+962    	; 0x400 <__vector_15>
      3e:	00 00       	nop
      40:	44 c0       	rjmp	.+136    	; 0xca <__bad_interrupt>
      42:	00 00       	nop
      44:	42 c0       	rjmp	.+132    	; 0xca <__bad_interrupt>
      46:	00 00       	nop
      48:	81 c3       	rjmp	.+1794   	; 0x74c <__vector_18>
      4a:	00 00       	nop
      4c:	3e c0       	rjmp	.+124    	; 0xca <__bad_interrupt>
      4e:	00 00       	nop
      50:	3c c0       	rjmp	.+120    	; 0xca <__bad_interrupt>
      52:	00 00       	nop
      54:	3a c0       	rjmp	.+116    	; 0xca <__bad_interrupt>
      56:	00 00       	nop
      58:	38 c0       	rjmp	.+112    	; 0xca <__bad_interrupt>
      5a:	00 00       	nop
      5c:	36 c0       	rjmp	.+108    	; 0xca <__bad_interrupt>
      5e:	00 00       	nop
      60:	34 c0       	rjmp	.+104    	; 0xca <__bad_interrupt>
      62:	00 00       	nop
      64:	32 c0       	rjmp	.+100    	; 0xca <__bad_interrupt>
      66:	00 00       	nop
      68:	30 c0       	rjmp	.+96     	; 0xca <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2e c0       	rjmp	.+92     	; 0xca <__bad_interrupt>
      6e:	00 00       	nop
      70:	ce c3       	rjmp	.+1948   	; 0x80e <__vector_28>
      72:	00 00       	nop
      74:	2a c0       	rjmp	.+84     	; 0xca <__bad_interrupt>
      76:	00 00       	nop
      78:	99 c3       	rjmp	.+1842   	; 0x7ac <__vector_30>
      7a:	00 00       	nop
      7c:	26 c0       	rjmp	.+76     	; 0xca <__bad_interrupt>
      7e:	00 00       	nop
      80:	24 c0       	rjmp	.+72     	; 0xca <__bad_interrupt>
      82:	00 00       	nop
      84:	22 c0       	rjmp	.+68     	; 0xca <__bad_interrupt>
      86:	00 00       	nop
      88:	20 c0       	rjmp	.+64     	; 0xca <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e6 ea       	ldi	r30, 0xA6	; 166
      a0:	fb e3       	ldi	r31, 0x3B	; 59
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a0 3f       	cpi	r26, 0xF0	; 240
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	2c e0       	ldi	r18, 0x0C	; 12
      b4:	a0 ef       	ldi	r26, 0xF0	; 240
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ae 3e       	cpi	r26, 0xEE	; 238
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <main>
      c6:	0c 94 d1 1d 	jmp	0x3ba2	; 0x3ba2 <_exit>

000000ca <__bad_interrupt>:
      ca:	9a cf       	rjmp	.-204    	; 0x0 <__vectors>

000000cc <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      cc:	fc 01       	movw	r30, r24
      ce:	68 0f       	add	r22, r24
      d0:	79 1f       	adc	r23, r25
      d2:	8f ef       	ldi	r24, 0xFF	; 255
      d4:	9f ef       	ldi	r25, 0xFF	; 255
      d6:	e6 17       	cp	r30, r22
      d8:	f7 07       	cpc	r31, r23
      da:	99 f0       	breq	.+38     	; 0x102 <_Z5CRC16Phi+0x36>
      dc:	21 91       	ld	r18, Z+
      de:	82 27       	eor	r24, r18
      e0:	28 e0       	ldi	r18, 0x08	; 8
      e2:	30 e0       	ldi	r19, 0x00	; 0
      e4:	ac 01       	movw	r20, r24
      e6:	41 70       	andi	r20, 0x01	; 1
      e8:	55 27       	eor	r21, r21
      ea:	96 95       	lsr	r25
      ec:	87 95       	ror	r24
      ee:	45 2b       	or	r20, r21
      f0:	21 f0       	breq	.+8      	; 0xfa <_Z5CRC16Phi+0x2e>
      f2:	41 e0       	ldi	r20, 0x01	; 1
      f4:	84 27       	eor	r24, r20
      f6:	40 ea       	ldi	r20, 0xA0	; 160
      f8:	94 27       	eor	r25, r20
      fa:	21 50       	subi	r18, 0x01	; 1
      fc:	31 09       	sbc	r19, r1
      fe:	91 f7       	brne	.-28     	; 0xe4 <_Z5CRC16Phi+0x18>
     100:	ea cf       	rjmp	.-44     	; 0xd6 <_Z5CRC16Phi+0xa>
     102:	08 95       	ret

00000104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     104:	cf 93       	push	r28
     106:	df 93       	push	r29
     108:	dc 01       	movw	r26, r24
     10a:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     10c:	8c 91       	ld	r24, X
     10e:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     110:	11 96       	adiw	r26, 0x01	; 1
     112:	8c 91       	ld	r24, X
     114:	11 97       	sbiw	r26, 0x01	; 1
     116:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     118:	13 96       	adiw	r26, 0x03	; 3
     11a:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     11c:	92 e0       	ldi	r25, 0x02	; 2
     11e:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     120:	e8 2f       	mov	r30, r24
     122:	f0 e0       	ldi	r31, 0x00	; 0
     124:	ee 0f       	add	r30, r30
     126:	ff 1f       	adc	r31, r31
     128:	e4 0f       	add	r30, r20
     12a:	f5 1f       	adc	r31, r21
     12c:	81 81       	ldd	r24, Z+1	; 0x01
     12e:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     130:	80 81       	ld	r24, Z
     132:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     134:	65 e0       	ldi	r22, 0x05	; 5
     136:	70 e0       	ldi	r23, 0x00	; 0
     138:	ce 01       	movw	r24, r28
     13a:	c8 df       	rcall	.-112    	; 0xcc <_Z5CRC16Phi>
	function04->CRC = crc16;
     13c:	9e 83       	std	Y+6, r25	; 0x06
     13e:	8d 83       	std	Y+5, r24	; 0x05
}
     140:	df 91       	pop	r29
     142:	cf 91       	pop	r28
     144:	08 95       	ret

00000146 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     146:	cf 93       	push	r28
     148:	df 93       	push	r29
     14a:	fc 01       	movw	r30, r24
     14c:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     14e:	80 81       	ld	r24, Z
     150:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     156:	82 81       	ldd	r24, Z+2	; 0x02
     158:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     15a:	83 81       	ldd	r24, Z+3	; 0x03
     15c:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     15e:	84 81       	ldd	r24, Z+4	; 0x04
     160:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     162:	85 81       	ldd	r24, Z+5	; 0x05
     164:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     166:	66 e0       	ldi	r22, 0x06	; 6
     168:	70 e0       	ldi	r23, 0x00	; 0
     16a:	ce 01       	movw	r24, r28
     16c:	af df       	rcall	.-162    	; 0xcc <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     16e:	9f 83       	std	Y+7, r25	; 0x07
     170:	8e 83       	std	Y+6, r24	; 0x06
}
     172:	df 91       	pop	r29
     174:	cf 91       	pop	r28
     176:	08 95       	ret

00000178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	fc 01       	movw	r30, r24
     17e:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     180:	80 81       	ld	r24, Z
     182:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     184:	81 81       	ldd	r24, Z+1	; 0x01
     186:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     188:	82 81       	ldd	r24, Z+2	; 0x02
     18a:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     18c:	83 81       	ldd	r24, Z+3	; 0x03
     18e:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     190:	94 81       	ldd	r25, Z+4	; 0x04
     192:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     194:	95 81       	ldd	r25, Z+5	; 0x05
     196:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     198:	96 81       	ldd	r25, Z+6	; 0x06
     19a:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     19c:	27 81       	ldd	r18, Z+7	; 0x07
     19e:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1a0:	90 85       	ldd	r25, Z+8	; 0x08
     1a2:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1a4:	e8 2f       	mov	r30, r24
     1a6:	f0 e0       	ldi	r31, 0x00	; 0
     1a8:	ee 0f       	add	r30, r30
     1aa:	ff 1f       	adc	r31, r31
     1ac:	e4 0f       	add	r30, r20
     1ae:	f5 1f       	adc	r31, r21
     1b0:	89 2f       	mov	r24, r25
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	92 2b       	or	r25, r18
     1b6:	91 83       	std	Z+1, r25	; 0x01
     1b8:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1ba:	69 e0       	ldi	r22, 0x09	; 9
     1bc:	70 e0       	ldi	r23, 0x00	; 0
     1be:	ce 01       	movw	r24, r28
     1c0:	85 df       	rcall	.-246    	; 0xcc <_Z5CRC16Phi>
	function10->CRC = crc16;
     1c2:	9a 87       	std	Y+10, r25	; 0x0a
     1c4:	89 87       	std	Y+9, r24	; 0x09
}
     1c6:	df 91       	pop	r29
     1c8:	cf 91       	pop	r28
     1ca:	08 95       	ret

000001cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	fc 01       	movw	r30, r24
     1d2:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1d4:	80 81       	ld	r24, Z
     1d6:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1d8:	81 81       	ldd	r24, Z+1	; 0x01
     1da:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1dc:	82 81       	ldd	r24, Z+2	; 0x02
     1de:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1e0:	83 81       	ldd	r24, Z+3	; 0x03
     1e2:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     1e8:	85 81       	ldd	r24, Z+5	; 0x05
     1ea:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     1ec:	66 e0       	ldi	r22, 0x06	; 6
     1ee:	70 e0       	ldi	r23, 0x00	; 0
     1f0:	ce 01       	movw	r24, r28
     1f2:	6c df       	rcall	.-296    	; 0xcc <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     1f4:	9f 83       	std	Y+7, r25	; 0x07
     1f6:	8e 83       	std	Y+6, r24	; 0x06
}
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	08 95       	ret

000001fe <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     204:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     206:	81 e8       	ldi	r24, 0x81	; 129
     208:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     20a:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     20c:	63 e0       	ldi	r22, 0x03	; 3
     20e:	70 e0       	ldi	r23, 0x00	; 0
     210:	ce 01       	movw	r24, r28
     212:	5c df       	rcall	.-328    	; 0xcc <_Z5CRC16Phi>
	Exception->CRC = crc16;
     214:	9c 83       	std	Y+4, r25	; 0x04
     216:	8b 83       	std	Y+3, r24	; 0x03
}
     218:	df 91       	pop	r29
     21a:	cf 91       	pop	r28
     21c:	08 95       	ret

0000021e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     21e:	1f 93       	push	r17
     220:	cf 93       	push	r28
     222:	df 93       	push	r29
     224:	ec 01       	movw	r28, r24
     226:	cb 01       	movw	r24, r22
     228:	14 2f       	mov	r17, r20
     22a:	fe 01       	movw	r30, r28
     22c:	ea 57       	subi	r30, 0x7A	; 122
     22e:	ff 4f       	sbci	r31, 0xFF	; 255
     230:	71 83       	std	Z+1, r23	; 0x01
     232:	60 83       	st	Z, r22
     234:	64 2f       	mov	r22, r20
     236:	74 d2       	rcall	.+1256   	; 0x720 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     238:	88 23       	and	r24, r24
     23a:	71 f0       	breq	.+28     	; 0x258 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     23c:	fe 01       	movw	r30, r28
     23e:	eb 57       	subi	r30, 0x7B	; 123
     240:	ff 4f       	sbci	r31, 0xFF	; 255
     242:	10 83       	st	Z, r17
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	10 82       	st	Z, r1
     248:	34 97       	sbiw	r30, 0x04	; 4
     24a:	11 82       	std	Z+1, r1	; 0x01
     24c:	10 82       	st	Z, r1
     24e:	ce 57       	subi	r28, 0x7E	; 126
     250:	df 4f       	sbci	r29, 0xFF	; 255
     252:	19 82       	std	Y+1, r1	; 0x01
     254:	18 82       	st	Y, r1
     256:	04 c0       	rjmp	.+8      	; 0x260 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     258:	ca 57       	subi	r28, 0x7A	; 122
     25a:	df 4f       	sbci	r29, 0xFF	; 255
     25c:	19 82       	std	Y+1, r1	; 0x01
     25e:	18 82       	st	Y, r1
     260:	df 91       	pop	r29
     262:	cf 91       	pop	r28
     264:	1f 91       	pop	r17
     266:	08 95       	ret

00000268 <_ZN12SerialBuffernwEj>:
     268:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
     26c:	08 95       	ret

0000026e <_ZN12SerialBuffer11SerialstoreEc>:
     26e:	fc 01       	movw	r30, r24
     270:	e0 58       	subi	r30, 0x80	; 128
     272:	ff 4f       	sbci	r31, 0xFF	; 255
     274:	20 81       	ld	r18, Z
     276:	2f 5f       	subi	r18, 0xFF	; 255
     278:	2f 77       	andi	r18, 0x7F	; 127
     27a:	19 f4       	brne	.+6      	; 0x282 <_ZN12SerialBuffer11SerialstoreEc+0x14>
     27c:	11 82       	std	Z+1, r1	; 0x01
     27e:	10 82       	st	Z, r1
     280:	21 e0       	ldi	r18, 0x01	; 1
     282:	30 e0       	ldi	r19, 0x00	; 0
     284:	fc 01       	movw	r30, r24
     286:	ee 57       	subi	r30, 0x7E	; 126
     288:	ff 4f       	sbci	r31, 0xFF	; 255
     28a:	40 81       	ld	r20, Z
     28c:	51 81       	ldd	r21, Z+1	; 0x01
     28e:	24 17       	cp	r18, r20
     290:	35 07       	cpc	r19, r21
     292:	89 f0       	breq	.+34     	; 0x2b6 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     294:	dc 01       	movw	r26, r24
     296:	a0 58       	subi	r26, 0x80	; 128
     298:	bf 4f       	sbci	r27, 0xFF	; 255
     29a:	ed 91       	ld	r30, X+
     29c:	fc 91       	ld	r31, X
     29e:	11 97       	sbiw	r26, 0x01	; 1
     2a0:	e8 0f       	add	r30, r24
     2a2:	f9 1f       	adc	r31, r25
     2a4:	61 83       	std	Z+1, r22	; 0x01
     2a6:	2d 93       	st	X+, r18
     2a8:	3c 93       	st	X, r19
     2aa:	fc 01       	movw	r30, r24
     2ac:	ec 57       	subi	r30, 0x7C	; 124
     2ae:	ff 4f       	sbci	r31, 0xFF	; 255
     2b0:	80 81       	ld	r24, Z
     2b2:	8f 5f       	subi	r24, 0xFF	; 255
     2b4:	80 83       	st	Z, r24
     2b6:	08 95       	ret

000002b8 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2b8:	af 92       	push	r10
     2ba:	bf 92       	push	r11
     2bc:	cf 92       	push	r12
     2be:	df 92       	push	r13
     2c0:	ef 92       	push	r14
     2c2:	ff 92       	push	r15
     2c4:	0f 93       	push	r16
     2c6:	1f 93       	push	r17
     2c8:	cf 93       	push	r28
     2ca:	8c 01       	movw	r16, r24
     2cc:	6b 01       	movw	r12, r22
     2ce:	7a 01       	movw	r14, r20
     2d0:	dc 01       	movw	r26, r24
     2d2:	ab 57       	subi	r26, 0x7B	; 123
     2d4:	bf 4f       	sbci	r27, 0xFF	; 255
     2d6:	fc 01       	movw	r30, r24
     2d8:	ea 57       	subi	r30, 0x7A	; 122
     2da:	ff 4f       	sbci	r31, 0xFF	; 255
     2dc:	6c 91       	ld	r22, X
     2de:	80 81       	ld	r24, Z
     2e0:	91 81       	ldd	r25, Z+1	; 0x01
     2e2:	2b d2       	rcall	.+1110   	; 0x73a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2e4:	89 2b       	or	r24, r25
     2e6:	d1 f0       	breq	.+52     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2e8:	1e 14       	cp	r1, r14
     2ea:	1f 04       	cpc	r1, r15
     2ec:	bc f4       	brge	.+46     	; 0x31c <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     2ee:	c0 e0       	ldi	r28, 0x00	; 0
     2f0:	58 01       	movw	r10, r16
     2f2:	85 e8       	ldi	r24, 0x85	; 133
     2f4:	a8 0e       	add	r10, r24
     2f6:	b1 1c       	adc	r11, r1
     2f8:	0a 57       	subi	r16, 0x7A	; 122
     2fa:	1f 4f       	sbci	r17, 0xFF	; 255
     2fc:	f6 01       	movw	r30, r12
     2fe:	ec 0f       	add	r30, r28
     300:	f1 1d       	adc	r31, r1
     302:	40 81       	ld	r20, Z
     304:	f5 01       	movw	r30, r10
     306:	60 81       	ld	r22, Z
     308:	f8 01       	movw	r30, r16
     30a:	80 81       	ld	r24, Z
     30c:	91 81       	ldd	r25, Z+1	; 0x01
     30e:	c1 d1       	rcall	.+898    	; 0x692 <_ZN11Dev_Manager5WriteE8Dev_typec>
     310:	cf 5f       	subi	r28, 0xFF	; 255
     312:	2c 2f       	mov	r18, r28
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	2e 15       	cp	r18, r14
     318:	3f 05       	cpc	r19, r15
     31a:	84 f3       	brlt	.-32     	; 0x2fc <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	bf 90       	pop	r11
     32c:	af 90       	pop	r10
     32e:	08 95       	ret

00000330 <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     330:	fc 01       	movw	r30, r24
     332:	ee 57       	subi	r30, 0x7E	; 126
     334:	ff 4f       	sbci	r31, 0xFF	; 255
     336:	20 81       	ld	r18, Z
     338:	31 81       	ldd	r19, Z+1	; 0x01
     33a:	32 97       	sbiw	r30, 0x02	; 2
     33c:	40 81       	ld	r20, Z
     33e:	51 81       	ldd	r21, Z+1	; 0x01
     340:	42 17       	cp	r20, r18
     342:	53 07       	cpc	r21, r19
     344:	e9 f0       	breq	.+58     	; 0x380 <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     346:	2f 5f       	subi	r18, 0xFF	; 255
     348:	3f 4f       	sbci	r19, 0xFF	; 255
     34a:	fc 01       	movw	r30, r24
     34c:	e2 0f       	add	r30, r18
     34e:	f3 1f       	adc	r31, r19
     350:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     352:	2f 77       	andi	r18, 0x7F	; 127
     354:	33 27       	eor	r19, r19
     356:	fc 01       	movw	r30, r24
     358:	ee 57       	subi	r30, 0x7E	; 126
     35a:	ff 4f       	sbci	r31, 0xFF	; 255
     35c:	31 83       	std	Z+1, r19	; 0x01
     35e:	20 83       	st	Z, r18
		if (ib.tail == num)
     360:	32 96       	adiw	r30, 0x02	; 2
     362:	60 81       	ld	r22, Z
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	26 17       	cp	r18, r22
     368:	37 07       	cpc	r19, r23
     36a:	61 f4       	brne	.+24     	; 0x384 <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     36c:	32 97       	sbiw	r30, 0x02	; 2
     36e:	11 82       	std	Z+1, r1	; 0x01
     370:	10 82       	st	Z, r1
			ib.head = 0;
     372:	32 97       	sbiw	r30, 0x02	; 2
     374:	11 82       	std	Z+1, r1	; 0x01
     376:	10 82       	st	Z, r1
			num = 0;
     378:	34 96       	adiw	r30, 0x04	; 4
     37a:	10 82       	st	Z, r1
		}
		return data;
     37c:	84 2f       	mov	r24, r20
     37e:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     380:	8f ef       	ldi	r24, 0xFF	; 255
     382:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     384:	84 2f       	mov	r24, r20
	}
}
     386:	08 95       	ret

00000388 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     388:	dc 01       	movw	r26, r24
     38a:	a0 58       	subi	r26, 0x80	; 128
     38c:	bf 4f       	sbci	r27, 0xFF	; 255
     38e:	fc 01       	movw	r30, r24
     390:	ee 57       	subi	r30, 0x7E	; 126
     392:	ff 4f       	sbci	r31, 0xFF	; 255
     394:	8c 91       	ld	r24, X
     396:	90 81       	ld	r25, Z
     398:	89 1b       	sub	r24, r25
}
     39a:	8f 77       	andi	r24, 0x7F	; 127
     39c:	08 95       	ret

0000039e <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     39e:	fc 01       	movw	r30, r24
     3a0:	ee 57       	subi	r30, 0x7E	; 126
     3a2:	ff 4f       	sbci	r31, 0xFF	; 255
     3a4:	11 82       	std	Z+1, r1	; 0x01
     3a6:	10 82       	st	Z, r1
	ib.head = 0;
     3a8:	32 97       	sbiw	r30, 0x02	; 2
     3aa:	11 82       	std	Z+1, r1	; 0x01
     3ac:	10 82       	st	Z, r1
	num = 0;
     3ae:	34 96       	adiw	r30, 0x04	; 4
     3b0:	10 82       	st	Z, r1
     3b2:	08 95       	ret

000003b4 <Alarm_Init>:
	AlarmTable[Alarm].Time = 0;
	AlarmTable[Alarm].alarm_Handle = Handle;
}
void Alarm_Close(Alarm_t Alarm)
{
	AlarmTable[Alarm].alarm_Handle = NULL;
     3b4:	8c e0       	ldi	r24, 0x0C	; 12
     3b6:	83 bf       	out	0x33, r24	; 51
     3b8:	8c e7       	ldi	r24, 0x7C	; 124
     3ba:	81 bf       	out	0x31, r24	; 49
     3bc:	87 b7       	in	r24, 0x37	; 55
     3be:	82 60       	ori	r24, 0x02	; 2
     3c0:	87 bf       	out	0x37, r24	; 55
     3c2:	08 95       	ret

000003c4 <Alarm_Stop>:
     3c4:	87 b7       	in	r24, 0x37	; 55
     3c6:	8d 7f       	andi	r24, 0xFD	; 253
     3c8:	87 bf       	out	0x37, r24	; 55
     3ca:	08 95       	ret

000003cc <Alarm_Start>:
     3cc:	87 b7       	in	r24, 0x37	; 55
     3ce:	82 60       	ori	r24, 0x02	; 2
     3d0:	87 bf       	out	0x37, r24	; 55
     3d2:	08 95       	ret

000003d4 <Alarm_Open>:
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	fc 01       	movw	r30, r24
     3d8:	ee 0f       	add	r30, r30
     3da:	ff 1f       	adc	r31, r31
     3dc:	df 01       	movw	r26, r30
     3de:	a8 0f       	add	r26, r24
     3e0:	b9 1f       	adc	r27, r25
     3e2:	aa 0f       	add	r26, r26
     3e4:	bb 1f       	adc	r27, r27
     3e6:	a0 51       	subi	r26, 0x10	; 16
     3e8:	be 4f       	sbci	r27, 0xFE	; 254
     3ea:	11 96       	adiw	r26, 0x01	; 1
     3ec:	7c 93       	st	X, r23
     3ee:	6e 93       	st	-X, r22
     3f0:	13 96       	adiw	r26, 0x03	; 3
     3f2:	1c 92       	st	X, r1
     3f4:	1e 92       	st	-X, r1
     3f6:	12 97       	sbiw	r26, 0x02	; 2
     3f8:	fd 01       	movw	r30, r26
     3fa:	55 83       	std	Z+5, r21	; 0x05
     3fc:	44 83       	std	Z+4, r20	; 0x04
     3fe:	08 95       	ret

00000400 <__vector_15>:
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
     400:	1f 92       	push	r1
     402:	0f 92       	push	r0
     404:	0f b6       	in	r0, 0x3f	; 63
     406:	0f 92       	push	r0
     408:	11 24       	eor	r1, r1
     40a:	0b b6       	in	r0, 0x3b	; 59
     40c:	0f 92       	push	r0
     40e:	ef 92       	push	r14
     410:	ff 92       	push	r15
     412:	0f 93       	push	r16
     414:	1f 93       	push	r17
     416:	2f 93       	push	r18
     418:	3f 93       	push	r19
     41a:	4f 93       	push	r20
     41c:	5f 93       	push	r21
     41e:	6f 93       	push	r22
     420:	7f 93       	push	r23
     422:	8f 93       	push	r24
     424:	9f 93       	push	r25
     426:	af 93       	push	r26
     428:	bf 93       	push	r27
     42a:	cf 93       	push	r28
     42c:	df 93       	push	r29
     42e:	ef 93       	push	r30
     430:	ff 93       	push	r31
     432:	c0 ef       	ldi	r28, 0xF0	; 240
     434:	d1 e0       	ldi	r29, 0x01	; 1
     436:	0f 2e       	mov	r0, r31
     438:	fe e0       	ldi	r31, 0x0E	; 14
     43a:	ef 2e       	mov	r14, r31
     43c:	f2 e0       	ldi	r31, 0x02	; 2
     43e:	ff 2e       	mov	r15, r31
     440:	f0 2d       	mov	r31, r0
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
	{
		if(AlarmTable[i].alarm_Handle)
     442:	ec 81       	ldd	r30, Y+4	; 0x04
     444:	fd 81       	ldd	r31, Y+5	; 0x05
     446:	30 97       	sbiw	r30, 0x00	; 0
     448:	79 f0       	breq	.+30     	; 0x468 <__vector_15+0x68>
		{
			AlarmTable[i].Time++;
     44a:	8a 81       	ldd	r24, Y+2	; 0x02
     44c:	9b 81       	ldd	r25, Y+3	; 0x03
     44e:	01 96       	adiw	r24, 0x01	; 1
     450:	9b 83       	std	Y+3, r25	; 0x03
     452:	8a 83       	std	Y+2, r24	; 0x02
			if(AlarmTable[i].Period == AlarmTable[i].Time)
     454:	28 81       	ld	r18, Y
     456:	39 81       	ldd	r19, Y+1	; 0x01
     458:	82 17       	cp	r24, r18
     45a:	93 07       	cpc	r25, r19
     45c:	29 f4       	brne	.+10     	; 0x468 <__vector_15+0x68>
			{
				AlarmTable[i].Time = 0;
     45e:	1b 82       	std	Y+3, r1	; 0x03
     460:	1a 82       	std	Y+2, r1	; 0x02
				AlarmTable[i].alarm_Handle();
     462:	09 95       	icall
				AlarmTable[i].alarm_Handle = NULL;
     464:	1d 82       	std	Y+5, r1	; 0x05
     466:	1c 82       	std	Y+4, r1	; 0x04
     468:	26 96       	adiw	r28, 0x06	; 6
}
/*5ms마다 호출됨 */
void TIMER0_COMP_vect(void)
{
	uint8_t i;
	for(i=0;i<ALARM_MAX;i++)
     46a:	ce 15       	cp	r28, r14
     46c:	df 05       	cpc	r29, r15
     46e:	49 f7       	brne	.-46     	; 0x442 <__vector_15+0x42>
				AlarmTable[i].alarm_Handle();
				AlarmTable[i].alarm_Handle = NULL;
			}
		}
	}
}
     470:	ff 91       	pop	r31
     472:	ef 91       	pop	r30
     474:	df 91       	pop	r29
     476:	cf 91       	pop	r28
     478:	bf 91       	pop	r27
     47a:	af 91       	pop	r26
     47c:	9f 91       	pop	r25
     47e:	8f 91       	pop	r24
     480:	7f 91       	pop	r23
     482:	6f 91       	pop	r22
     484:	5f 91       	pop	r21
     486:	4f 91       	pop	r20
     488:	3f 91       	pop	r19
     48a:	2f 91       	pop	r18
     48c:	1f 91       	pop	r17
     48e:	0f 91       	pop	r16
     490:	ff 90       	pop	r15
     492:	ef 90       	pop	r14
     494:	0f 90       	pop	r0
     496:	0b be       	out	0x3b, r0	; 59
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0
     49e:	1f 90       	pop	r1
     4a0:	18 95       	reti

000004a2 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:

class DeviceDriveInterFace
{
	public:
	virtual void Device_Init() = 0;
	virtual char Device_Read() const{return 0;}
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	08 95       	ret

000004a6 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
	virtual void Device_Writes(const char* data){}
     4a6:	08 95       	ret

000004a8 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
	virtual void Device_Write(char data){}
     4a8:	08 95       	ret

000004aa <_ZN20DeviceDriveInterFace11Stop_DeviceEv>:
	virtual void Stop_Device(void){}
     4aa:	08 95       	ret

000004ac <_ZN20DeviceDriveInterFace12Start_DeviceEv>:
	virtual void Start_Device(void){}
     4ac:	08 95       	ret

000004ae <_ZN13Char_LCD2004A5delayEc>:
	if(addr < 8)
		this->Data_set(addr);
}
void Char_LCD2004A::operator delete(void* ptr)
{
	free(ptr);
     4ae:	66 23       	and	r22, r22
     4b0:	51 f0       	breq	.+20     	; 0x4c6 <_ZN13Char_LCD2004A5delayEc+0x18>
     4b2:	80 e0       	ldi	r24, 0x00	; 0
     4b4:	ef ec       	ldi	r30, 0xCF	; 207
     4b6:	f7 e0       	ldi	r31, 0x07	; 7
     4b8:	31 97       	sbiw	r30, 0x01	; 1
     4ba:	f1 f7       	brne	.-4      	; 0x4b8 <_ZN13Char_LCD2004A5delayEc+0xa>
     4bc:	00 c0       	rjmp	.+0      	; 0x4be <_ZN13Char_LCD2004A5delayEc+0x10>
     4be:	00 00       	nop
     4c0:	8f 5f       	subi	r24, 0xFF	; 255
     4c2:	68 13       	cpse	r22, r24
     4c4:	f7 cf       	rjmp	.-18     	; 0x4b4 <_ZN13Char_LCD2004A5delayEc+0x6>
     4c6:	08 95       	ret

000004c8 <_ZN13Char_LCD2004A11Command_SetEc>:
     4c8:	0f 93       	push	r16
     4ca:	1f 93       	push	r17
     4cc:	cf 93       	push	r28
     4ce:	8c 01       	movw	r16, r24
     4d0:	c6 2f       	mov	r28, r22
     4d2:	d8 98       	cbi	0x1b, 0	; 27
     4d4:	86 2f       	mov	r24, r22
     4d6:	80 7f       	andi	r24, 0xF0	; 240
     4d8:	8b bb       	out	0x1b, r24	; 27
     4da:	d9 9a       	sbi	0x1b, 1	; 27
     4dc:	61 e0       	ldi	r22, 0x01	; 1
     4de:	c8 01       	movw	r24, r16
     4e0:	e6 df       	rcall	.-52     	; 0x4ae <_ZN13Char_LCD2004A5delayEc>
     4e2:	d9 98       	cbi	0x1b, 1	; 27
     4e4:	c2 95       	swap	r28
     4e6:	c0 7f       	andi	r28, 0xF0	; 240
     4e8:	cb bb       	out	0x1b, r28	; 27
     4ea:	d9 9a       	sbi	0x1b, 1	; 27
     4ec:	61 e0       	ldi	r22, 0x01	; 1
     4ee:	c8 01       	movw	r24, r16
     4f0:	de df       	rcall	.-68     	; 0x4ae <_ZN13Char_LCD2004A5delayEc>
     4f2:	d9 98       	cbi	0x1b, 1	; 27
     4f4:	cf 91       	pop	r28
     4f6:	1f 91       	pop	r17
     4f8:	0f 91       	pop	r16
     4fa:	08 95       	ret

000004fc <_ZN13Char_LCD2004A8Data_setEc>:
     4fc:	0f 93       	push	r16
     4fe:	1f 93       	push	r17
     500:	cf 93       	push	r28
     502:	8c 01       	movw	r16, r24
     504:	c6 2f       	mov	r28, r22
     506:	d8 9a       	sbi	0x1b, 0	; 27
     508:	86 2f       	mov	r24, r22
     50a:	80 7f       	andi	r24, 0xF0	; 240
     50c:	81 60       	ori	r24, 0x01	; 1
     50e:	8b bb       	out	0x1b, r24	; 27
     510:	d9 9a       	sbi	0x1b, 1	; 27
     512:	61 e0       	ldi	r22, 0x01	; 1
     514:	c8 01       	movw	r24, r16
     516:	cb df       	rcall	.-106    	; 0x4ae <_ZN13Char_LCD2004A5delayEc>
     518:	d9 98       	cbi	0x1b, 1	; 27
     51a:	80 e1       	ldi	r24, 0x10	; 16
     51c:	c8 9f       	mul	r28, r24
     51e:	b0 01       	movw	r22, r0
     520:	11 24       	eor	r1, r1
     522:	61 60       	ori	r22, 0x01	; 1
     524:	6b bb       	out	0x1b, r22	; 27
     526:	d9 9a       	sbi	0x1b, 1	; 27
     528:	61 e0       	ldi	r22, 0x01	; 1
     52a:	c8 01       	movw	r24, r16
     52c:	c0 df       	rcall	.-128    	; 0x4ae <_ZN13Char_LCD2004A5delayEc>
     52e:	d9 98       	cbi	0x1b, 1	; 27
     530:	cf 91       	pop	r28
     532:	1f 91       	pop	r17
     534:	0f 91       	pop	r16
     536:	08 95       	ret

00000538 <_ZN13Char_LCD2004A13Device_WritesEPKc>:
     538:	0f 93       	push	r16
     53a:	1f 93       	push	r17
     53c:	cf 93       	push	r28
     53e:	df 93       	push	r29
     540:	eb 01       	movw	r28, r22
     542:	68 81       	ld	r22, Y
     544:	66 23       	and	r22, r22
     546:	39 f0       	breq	.+14     	; 0x556 <_ZN13Char_LCD2004A13Device_WritesEPKc+0x1e>
     548:	8c 01       	movw	r16, r24
     54a:	21 96       	adiw	r28, 0x01	; 1
     54c:	c8 01       	movw	r24, r16
     54e:	d6 df       	rcall	.-84     	; 0x4fc <_ZN13Char_LCD2004A8Data_setEc>
     550:	69 91       	ld	r22, Y+
     552:	61 11       	cpse	r22, r1
     554:	fb cf       	rjmp	.-10     	; 0x54c <_ZN13Char_LCD2004A13Device_WritesEPKc+0x14>
     556:	df 91       	pop	r29
     558:	cf 91       	pop	r28
     55a:	1f 91       	pop	r17
     55c:	0f 91       	pop	r16
     55e:	08 95       	ret

00000560 <_ZN13Char_LCD2004A9Clear_LcdEv>:
     560:	cf 93       	push	r28
     562:	df 93       	push	r29
     564:	ec 01       	movw	r28, r24
     566:	61 e0       	ldi	r22, 0x01	; 1
     568:	af df       	rcall	.-162    	; 0x4c8 <_ZN13Char_LCD2004A11Command_SetEc>
     56a:	65 e0       	ldi	r22, 0x05	; 5
     56c:	ce 01       	movw	r24, r28
     56e:	9f df       	rcall	.-194    	; 0x4ae <_ZN13Char_LCD2004A5delayEc>
     570:	df 91       	pop	r29
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <_ZN13Char_LCD2004A11Device_InitEv>:
     576:	cf 93       	push	r28
     578:	df 93       	push	r29
     57a:	ec 01       	movw	r28, r24
     57c:	8f ef       	ldi	r24, 0xFF	; 255
     57e:	8b bb       	out	0x1b, r24	; 27
     580:	68 e2       	ldi	r22, 0x28	; 40
     582:	ce 01       	movw	r24, r28
     584:	a1 df       	rcall	.-190    	; 0x4c8 <_ZN13Char_LCD2004A11Command_SetEc>
     586:	66 e0       	ldi	r22, 0x06	; 6
     588:	ce 01       	movw	r24, r28
     58a:	9e df       	rcall	.-196    	; 0x4c8 <_ZN13Char_LCD2004A11Command_SetEc>
     58c:	6c e0       	ldi	r22, 0x0C	; 12
     58e:	ce 01       	movw	r24, r28
     590:	9b df       	rcall	.-202    	; 0x4c8 <_ZN13Char_LCD2004A11Command_SetEc>
     592:	ce 01       	movw	r24, r28
     594:	e5 df       	rcall	.-54     	; 0x560 <_ZN13Char_LCD2004A9Clear_LcdEv>
     596:	df 91       	pop	r29
     598:	cf 91       	pop	r28
     59a:	08 95       	ret

0000059c <_ZN13Char_LCD2004AC1Ev>:
     59c:	2b e0       	ldi	r18, 0x0B	; 11
     59e:	31 e0       	ldi	r19, 0x01	; 1
     5a0:	fc 01       	movw	r30, r24
     5a2:	31 83       	std	Z+1, r19	; 0x01
     5a4:	20 83       	st	Z, r18
     5a6:	2f ef       	ldi	r18, 0xFF	; 255
     5a8:	2a bb       	out	0x1a, r18	; 26
     5aa:	e5 cf       	rjmp	.-54     	; 0x576 <_ZN13Char_LCD2004A11Device_InitEv>
     5ac:	08 95       	ret

000005ae <_ZN13Char_LCD2004A10Cursor_SetEcc>:
     5ae:	41 30       	cpi	r20, 0x01	; 1
     5b0:	41 f0       	breq	.+16     	; 0x5c2 <_ZN13Char_LCD2004A10Cursor_SetEcc+0x14>
     5b2:	28 f0       	brcs	.+10     	; 0x5be <_ZN13Char_LCD2004A10Cursor_SetEcc+0x10>
     5b4:	42 30       	cpi	r20, 0x02	; 2
     5b6:	39 f0       	breq	.+14     	; 0x5c6 <_ZN13Char_LCD2004A10Cursor_SetEcc+0x18>
     5b8:	43 30       	cpi	r20, 0x03	; 3
     5ba:	39 f0       	breq	.+14     	; 0x5ca <_ZN13Char_LCD2004A10Cursor_SetEcc+0x1c>
     5bc:	07 c0       	rjmp	.+14     	; 0x5cc <_ZN13Char_LCD2004A10Cursor_SetEcc+0x1e>
     5be:	40 e8       	ldi	r20, 0x80	; 128
     5c0:	05 c0       	rjmp	.+10     	; 0x5cc <_ZN13Char_LCD2004A10Cursor_SetEcc+0x1e>
     5c2:	40 ec       	ldi	r20, 0xC0	; 192
     5c4:	03 c0       	rjmp	.+6      	; 0x5cc <_ZN13Char_LCD2004A10Cursor_SetEcc+0x1e>
     5c6:	44 e9       	ldi	r20, 0x94	; 148
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <_ZN13Char_LCD2004A10Cursor_SetEcc+0x1e>
     5ca:	44 ed       	ldi	r20, 0xD4	; 212
     5cc:	64 0f       	add	r22, r20
     5ce:	7c cf       	rjmp	.-264    	; 0x4c8 <_ZN13Char_LCD2004A11Command_SetEc>
     5d0:	08 95       	ret

000005d2 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc>:
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	8c 01       	movw	r16, r24
     5dc:	e9 01       	movw	r28, r18
     5de:	e7 df       	rcall	.-50     	; 0x5ae <_ZN13Char_LCD2004A10Cursor_SetEcc>
     5e0:	68 81       	ld	r22, Y
     5e2:	66 23       	and	r22, r22
     5e4:	31 f0       	breq	.+12     	; 0x5f2 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc+0x20>
     5e6:	21 96       	adiw	r28, 0x01	; 1
     5e8:	c8 01       	movw	r24, r16
     5ea:	88 df       	rcall	.-240    	; 0x4fc <_ZN13Char_LCD2004A8Data_setEc>
     5ec:	69 91       	ld	r22, Y+
     5ee:	61 11       	cpse	r22, r1
     5f0:	fb cf       	rjmp	.-10     	; 0x5e8 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc+0x16>
     5f2:	df 91       	pop	r29
     5f4:	cf 91       	pop	r28
     5f6:	1f 91       	pop	r17
     5f8:	0f 91       	pop	r16
     5fa:	08 95       	ret

000005fc <_ZN13Char_LCD2004AnwEj>:
}
void* Char_LCD2004A::operator new(size_t size)
{
	return malloc(size);
     5fc:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
}
     600:	08 95       	ret

00000602 <_ZN12Count_Sensor11Device_InitEv>:
#define cbi(PORTX, BitX) PORTX &= ~(1 << BitX)
void Count_Sensor::Device_Init()
{
	//cbi(DDRD,0); //PORTD 0PIN INPUT
	//sbi(PORTD,0); //USE PULL UP
	DDRD = 0x00;
     602:	11 ba       	out	0x11, r1	; 17
	PORTD = 0xFF;
     604:	8f ef       	ldi	r24, 0xFF	; 255
     606:	82 bb       	out	0x12, r24	; 18
	sbi(EICRA,1);
     608:	ea e6       	ldi	r30, 0x6A	; 106
     60a:	f0 e0       	ldi	r31, 0x00	; 0
     60c:	80 81       	ld	r24, Z
     60e:	82 60       	ori	r24, 0x02	; 2
     610:	80 83       	st	Z, r24
	cbi(EICRA,0);  // ISC10 = 1 ISC00 = 0;
     612:	80 81       	ld	r24, Z
     614:	8e 7f       	andi	r24, 0xFE	; 254
     616:	80 83       	st	Z, r24
	sbi(EIMSK,0);  // 0Pin interrupt Enable;
     618:	89 b7       	in	r24, 0x39	; 57
     61a:	81 60       	ori	r24, 0x01	; 1
     61c:	89 bf       	out	0x39, r24	; 57
     61e:	08 95       	ret

00000620 <_ZN12Count_SensornwEj>:
}
void* Count_Sensor::operator new(size_t size)
{
	return malloc(size);
     620:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
}
     624:	08 95       	ret

00000626 <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     626:	28 e0       	ldi	r18, 0x08	; 8
     628:	dc 01       	movw	r26, r24
     62a:	e2 2f       	mov	r30, r18
     62c:	1d 92       	st	X+, r1
     62e:	ea 95       	dec	r30
     630:	e9 f7       	brne	.-6      	; 0x62c <_ZN11Dev_ManagerC1Ev+0x6>
     632:	fc 01       	movw	r30, r24
     634:	38 96       	adiw	r30, 0x08	; 8
     636:	df 01       	movw	r26, r30
     638:	1d 92       	st	X+, r1
     63a:	2a 95       	dec	r18
     63c:	e9 f7       	brne	.-6      	; 0x638 <_ZN11Dev_ManagerC1Ev+0x12>
     63e:	90 93 0f 02 	sts	0x020F, r25	; 0x80020f <_ZN11Dev_Manager4instE+0x1>
     642:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <_ZN11Dev_Manager4instE>
     646:	08 95       	ret

00000648 <_ZN11Dev_Manager11getInstanceEv>:
     648:	cf 93       	push	r28
     64a:	df 93       	push	r29
     64c:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <_ZN11Dev_Manager4instE>
     650:	90 91 0f 02 	lds	r25, 0x020F	; 0x80020f <_ZN11Dev_Manager4instE+0x1>
     654:	89 2b       	or	r24, r25
     656:	51 f4       	brne	.+20     	; 0x66c <_ZN11Dev_Manager11getInstanceEv+0x24>
     658:	80 e1       	ldi	r24, 0x10	; 16
     65a:	90 e0       	ldi	r25, 0x00	; 0
     65c:	0e 94 11 10 	call	0x2022	; 0x2022 <pvPortMalloc>
     660:	ec 01       	movw	r28, r24
     662:	e1 df       	rcall	.-62     	; 0x626 <_ZN11Dev_ManagerC1Ev>
     664:	d0 93 0f 02 	sts	0x020F, r29	; 0x80020f <_ZN11Dev_Manager4instE+0x1>
     668:	c0 93 0e 02 	sts	0x020E, r28	; 0x80020e <_ZN11Dev_Manager4instE>
     66c:	80 91 0e 02 	lds	r24, 0x020E	; 0x80020e <_ZN11Dev_Manager4instE>
     670:	90 91 0f 02 	lds	r25, 0x020F	; 0x80020f <_ZN11Dev_Manager4instE+0x1>
     674:	df 91       	pop	r29
     676:	cf 91       	pop	r28
     678:	08 95       	ret

0000067a <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     67a:	50 e0       	ldi	r21, 0x00	; 0
     67c:	44 0f       	add	r20, r20
     67e:	55 1f       	adc	r21, r21
     680:	84 0f       	add	r24, r20
     682:	95 1f       	adc	r25, r21
     684:	fc 01       	movw	r30, r24
     686:	71 83       	std	Z+1, r23	; 0x01
     688:	60 83       	st	Z, r22
     68a:	08 95       	ret

0000068c <_ZN11Dev_ManagernwEj>:
     68c:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
     690:	08 95       	ret

00000692 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     692:	26 2f       	mov	r18, r22
     694:	30 e0       	ldi	r19, 0x00	; 0
     696:	22 0f       	add	r18, r18
     698:	33 1f       	adc	r19, r19
     69a:	82 0f       	add	r24, r18
     69c:	93 1f       	adc	r25, r19
     69e:	dc 01       	movw	r26, r24
     6a0:	8d 91       	ld	r24, X+
     6a2:	9c 91       	ld	r25, X
     6a4:	00 97       	sbiw	r24, 0x00	; 0
     6a6:	41 f0       	breq	.+16     	; 0x6b8 <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     6a8:	64 2f       	mov	r22, r20
     6aa:	dc 01       	movw	r26, r24
     6ac:	ed 91       	ld	r30, X+
     6ae:	fc 91       	ld	r31, X
     6b0:	06 80       	ldd	r0, Z+6	; 0x06
     6b2:	f7 81       	ldd	r31, Z+7	; 0x07
     6b4:	e0 2d       	mov	r30, r0
     6b6:	09 95       	icall
     6b8:	08 95       	ret

000006ba <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     6ba:	26 2f       	mov	r18, r22
     6bc:	30 e0       	ldi	r19, 0x00	; 0
     6be:	22 0f       	add	r18, r18
     6c0:	33 1f       	adc	r19, r19
     6c2:	82 0f       	add	r24, r18
     6c4:	93 1f       	adc	r25, r19
     6c6:	dc 01       	movw	r26, r24
     6c8:	8d 91       	ld	r24, X+
     6ca:	9c 91       	ld	r25, X
     6cc:	00 97       	sbiw	r24, 0x00	; 0
     6ce:	41 f0       	breq	.+16     	; 0x6e0 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     6d0:	ba 01       	movw	r22, r20
     6d2:	dc 01       	movw	r26, r24
     6d4:	ed 91       	ld	r30, X+
     6d6:	fc 91       	ld	r31, X
     6d8:	04 80       	ldd	r0, Z+4	; 0x04
     6da:	f5 81       	ldd	r31, Z+5	; 0x05
     6dc:	e0 2d       	mov	r30, r0
     6de:	09 95       	icall
     6e0:	08 95       	ret

000006e2 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	66 0f       	add	r22, r22
     6e6:	77 1f       	adc	r23, r23
     6e8:	86 0f       	add	r24, r22
     6ea:	97 1f       	adc	r25, r23
     6ec:	dc 01       	movw	r26, r24
     6ee:	8d 91       	ld	r24, X+
     6f0:	9c 91       	ld	r25, X
     6f2:	00 97       	sbiw	r24, 0x00	; 0
     6f4:	39 f0       	breq	.+14     	; 0x704 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     6f6:	dc 01       	movw	r26, r24
     6f8:	ed 91       	ld	r30, X+
     6fa:	fc 91       	ld	r31, X
     6fc:	01 90       	ld	r0, Z+
     6fe:	f0 81       	ld	r31, Z
     700:	e0 2d       	mov	r30, r0
     702:	09 95       	icall
     704:	08 95       	ret

00000706 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     706:	e6 2f       	mov	r30, r22
     708:	f0 e0       	ldi	r31, 0x00	; 0
     70a:	ee 0f       	add	r30, r30
     70c:	ff 1f       	adc	r31, r31
     70e:	e8 0f       	add	r30, r24
     710:	f9 1f       	adc	r31, r25
     712:	80 81       	ld	r24, Z
     714:	91 81       	ldd	r25, Z+1	; 0x01
     716:	89 2b       	or	r24, r25
     718:	11 f0       	breq	.+4      	; 0x71e <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     71a:	51 87       	std	Z+9, r21	; 0x09
     71c:	40 87       	std	Z+8, r20	; 0x08
     71e:	08 95       	ret

00000720 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     720:	70 e0       	ldi	r23, 0x00	; 0
     722:	66 0f       	add	r22, r22
     724:	77 1f       	adc	r23, r23
     726:	fc 01       	movw	r30, r24
     728:	e6 0f       	add	r30, r22
     72a:	f7 1f       	adc	r31, r23
     72c:	81 e0       	ldi	r24, 0x01	; 1
     72e:	20 81       	ld	r18, Z
     730:	31 81       	ldd	r19, Z+1	; 0x01
     732:	23 2b       	or	r18, r19
     734:	09 f4       	brne	.+2      	; 0x738 <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     736:	80 e0       	ldi	r24, 0x00	; 0
     738:	08 95       	ret

0000073a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* const Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	66 0f       	add	r22, r22
     73e:	77 1f       	adc	r23, r23
     740:	86 0f       	add	r24, r22
     742:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     744:	fc 01       	movw	r30, r24
     746:	80 81       	ld	r24, Z
     748:	91 81       	ldd	r25, Z+1	; 0x01
     74a:	08 95       	ret

0000074c <__vector_18>:
ISR(USART0_RX_vect)
{
     74c:	1f 92       	push	r1
     74e:	0f 92       	push	r0
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	0f 92       	push	r0
     754:	11 24       	eor	r1, r1
     756:	0b b6       	in	r0, 0x3b	; 59
     758:	0f 92       	push	r0
     75a:	2f 93       	push	r18
     75c:	3f 93       	push	r19
     75e:	4f 93       	push	r20
     760:	5f 93       	push	r21
     762:	6f 93       	push	r22
     764:	7f 93       	push	r23
     766:	8f 93       	push	r24
     768:	9f 93       	push	r25
     76a:	af 93       	push	r26
     76c:	bf 93       	push	r27
     76e:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     770:	ff 93       	push	r31
     772:	6a df       	rcall	.-300    	; 0x648 <_ZN11Dev_Manager11getInstanceEv>
     774:	6c b1       	in	r22, 0x0c	; 12
     776:	70 e0       	ldi	r23, 0x00	; 0
     778:	dc 01       	movw	r26, r24
     77a:	18 96       	adiw	r26, 0x08	; 8
     77c:	ed 91       	ld	r30, X+
     77e:	fc 91       	ld	r31, X
     780:	19 97       	sbiw	r26, 0x09	; 9
     782:	80 e0       	ldi	r24, 0x00	; 0
}
     784:	09 95       	icall
     786:	ff 91       	pop	r31
     788:	ef 91       	pop	r30
     78a:	bf 91       	pop	r27
     78c:	af 91       	pop	r26
     78e:	9f 91       	pop	r25
     790:	8f 91       	pop	r24
     792:	7f 91       	pop	r23
     794:	6f 91       	pop	r22
     796:	5f 91       	pop	r21
     798:	4f 91       	pop	r20
     79a:	3f 91       	pop	r19
     79c:	2f 91       	pop	r18
     79e:	0f 90       	pop	r0
     7a0:	0b be       	out	0x3b, r0	; 59
     7a2:	0f 90       	pop	r0
     7a4:	0f be       	out	0x3f, r0	; 63
     7a6:	0f 90       	pop	r0
     7a8:	1f 90       	pop	r1
     7aa:	18 95       	reti

000007ac <__vector_30>:
ISR(USART1_RX_vect)
{
     7ac:	1f 92       	push	r1
     7ae:	0f 92       	push	r0
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	0f 92       	push	r0
     7b4:	11 24       	eor	r1, r1
     7b6:	0b b6       	in	r0, 0x3b	; 59
     7b8:	0f 92       	push	r0
     7ba:	2f 93       	push	r18
     7bc:	3f 93       	push	r19
     7be:	4f 93       	push	r20
     7c0:	5f 93       	push	r21
     7c2:	6f 93       	push	r22
     7c4:	7f 93       	push	r23
     7c6:	8f 93       	push	r24
     7c8:	9f 93       	push	r25
     7ca:	af 93       	push	r26
     7cc:	bf 93       	push	r27
     7ce:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     7d0:	ff 93       	push	r31
     7d2:	3a df       	rcall	.-396    	; 0x648 <_ZN11Dev_Manager11getInstanceEv>
     7d4:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     7d8:	70 e0       	ldi	r23, 0x00	; 0
     7da:	dc 01       	movw	r26, r24
     7dc:	1a 96       	adiw	r26, 0x0a	; 10
     7de:	ed 91       	ld	r30, X+
     7e0:	fc 91       	ld	r31, X
     7e2:	1b 97       	sbiw	r26, 0x0b	; 11
     7e4:	81 e0       	ldi	r24, 0x01	; 1
}
     7e6:	09 95       	icall
     7e8:	ff 91       	pop	r31
     7ea:	ef 91       	pop	r30
     7ec:	bf 91       	pop	r27
     7ee:	af 91       	pop	r26
     7f0:	9f 91       	pop	r25
     7f2:	8f 91       	pop	r24
     7f4:	7f 91       	pop	r23
     7f6:	6f 91       	pop	r22
     7f8:	5f 91       	pop	r21
     7fa:	4f 91       	pop	r20
     7fc:	3f 91       	pop	r19
     7fe:	2f 91       	pop	r18
     800:	0f 90       	pop	r0
     802:	0b be       	out	0x3b, r0	; 59
     804:	0f 90       	pop	r0
     806:	0f be       	out	0x3f, r0	; 63
     808:	0f 90       	pop	r0
     80a:	1f 90       	pop	r1
     80c:	18 95       	reti

0000080e <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     80e:	1f 92       	push	r1
     810:	0f 92       	push	r0
     812:	0f b6       	in	r0, 0x3f	; 63
     814:	0f 92       	push	r0
     816:	11 24       	eor	r1, r1
     818:	0b b6       	in	r0, 0x3b	; 59
     81a:	0f 92       	push	r0
     81c:	2f 93       	push	r18
     81e:	3f 93       	push	r19
     820:	4f 93       	push	r20
     822:	5f 93       	push	r21
     824:	6f 93       	push	r22
     826:	7f 93       	push	r23
     828:	8f 93       	push	r24
     82a:	9f 93       	push	r25
     82c:	af 93       	push	r26
     82e:	bf 93       	push	r27
     830:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,NULL);
     832:	ff 93       	push	r31
     834:	09 df       	rcall	.-494    	; 0x648 <_ZN11Dev_Manager11getInstanceEv>
     836:	dc 01       	movw	r26, r24
     838:	1c 96       	adiw	r26, 0x0c	; 12
     83a:	ed 91       	ld	r30, X+
     83c:	fc 91       	ld	r31, X
     83e:	1d 97       	sbiw	r26, 0x0d	; 13
     840:	60 e0       	ldi	r22, 0x00	; 0
     842:	70 e0       	ldi	r23, 0x00	; 0
     844:	82 e0       	ldi	r24, 0x02	; 2
}
     846:	09 95       	icall
     848:	ff 91       	pop	r31
     84a:	ef 91       	pop	r30
     84c:	bf 91       	pop	r27
     84e:	af 91       	pop	r26
     850:	9f 91       	pop	r25
     852:	8f 91       	pop	r24
     854:	7f 91       	pop	r23
     856:	6f 91       	pop	r22
     858:	5f 91       	pop	r21
     85a:	4f 91       	pop	r20
     85c:	3f 91       	pop	r19
     85e:	2f 91       	pop	r18
     860:	0f 90       	pop	r0
     862:	0b be       	out	0x3b, r0	; 59
     864:	0f 90       	pop	r0
     866:	0f be       	out	0x3f, r0	; 63
     868:	0f 90       	pop	r0
     86a:	1f 90       	pop	r1
     86c:	18 95       	reti

0000086e <__vector_1>:
ISR(INT0_vect)
{
     86e:	1f 92       	push	r1
     870:	0f 92       	push	r0
     872:	0f b6       	in	r0, 0x3f	; 63
     874:	0f 92       	push	r0
     876:	11 24       	eor	r1, r1
     878:	0b b6       	in	r0, 0x3b	; 59
     87a:	0f 92       	push	r0
     87c:	2f 93       	push	r18
     87e:	3f 93       	push	r19
     880:	4f 93       	push	r20
     882:	5f 93       	push	r21
     884:	6f 93       	push	r22
     886:	7f 93       	push	r23
     888:	8f 93       	push	r24
     88a:	9f 93       	push	r25
     88c:	af 93       	push	r26
     88e:	bf 93       	push	r27
     890:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[COUNT_SENSOR](COUNT_SENSOR,NULL);
     892:	ff 93       	push	r31
     894:	d9 de       	rcall	.-590    	; 0x648 <_ZN11Dev_Manager11getInstanceEv>
     896:	dc 01       	movw	r26, r24
     898:	1e 96       	adiw	r26, 0x0e	; 14
     89a:	ed 91       	ld	r30, X+
     89c:	fc 91       	ld	r31, X
     89e:	1f 97       	sbiw	r26, 0x0f	; 15
     8a0:	60 e0       	ldi	r22, 0x00	; 0
     8a2:	70 e0       	ldi	r23, 0x00	; 0
     8a4:	83 e0       	ldi	r24, 0x03	; 3
     8a6:	09 95       	icall
     8a8:	ff 91       	pop	r31
     8aa:	ef 91       	pop	r30
     8ac:	bf 91       	pop	r27
     8ae:	af 91       	pop	r26
     8b0:	9f 91       	pop	r25
     8b2:	8f 91       	pop	r24
     8b4:	7f 91       	pop	r23
     8b6:	6f 91       	pop	r22
     8b8:	5f 91       	pop	r21
     8ba:	4f 91       	pop	r20
     8bc:	3f 91       	pop	r19
     8be:	2f 91       	pop	r18
     8c0:	0f 90       	pop	r0
     8c2:	0b be       	out	0x3b, r0	; 59
     8c4:	0f 90       	pop	r0
     8c6:	0f be       	out	0x3f, r0	; 63
     8c8:	0f 90       	pop	r0
     8ca:	1f 90       	pop	r1
     8cc:	18 95       	reti

000008ce <_ZN5Timer11Device_InitEv>:
{
	
}
void Timer::Device_Init()
{
	TCCR3A = 0x40;
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
	TCCR3B = 0x04;
     8d4:	84 e0       	ldi	r24, 0x04	; 4
     8d6:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
	OCR3A = 15624;
     8da:	88 e0       	ldi	r24, 0x08	; 8
     8dc:	9d e3       	ldi	r25, 0x3D	; 61
     8de:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     8e2:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
	ETIMSK = 1 << OCIE3C;
     8e6:	82 e0       	ldi	r24, 0x02	; 2
     8e8:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     8ec:	08 95       	ret

000008ee <_ZN5TimerC1Ev>:
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"

Timer::Timer()
     8ee:	2b e2       	ldi	r18, 0x2B	; 43
     8f0:	31 e0       	ldi	r19, 0x01	; 1
     8f2:	fc 01       	movw	r30, r24
     8f4:	31 83       	std	Z+1, r19	; 0x01
     8f6:	20 83       	st	Z, r18
     8f8:	08 95       	ret

000008fa <_ZN5TimernwEj>:
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
	return malloc(size);
     8fa:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
}
     8fe:	08 95       	ret

00000900 <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     900:	cf 93       	push	r28
     902:	df 93       	push	r29
     904:	ec 01       	movw	r28, r24
     906:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     90a:	88 e9       	ldi	r24, 0x98	; 152
     90c:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     910:	86 e0       	ldi	r24, 0x06	; 6
     912:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     916:	be 01       	movw	r22, r28
     918:	6e 5f       	subi	r22, 0xFE	; 254
     91a:	7f 4f       	sbci	r23, 0xFF	; 255
     91c:	ce 01       	movw	r24, r28
     91e:	19 d1       	rcall	.+562    	; 0xb52 <_ZN4Ubbr10Ubbr_ValueERKj>
     920:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     924:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	0e 94 da 13 	call	0x27b4	; 0x27b4 <xQueueCreateMutex>
     92e:	9f 83       	std	Y+7, r25	; 0x07
     930:	8e 83       	std	Y+6, r24	; 0x06
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	0e 94 da 13 	call	0x27b4	; 0x27b4 <xQueueCreateMutex>
     938:	9d 83       	std	Y+5, r25	; 0x05
     93a:	8c 83       	std	Y+4, r24	; 0x04
     93c:	df 91       	pop	r29
     93e:	cf 91       	pop	r28
     940:	08 95       	ret

00000942 <_ZN11RS485DriverC1Ev>:
     942:	2b e3       	ldi	r18, 0x3B	; 59
     944:	31 e0       	ldi	r19, 0x01	; 1
     946:	fc 01       	movw	r30, r24
     948:	31 83       	std	Z+1, r19	; 0x01
     94a:	20 83       	st	Z, r18
     94c:	20 e8       	ldi	r18, 0x80	; 128
     94e:	35 e2       	ldi	r19, 0x25	; 37
     950:	33 83       	std	Z+3, r19	; 0x03
     952:	22 83       	std	Z+2, r18	; 0x02
     954:	20 91 10 02 	lds	r18, 0x0210	; 0x800210 <_ZN11RS485Driver4instE>
     958:	30 91 11 02 	lds	r19, 0x0211	; 0x800211 <_ZN11RS485Driver4instE+0x1>
     95c:	23 2b       	or	r18, r19
     95e:	21 f4       	brne	.+8      	; 0x968 <_ZN11RS485DriverC1Ev+0x26>
     960:	90 93 11 02 	sts	0x0211, r25	; 0x800211 <_ZN11RS485Driver4instE+0x1>
     964:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <_ZN11RS485Driver4instE>
     968:	08 95       	ret

0000096a <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     96a:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
}
     96e:	08 95       	ret

00000970 <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     970:	1f 93       	push	r17
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	ec 01       	movw	r28, r24
     978:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     97a:	20 e0       	ldi	r18, 0x00	; 0
     97c:	44 e6       	ldi	r20, 0x64	; 100
     97e:	50 e0       	ldi	r21, 0x00	; 0
     980:	60 e0       	ldi	r22, 0x00	; 0
     982:	70 e0       	ldi	r23, 0x00	; 0
     984:	8c 81       	ldd	r24, Y+4	; 0x04
     986:	9d 81       	ldd	r25, Y+5	; 0x05
     988:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xQueueGenericReceive>
     98c:	81 30       	cpi	r24, 0x01	; 1
     98e:	81 f4       	brne	.+32     	; 0x9b0 <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     990:	eb e9       	ldi	r30, 0x9B	; 155
     992:	f0 e0       	ldi	r31, 0x00	; 0
     994:	80 81       	ld	r24, Z
     996:	85 ff       	sbrs	r24, 5
     998:	fd cf       	rjmp	.-6      	; 0x994 <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     99a:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	40 e0       	ldi	r20, 0x00	; 0
     9a2:	50 e0       	ldi	r21, 0x00	; 0
     9a4:	60 e0       	ldi	r22, 0x00	; 0
     9a6:	70 e0       	ldi	r23, 0x00	; 0
     9a8:	8c 81       	ldd	r24, Y+4	; 0x04
     9aa:	9d 81       	ldd	r25, Y+5	; 0x05
     9ac:	0e 94 48 13 	call	0x2690	; 0x2690 <xQueueGenericSend>
	}
}
     9b0:	df 91       	pop	r29
     9b2:	cf 91       	pop	r28
     9b4:	1f 91       	pop	r17
     9b6:	08 95       	ret

000009b8 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     9b8:	db cf       	rjmp	.-74     	; 0x970 <_ZN11RS485Driver12UART_PutcharEc>
     9ba:	08 95       	ret

000009bc <_ZN11RS485Driver14UART_PutStringEPKc>:
     9bc:	0f 93       	push	r16
     9be:	1f 93       	push	r17
     9c0:	cf 93       	push	r28
     9c2:	df 93       	push	r29
     9c4:	8c 01       	movw	r16, r24
     9c6:	eb 01       	movw	r28, r22
     9c8:	20 e0       	ldi	r18, 0x00	; 0
     9ca:	44 e6       	ldi	r20, 0x64	; 100
     9cc:	50 e0       	ldi	r21, 0x00	; 0
     9ce:	60 e0       	ldi	r22, 0x00	; 0
     9d0:	70 e0       	ldi	r23, 0x00	; 0
     9d2:	fc 01       	movw	r30, r24
     9d4:	86 81       	ldd	r24, Z+6	; 0x06
     9d6:	97 81       	ldd	r25, Z+7	; 0x07
     9d8:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xQueueGenericReceive>
     9dc:	81 30       	cpi	r24, 0x01	; 1
     9de:	99 f4       	brne	.+38     	; 0xa06 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     9e0:	68 81       	ld	r22, Y
     9e2:	66 23       	and	r22, r22
     9e4:	31 f0       	breq	.+12     	; 0x9f2 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     9e6:	21 96       	adiw	r28, 0x01	; 1
     9e8:	c8 01       	movw	r24, r16
     9ea:	c2 df       	rcall	.-124    	; 0x970 <_ZN11RS485Driver12UART_PutcharEc>
     9ec:	69 91       	ld	r22, Y+
     9ee:	61 11       	cpse	r22, r1
     9f0:	fb cf       	rjmp	.-10     	; 0x9e8 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     9f2:	20 e0       	ldi	r18, 0x00	; 0
     9f4:	40 e0       	ldi	r20, 0x00	; 0
     9f6:	50 e0       	ldi	r21, 0x00	; 0
     9f8:	60 e0       	ldi	r22, 0x00	; 0
     9fa:	70 e0       	ldi	r23, 0x00	; 0
     9fc:	f8 01       	movw	r30, r16
     9fe:	86 81       	ldd	r24, Z+6	; 0x06
     a00:	97 81       	ldd	r25, Z+7	; 0x07
     a02:	0e 94 48 13 	call	0x2690	; 0x2690 <xQueueGenericSend>
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	1f 91       	pop	r17
     a0c:	0f 91       	pop	r16
     a0e:	08 95       	ret

00000a10 <_ZN11RS485Driver13Device_WritesEPKc>:
     a10:	d5 cf       	rjmp	.-86     	; 0x9bc <_ZN11RS485Driver14UART_PutStringEPKc>
     a12:	08 95       	ret

00000a14 <__vector_9>:
	OCR2 = 249; //4ms마다 인터럽트
	sbi(TIMSK,OCIE2); // 인터럽트 활성화	
	//Timer_Alarm::ptr = mem4;
}
void Timer_Alarm::Service_routine()
{
     a14:	1f 92       	push	r1
     a16:	0f 92       	push	r0
     a18:	0f b6       	in	r0, 0x3f	; 63
     a1a:	0f 92       	push	r0
     a1c:	11 24       	eor	r1, r1
     a1e:	0b b6       	in	r0, 0x3b	; 59
     a20:	0f 92       	push	r0
     a22:	8f 93       	push	r24
     a24:	9f 93       	push	r25
     a26:	ef 93       	push	r30
     a28:	ff 93       	push	r31
	mem4[3]++;
     a2a:	e3 e0       	ldi	r30, 0x03	; 3
     a2c:	f3 e0       	ldi	r31, 0x03	; 3
     a2e:	86 81       	ldd	r24, Z+6	; 0x06
     a30:	97 81       	ldd	r25, Z+7	; 0x07
     a32:	01 96       	adiw	r24, 0x01	; 1
     a34:	97 83       	std	Z+7, r25	; 0x07
     a36:	86 83       	std	Z+6, r24	; 0x06
}
     a38:	ff 91       	pop	r31
     a3a:	ef 91       	pop	r30
     a3c:	9f 91       	pop	r25
     a3e:	8f 91       	pop	r24
     a40:	0f 90       	pop	r0
     a42:	0b be       	out	0x3b, r0	; 59
     a44:	0f 90       	pop	r0
     a46:	0f be       	out	0x3f, r0	; 63
     a48:	0f 90       	pop	r0
     a4a:	1f 90       	pop	r1
     a4c:	18 95       	reti

00000a4e <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     a4e:	cf 93       	push	r28
     a50:	df 93       	push	r29
     a52:	ec 01       	movw	r28, r24
     a54:	88 e9       	ldi	r24, 0x98	; 152
     a56:	8a b9       	out	0x0a, r24	; 10
     a58:	86 e0       	ldi	r24, 0x06	; 6
     a5a:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     a5e:	be 01       	movw	r22, r28
     a60:	6e 5f       	subi	r22, 0xFE	; 254
     a62:	7f 4f       	sbci	r23, 0xFF	; 255
     a64:	ce 01       	movw	r24, r28
     a66:	75 d0       	rcall	.+234    	; 0xb52 <_ZN4Ubbr10Ubbr_ValueERKj>
     a68:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     a6c:	99 b9       	out	0x09, r25	; 9
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	0e 94 da 13 	call	0x27b4	; 0x27b4 <xQueueCreateMutex>
     a74:	9f 83       	std	Y+7, r25	; 0x07
     a76:	8e 83       	std	Y+6, r24	; 0x06
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	0e 94 da 13 	call	0x27b4	; 0x27b4 <xQueueCreateMutex>
     a7e:	9d 83       	std	Y+5, r25	; 0x05
     a80:	8c 83       	std	Y+4, r24	; 0x04
     a82:	df 91       	pop	r29
     a84:	cf 91       	pop	r28
     a86:	08 95       	ret

00000a88 <_ZN10UartDriverC1Ev>:
     a88:	2b e4       	ldi	r18, 0x4B	; 75
     a8a:	31 e0       	ldi	r19, 0x01	; 1
     a8c:	fc 01       	movw	r30, r24
     a8e:	31 83       	std	Z+1, r19	; 0x01
     a90:	20 83       	st	Z, r18
     a92:	20 e4       	ldi	r18, 0x40	; 64
     a94:	38 e3       	ldi	r19, 0x38	; 56
     a96:	33 83       	std	Z+3, r19	; 0x03
     a98:	22 83       	std	Z+2, r18	; 0x02
     a9a:	20 91 12 02 	lds	r18, 0x0212	; 0x800212 <_ZN10UartDriver4instE>
     a9e:	30 91 13 02 	lds	r19, 0x0213	; 0x800213 <_ZN10UartDriver4instE+0x1>
     aa2:	23 2b       	or	r18, r19
     aa4:	21 f4       	brne	.+8      	; 0xaae <_ZN10UartDriverC1Ev+0x26>
     aa6:	90 93 13 02 	sts	0x0213, r25	; 0x800213 <_ZN10UartDriver4instE+0x1>
     aaa:	80 93 12 02 	sts	0x0212, r24	; 0x800212 <_ZN10UartDriver4instE>
     aae:	08 95       	ret

00000ab0 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     ab0:	0c 94 11 10 	jmp	0x2022	; 0x2022 <pvPortMalloc>
}
     ab4:	08 95       	ret

00000ab6 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     ab6:	1f 93       	push	r17
     ab8:	cf 93       	push	r28
     aba:	df 93       	push	r29
     abc:	ec 01       	movw	r28, r24
     abe:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     ac0:	20 e0       	ldi	r18, 0x00	; 0
     ac2:	44 e6       	ldi	r20, 0x64	; 100
     ac4:	50 e0       	ldi	r21, 0x00	; 0
     ac6:	60 e0       	ldi	r22, 0x00	; 0
     ac8:	70 e0       	ldi	r23, 0x00	; 0
     aca:	8c 81       	ldd	r24, Y+4	; 0x04
     acc:	9d 81       	ldd	r25, Y+5	; 0x05
     ace:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xQueueGenericReceive>
     ad2:	81 30       	cpi	r24, 0x01	; 1
     ad4:	61 f4       	brne	.+24     	; 0xaee <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     ad6:	5d 9b       	sbis	0x0b, 5	; 11
     ad8:	fe cf       	rjmp	.-4      	; 0xad6 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     ada:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     adc:	20 e0       	ldi	r18, 0x00	; 0
     ade:	40 e0       	ldi	r20, 0x00	; 0
     ae0:	50 e0       	ldi	r21, 0x00	; 0
     ae2:	60 e0       	ldi	r22, 0x00	; 0
     ae4:	70 e0       	ldi	r23, 0x00	; 0
     ae6:	8c 81       	ldd	r24, Y+4	; 0x04
     ae8:	9d 81       	ldd	r25, Y+5	; 0x05
     aea:	0e 94 48 13 	call	0x2690	; 0x2690 <xQueueGenericSend>
	}
}
     aee:	df 91       	pop	r29
     af0:	cf 91       	pop	r28
     af2:	1f 91       	pop	r17
     af4:	08 95       	ret

00000af6 <_ZN10UartDriver12Device_WriteEc>:
     af6:	df cf       	rjmp	.-66     	; 0xab6 <_ZN10UartDriver12UART_PutcharEc>
     af8:	08 95       	ret

00000afa <_ZN10UartDriver14UART_PutStringEPKc>:
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	8c 01       	movw	r16, r24
     b04:	eb 01       	movw	r28, r22
     b06:	20 e0       	ldi	r18, 0x00	; 0
     b08:	44 e6       	ldi	r20, 0x64	; 100
     b0a:	50 e0       	ldi	r21, 0x00	; 0
     b0c:	60 e0       	ldi	r22, 0x00	; 0
     b0e:	70 e0       	ldi	r23, 0x00	; 0
     b10:	fc 01       	movw	r30, r24
     b12:	86 81       	ldd	r24, Z+6	; 0x06
     b14:	97 81       	ldd	r25, Z+7	; 0x07
     b16:	0e 94 f2 13 	call	0x27e4	; 0x27e4 <xQueueGenericReceive>
     b1a:	81 30       	cpi	r24, 0x01	; 1
     b1c:	99 f4       	brne	.+38     	; 0xb44 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     b1e:	68 81       	ld	r22, Y
     b20:	66 23       	and	r22, r22
     b22:	31 f0       	breq	.+12     	; 0xb30 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     b24:	21 96       	adiw	r28, 0x01	; 1
     b26:	c8 01       	movw	r24, r16
     b28:	c6 df       	rcall	.-116    	; 0xab6 <_ZN10UartDriver12UART_PutcharEc>
     b2a:	69 91       	ld	r22, Y+
     b2c:	61 11       	cpse	r22, r1
     b2e:	fb cf       	rjmp	.-10     	; 0xb26 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     b30:	20 e0       	ldi	r18, 0x00	; 0
     b32:	40 e0       	ldi	r20, 0x00	; 0
     b34:	50 e0       	ldi	r21, 0x00	; 0
     b36:	60 e0       	ldi	r22, 0x00	; 0
     b38:	70 e0       	ldi	r23, 0x00	; 0
     b3a:	f8 01       	movw	r30, r16
     b3c:	86 81       	ldd	r24, Z+6	; 0x06
     b3e:	97 81       	ldd	r25, Z+7	; 0x07
     b40:	0e 94 48 13 	call	0x2690	; 0x2690 <xQueueGenericSend>
     b44:	df 91       	pop	r29
     b46:	cf 91       	pop	r28
     b48:	1f 91       	pop	r17
     b4a:	0f 91       	pop	r16
     b4c:	08 95       	ret

00000b4e <_ZN10UartDriver13Device_WritesEPKc>:
     b4e:	d5 cf       	rjmp	.-86     	; 0xafa <_ZN10UartDriver14UART_PutStringEPKc>
     b50:	08 95       	ret

00000b52 <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     b52:	cf 92       	push	r12
     b54:	df 92       	push	r13
     b56:	ef 92       	push	r14
     b58:	ff 92       	push	r15
     b5a:	cf 93       	push	r28
     b5c:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
     b5e:	fb 01       	movw	r30, r22
     b60:	20 81       	ld	r18, Z
     b62:	31 81       	ldd	r19, Z+1	; 0x01
     b64:	c9 01       	movw	r24, r18
     b66:	a0 e0       	ldi	r26, 0x00	; 0
     b68:	b0 e0       	ldi	r27, 0x00	; 0
     b6a:	88 0f       	add	r24, r24
     b6c:	99 1f       	adc	r25, r25
     b6e:	aa 1f       	adc	r26, r26
     b70:	bb 1f       	adc	r27, r27
     b72:	88 0f       	add	r24, r24
     b74:	99 1f       	adc	r25, r25
     b76:	aa 1f       	adc	r26, r26
     b78:	bb 1f       	adc	r27, r27
     b7a:	9c 01       	movw	r18, r24
     b7c:	ad 01       	movw	r20, r26
     b7e:	22 0f       	add	r18, r18
     b80:	33 1f       	adc	r19, r19
     b82:	44 1f       	adc	r20, r20
     b84:	55 1f       	adc	r21, r21
     b86:	22 0f       	add	r18, r18
     b88:	33 1f       	adc	r19, r19
     b8a:	44 1f       	adc	r20, r20
     b8c:	55 1f       	adc	r21, r21
     b8e:	60 e0       	ldi	r22, 0x00	; 0
     b90:	74 e2       	ldi	r23, 0x24	; 36
     b92:	84 ef       	ldi	r24, 0xF4	; 244
     b94:	90 e0       	ldi	r25, 0x00	; 0
     b96:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__udivmodsi4>
     b9a:	ca 01       	movw	r24, r20
     b9c:	b9 01       	movw	r22, r18
     b9e:	61 50       	subi	r22, 0x01	; 1
     ba0:	71 09       	sbc	r23, r1
     ba2:	81 09       	sbc	r24, r1
     ba4:	91 09       	sbc	r25, r1
     ba6:	0e 94 24 1a 	call	0x3448	; 0x3448 <__floatunsisf>
     baa:	20 e0       	ldi	r18, 0x00	; 0
     bac:	30 e0       	ldi	r19, 0x00	; 0
     bae:	40 e0       	ldi	r20, 0x00	; 0
     bb0:	5f e3       	ldi	r21, 0x3F	; 63
     bb2:	0e 94 94 19 	call	0x3328	; 0x3328 <__addsf3>
     bb6:	6b 01       	movw	r12, r22
     bb8:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     bba:	0e 94 f8 19 	call	0x33f0	; 0x33f0 <__fixunssfsi>
     bbe:	d6 2f       	mov	r29, r22
     bc0:	f0 e0       	ldi	r31, 0x00	; 0
     bc2:	cf 2f       	mov	r28, r31
     bc4:	c7 01       	movw	r24, r14
     bc6:	b6 01       	movw	r22, r12
     bc8:	0e 94 f8 19 	call	0x33f0	; 0x33f0 <__fixunssfsi>
}
     bcc:	ce 01       	movw	r24, r28
     bce:	86 2b       	or	r24, r22
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	ff 90       	pop	r15
     bd6:	ef 90       	pop	r14
     bd8:	df 90       	pop	r13
     bda:	cf 90       	pop	r12
     bdc:	08 95       	ret

00000bde <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     bde:	c0 98       	cbi	0x18, 0	; 24
     be0:	96 2f       	mov	r25, r22
     be2:	6f 71       	andi	r22, 0x1F	; 31
     be4:	86 2b       	or	r24, r22
     be6:	8f b9       	out	0x0f, r24	; 15
     be8:	77 9b       	sbis	0x0e, 7	; 14
     bea:	fe cf       	rjmp	.-4      	; 0xbe8 <_Z14enc28j60ReadOphh+0xa>
     bec:	1f b8       	out	0x0f, r1	; 15
     bee:	77 9b       	sbis	0x0e, 7	; 14
     bf0:	fe cf       	rjmp	.-4      	; 0xbee <_Z14enc28j60ReadOphh+0x10>
     bf2:	99 23       	and	r25, r25
     bf4:	1c f4       	brge	.+6      	; 0xbfc <_Z14enc28j60ReadOphh+0x1e>
     bf6:	1f b8       	out	0x0f, r1	; 15
     bf8:	77 9b       	sbis	0x0e, 7	; 14
     bfa:	fe cf       	rjmp	.-4      	; 0xbf8 <_Z14enc28j60ReadOphh+0x1a>
     bfc:	c0 9a       	sbi	0x18, 0	; 24
     bfe:	8f b1       	in	r24, 0x0f	; 15
     c00:	08 95       	ret

00000c02 <_Z15enc28j60WriteOphhh>:
     c02:	c0 98       	cbi	0x18, 0	; 24
     c04:	6f 71       	andi	r22, 0x1F	; 31
     c06:	86 2b       	or	r24, r22
     c08:	8f b9       	out	0x0f, r24	; 15
     c0a:	77 9b       	sbis	0x0e, 7	; 14
     c0c:	fe cf       	rjmp	.-4      	; 0xc0a <_Z15enc28j60WriteOphhh+0x8>
     c0e:	4f b9       	out	0x0f, r20	; 15
     c10:	77 9b       	sbis	0x0e, 7	; 14
     c12:	fe cf       	rjmp	.-4      	; 0xc10 <_Z15enc28j60WriteOphhh+0xe>
     c14:	c0 9a       	sbi	0x18, 0	; 24
     c16:	08 95       	ret

00000c18 <_Z18enc28j60ReadBufferjPh>:
     c18:	fb 01       	movw	r30, r22
     c1a:	c0 98       	cbi	0x18, 0	; 24
     c1c:	2a e3       	ldi	r18, 0x3A	; 58
     c1e:	2f b9       	out	0x0f, r18	; 15
     c20:	77 9b       	sbis	0x0e, 7	; 14
     c22:	fe cf       	rjmp	.-4      	; 0xc20 <_Z18enc28j60ReadBufferjPh+0x8>
     c24:	00 97       	sbiw	r24, 0x00	; 0
     c26:	61 f0       	breq	.+24     	; 0xc40 <_Z18enc28j60ReadBufferjPh+0x28>
     c28:	df 01       	movw	r26, r30
     c2a:	a8 0f       	add	r26, r24
     c2c:	b9 1f       	adc	r27, r25
     c2e:	1f b8       	out	0x0f, r1	; 15
     c30:	77 9b       	sbis	0x0e, 7	; 14
     c32:	fe cf       	rjmp	.-4      	; 0xc30 <_Z18enc28j60ReadBufferjPh+0x18>
     c34:	9f b1       	in	r25, 0x0f	; 15
     c36:	91 93       	st	Z+, r25
     c38:	ae 17       	cp	r26, r30
     c3a:	bf 07       	cpc	r27, r31
     c3c:	c1 f7       	brne	.-16     	; 0xc2e <_Z18enc28j60ReadBufferjPh+0x16>
     c3e:	01 c0       	rjmp	.+2      	; 0xc42 <_Z18enc28j60ReadBufferjPh+0x2a>
     c40:	df 01       	movw	r26, r30
     c42:	1c 92       	st	X, r1
     c44:	c0 9a       	sbi	0x18, 0	; 24
     c46:	08 95       	ret

00000c48 <_Z19enc28j60WriteBufferjPh>:
     c48:	fb 01       	movw	r30, r22
     c4a:	c0 98       	cbi	0x18, 0	; 24
     c4c:	2a e7       	ldi	r18, 0x7A	; 122
     c4e:	2f b9       	out	0x0f, r18	; 15
     c50:	77 9b       	sbis	0x0e, 7	; 14
     c52:	fe cf       	rjmp	.-4      	; 0xc50 <_Z19enc28j60WriteBufferjPh+0x8>
     c54:	00 97       	sbiw	r24, 0x00	; 0
     c56:	61 f0       	breq	.+24     	; 0xc70 <_Z19enc28j60WriteBufferjPh+0x28>
     c58:	9f 01       	movw	r18, r30
     c5a:	28 0f       	add	r18, r24
     c5c:	39 1f       	adc	r19, r25
     c5e:	03 c0       	rjmp	.+6      	; 0xc66 <_Z19enc28j60WriteBufferjPh+0x1e>
     c60:	2e 17       	cp	r18, r30
     c62:	3f 07       	cpc	r19, r31
     c64:	29 f0       	breq	.+10     	; 0xc70 <_Z19enc28j60WriteBufferjPh+0x28>
     c66:	91 91       	ld	r25, Z+
     c68:	9f b9       	out	0x0f, r25	; 15
     c6a:	77 9b       	sbis	0x0e, 7	; 14
     c6c:	fe cf       	rjmp	.-4      	; 0xc6a <_Z19enc28j60WriteBufferjPh+0x22>
     c6e:	f8 cf       	rjmp	.-16     	; 0xc60 <_Z19enc28j60WriteBufferjPh+0x18>
     c70:	c0 9a       	sbi	0x18, 0	; 24
     c72:	08 95       	ret

00000c74 <_Z15enc28j60SetBankh>:
     c74:	1f 93       	push	r17
     c76:	cf 93       	push	r28
     c78:	df 93       	push	r29
     c7a:	18 2f       	mov	r17, r24
     c7c:	10 76       	andi	r17, 0x60	; 96
     c7e:	c1 2f       	mov	r28, r17
     c80:	d0 e0       	ldi	r29, 0x00	; 0
     c82:	80 91 16 02 	lds	r24, 0x0216	; 0x800216 <_ZL12Enc28j60Bank>
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	c8 17       	cp	r28, r24
     c8a:	d9 07       	cpc	r29, r25
     c8c:	a1 f0       	breq	.+40     	; 0xcb6 <_Z15enc28j60SetBankh+0x42>
     c8e:	43 e0       	ldi	r20, 0x03	; 3
     c90:	6f e1       	ldi	r22, 0x1F	; 31
     c92:	80 ea       	ldi	r24, 0xA0	; 160
     c94:	b6 df       	rcall	.-148    	; 0xc02 <_Z15enc28j60WriteOphhh>
     c96:	ae 01       	movw	r20, r28
     c98:	55 95       	asr	r21
     c9a:	47 95       	ror	r20
     c9c:	55 95       	asr	r21
     c9e:	47 95       	ror	r20
     ca0:	55 95       	asr	r21
     ca2:	47 95       	ror	r20
     ca4:	55 95       	asr	r21
     ca6:	47 95       	ror	r20
     ca8:	55 95       	asr	r21
     caa:	47 95       	ror	r20
     cac:	6f e1       	ldi	r22, 0x1F	; 31
     cae:	80 e8       	ldi	r24, 0x80	; 128
     cb0:	a8 df       	rcall	.-176    	; 0xc02 <_Z15enc28j60WriteOphhh>
     cb2:	10 93 16 02 	sts	0x0216, r17	; 0x800216 <_ZL12Enc28j60Bank>
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	1f 91       	pop	r17
     cbc:	08 95       	ret

00000cbe <_Z12enc28j60Readh>:
     cbe:	cf 93       	push	r28
     cc0:	c8 2f       	mov	r28, r24
     cc2:	d8 df       	rcall	.-80     	; 0xc74 <_Z15enc28j60SetBankh>
     cc4:	6c 2f       	mov	r22, r28
     cc6:	80 e0       	ldi	r24, 0x00	; 0
     cc8:	8a df       	rcall	.-236    	; 0xbde <_Z14enc28j60ReadOphh>
     cca:	cf 91       	pop	r28
     ccc:	08 95       	ret

00000cce <_Z13enc28j60Writehh>:
     cce:	cf 93       	push	r28
     cd0:	df 93       	push	r29
     cd2:	c8 2f       	mov	r28, r24
     cd4:	d6 2f       	mov	r29, r22
     cd6:	ce df       	rcall	.-100    	; 0xc74 <_Z15enc28j60SetBankh>
     cd8:	4d 2f       	mov	r20, r29
     cda:	6c 2f       	mov	r22, r28
     cdc:	80 e4       	ldi	r24, 0x40	; 64
     cde:	91 df       	rcall	.-222    	; 0xc02 <_Z15enc28j60WriteOphhh>
     ce0:	df 91       	pop	r29
     ce2:	cf 91       	pop	r28
     ce4:	08 95       	ret

00000ce6 <_Z16enc28j60PhyWritehj>:
     ce6:	cf 93       	push	r28
     ce8:	df 93       	push	r29
     cea:	d6 2f       	mov	r29, r22
     cec:	c7 2f       	mov	r28, r23
     cee:	68 2f       	mov	r22, r24
     cf0:	84 ed       	ldi	r24, 0xD4	; 212
     cf2:	ed df       	rcall	.-38     	; 0xcce <_Z13enc28j60Writehh>
     cf4:	6d 2f       	mov	r22, r29
     cf6:	86 ed       	ldi	r24, 0xD6	; 214
     cf8:	ea df       	rcall	.-44     	; 0xcce <_Z13enc28j60Writehh>
     cfa:	6c 2f       	mov	r22, r28
     cfc:	87 ed       	ldi	r24, 0xD7	; 215
     cfe:	e7 df       	rcall	.-50     	; 0xcce <_Z13enc28j60Writehh>
     d00:	8a ee       	ldi	r24, 0xEA	; 234
     d02:	dd df       	rcall	.-70     	; 0xcbe <_Z12enc28j60Readh>
     d04:	80 ff       	sbrs	r24, 0
     d06:	04 c0       	rjmp	.+8      	; 0xd10 <_Z16enc28j60PhyWritehj+0x2a>
     d08:	85 e0       	ldi	r24, 0x05	; 5
     d0a:	8a 95       	dec	r24
     d0c:	f1 f7       	brne	.-4      	; 0xd0a <_Z16enc28j60PhyWritehj+0x24>
     d0e:	f8 cf       	rjmp	.-16     	; 0xd00 <_Z16enc28j60PhyWritehj+0x1a>
     d10:	df 91       	pop	r29
     d12:	cf 91       	pop	r28
     d14:	08 95       	ret

00000d16 <_Z14enc28j60clkouth>:
     d16:	68 2f       	mov	r22, r24
     d18:	67 70       	andi	r22, 0x07	; 7
     d1a:	85 e7       	ldi	r24, 0x75	; 117
     d1c:	d8 cf       	rjmp	.-80     	; 0xcce <_Z13enc28j60Writehh>
     d1e:	08 95       	ret

00000d20 <_Z12enc28j60InitPh>:
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	ec 01       	movw	r28, r24
     d26:	b8 9a       	sbi	0x17, 0	; 23
     d28:	c0 9a       	sbi	0x18, 0	; 24
     d2a:	a6 d2       	rcall	.+1356   	; 0x1278 <_Z8spi_initv>
     d2c:	4f ef       	ldi	r20, 0xFF	; 255
     d2e:	60 e0       	ldi	r22, 0x00	; 0
     d30:	8f ef       	ldi	r24, 0xFF	; 255
     d32:	67 df       	rcall	.-306    	; 0xc02 <_Z15enc28j60WriteOphhh>
     d34:	82 e3       	ldi	r24, 0x32	; 50
     d36:	90 e0       	ldi	r25, 0x00	; 0
     d38:	a9 d2       	rcall	.+1362   	; 0x128c <_Z8delay_msj>
     d3a:	10 92 15 02 	sts	0x0215, r1	; 0x800215 <_ZL13NextPacketPtr+0x1>
     d3e:	10 92 14 02 	sts	0x0214, r1	; 0x800214 <_ZL13NextPacketPtr>
     d42:	60 e0       	ldi	r22, 0x00	; 0
     d44:	88 e0       	ldi	r24, 0x08	; 8
     d46:	c3 df       	rcall	.-122    	; 0xcce <_Z13enc28j60Writehh>
     d48:	60 e0       	ldi	r22, 0x00	; 0
     d4a:	89 e0       	ldi	r24, 0x09	; 9
     d4c:	c0 df       	rcall	.-128    	; 0xcce <_Z13enc28j60Writehh>
     d4e:	60 e0       	ldi	r22, 0x00	; 0
     d50:	8c e0       	ldi	r24, 0x0C	; 12
     d52:	bd df       	rcall	.-134    	; 0xcce <_Z13enc28j60Writehh>
     d54:	60 e0       	ldi	r22, 0x00	; 0
     d56:	8d e0       	ldi	r24, 0x0D	; 13
     d58:	ba df       	rcall	.-140    	; 0xcce <_Z13enc28j60Writehh>
     d5a:	6e ef       	ldi	r22, 0xFE	; 254
     d5c:	8a e0       	ldi	r24, 0x0A	; 10
     d5e:	b7 df       	rcall	.-146    	; 0xcce <_Z13enc28j60Writehh>
     d60:	69 e1       	ldi	r22, 0x19	; 25
     d62:	8b e0       	ldi	r24, 0x0B	; 11
     d64:	b4 df       	rcall	.-152    	; 0xcce <_Z13enc28j60Writehh>
     d66:	6f ef       	ldi	r22, 0xFF	; 255
     d68:	84 e0       	ldi	r24, 0x04	; 4
     d6a:	b1 df       	rcall	.-158    	; 0xcce <_Z13enc28j60Writehh>
     d6c:	69 e1       	ldi	r22, 0x19	; 25
     d6e:	85 e0       	ldi	r24, 0x05	; 5
     d70:	ae df       	rcall	.-164    	; 0xcce <_Z13enc28j60Writehh>
     d72:	6f ef       	ldi	r22, 0xFF	; 255
     d74:	86 e0       	ldi	r24, 0x06	; 6
     d76:	ab df       	rcall	.-170    	; 0xcce <_Z13enc28j60Writehh>
     d78:	6f e1       	ldi	r22, 0x1F	; 31
     d7a:	87 e0       	ldi	r24, 0x07	; 7
     d7c:	a8 df       	rcall	.-176    	; 0xcce <_Z13enc28j60Writehh>
     d7e:	60 eb       	ldi	r22, 0xB0	; 176
     d80:	88 e3       	ldi	r24, 0x38	; 56
     d82:	a5 df       	rcall	.-182    	; 0xcce <_Z13enc28j60Writehh>
     d84:	6f e3       	ldi	r22, 0x3F	; 63
     d86:	88 e2       	ldi	r24, 0x28	; 40
     d88:	a2 df       	rcall	.-188    	; 0xcce <_Z13enc28j60Writehh>
     d8a:	60 e3       	ldi	r22, 0x30	; 48
     d8c:	89 e2       	ldi	r24, 0x29	; 41
     d8e:	9f df       	rcall	.-194    	; 0xcce <_Z13enc28j60Writehh>
     d90:	69 ef       	ldi	r22, 0xF9	; 249
     d92:	80 e3       	ldi	r24, 0x30	; 48
     d94:	9c df       	rcall	.-200    	; 0xcce <_Z13enc28j60Writehh>
     d96:	67 ef       	ldi	r22, 0xF7	; 247
     d98:	81 e3       	ldi	r24, 0x31	; 49
     d9a:	99 df       	rcall	.-206    	; 0xcce <_Z13enc28j60Writehh>
     d9c:	6d e0       	ldi	r22, 0x0D	; 13
     d9e:	80 ec       	ldi	r24, 0xC0	; 192
     da0:	96 df       	rcall	.-212    	; 0xcce <_Z13enc28j60Writehh>
     da2:	60 e0       	ldi	r22, 0x00	; 0
     da4:	81 ec       	ldi	r24, 0xC1	; 193
     da6:	93 df       	rcall	.-218    	; 0xcce <_Z13enc28j60Writehh>
     da8:	42 e3       	ldi	r20, 0x32	; 50
     daa:	62 ec       	ldi	r22, 0xC2	; 194
     dac:	80 e8       	ldi	r24, 0x80	; 128
     dae:	29 df       	rcall	.-430    	; 0xc02 <_Z15enc28j60WriteOphhh>
     db0:	62 e1       	ldi	r22, 0x12	; 18
     db2:	86 ec       	ldi	r24, 0xC6	; 198
     db4:	8c df       	rcall	.-232    	; 0xcce <_Z13enc28j60Writehh>
     db6:	6c e0       	ldi	r22, 0x0C	; 12
     db8:	87 ec       	ldi	r24, 0xC7	; 199
     dba:	89 df       	rcall	.-238    	; 0xcce <_Z13enc28j60Writehh>
     dbc:	62 e1       	ldi	r22, 0x12	; 18
     dbe:	84 ec       	ldi	r24, 0xC4	; 196
     dc0:	86 df       	rcall	.-244    	; 0xcce <_Z13enc28j60Writehh>
     dc2:	6c ed       	ldi	r22, 0xDC	; 220
     dc4:	8a ec       	ldi	r24, 0xCA	; 202
     dc6:	83 df       	rcall	.-250    	; 0xcce <_Z13enc28j60Writehh>
     dc8:	65 e0       	ldi	r22, 0x05	; 5
     dca:	8b ec       	ldi	r24, 0xCB	; 203
     dcc:	80 df       	rcall	.-256    	; 0xcce <_Z13enc28j60Writehh>
     dce:	68 81       	ld	r22, Y
     dd0:	84 ee       	ldi	r24, 0xE4	; 228
     dd2:	7d df       	rcall	.-262    	; 0xcce <_Z13enc28j60Writehh>
     dd4:	69 81       	ldd	r22, Y+1	; 0x01
     dd6:	85 ee       	ldi	r24, 0xE5	; 229
     dd8:	7a df       	rcall	.-268    	; 0xcce <_Z13enc28j60Writehh>
     dda:	6a 81       	ldd	r22, Y+2	; 0x02
     ddc:	82 ee       	ldi	r24, 0xE2	; 226
     dde:	77 df       	rcall	.-274    	; 0xcce <_Z13enc28j60Writehh>
     de0:	6b 81       	ldd	r22, Y+3	; 0x03
     de2:	83 ee       	ldi	r24, 0xE3	; 227
     de4:	74 df       	rcall	.-280    	; 0xcce <_Z13enc28j60Writehh>
     de6:	6c 81       	ldd	r22, Y+4	; 0x04
     de8:	80 ee       	ldi	r24, 0xE0	; 224
     dea:	71 df       	rcall	.-286    	; 0xcce <_Z13enc28j60Writehh>
     dec:	6d 81       	ldd	r22, Y+5	; 0x05
     dee:	81 ee       	ldi	r24, 0xE1	; 225
     df0:	6e df       	rcall	.-292    	; 0xcce <_Z13enc28j60Writehh>
     df2:	60 e0       	ldi	r22, 0x00	; 0
     df4:	71 e0       	ldi	r23, 0x01	; 1
     df6:	80 e1       	ldi	r24, 0x10	; 16
     df8:	76 df       	rcall	.-276    	; 0xce6 <_Z16enc28j60PhyWritehj>
     dfa:	8f e1       	ldi	r24, 0x1F	; 31
     dfc:	3b df       	rcall	.-394    	; 0xc74 <_Z15enc28j60SetBankh>
     dfe:	40 ec       	ldi	r20, 0xC0	; 192
     e00:	6b e1       	ldi	r22, 0x1B	; 27
     e02:	80 e8       	ldi	r24, 0x80	; 128
     e04:	fe de       	rcall	.-516    	; 0xc02 <_Z15enc28j60WriteOphhh>
     e06:	44 e0       	ldi	r20, 0x04	; 4
     e08:	6f e1       	ldi	r22, 0x1F	; 31
     e0a:	80 e8       	ldi	r24, 0x80	; 128
     e0c:	fa de       	rcall	.-524    	; 0xc02 <_Z15enc28j60WriteOphhh>
     e0e:	df 91       	pop	r29
     e10:	cf 91       	pop	r28
     e12:	08 95       	ret

00000e14 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	ec 01       	movw	r28, r24
     e1e:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     e20:	6f ef       	ldi	r22, 0xFF	; 255
     e22:	82 e0       	ldi	r24, 0x02	; 2
     e24:	54 df       	rcall	.-344    	; 0xcce <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     e26:	69 e1       	ldi	r22, 0x19	; 25
     e28:	83 e0       	ldi	r24, 0x03	; 3
     e2a:	51 df       	rcall	.-350    	; 0xcce <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     e2c:	6c 2f       	mov	r22, r28
     e2e:	61 50       	subi	r22, 0x01	; 1
     e30:	86 e0       	ldi	r24, 0x06	; 6
     e32:	4d df       	rcall	.-358    	; 0xcce <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     e34:	ce 01       	movw	r24, r28
     e36:	81 50       	subi	r24, 0x01	; 1
     e38:	96 4e       	sbci	r25, 0xE6	; 230
     e3a:	69 2f       	mov	r22, r25
     e3c:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     e3e:	47 df       	rcall	.-370    	; 0xcce <_Z13enc28j60Writehh>
     e40:	40 e0       	ldi	r20, 0x00	; 0
     e42:	60 e0       	ldi	r22, 0x00	; 0
     e44:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     e46:	dd de       	rcall	.-582    	; 0xc02 <_Z15enc28j60WriteOphhh>
     e48:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     e4a:	ce 01       	movw	r24, r28
     e4c:	fd de       	rcall	.-518    	; 0xc48 <_Z19enc28j60WriteBufferjPh>
     e4e:	48 e0       	ldi	r20, 0x08	; 8
     e50:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     e52:	80 e8       	ldi	r24, 0x80	; 128
     e54:	d6 de       	rcall	.-596    	; 0xc02 <_Z15enc28j60WriteOphhh>
     e56:	8c e1       	ldi	r24, 0x1C	; 28
     e58:	32 df       	rcall	.-412    	; 0xcbe <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     e5a:	81 ff       	sbrs	r24, 1
     e5c:	04 c0       	rjmp	.+8      	; 0xe66 <_Z18enc28j60PacketSendjPh+0x52>
     e5e:	48 e0       	ldi	r20, 0x08	; 8
     e60:	6f e1       	ldi	r22, 0x1F	; 31
     e62:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     e64:	ce de       	rcall	.-612    	; 0xc02 <_Z15enc28j60WriteOphhh>
     e66:	df 91       	pop	r29
     e68:	cf 91       	pop	r28
     e6a:	1f 91       	pop	r17
     e6c:	0f 91       	pop	r16
     e6e:	08 95       	ret

00000e70 <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     e70:	9f 92       	push	r9
     e72:	af 92       	push	r10
     e74:	bf 92       	push	r11
     e76:	cf 92       	push	r12
     e78:	df 92       	push	r13
     e7a:	ef 92       	push	r14
     e7c:	ff 92       	push	r15
     e7e:	0f 93       	push	r16
     e80:	1f 93       	push	r17
     e82:	cf 93       	push	r28
     e84:	df 93       	push	r29
     e86:	5c 01       	movw	r10, r24
     e88:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     e8a:	89 e3       	ldi	r24, 0x39	; 57
     e8c:	18 df       	rcall	.-464    	; 0xcbe <_Z12enc28j60Readh>
     e8e:	88 23       	and	r24, r24
     e90:	09 f4       	brne	.+2      	; 0xe94 <_Z21enc28j60PacketReceivejPh+0x24>
     e92:	45 c0       	rjmp	.+138    	; 0xf1e <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     e94:	60 91 14 02 	lds	r22, 0x0214	; 0x800214 <_ZL13NextPacketPtr>
     e98:	c0 91 15 02 	lds	r28, 0x0215	; 0x800215 <_ZL13NextPacketPtr+0x1>
     e9c:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     e9e:	17 df       	rcall	.-466    	; 0xcce <_Z13enc28j60Writehh>
     ea0:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	14 df       	rcall	.-472    	; 0xcce <_Z13enc28j60Writehh>
     ea6:	60 e0       	ldi	r22, 0x00	; 0
     ea8:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     eaa:	99 de       	rcall	.-718    	; 0xbde <_Z14enc28j60ReadOphh>
     eac:	c8 2f       	mov	r28, r24
     eae:	60 e0       	ldi	r22, 0x00	; 0
     eb0:	8a e3       	ldi	r24, 0x3A	; 58
     eb2:	95 de       	rcall	.-726    	; 0xbde <_Z14enc28j60ReadOphh>
     eb4:	d0 e0       	ldi	r29, 0x00	; 0
     eb6:	d8 2b       	or	r29, r24
     eb8:	d0 93 15 02 	sts	0x0215, r29	; 0x800215 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     ebc:	c0 93 14 02 	sts	0x0214, r28	; 0x800214 <_ZL13NextPacketPtr>
     ec0:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     ec2:	8a e3       	ldi	r24, 0x3A	; 58
     ec4:	8c de       	rcall	.-744    	; 0xbde <_Z14enc28j60ReadOphh>
     ec6:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     ec8:	60 e0       	ldi	r22, 0x00	; 0
     eca:	8a e3       	ldi	r24, 0x3A	; 58
     ecc:	88 de       	rcall	.-752    	; 0xbde <_Z14enc28j60ReadOphh>
     ece:	98 2e       	mov	r9, r24
     ed0:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     ed2:	8a e3       	ldi	r24, 0x3A	; 58
     ed4:	84 de       	rcall	.-760    	; 0xbde <_Z14enc28j60ReadOphh>
     ed6:	c8 2e       	mov	r12, r24
     ed8:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     eda:	8a e3       	ldi	r24, 0x3A	; 58
     edc:	80 de       	rcall	.-768    	; 0xbde <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     ede:	c7 fe       	sbrs	r12, 7
     ee0:	0f c0       	rjmp	.+30     	; 0xf00 <_Z21enc28j60PacketReceivejPh+0x90>
     ee2:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     ee4:	a8 1a       	sub	r10, r24
     ee6:	b1 08       	sbc	r11, r1
     ee8:	10 e0       	ldi	r17, 0x00	; 0
     eea:	19 29       	or	r17, r9
     eec:	04 50       	subi	r16, 0x04	; 4
     eee:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     ef0:	a0 16       	cp	r10, r16
     ef2:	b1 06       	cpc	r11, r17
     ef4:	08 f4       	brcc	.+2      	; 0xef8 <_Z21enc28j60PacketReceivejPh+0x88>
     ef6:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     ef8:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     efa:	c8 01       	movw	r24, r16
     efc:	8d de       	rcall	.-742    	; 0xc18 <_Z18enc28j60ReadBufferjPh>
     efe:	02 c0       	rjmp	.+4      	; 0xf04 <_Z21enc28j60PacketReceivejPh+0x94>
     f00:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     f02:	10 e0       	ldi	r17, 0x00	; 0
     f04:	6c 2f       	mov	r22, r28
     f06:	8c e0       	ldi	r24, 0x0C	; 12
     f08:	e2 de       	rcall	.-572    	; 0xcce <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     f0a:	6d 2f       	mov	r22, r29
     f0c:	8d e0       	ldi	r24, 0x0D	; 13
     f0e:	df de       	rcall	.-578    	; 0xcce <_Z13enc28j60Writehh>
     f10:	40 e4       	ldi	r20, 0x40	; 64
     f12:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     f14:	80 e8       	ldi	r24, 0x80	; 128
     f16:	75 de       	rcall	.-790    	; 0xc02 <_Z15enc28j60WriteOphhh>
     f18:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     f1a:	91 2f       	mov	r25, r17
     f1c:	02 c0       	rjmp	.+4      	; 0xf22 <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     f1e:	80 e0       	ldi	r24, 0x00	; 0
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	1f 91       	pop	r17
     f28:	0f 91       	pop	r16
     f2a:	ff 90       	pop	r15
     f2c:	ef 90       	pop	r14
     f2e:	df 90       	pop	r13
     f30:	cf 90       	pop	r12
     f32:	bf 90       	pop	r11
     f34:	af 90       	pop	r10
     f36:	9f 90       	pop	r9
     f38:	08 95       	ret

00000f3a <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     f3a:	cf 92       	push	r12
     f3c:	df 92       	push	r13
     f3e:	ef 92       	push	r14
     f40:	ff 92       	push	r15
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	ec 01       	movw	r28, r24
     f48:	db 01       	movw	r26, r22
     f4a:	41 30       	cpi	r20, 0x01	; 1
     f4c:	61 f4       	brne	.+24     	; 0xf66 <_Z8checksumPhjh+0x2c>
     f4e:	6b 01       	movw	r12, r22
     f50:	88 e0       	ldi	r24, 0x08	; 8
     f52:	c8 1a       	sub	r12, r24
     f54:	d1 08       	sbc	r13, r1
     f56:	e1 2c       	mov	r14, r1
     f58:	f1 2c       	mov	r15, r1
     f5a:	81 e1       	ldi	r24, 0x11	; 17
     f5c:	c8 0e       	add	r12, r24
     f5e:	d1 1c       	adc	r13, r1
     f60:	e1 1c       	adc	r14, r1
     f62:	f1 1c       	adc	r15, r1
     f64:	11 c0       	rjmp	.+34     	; 0xf88 <_Z8checksumPhjh+0x4e>
     f66:	42 30       	cpi	r20, 0x02	; 2
     f68:	61 f4       	brne	.+24     	; 0xf82 <_Z8checksumPhjh+0x48>
     f6a:	6b 01       	movw	r12, r22
     f6c:	88 e0       	ldi	r24, 0x08	; 8
     f6e:	c8 1a       	sub	r12, r24
     f70:	d1 08       	sbc	r13, r1
     f72:	e1 2c       	mov	r14, r1
     f74:	f1 2c       	mov	r15, r1
     f76:	86 e0       	ldi	r24, 0x06	; 6
     f78:	c8 0e       	add	r12, r24
     f7a:	d1 1c       	adc	r13, r1
     f7c:	e1 1c       	adc	r14, r1
     f7e:	f1 1c       	adc	r15, r1
     f80:	03 c0       	rjmp	.+6      	; 0xf88 <_Z8checksumPhjh+0x4e>
     f82:	c1 2c       	mov	r12, r1
     f84:	d1 2c       	mov	r13, r1
     f86:	76 01       	movw	r14, r12
     f88:	a2 30       	cpi	r26, 0x02	; 2
     f8a:	b1 05       	cpc	r27, r1
     f8c:	f0 f0       	brcs	.+60     	; 0xfca <_Z8checksumPhjh+0x90>
     f8e:	9d 01       	movw	r18, r26
     f90:	fe 01       	movw	r30, r28
     f92:	40 81       	ld	r20, Z
     f94:	50 e0       	ldi	r21, 0x00	; 0
     f96:	60 e0       	ldi	r22, 0x00	; 0
     f98:	70 e0       	ldi	r23, 0x00	; 0
     f9a:	76 2f       	mov	r23, r22
     f9c:	65 2f       	mov	r22, r21
     f9e:	54 2f       	mov	r21, r20
     fa0:	44 27       	eor	r20, r20
     fa2:	81 81       	ldd	r24, Z+1	; 0x01
     fa4:	48 2b       	or	r20, r24
     fa6:	c4 0e       	add	r12, r20
     fa8:	d5 1e       	adc	r13, r21
     faa:	e6 1e       	adc	r14, r22
     fac:	f7 1e       	adc	r15, r23
     fae:	32 96       	adiw	r30, 0x02	; 2
     fb0:	22 50       	subi	r18, 0x02	; 2
     fb2:	31 09       	sbc	r19, r1
     fb4:	22 30       	cpi	r18, 0x02	; 2
     fb6:	31 05       	cpc	r19, r1
     fb8:	60 f7       	brcc	.-40     	; 0xf92 <_Z8checksumPhjh+0x58>
     fba:	cd 01       	movw	r24, r26
     fbc:	02 97       	sbiw	r24, 0x02	; 2
     fbe:	8e 7f       	andi	r24, 0xFE	; 254
     fc0:	02 96       	adiw	r24, 0x02	; 2
     fc2:	c8 0f       	add	r28, r24
     fc4:	d9 1f       	adc	r29, r25
     fc6:	a1 70       	andi	r26, 0x01	; 1
     fc8:	bb 27       	eor	r27, r27
     fca:	ab 2b       	or	r26, r27
     fcc:	61 f0       	breq	.+24     	; 0xfe6 <_Z8checksumPhjh+0xac>
     fce:	88 81       	ld	r24, Y
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	a0 e0       	ldi	r26, 0x00	; 0
     fd4:	b0 e0       	ldi	r27, 0x00	; 0
     fd6:	ba 2f       	mov	r27, r26
     fd8:	a9 2f       	mov	r26, r25
     fda:	98 2f       	mov	r25, r24
     fdc:	88 27       	eor	r24, r24
     fde:	c8 0e       	add	r12, r24
     fe0:	d9 1e       	adc	r13, r25
     fe2:	ea 1e       	adc	r14, r26
     fe4:	fb 1e       	adc	r15, r27
     fe6:	a7 01       	movw	r20, r14
     fe8:	66 27       	eor	r22, r22
     fea:	77 27       	eor	r23, r23
     fec:	41 15       	cp	r20, r1
     fee:	51 05       	cpc	r21, r1
     ff0:	61 05       	cpc	r22, r1
     ff2:	71 05       	cpc	r23, r1
     ff4:	71 f0       	breq	.+28     	; 0x1012 <_Z8checksumPhjh+0xd8>
     ff6:	ee 24       	eor	r14, r14
     ff8:	ff 24       	eor	r15, r15
     ffa:	c4 0e       	add	r12, r20
     ffc:	d5 1e       	adc	r13, r21
     ffe:	e6 1e       	adc	r14, r22
    1000:	f7 1e       	adc	r15, r23
    1002:	a7 01       	movw	r20, r14
    1004:	66 27       	eor	r22, r22
    1006:	77 27       	eor	r23, r23
    1008:	41 15       	cp	r20, r1
    100a:	51 05       	cpc	r21, r1
    100c:	61 05       	cpc	r22, r1
    100e:	71 05       	cpc	r23, r1
    1010:	91 f7       	brne	.-28     	; 0xff6 <_Z8checksumPhjh+0xbc>
    1012:	c6 01       	movw	r24, r12
    1014:	80 95       	com	r24
    1016:	90 95       	com	r25
    1018:	df 91       	pop	r29
    101a:	cf 91       	pop	r28
    101c:	ff 90       	pop	r15
    101e:	ef 90       	pop	r14
    1020:	df 90       	pop	r13
    1022:	cf 90       	pop	r12
    1024:	08 95       	ret

00001026 <_Z19init_ip_arp_udp_tcpPhS_h>:
    1026:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
    102a:	a6 2f       	mov	r26, r22
    102c:	b7 2f       	mov	r27, r23
    102e:	e7 e1       	ldi	r30, 0x17	; 23
    1030:	f2 e0       	ldi	r31, 0x02	; 2
    1032:	4b e1       	ldi	r20, 0x1B	; 27
    1034:	52 e0       	ldi	r21, 0x02	; 2
    1036:	2d 91       	ld	r18, X+
    1038:	21 93       	st	Z+, r18
    103a:	e4 17       	cp	r30, r20
    103c:	f5 07       	cpc	r31, r21
    103e:	d9 f7       	brne	.-10     	; 0x1036 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
    1040:	a8 2f       	mov	r26, r24
    1042:	b9 2f       	mov	r27, r25
    1044:	eb e1       	ldi	r30, 0x1B	; 27
    1046:	f2 e0       	ldi	r31, 0x02	; 2
    1048:	21 e2       	ldi	r18, 0x21	; 33
    104a:	32 e0       	ldi	r19, 0x02	; 2
    104c:	8d 91       	ld	r24, X+
    104e:	81 93       	st	Z+, r24
    1050:	e2 17       	cp	r30, r18
    1052:	f3 07       	cpc	r31, r19
    1054:	d9 f7       	brne	.-10     	; 0x104c <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
    1056:	08 95       	ret

00001058 <_Z25eth_type_is_arp_and_my_ipPhj>:
    1058:	69 32       	cpi	r22, 0x29	; 41
    105a:	71 05       	cpc	r23, r1
    105c:	c8 f0       	brcs	.+50     	; 0x1090 <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
    105e:	fc 01       	movw	r30, r24
    1060:	24 85       	ldd	r18, Z+12	; 0x0c
    1062:	28 30       	cpi	r18, 0x08	; 8
    1064:	b9 f4       	brne	.+46     	; 0x1094 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
    1066:	25 85       	ldd	r18, Z+13	; 0x0d
    1068:	26 30       	cpi	r18, 0x06	; 6
    106a:	b1 f4       	brne	.+44     	; 0x1098 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
    106c:	36 a1       	ldd	r19, Z+38	; 0x26
    106e:	20 91 17 02 	lds	r18, 0x0217	; 0x800217 <_ZL6ipaddr>
    1072:	32 13       	cpse	r19, r18
    1074:	13 c0       	rjmp	.+38     	; 0x109c <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
    1076:	b7 96       	adiw	r30, 0x27	; 39
    1078:	a8 e1       	ldi	r26, 0x18	; 24
    107a:	b2 e0       	ldi	r27, 0x02	; 2
    107c:	8a 96       	adiw	r24, 0x2a	; 42
    107e:	31 91       	ld	r19, Z+
    1080:	2d 91       	ld	r18, X+
    1082:	32 13       	cpse	r19, r18
    1084:	0d c0       	rjmp	.+26     	; 0x10a0 <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
    1086:	e8 17       	cp	r30, r24
    1088:	f9 07       	cpc	r31, r25
    108a:	c9 f7       	brne	.-14     	; 0x107e <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
    108c:	81 e0       	ldi	r24, 0x01	; 1
    108e:	08 95       	ret
    1090:	80 e0       	ldi	r24, 0x00	; 0
    1092:	08 95       	ret
    1094:	80 e0       	ldi	r24, 0x00	; 0
    1096:	08 95       	ret
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	08 95       	ret
    109c:	80 e0       	ldi	r24, 0x00	; 0
    109e:	08 95       	ret
    10a0:	80 e0       	ldi	r24, 0x00	; 0
    10a2:	08 95       	ret

000010a4 <_Z24eth_type_is_ip_and_my_ipPhj>:
    10a4:	cf 93       	push	r28
    10a6:	df 93       	push	r29
    10a8:	fc 01       	movw	r30, r24
    10aa:	6a 32       	cpi	r22, 0x2A	; 42
    10ac:	71 05       	cpc	r23, r1
    10ae:	e0 f0       	brcs	.+56     	; 0x10e8 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
    10b0:	84 85       	ldd	r24, Z+12	; 0x0c
    10b2:	88 30       	cpi	r24, 0x08	; 8
    10b4:	d9 f4       	brne	.+54     	; 0x10ec <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
    10b6:	85 85       	ldd	r24, Z+13	; 0x0d
    10b8:	81 11       	cpse	r24, r1
    10ba:	1a c0       	rjmp	.+52     	; 0x10f0 <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
    10bc:	96 85       	ldd	r25, Z+14	; 0x0e
    10be:	95 34       	cpi	r25, 0x45	; 69
    10c0:	c1 f4       	brne	.+48     	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10c2:	26 8d       	ldd	r18, Z+30	; 0x1e
    10c4:	90 91 17 02 	lds	r25, 0x0217	; 0x800217 <_ZL6ipaddr>
    10c8:	29 13       	cpse	r18, r25
    10ca:	13 c0       	rjmp	.+38     	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10cc:	df 01       	movw	r26, r30
    10ce:	5f 96       	adiw	r26, 0x1f	; 31
    10d0:	c8 e1       	ldi	r28, 0x18	; 24
    10d2:	d2 e0       	ldi	r29, 0x02	; 2
    10d4:	b2 96       	adiw	r30, 0x22	; 34
    10d6:	2d 91       	ld	r18, X+
    10d8:	99 91       	ld	r25, Y+
    10da:	29 13       	cpse	r18, r25
    10dc:	0a c0       	rjmp	.+20     	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10de:	ae 17       	cp	r26, r30
    10e0:	bf 07       	cpc	r27, r31
    10e2:	c9 f7       	brne	.-14     	; 0x10d6 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
    10e4:	81 e0       	ldi	r24, 0x01	; 1
    10e6:	05 c0       	rjmp	.+10     	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10e8:	80 e0       	ldi	r24, 0x00	; 0
    10ea:	03 c0       	rjmp	.+6      	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10ec:	80 e0       	ldi	r24, 0x00	; 0
    10ee:	01 c0       	rjmp	.+2      	; 0x10f2 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
    10f0:	80 e0       	ldi	r24, 0x00	; 0
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	08 95       	ret

000010f8 <_Z8make_ethPh>:
    10f8:	fc 01       	movw	r30, r24
    10fa:	ab e1       	ldi	r26, 0x1B	; 27
    10fc:	b2 e0       	ldi	r27, 0x02	; 2
    10fe:	9c 01       	movw	r18, r24
    1100:	2a 5f       	subi	r18, 0xFA	; 250
    1102:	3f 4f       	sbci	r19, 0xFF	; 255
    1104:	86 81       	ldd	r24, Z+6	; 0x06
    1106:	81 93       	st	Z+, r24
    1108:	8d 91       	ld	r24, X+
    110a:	85 83       	std	Z+5, r24	; 0x05
    110c:	e2 17       	cp	r30, r18
    110e:	f3 07       	cpc	r31, r19
    1110:	c9 f7       	brne	.-14     	; 0x1104 <__stack+0x5>
    1112:	08 95       	ret

00001114 <_Z20fill_ip_hdr_checksumPh>:
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	ec 01       	movw	r28, r24
    111a:	18 8e       	std	Y+24, r1	; 0x18
    111c:	19 8e       	std	Y+25, r1	; 0x19
    111e:	80 e4       	ldi	r24, 0x40	; 64
    1120:	8c 8b       	std	Y+20, r24	; 0x14
    1122:	1d 8a       	std	Y+21, r1	; 0x15
    1124:	8e 8b       	std	Y+22, r24	; 0x16
    1126:	40 e0       	ldi	r20, 0x00	; 0
    1128:	64 e1       	ldi	r22, 0x14	; 20
    112a:	70 e0       	ldi	r23, 0x00	; 0
    112c:	ce 01       	movw	r24, r28
    112e:	0e 96       	adiw	r24, 0x0e	; 14
    1130:	04 df       	rcall	.-504    	; 0xf3a <_Z8checksumPhjh>
    1132:	98 8f       	std	Y+24, r25	; 0x18
    1134:	89 8f       	std	Y+25, r24	; 0x19
    1136:	df 91       	pop	r29
    1138:	cf 91       	pop	r28
    113a:	08 95       	ret

0000113c <_Z7make_ipPh>:
    113c:	ac 01       	movw	r20, r24
    113e:	a7 e1       	ldi	r26, 0x17	; 23
    1140:	b2 e0       	ldi	r27, 0x02	; 2
    1142:	fc 01       	movw	r30, r24
    1144:	7a 96       	adiw	r30, 0x1a	; 26
    1146:	2b e1       	ldi	r18, 0x1B	; 27
    1148:	32 e0       	ldi	r19, 0x02	; 2
    114a:	90 81       	ld	r25, Z
    114c:	94 83       	std	Z+4, r25	; 0x04
    114e:	9d 91       	ld	r25, X+
    1150:	91 93       	st	Z+, r25
    1152:	a2 17       	cp	r26, r18
    1154:	b3 07       	cpc	r27, r19
    1156:	c9 f7       	brne	.-14     	; 0x114a <_Z7make_ipPh+0xe>
    1158:	ca 01       	movw	r24, r20
    115a:	dc cf       	rjmp	.-72     	; 0x1114 <_Z20fill_ip_hdr_checksumPh>
    115c:	08 95       	ret

0000115e <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
    115e:	cf 93       	push	r28
    1160:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
    1162:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
    1164:	c9 df       	rcall	.-110    	; 0x10f8 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
    1166:	1c 8a       	std	Y+20, r1	; 0x14
    1168:	82 e0       	ldi	r24, 0x02	; 2
    116a:	8d 8b       	std	Y+21, r24	; 0x15
    116c:	ab e1       	ldi	r26, 0x1B	; 27
    116e:	b2 e0       	ldi	r27, 0x02	; 2
    1170:	fe 01       	movw	r30, r28
    1172:	76 96       	adiw	r30, 0x16	; 22
    1174:	21 e2       	ldi	r18, 0x21	; 33
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
    1176:	32 e0       	ldi	r19, 0x02	; 2
    1178:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
    117a:	82 87       	std	Z+10, r24	; 0x0a
    117c:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
    117e:	81 93       	st	Z+, r24
    1180:	a2 17       	cp	r26, r18
    1182:	b3 07       	cpc	r27, r19
    1184:	c9 f7       	brne	.-14     	; 0x1178 <_Z28make_arp_answer_from_requestPh+0x1a>
    1186:	a7 e1       	ldi	r26, 0x17	; 23
    1188:	b2 e0       	ldi	r27, 0x02	; 2
    118a:	fe 01       	movw	r30, r28
    118c:	7c 96       	adiw	r30, 0x1c	; 28
    118e:	2b e1       	ldi	r18, 0x1B	; 27
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
    1190:	32 e0       	ldi	r19, 0x02	; 2
    1192:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
    1194:	82 87       	std	Z+10, r24	; 0x0a
    1196:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
    1198:	81 93       	st	Z+, r24
    119a:	a2 17       	cp	r26, r18
    119c:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
    119e:	c9 f7       	brne	.-14     	; 0x1192 <_Z28make_arp_answer_from_requestPh+0x34>
    11a0:	be 01       	movw	r22, r28
    11a2:	8a e2       	ldi	r24, 0x2A	; 42
    11a4:	90 e0       	ldi	r25, 0x00	; 0
}
    11a6:	36 de       	rcall	.-916    	; 0xe14 <_Z18enc28j60PacketSendjPh>
    11a8:	df 91       	pop	r29
    11aa:	cf 91       	pop	r28
    11ac:	08 95       	ret

000011ae <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
    11ae:	0f 93       	push	r16
    11b0:	1f 93       	push	r17
    11b2:	cf 93       	push	r28
    11b4:	df 93       	push	r29
    11b6:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
    11b8:	8b 01       	movw	r16, r22
    11ba:	9e df       	rcall	.-196    	; 0x10f8 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
    11bc:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
    11be:	be df       	rcall	.-132    	; 0x113c <_Z7make_ipPh>
    11c0:	1a a2       	std	Y+34, r1	; 0x22
    11c2:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
    11c4:	88 3f       	cpi	r24, 0xF8	; 248
    11c6:	18 f0       	brcs	.+6      	; 0x11ce <_Z28make_echo_reply_from_requestPhj+0x20>
    11c8:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
    11ca:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
    11cc:	9d a3       	std	Y+37, r25	; 0x25
    11ce:	88 5f       	subi	r24, 0xF8	; 248
    11d0:	8c a3       	std	Y+36, r24	; 0x24
}
    11d2:	be 01       	movw	r22, r28
    11d4:	c8 01       	movw	r24, r16
    11d6:	1e de       	rcall	.-964    	; 0xe14 <_Z18enc28j60PacketSendjPh>
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	1f 91       	pop	r17
    11de:	0f 91       	pop	r16
    11e0:	08 95       	ret

000011e2 <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
    11e2:	df 92       	push	r13
    11e4:	ef 92       	push	r14
    11e6:	ff 92       	push	r15
    11e8:	0f 93       	push	r16
    11ea:	1f 93       	push	r17
    11ec:	cf 93       	push	r28
    11ee:	df 93       	push	r29
    11f0:	ec 01       	movw	r28, r24
    11f2:	d6 2e       	mov	r13, r22
    11f4:	e7 2e       	mov	r14, r23
    11f6:	04 2f       	mov	r16, r20
    11f8:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
    11fa:	f3 2e       	mov	r15, r19
    11fc:	7d df       	rcall	.-262    	; 0x10f8 <_Z8make_ethPh>
    11fe:	0d 3d       	cpi	r16, 0xDD	; 221
    1200:	08 f0       	brcs	.+2      	; 0x1204 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
    1202:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
    1204:	18 8a       	std	Y+16, r1	; 0x10
    1206:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
    1208:	80 0f       	add	r24, r16
    120a:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
    120c:	ce 01       	movw	r24, r28
    120e:	96 df       	rcall	.-212    	; 0x113c <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
    1210:	8a a1       	ldd	r24, Y+34	; 0x22
    1212:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
    1214:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
    1216:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
    1218:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
    121a:	1b a3       	std	Y+35, r17	; 0x23
    121c:	1e a2       	std	Y+38, r1	; 0x26
    121e:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
    1220:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
    1222:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
    1224:	18 a6       	std	Y+40, r1	; 0x28
    1226:	19 a6       	std	Y+41, r1	; 0x29
    1228:	00 23       	and	r16, r16
    122a:	81 f0       	breq	.+32     	; 0x124c <_Z27make_udp_reply_from_requestPhPchj+0x6a>
    122c:	ad 2d       	mov	r26, r13
    122e:	be 2d       	mov	r27, r14
    1230:	fe 01       	movw	r30, r28
    1232:	ba 96       	adiw	r30, 0x2a	; 42
    1234:	2f ef       	ldi	r18, 0xFF	; 255
    1236:	20 0f       	add	r18, r16
    1238:	30 e0       	ldi	r19, 0x00	; 0
    123a:	25 5d       	subi	r18, 0xD5	; 213
    123c:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
    123e:	2c 0f       	add	r18, r28
    1240:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
    1242:	9d 91       	ld	r25, X+
    1244:	91 93       	st	Z+, r25
    1246:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
    1248:	f3 07       	cpc	r31, r19
    124a:	d9 f7       	brne	.-10     	; 0x1242 <_Z27make_udp_reply_from_requestPhPchj+0x60>
    124c:	10 e0       	ldi	r17, 0x00	; 0
    124e:	b8 01       	movw	r22, r16
    1250:	60 5f       	subi	r22, 0xF0	; 240
    1252:	7f 4f       	sbci	r23, 0xFF	; 255
    1254:	41 e0       	ldi	r20, 0x01	; 1
    1256:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
    1258:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
    125a:	6f de       	rcall	.-802    	; 0xf3a <_Z8checksumPhjh>
    125c:	98 a7       	std	Y+40, r25	; 0x28
    125e:	89 a7       	std	Y+41, r24	; 0x29
    1260:	be 01       	movw	r22, r28
}
    1262:	c8 01       	movw	r24, r16
    1264:	8a 96       	adiw	r24, 0x2a	; 42
    1266:	d6 dd       	rcall	.-1108   	; 0xe14 <_Z18enc28j60PacketSendjPh>
    1268:	df 91       	pop	r29
    126a:	cf 91       	pop	r28
    126c:	1f 91       	pop	r17
    126e:	0f 91       	pop	r16
    1270:	ff 90       	pop	r15
    1272:	ef 90       	pop	r14
    1274:	df 90       	pop	r13
    1276:	08 95       	ret

00001278 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
    1278:	87 b3       	in	r24, 0x17	; 23
    127a:	86 60       	ori	r24, 0x06	; 6
    127c:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
    127e:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
    1280:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
    1282:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
    1284:	80 e5       	ldi	r24, 0x50	; 80
    1286:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
    1288:	70 9a       	sbi	0x0e, 0	; 14
    128a:	08 95       	ret

0000128c <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    128c:	00 97       	sbiw	r24, 0x00	; 0
    128e:	41 f0       	breq	.+16     	; 0x12a0 <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1290:	ef eb       	ldi	r30, 0xBF	; 191
    1292:	f0 e0       	ldi	r31, 0x00	; 0
    1294:	31 97       	sbiw	r30, 0x01	; 1
    1296:	f1 f7       	brne	.-4      	; 0x1294 <_Z8delay_msj+0x8>
    1298:	00 c0       	rjmp	.+0      	; 0x129a <_Z8delay_msj+0xe>
    129a:	00 00       	nop
                _delay_ms(0.96);
                ms--;
    129c:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
    129e:	c1 f7       	brne	.-16     	; 0x1290 <_Z8delay_msj+0x4>
    12a0:	08 95       	ret

000012a2 <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
    12a2:	e3 e0       	ldi	r30, 0x03	; 3
    12a4:	f3 e0       	ldi	r31, 0x03	; 3
    12a6:	84 85       	ldd	r24, Z+12	; 0x0c
    12a8:	95 85       	ldd	r25, Z+13	; 0x0d
    12aa:	01 96       	adiw	r24, 0x01	; 1
    12ac:	95 87       	std	Z+13, r25	; 0x0d
    12ae:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
    12b0:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
    12b2:	c6 98       	cbi	0x18, 6	; 24
    12b4:	08 95       	ret

000012b6 <_Z9Set_Alarmv>:
{
	Alarm_Open(ALARM0,20,Set_Alarm);
}
void Set_Alarm()
{
	if(chatter_flag == 0)
    12b6:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <chatter_flag>
    12ba:	81 11       	cpse	r24, r1
    12bc:	03 c0       	rjmp	.+6      	; 0x12c4 <_Z9Set_Alarmv+0xe>
	{
		chatter_flag = 1;
    12be:	81 e0       	ldi	r24, 0x01	; 1
    12c0:	80 93 fe 02 	sts	0x02FE, r24	; 0x8002fe <chatter_flag>
    12c4:	08 95       	ret

000012c6 <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
    12ca:	cd b7       	in	r28, 0x3d	; 61
    12cc:	de b7       	in	r29, 0x3e	; 62
    12ce:	ad 97       	sbiw	r28, 0x2d	; 45
    12d0:	0f b6       	in	r0, 0x3f	; 63
    12d2:	f8 94       	cli
    12d4:	de bf       	out	0x3e, r29	; 62
    12d6:	0f be       	out	0x3f, r0	; 63
    12d8:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    12da:	0f 2e       	mov	r0, r31
    12dc:	ff ef       	ldi	r31, 0xFF	; 255
    12de:	cf 2e       	mov	r12, r31
    12e0:	f2 e0       	ldi	r31, 0x02	; 2
    12e2:	df 2e       	mov	r13, r31
    12e4:	f0 2d       	mov	r31, r0
	 
	 
	
	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    12e6:	0f 2e       	mov	r0, r31
    12e8:	f3 e4       	ldi	r31, 0x43	; 67
    12ea:	4f 2e       	mov	r4, r31
    12ec:	f3 e0       	ldi	r31, 0x03	; 3
    12ee:	5f 2e       	mov	r5, r31
    12f0:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
    12f2:	9e 01       	movw	r18, r28
    12f4:	23 5f       	subi	r18, 0xF3	; 243
    12f6:	3f 4f       	sbci	r19, 0xFF	; 255
    12f8:	3b a7       	std	Y+43, r19	; 0x2b
    12fa:	2a a7       	std	Y+42, r18	; 0x2a
	 //char ip_adr2[3];
	 //char ip_adr3[3];
	 //char ip_adr4[3];
	 lcd->Clear_Lcd();
	 lcd->Device_Writes("IP :");
	 sprintf(ip_adr1,"%d",myip[0]);
    12fc:	0f 2e       	mov	r0, r31
    12fe:	fa ef       	ldi	r31, 0xFA	; 250
    1300:	8f 2e       	mov	r8, r31
    1302:	f2 e0       	ldi	r31, 0x02	; 2
    1304:	9f 2e       	mov	r9, r31
    1306:	f0 2d       	mov	r31, r0
	 
	 
	
	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    1308:	0f 2e       	mov	r0, r31
    130a:	f5 e4       	ldi	r31, 0x45	; 69
    130c:	6f 2e       	mov	r6, r31
    130e:	f3 e0       	ldi	r31, 0x03	; 3
    1310:	7f 2e       	mov	r7, r31
    1312:	f0 2d       	mov	r31, r0
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    1314:	f6 01       	movw	r30, r12
    1316:	80 81       	ld	r24, Z
    1318:	91 81       	ldd	r25, Z+1	; 0x01
    131a:	a2 81       	ldd	r26, Z+2	; 0x02
    131c:	b3 81       	ldd	r27, Z+3	; 0x03
    131e:	80 93 fa 02 	sts	0x02FA, r24	; 0x8002fa <_ZZL5proc2PvE4myip>
    1322:	90 93 fb 02 	sts	0x02FB, r25	; 0x8002fb <_ZZL5proc2PvE4myip+0x1>
    1326:	a0 93 fc 02 	sts	0x02FC, r26	; 0x8002fc <_ZZL5proc2PvE4myip+0x2>
    132a:	b0 93 fd 02 	sts	0x02FD, r27	; 0x8002fd <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
    132e:	8f ef       	ldi	r24, 0xFF	; 255
    1330:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    1332:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    1338:	f3 dc       	rcall	.-1562   	; 0xd20 <_Z12enc28j60InitPh>
    133a:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    133c:	ec dc       	rcall	.-1576   	; 0xd16 <_Z14enc28j60clkouth>
    133e:	8a e0       	ldi	r24, 0x0A	; 10
    1340:	90 e0       	ldi	r25, 0x00	; 0
    1342:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    1346:	66 e7       	ldi	r22, 0x76	; 118
    1348:	74 e0       	ldi	r23, 0x04	; 4
    134a:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    134c:	cc dc       	rcall	.-1640   	; 0xce6 <_Z16enc28j60PhyWritehj>
    134e:	84 e1       	ldi	r24, 0x14	; 20
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <vTaskDelay>
	 //init the ethernet/ip layer:
	 char ip_adr1[12];
	 //char ip_adr2[3];
	 //char ip_adr3[3];
	 //char ip_adr4[3];
	 lcd->Clear_Lcd();
    1356:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    135a:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
	 lcd->Device_Writes("IP :");
    135e:	00 d9       	rcall	.-3584   	; 0x560 <_ZN13Char_LCD2004A9Clear_LcdEv>
    1360:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1364:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1368:	dc 01       	movw	r26, r24
    136a:	ed 91       	ld	r30, X+
    136c:	fc 91       	ld	r31, X
    136e:	04 80       	ldd	r0, Z+4	; 0x04
    1370:	f5 81       	ldd	r31, Z+5	; 0x05
    1372:	e0 2d       	mov	r30, r0
    1374:	67 e5       	ldi	r22, 0x57	; 87
    1376:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%d",myip[0]);
    1378:	09 95       	icall
    137a:	f4 01       	movw	r30, r8
    137c:	80 81       	ld	r24, Z
    137e:	1f 92       	push	r1
    1380:	8f 93       	push	r24
    1382:	0f 2e       	mov	r0, r31
    1384:	fc e5       	ldi	r31, 0x5C	; 92
    1386:	ef 2e       	mov	r14, r31
    1388:	f1 e0       	ldi	r31, 0x01	; 1
    138a:	ff 2e       	mov	r15, r31
    138c:	f0 2d       	mov	r31, r0
    138e:	ff 92       	push	r15
    1390:	ef 92       	push	r14
    1392:	8e 01       	movw	r16, r28
    1394:	0f 5f       	subi	r16, 0xFF	; 255
    1396:	1f 4f       	sbci	r17, 0xFF	; 255
    1398:	1f 93       	push	r17
    139a:	0f 93       	push	r16
    139c:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    13a0:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    13a4:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    13a8:	dc 01       	movw	r26, r24
    13aa:	ed 91       	ld	r30, X+
    13ac:	fc 91       	ld	r31, X
    13ae:	04 80       	ldd	r0, Z+4	; 0x04
    13b0:	f5 81       	ldd	r31, Z+5	; 0x05
    13b2:	e0 2d       	mov	r30, r0
    13b4:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(".");
    13b6:	09 95       	icall
    13b8:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    13bc:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    13c0:	dc 01       	movw	r26, r24
    13c2:	ed 91       	ld	r30, X+
    13c4:	fc 91       	ld	r31, X
    13c6:	04 80       	ldd	r0, Z+4	; 0x04
    13c8:	f5 81       	ldd	r31, Z+5	; 0x05
    13ca:	e0 2d       	mov	r30, r0
    13cc:	6f e5       	ldi	r22, 0x5F	; 95
    13ce:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%d",myip[1]);
    13d0:	09 95       	icall
    13d2:	f4 01       	movw	r30, r8
    13d4:	81 81       	ldd	r24, Z+1	; 0x01
    13d6:	1f 92       	push	r1
    13d8:	8f 93       	push	r24
    13da:	ff 92       	push	r15
    13dc:	ef 92       	push	r14
    13de:	1f 93       	push	r17
    13e0:	0f 93       	push	r16
    13e2:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    13e6:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    13ea:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    13ee:	dc 01       	movw	r26, r24
    13f0:	ed 91       	ld	r30, X+
    13f2:	fc 91       	ld	r31, X
    13f4:	04 80       	ldd	r0, Z+4	; 0x04
    13f6:	f5 81       	ldd	r31, Z+5	; 0x05
    13f8:	e0 2d       	mov	r30, r0
    13fa:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(".");
    13fc:	09 95       	icall
    13fe:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1402:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1406:	dc 01       	movw	r26, r24
    1408:	ed 91       	ld	r30, X+
    140a:	fc 91       	ld	r31, X
    140c:	04 80       	ldd	r0, Z+4	; 0x04
    140e:	f5 81       	ldd	r31, Z+5	; 0x05
    1410:	e0 2d       	mov	r30, r0
    1412:	6f e5       	ldi	r22, 0x5F	; 95
    1414:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%d",myip[2]);
    1416:	09 95       	icall
    1418:	f4 01       	movw	r30, r8
    141a:	82 81       	ldd	r24, Z+2	; 0x02
    141c:	1f 92       	push	r1
    141e:	8f 93       	push	r24
    1420:	ff 92       	push	r15
    1422:	ef 92       	push	r14
    1424:	1f 93       	push	r17
    1426:	0f 93       	push	r16
    1428:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    142c:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1430:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1434:	dc 01       	movw	r26, r24
    1436:	ed 91       	ld	r30, X+
    1438:	fc 91       	ld	r31, X
    143a:	04 80       	ldd	r0, Z+4	; 0x04
    143c:	f5 81       	ldd	r31, Z+5	; 0x05
    143e:	e0 2d       	mov	r30, r0
    1440:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(".");
    1442:	09 95       	icall
    1444:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1448:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    144c:	dc 01       	movw	r26, r24
    144e:	ed 91       	ld	r30, X+
    1450:	fc 91       	ld	r31, X
    1452:	04 80       	ldd	r0, Z+4	; 0x04
    1454:	f5 81       	ldd	r31, Z+5	; 0x05
    1456:	e0 2d       	mov	r30, r0
    1458:	6f e5       	ldi	r22, 0x5F	; 95
    145a:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%d",myip[3]);
    145c:	09 95       	icall
    145e:	f4 01       	movw	r30, r8
    1460:	83 81       	ldd	r24, Z+3	; 0x03
    1462:	1f 92       	push	r1
    1464:	8f 93       	push	r24
    1466:	ff 92       	push	r15
    1468:	ef 92       	push	r14
    146a:	1f 93       	push	r17
    146c:	0f 93       	push	r16
    146e:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    1472:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1476:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    147a:	dc 01       	movw	r26, r24
    147c:	ed 91       	ld	r30, X+
    147e:	fc 91       	ld	r31, X
    1480:	04 80       	ldd	r0, Z+4	; 0x04
    1482:	f5 81       	ldd	r31, Z+5	; 0x05
    1484:	e0 2d       	mov	r30, r0
    1486:	b8 01       	movw	r22, r16
	 lcd->Set_Cursor_Print(0,1,"MAC:");
    1488:	09 95       	icall
    148a:	21 e6       	ldi	r18, 0x61	; 97
    148c:	31 e0       	ldi	r19, 0x01	; 1
    148e:	41 e0       	ldi	r20, 0x01	; 1
    1490:	60 e0       	ldi	r22, 0x00	; 0
    1492:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1496:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
	 
	 sprintf(ip_adr1,"%x",mymac[0]);
    149a:	9b d8       	rcall	.-3786   	; 0x5d2 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc>
    149c:	0f 2e       	mov	r0, r31
    149e:	f1 e0       	ldi	r31, 0x01	; 1
    14a0:	af 2e       	mov	r10, r31
    14a2:	f1 e0       	ldi	r31, 0x01	; 1
    14a4:	bf 2e       	mov	r11, r31
    14a6:	f0 2d       	mov	r31, r0
    14a8:	f5 01       	movw	r30, r10
    14aa:	80 81       	ld	r24, Z
    14ac:	1f 92       	push	r1
    14ae:	8f 93       	push	r24
    14b0:	0f 2e       	mov	r0, r31
    14b2:	f6 e6       	ldi	r31, 0x66	; 102
    14b4:	ef 2e       	mov	r14, r31
    14b6:	f1 e0       	ldi	r31, 0x01	; 1
    14b8:	ff 2e       	mov	r15, r31
    14ba:	f0 2d       	mov	r31, r0
    14bc:	ff 92       	push	r15
    14be:	ef 92       	push	r14
    14c0:	1f 93       	push	r17
    14c2:	0f 93       	push	r16
    14c4:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    14c8:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    14cc:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    14d0:	dc 01       	movw	r26, r24
    14d2:	ed 91       	ld	r30, X+
    14d4:	fc 91       	ld	r31, X
    14d6:	04 80       	ldd	r0, Z+4	; 0x04
    14d8:	f5 81       	ldd	r31, Z+5	; 0x05
    14da:	e0 2d       	mov	r30, r0
    14dc:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    14de:	09 95       	icall
    14e0:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    14e4:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    14e8:	dc 01       	movw	r26, r24
    14ea:	ed 91       	ld	r30, X+
    14ec:	fc 91       	ld	r31, X
    14ee:	04 80       	ldd	r0, Z+4	; 0x04
    14f0:	f5 81       	ldd	r31, Z+5	; 0x05
    14f2:	e0 2d       	mov	r30, r0
    14f4:	6a e5       	ldi	r22, 0x5A	; 90
    14f6:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%x",mymac[1]);
    14f8:	09 95       	icall
    14fa:	f5 01       	movw	r30, r10
    14fc:	81 81       	ldd	r24, Z+1	; 0x01
    14fe:	1f 92       	push	r1
    1500:	8f 93       	push	r24
    1502:	ff 92       	push	r15
    1504:	ef 92       	push	r14
    1506:	1f 93       	push	r17
    1508:	0f 93       	push	r16
    150a:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    150e:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1512:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1516:	0f b6       	in	r0, 0x3f	; 63
    1518:	f8 94       	cli
    151a:	de bf       	out	0x3e, r29	; 62
    151c:	0f be       	out	0x3f, r0	; 63
    151e:	cd bf       	out	0x3d, r28	; 61
    1520:	dc 01       	movw	r26, r24
    1522:	ed 91       	ld	r30, X+
    1524:	fc 91       	ld	r31, X
    1526:	04 80       	ldd	r0, Z+4	; 0x04
    1528:	f5 81       	ldd	r31, Z+5	; 0x05
    152a:	e0 2d       	mov	r30, r0
    152c:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    152e:	09 95       	icall
    1530:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1534:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1538:	dc 01       	movw	r26, r24
    153a:	ed 91       	ld	r30, X+
    153c:	fc 91       	ld	r31, X
    153e:	04 80       	ldd	r0, Z+4	; 0x04
    1540:	f5 81       	ldd	r31, Z+5	; 0x05
    1542:	e0 2d       	mov	r30, r0
    1544:	6a e5       	ldi	r22, 0x5A	; 90
    1546:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%x",mymac[2]);
    1548:	09 95       	icall
    154a:	f5 01       	movw	r30, r10
    154c:	82 81       	ldd	r24, Z+2	; 0x02
    154e:	1f 92       	push	r1
    1550:	8f 93       	push	r24
    1552:	ff 92       	push	r15
    1554:	ef 92       	push	r14
    1556:	1f 93       	push	r17
    1558:	0f 93       	push	r16
    155a:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    155e:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1562:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1566:	dc 01       	movw	r26, r24
    1568:	ed 91       	ld	r30, X+
    156a:	fc 91       	ld	r31, X
    156c:	04 80       	ldd	r0, Z+4	; 0x04
    156e:	f5 81       	ldd	r31, Z+5	; 0x05
    1570:	e0 2d       	mov	r30, r0
    1572:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    1574:	09 95       	icall
    1576:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    157a:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    157e:	dc 01       	movw	r26, r24
    1580:	ed 91       	ld	r30, X+
    1582:	fc 91       	ld	r31, X
    1584:	04 80       	ldd	r0, Z+4	; 0x04
    1586:	f5 81       	ldd	r31, Z+5	; 0x05
    1588:	e0 2d       	mov	r30, r0
    158a:	6a e5       	ldi	r22, 0x5A	; 90
    158c:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%x",mymac[3]);
    158e:	09 95       	icall
    1590:	f5 01       	movw	r30, r10
    1592:	83 81       	ldd	r24, Z+3	; 0x03
    1594:	1f 92       	push	r1
    1596:	8f 93       	push	r24
    1598:	ff 92       	push	r15
    159a:	ef 92       	push	r14
    159c:	1f 93       	push	r17
    159e:	0f 93       	push	r16
    15a0:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    15a4:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    15a8:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    15ac:	dc 01       	movw	r26, r24
    15ae:	ed 91       	ld	r30, X+
    15b0:	fc 91       	ld	r31, X
    15b2:	04 80       	ldd	r0, Z+4	; 0x04
    15b4:	f5 81       	ldd	r31, Z+5	; 0x05
    15b6:	e0 2d       	mov	r30, r0
    15b8:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    15ba:	09 95       	icall
    15bc:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    15c0:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    15c4:	dc 01       	movw	r26, r24
    15c6:	ed 91       	ld	r30, X+
    15c8:	fc 91       	ld	r31, X
    15ca:	04 80       	ldd	r0, Z+4	; 0x04
    15cc:	f5 81       	ldd	r31, Z+5	; 0x05
    15ce:	e0 2d       	mov	r30, r0
    15d0:	6a e5       	ldi	r22, 0x5A	; 90
    15d2:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%x",mymac[4]);
    15d4:	09 95       	icall
    15d6:	f5 01       	movw	r30, r10
    15d8:	84 81       	ldd	r24, Z+4	; 0x04
    15da:	1f 92       	push	r1
    15dc:	8f 93       	push	r24
    15de:	ff 92       	push	r15
    15e0:	ef 92       	push	r14
    15e2:	1f 93       	push	r17
    15e4:	0f 93       	push	r16
    15e6:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    15ea:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    15ee:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    15f2:	dc 01       	movw	r26, r24
    15f4:	ed 91       	ld	r30, X+
    15f6:	fc 91       	ld	r31, X
    15f8:	04 80       	ldd	r0, Z+4	; 0x04
    15fa:	f5 81       	ldd	r31, Z+5	; 0x05
    15fc:	e0 2d       	mov	r30, r0
    15fe:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    1600:	09 95       	icall
    1602:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1606:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    160a:	dc 01       	movw	r26, r24
    160c:	ed 91       	ld	r30, X+
    160e:	fc 91       	ld	r31, X
    1610:	04 80       	ldd	r0, Z+4	; 0x04
    1612:	f5 81       	ldd	r31, Z+5	; 0x05
    1614:	e0 2d       	mov	r30, r0
    1616:	6a e5       	ldi	r22, 0x5A	; 90
    1618:	71 e0       	ldi	r23, 0x01	; 1
	 sprintf(ip_adr1,"%x",mymac[5]);
    161a:	09 95       	icall
    161c:	f5 01       	movw	r30, r10
    161e:	85 81       	ldd	r24, Z+5	; 0x05
    1620:	1f 92       	push	r1
    1622:	8f 93       	push	r24
    1624:	ff 92       	push	r15
    1626:	ef 92       	push	r14
    1628:	1f 93       	push	r17
    162a:	0f 93       	push	r16
    162c:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <sprintf>
	 lcd->Device_Writes(ip_adr1);
    1630:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1634:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1638:	dc 01       	movw	r26, r24
    163a:	ed 91       	ld	r30, X+
    163c:	fc 91       	ld	r31, X
    163e:	04 80       	ldd	r0, Z+4	; 0x04
    1640:	f5 81       	ldd	r31, Z+5	; 0x05
    1642:	e0 2d       	mov	r30, r0
    1644:	b8 01       	movw	r22, r16
	 lcd->Device_Writes(":");
    1646:	09 95       	icall
    1648:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    164c:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1650:	dc 01       	movw	r26, r24
    1652:	ed 91       	ld	r30, X+
    1654:	fc 91       	ld	r31, X
    1656:	04 80       	ldd	r0, Z+4	; 0x04
    1658:	f5 81       	ldd	r31, Z+5	; 0x05
    165a:	e0 2d       	mov	r30, r0
    165c:	6a e5       	ldi	r22, 0x5A	; 90
    165e:	71 e0       	ldi	r23, 0x01	; 1
	 lcd->Set_Cursor_Print(0,2,"  Sensor Gateway");
    1660:	09 95       	icall
    1662:	29 e6       	ldi	r18, 0x69	; 105
    1664:	31 e0       	ldi	r19, 0x01	; 1
    1666:	42 e0       	ldi	r20, 0x02	; 2
    1668:	60 e0       	ldi	r22, 0x00	; 0
    166a:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    166e:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
    1672:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc>
	 lcd->Set_Cursor_Print(0,3,"  BLUE-BIZ.CO.LTD");
    1676:	2a e7       	ldi	r18, 0x7A	; 122
    1678:	31 e0       	ldi	r19, 0x01	; 1
    167a:	43 e0       	ldi	r20, 0x03	; 3
    167c:	60 e0       	ldi	r22, 0x00	; 0
    167e:	80 91 84 03 	lds	r24, 0x0384	; 0x800384 <lcd>
    1682:	90 91 85 03 	lds	r25, 0x0385	; 0x800385 <lcd+0x1>
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    1686:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <_ZN13Char_LCD2004A16Set_Cursor_PrintEccPKc>
    168a:	40 e5       	ldi	r20, 0x50	; 80
    168c:	b4 01       	movw	r22, r8
    168e:	c5 01       	movw	r24, r10
    1690:	ca dc       	rcall	.-1644   	; 0x1026 <_Z19init_ip_arp_udp_tcpPhS_h>
    1692:	0f b6       	in	r0, 0x3f	; 63
    1694:	f8 94       	cli
    1696:	de bf       	out	0x3e, r29	; 62
    1698:	0f be       	out	0x3f, r0	; 63

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
    169a:	cd bf       	out	0x3d, r28	; 61
	 
	 
	
	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    169c:	21 2c       	mov	r2, r1
    169e:	33 24       	eor	r3, r3
    16a0:	33 94       	inc	r3
    16a2:	07 e4       	ldi	r16, 0x47	; 71
    16a4:	13 e0       	ldi	r17, 0x03	; 3
    16a6:	0f 2e       	mov	r0, r31
    16a8:	f9 e4       	ldi	r31, 0x49	; 73
    16aa:	ef 2e       	mov	r14, r31
    16ac:	f3 e0       	ldi	r31, 0x03	; 3
    16ae:	ff 2e       	mov	r15, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    16b0:	f0 2d       	mov	r31, r0
    16b2:	0f 2e       	mov	r0, r31
    16b4:	f3 e0       	ldi	r31, 0x03	; 3
    16b6:	af 2e       	mov	r10, r31
    16b8:	f3 e0       	ldi	r31, 0x03	; 3
    16ba:	bf 2e       	mov	r11, r31
	 
	 
	
	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    16bc:	f0 2d       	mov	r31, r0
    16be:	d6 01       	movw	r26, r12
    16c0:	8c 91       	ld	r24, X
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	f2 01       	movw	r30, r4
    16c6:	60 81       	ld	r22, Z
    16c8:	71 81       	ldd	r23, Z+1	; 0x01
    16ca:	11 96       	adiw	r26, 0x01	; 1
    16cc:	4c 91       	ld	r20, X
    16ce:	50 e0       	ldi	r21, 0x00	; 0
    16d0:	33 2d       	mov	r19, r3
    16d2:	f3 01       	movw	r30, r6
    16d4:	a0 81       	ld	r26, Z
    16d6:	b1 81       	ldd	r27, Z+1	; 0x01
    16d8:	4a 17       	cp	r20, r26
    16da:	5b 07       	cpc	r21, r27
    16dc:	09 f4       	brne	.+2      	; 0x16e0 <_ZL5proc2Pv+0x41a>
    16de:	30 e0       	ldi	r19, 0x00	; 0
    16e0:	23 2d       	mov	r18, r3
    16e2:	86 17       	cp	r24, r22
    16e4:	97 07       	cpc	r25, r23
    16e6:	09 f4       	brne	.+2      	; 0x16ea <_ZL5proc2Pv+0x424>
    16e8:	20 e0       	ldi	r18, 0x00	; 0
    16ea:	f3 2f       	mov	r31, r19
    16ec:	f2 2b       	or	r31, r18
    16ee:	d6 01       	movw	r26, r12
    16f0:	12 96       	adiw	r26, 0x02	; 2
    16f2:	2c 91       	ld	r18, X
    16f4:	30 e0       	ldi	r19, 0x00	; 0
    16f6:	e3 2d       	mov	r30, r3
    16f8:	d8 01       	movw	r26, r16
    16fa:	4d 91       	ld	r20, X+
    16fc:	5c 91       	ld	r21, X
    16fe:	24 17       	cp	r18, r20
    1700:	35 07       	cpc	r19, r21
    1702:	09 f4       	brne	.+2      	; 0x1706 <_ZL5proc2Pv+0x440>
    1704:	e0 e0       	ldi	r30, 0x00	; 0
    1706:	ef 2b       	or	r30, r31
    1708:	71 f4       	brne	.+28     	; 0x1726 <_ZL5proc2Pv+0x460>
    170a:	f6 01       	movw	r30, r12
    170c:	23 81       	ldd	r18, Z+3	; 0x03
    170e:	30 e0       	ldi	r19, 0x00	; 0
    1710:	e3 2d       	mov	r30, r3
    1712:	d7 01       	movw	r26, r14
    1714:	4d 91       	ld	r20, X+
    1716:	5c 91       	ld	r21, X
    1718:	24 17       	cp	r18, r20
    171a:	35 07       	cpc	r19, r21
    171c:	09 f4       	brne	.+2      	; 0x1720 <_ZL5proc2Pv+0x45a>
    171e:	e0 e0       	ldi	r30, 0x00	; 0
    1720:	ee 23       	and	r30, r30
    1722:	09 f4       	brne	.+2      	; 0x1726 <_ZL5proc2Pv+0x460>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    1724:	46 c0       	rjmp	.+140    	; 0x17b2 <_ZL5proc2Pv+0x4ec>
    1726:	86 17       	cp	r24, r22
    1728:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    172a:	41 f0       	breq	.+16     	; 0x173c <_ZL5proc2Pv+0x476>
    172c:	80 e0       	ldi	r24, 0x00	; 0
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    1734:	f2 01       	movw	r30, r4
    1736:	80 81       	ld	r24, Z
    1738:	d6 01       	movw	r26, r12
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    173a:	8c 93       	st	X, r24
    173c:	f3 01       	movw	r30, r6
    173e:	60 81       	ld	r22, Z
    1740:	71 81       	ldd	r23, Z+1	; 0x01
    1742:	d6 01       	movw	r26, r12
    1744:	11 96       	adiw	r26, 0x01	; 1
    1746:	8c 91       	ld	r24, X
    1748:	90 e0       	ldi	r25, 0x00	; 0
    174a:	86 17       	cp	r24, r22
    174c:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    174e:	49 f0       	breq	.+18     	; 0x1762 <_ZL5proc2Pv+0x49c>
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	90 e0       	ldi	r25, 0x00	; 0
    1754:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    1758:	f3 01       	movw	r30, r6
    175a:	80 81       	ld	r24, Z
    175c:	d6 01       	movw	r26, r12
    175e:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    1760:	8c 93       	st	X, r24
    1762:	60 91 47 03 	lds	r22, 0x0347	; 0x800347 <mem4+0x44>
    1766:	70 91 48 03 	lds	r23, 0x0348	; 0x800348 <mem4+0x45>
    176a:	f6 01       	movw	r30, r12
    176c:	82 81       	ldd	r24, Z+2	; 0x02
    176e:	90 e0       	ldi	r25, 0x00	; 0
    1770:	86 17       	cp	r24, r22
    1772:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    1774:	49 f0       	breq	.+18     	; 0x1788 <_ZL5proc2Pv+0x4c2>
    1776:	82 e0       	ldi	r24, 0x02	; 2
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    177e:	80 91 47 03 	lds	r24, 0x0347	; 0x800347 <mem4+0x44>
    1782:	d6 01       	movw	r26, r12
    1784:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    1786:	8c 93       	st	X, r24
    1788:	60 91 49 03 	lds	r22, 0x0349	; 0x800349 <mem4+0x46>
    178c:	70 91 4a 03 	lds	r23, 0x034A	; 0x80034a <mem4+0x47>
    1790:	f6 01       	movw	r30, r12
    1792:	83 81       	ldd	r24, Z+3	; 0x03
    1794:	90 e0       	ldi	r25, 0x00	; 0
    1796:	86 17       	cp	r24, r22
    1798:	97 07       	cpc	r25, r23
    179a:	09 f4       	brne	.+2      	; 0x179e <_ZL5proc2Pv+0x4d8>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    179c:	bb cd       	rjmp	.-1162   	; 0x1314 <_ZL5proc2Pv+0x4e>
    179e:	83 e0       	ldi	r24, 0x03	; 3
    17a0:	90 e0       	ldi	r25, 0x00	; 0
    17a2:	0e 94 c0 1d 	call	0x3b80	; 0x3b80 <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    17a6:	80 91 49 03 	lds	r24, 0x0349	; 0x800349 <mem4+0x46>
    17aa:	d6 01       	movw	r26, r12
    17ac:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    17ae:	8c 93       	st	X, r24
    17b0:	a5 cd       	rjmp	.-1206   	; 0x12fc <_ZL5proc2Pv+0x36>
    17b2:	61 e3       	ldi	r22, 0x31	; 49
    17b4:	72 e0       	ldi	r23, 0x02	; 2
    17b6:	88 ec       	ldi	r24, 0xC8	; 200
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	5a db       	rcall	.-2380   	; 0xe70 <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    17bc:	9d a7       	std	Y+45, r25	; 0x2d
    17be:	8c a7       	std	Y+44, r24	; 0x2c
    17c0:	00 97       	sbiw	r24, 0x00	; 0
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    17c2:	09 f4       	brne	.+2      	; 0x17c6 <_ZL5proc2Pv+0x500>
    17c4:	73 c0       	rjmp	.+230    	; 0x18ac <_ZL5proc2Pv+0x5e6>
    17c6:	bc 01       	movw	r22, r24
    17c8:	81 e3       	ldi	r24, 0x31	; 49
    17ca:	92 e0       	ldi	r25, 0x02	; 2
		 {
			 make_arp_answer_from_request(buf);
    17cc:	45 dc       	rcall	.-1910   	; 0x1058 <_Z25eth_type_is_arp_and_my_ipPhj>
    17ce:	88 23       	and	r24, r24
    17d0:	21 f0       	breq	.+8      	; 0x17da <_ZL5proc2Pv+0x514>
			 continue;
    17d2:	81 e3       	ldi	r24, 0x31	; 49
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    17d4:	92 e0       	ldi	r25, 0x02	; 2
    17d6:	c3 dc       	rcall	.-1658   	; 0x115e <_Z28make_arp_answer_from_requestPh>
    17d8:	72 cf       	rjmp	.-284    	; 0x16be <_ZL5proc2Pv+0x3f8>
    17da:	6c a5       	ldd	r22, Y+44	; 0x2c
    17dc:	7d a5       	ldd	r23, Y+45	; 0x2d
    17de:	81 e3       	ldi	r24, 0x31	; 49
    17e0:	92 e0       	ldi	r25, 0x02	; 2
    17e2:	60 dc       	rcall	.-1856   	; 0x10a4 <_Z24eth_type_is_ip_and_my_ipPhj>
    17e4:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    17e6:	09 f4       	brne	.+2      	; 0x17ea <_ZL5proc2Pv+0x524>
    17e8:	6a cf       	rjmp	.-300    	; 0x16be <_ZL5proc2Pv+0x3f8>
    17ea:	80 91 48 02 	lds	r24, 0x0248	; 0x800248 <_ZZL5proc2PvE3buf+0x17>
    17ee:	81 30       	cpi	r24, 0x01	; 1
    17f0:	51 f4       	brne	.+20     	; 0x1806 <_ZL5proc2Pv+0x540>
    17f2:	80 91 53 02 	lds	r24, 0x0253	; 0x800253 <_ZZL5proc2PvE3buf+0x22>
		 {
			make_echo_reply_from_request(buf,plen);
    17f6:	88 30       	cpi	r24, 0x08	; 8
    17f8:	31 f4       	brne	.+12     	; 0x1806 <_ZL5proc2Pv+0x540>
    17fa:	6c a5       	ldd	r22, Y+44	; 0x2c
    17fc:	7d a5       	ldd	r23, Y+45	; 0x2d
    17fe:	81 e3       	ldi	r24, 0x31	; 49
			continue;
    1800:	92 e0       	ldi	r25, 0x02	; 2
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    1802:	d5 dc       	rcall	.-1622   	; 0x11ae <_Z28make_echo_reply_from_requestPhj>
    1804:	5c cf       	rjmp	.-328    	; 0x16be <_ZL5proc2Pv+0x3f8>
    1806:	80 91 5b 02 	lds	r24, 0x025B	; 0x80025b <_ZZL5proc2PvE3buf+0x2a>
    180a:	81 33       	cpi	r24, 0x31	; 49
		 {
			 char temp[29] = {0};
    180c:	09 f0       	breq	.+2      	; 0x1810 <_ZL5proc2Pv+0x54a>
    180e:	4e c0       	rjmp	.+156    	; 0x18ac <_ZL5proc2Pv+0x5e6>
    1810:	8d e1       	ldi	r24, 0x1D	; 29
    1812:	ea a5       	ldd	r30, Y+42	; 0x2a
    1814:	fb a5       	ldd	r31, Y+43	; 0x2b
    1816:	11 92       	st	Z+, r1
			 char loop = buf[UDP_DATA_P + 1];
    1818:	8a 95       	dec	r24
    181a:	e9 f7       	brne	.-6      	; 0x1816 <_ZL5proc2Pv+0x550>
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    181c:	80 91 5c 02 	lds	r24, 0x025C	; 0x80025c <_ZZL5proc2PvE3buf+0x2b>
    1820:	80 53       	subi	r24, 0x30	; 48
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	01 96       	adiw	r24, 0x01	; 1
    1826:	82 30       	cpi	r24, 0x02	; 2
    1828:	91 05       	cpc	r25, r1
    182a:	0c f0       	brlt	.+2      	; 0x182e <_ZL5proc2Pv+0x568>
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    182c:	85 c0       	rjmp	.+266    	; 0x1938 <_ZL5proc2Pv+0x672>
    182e:	25 c0       	rjmp	.+74     	; 0x187a <_ZL5proc2Pv+0x5b4>
    1830:	f9 01       	movw	r30, r18
    1832:	ef 5c       	subi	r30, 0xCF	; 207
    1834:	fd 4f       	sbci	r31, 0xFD	; 253
    1836:	63 a5       	ldd	r22, Z+43	; 0x2b
    1838:	ec e0       	ldi	r30, 0x0C	; 12
    183a:	f0 e0       	ldi	r31, 0x00	; 0
    183c:	ec 0f       	add	r30, r28
    183e:	fd 1f       	adc	r31, r29
    1840:	e2 0f       	add	r30, r18
				 if(i % 2 == 0)
    1842:	f3 1f       	adc	r31, r19
    1844:	60 83       	st	Z, r22
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    1846:	40 fd       	sbrc	r20, 0
    1848:	12 c0       	rjmp	.+36     	; 0x186e <_ZL5proc2Pv+0x5a8>
    184a:	e5 2f       	mov	r30, r21
    184c:	f0 e0       	ldi	r31, 0x00	; 0
    184e:	ee 0f       	add	r30, r30
    1850:	ff 1f       	adc	r31, r31
    1852:	e9 5e       	subi	r30, 0xE9	; 233
    1854:	fc 4f       	sbci	r31, 0xFC	; 252
    1856:	ab e0       	ldi	r26, 0x0B	; 11
    1858:	b0 e0       	ldi	r27, 0x00	; 0
    185a:	ac 0f       	add	r26, r28
    185c:	bd 1f       	adc	r27, r29
    185e:	a2 0f       	add	r26, r18
    1860:	b3 1f       	adc	r27, r19
    1862:	2c 91       	ld	r18, X
    1864:	30 e0       	ldi	r19, 0x00	; 0
    1866:	36 2b       	or	r19, r22
					num++;
    1868:	31 83       	std	Z+1, r19	; 0x01
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    186a:	20 83       	st	Z, r18
    186c:	5f 5f       	subi	r21, 0xFF	; 255
    186e:	4f 5f       	subi	r20, 0xFF	; 255
    1870:	24 2f       	mov	r18, r20
    1872:	30 e0       	ldi	r19, 0x00	; 0
    1874:	28 17       	cp	r18, r24
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    1876:	39 07       	cpc	r19, r25
    1878:	dc f2       	brlt	.-74     	; 0x1830 <_ZL5proc2Pv+0x56a>
    187a:	d5 01       	movw	r26, r10
    187c:	d0 96       	adiw	r26, 0x30	; 48
    187e:	8d 91       	ld	r24, X+
    1880:	9c 91       	ld	r25, X
    1882:	d1 97       	sbiw	r26, 0x31	; 49
    1884:	51 96       	adiw	r26, 0x11	; 17
    1886:	9c 93       	st	X, r25
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1888:	8e 93       	st	-X, r24
    188a:	50 97       	sbiw	r26, 0x10	; 16
    188c:	dd 96       	adiw	r26, 0x3d	; 61
    188e:	9c 93       	st	X, r25
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    1890:	8e 93       	st	-X, r24
    1892:	dc 97       	sbiw	r26, 0x3c	; 60
    1894:	d9 96       	adiw	r26, 0x39	; 57
    1896:	9c 93       	st	X, r25
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1898:	8e 93       	st	-X, r24
    189a:	d8 97       	sbiw	r26, 0x38	; 56
    189c:	d7 96       	adiw	r26, 0x37	; 55
    189e:	9c 93       	st	X, r25
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    18a0:	8e 93       	st	-X, r24
    18a2:	d6 97       	sbiw	r26, 0x36	; 54
    18a4:	df 96       	adiw	r26, 0x3f	; 63
    18a6:	9c 93       	st	X, r25
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    18a8:	8e 93       	st	-X, r24
			 if(led_flag)
    18aa:	de 97       	sbiw	r26, 0x3e	; 62
			 {
				 PORTB = sbi(PORTB,4);
    18ac:	20 94       	com	r2
    18ae:	29 f0       	breq	.+10     	; 0x18ba <_ZL5proc2Pv+0x5f4>
    18b0:	88 b3       	in	r24, 0x18	; 24
    18b2:	80 61       	ori	r24, 0x10	; 16
    18b4:	88 bb       	out	0x18, r24	; 24
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    18b6:	88 bb       	out	0x18, r24	; 24
    18b8:	04 c0       	rjmp	.+8      	; 0x18c2 <_ZL5proc2Pv+0x5fc>
    18ba:	88 b3       	in	r24, 0x18	; 24
    18bc:	8f 7e       	andi	r24, 0xEF	; 239
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    18be:	88 bb       	out	0x18, r24	; 24
    18c0:	88 bb       	out	0x18, r24	; 24
    18c2:	f5 01       	movw	r30, r10
    18c4:	82 81       	ldd	r24, Z+2	; 0x02
    18c6:	93 81       	ldd	r25, Z+3	; 0x03
    18c8:	a1 e2       	ldi	r26, 0x21	; 33
    18ca:	b2 e0       	ldi	r27, 0x02	; 2
    18cc:	11 96       	adiw	r26, 0x01	; 1
			 data[1] = mem4[COUNT];
    18ce:	9c 93       	st	X, r25
    18d0:	8e 93       	st	-X, r24
    18d2:	86 81       	ldd	r24, Z+6	; 0x06
    18d4:	97 81       	ldd	r25, Z+7	; 0x07
    18d6:	90 93 24 02 	sts	0x0224, r25	; 0x800224 <_ZZL5proc2PvE4data+0x3>
			 data[2] = mem4[PRESSURE];
    18da:	80 93 23 02 	sts	0x0223, r24	; 0x800223 <_ZZL5proc2PvE4data+0x2>
    18de:	84 81       	ldd	r24, Z+4	; 0x04
    18e0:	95 81       	ldd	r25, Z+5	; 0x05
    18e2:	90 93 26 02 	sts	0x0226, r25	; 0x800226 <_ZZL5proc2PvE4data+0x5>
			 data[3] = mem4[GOAL_CNT];
    18e6:	80 93 25 02 	sts	0x0225, r24	; 0x800225 <_ZZL5proc2PvE4data+0x4>
    18ea:	80 89       	ldd	r24, Z+16	; 0x10
    18ec:	91 89       	ldd	r25, Z+17	; 0x11
    18ee:	90 93 28 02 	sts	0x0228, r25	; 0x800228 <_ZZL5proc2PvE4data+0x7>
			 data[4] = mem4[MACHINE_STATES];
    18f2:	80 93 27 02 	sts	0x0227, r24	; 0x800227 <_ZZL5proc2PvE4data+0x6>
    18f6:	82 89       	ldd	r24, Z+18	; 0x12
    18f8:	93 89       	ldd	r25, Z+19	; 0x13
    18fa:	90 93 2a 02 	sts	0x022A, r25	; 0x80022a <_ZZL5proc2PvE4data+0x9>
			 data[5] = mem4[SEC];
    18fe:	80 93 29 02 	sts	0x0229, r24	; 0x800229 <_ZZL5proc2PvE4data+0x8>
    1902:	84 85       	ldd	r24, Z+12	; 0x0c
    1904:	95 85       	ldd	r25, Z+13	; 0x0d
    1906:	90 93 2c 02 	sts	0x022C, r25	; 0x80022c <_ZZL5proc2PvE4data+0xb>
			 data[6] = mem4[MIN];
    190a:	80 93 2b 02 	sts	0x022B, r24	; 0x80022b <_ZZL5proc2PvE4data+0xa>
    190e:	82 85       	ldd	r24, Z+10	; 0x0a
    1910:	93 85       	ldd	r25, Z+11	; 0x0b
    1912:	90 93 2e 02 	sts	0x022E, r25	; 0x80022e <_ZZL5proc2PvE4data+0xd>
			 data[7] = mem4[HOUR];
    1916:	80 93 2d 02 	sts	0x022D, r24	; 0x80022d <_ZZL5proc2PvE4data+0xc>
    191a:	80 85       	ldd	r24, Z+8	; 0x08
    191c:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    191e:	90 93 30 02 	sts	0x0230, r25	; 0x800230 <_ZZL5proc2PvE4data+0xf>
    1922:	80 93 2f 02 	sts	0x022F, r24	; 0x80022f <_ZZL5proc2PvE4data+0xe>
    1926:	2f e0       	ldi	r18, 0x0F	; 15
    1928:	37 e2       	ldi	r19, 0x27	; 39
    192a:	40 e1       	ldi	r20, 0x10	; 16
    192c:	bd 01       	movw	r22, r26
			// memcpy(buf,data,sizeof(data));
			 //enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+sizeof(data),buf);
			 //vTaskDelay(500);
			 //memset(buf,0,sizeof(buf));
			// vTaskDelay(100);
			taskYIELD();
    192e:	81 e3       	ldi	r24, 0x31	; 49
    1930:	92 e0       	ldi	r25, 0x02	; 2
    1932:	57 dc       	rcall	.-1874   	; 0x11e2 <_Z27make_udp_reply_from_requestPhPchj>
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    1934:	d5 d4       	rcall	.+2474   	; 0x22e0 <vPortYield>
    1936:	c3 ce       	rjmp	.-634    	; 0x16be <_ZL5proc2Pv+0x3f8>
    1938:	20 91 5d 02 	lds	r18, 0x025D	; 0x80025d <_ZZL5proc2PvE3buf+0x2c>
    193c:	2d 87       	std	Y+13, r18	; 0x0d
    193e:	41 e0       	ldi	r20, 0x01	; 1
    1940:	50 e0       	ldi	r21, 0x00	; 0
    1942:	95 cf       	rjmp	.-214    	; 0x186e <_ZL5proc2Pv+0x5a8>

00001944 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    1944:	cf 93       	push	r28
    1946:	df 93       	push	r29
    1948:	cd b7       	in	r28, 0x3d	; 61
    194a:	de b7       	in	r29, 0x3e	; 62
    194c:	2f 97       	sbiw	r28, 0x0f	; 15
    194e:	0f b6       	in	r0, 0x3f	; 63
    1950:	f8 94       	cli
    1952:	de bf       	out	0x3e, r29	; 62
    1954:	0f be       	out	0x3f, r0	; 63
    1956:	cd bf       	out	0x3d, r28	; 61
    1958:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
    195a:	fe 01       	movw	r30, r28
    195c:	31 96       	adiw	r30, 0x01	; 1
    195e:	8f e0       	ldi	r24, 0x0F	; 15
    1960:	df 01       	movw	r26, r30
    1962:	1d 92       	st	X+, r1
    1964:	8a 95       	dec	r24
    1966:	e9 f7       	brne	.-6      	; 0x1962 <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1968:	03 e0       	ldi	r16, 0x03	; 3
    196a:	13 e0       	ldi	r17, 0x03	; 3
    196c:	5e 01       	movw	r10, r28
    196e:	b0 e1       	ldi	r27, 0x10	; 16
    1970:	ab 0e       	add	r10, r27
    1972:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    1974:	0f 2e       	mov	r0, r31
    1976:	fa e9       	ldi	r31, 0x9A	; 154
    1978:	8f 2e       	mov	r8, r31
    197a:	91 2c       	mov	r9, r1
    197c:	f0 2d       	mov	r31, r0
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    197e:	0f 2e       	mov	r0, r31
    1980:	fb e4       	ldi	r31, 0x4B	; 75
    1982:	6f 2e       	mov	r6, r31
    1984:	f3 e0       	ldi	r31, 0x03	; 3
    1986:	7f 2e       	mov	r7, r31
    1988:	f0 2d       	mov	r31, r0
					mem4[COUNT] = count_number;
				}
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    198a:	0f 2e       	mov	r0, r31
    198c:	f3 e0       	ldi	r31, 0x03	; 3
    198e:	4f 2e       	mov	r4, r31
    1990:	51 2c       	mov	r5, r1
    1992:	f0 2d       	mov	r31, r0
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1994:	f8 01       	movw	r30, r16
    1996:	80 89       	ldd	r24, Z+16	; 0x10
    1998:	91 89       	ldd	r25, Z+17	; 0x11
    199a:	26 ad       	ldd	r18, Z+62	; 0x3e
    199c:	37 ad       	ldd	r19, Z+63	; 0x3f
    199e:	28 17       	cp	r18, r24
    19a0:	39 07       	cpc	r19, r25
    19a2:	41 f0       	breq	.+16     	; 0x19b4 <_ZL5proc1Pv+0x70>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    19a4:	95 af       	std	Z+61, r25	; 0x3d
    19a6:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    19a8:	91 af       	std	Z+57, r25	; 0x39
    19aa:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    19ac:	97 ab       	std	Z+55, r25	; 0x37
    19ae:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    19b0:	97 af       	std	Z+63, r25	; 0x3f
    19b2:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    19b4:	c6 01       	movw	r24, r12
    19b6:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    19ba:	8f 30       	cpi	r24, 0x0F	; 15
    19bc:	58 f3       	brcs	.-42     	; 0x1994 <_ZL5proc1Pv+0x50>
    19be:	ce 01       	movw	r24, r28
    19c0:	01 96       	adiw	r24, 0x01	; 1
    19c2:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    19c4:	c6 01       	movw	r24, r12
    19c6:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    19ca:	d7 01       	movw	r26, r14
    19cc:	8d 93       	st	X+, r24
    19ce:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    19d0:	aa 15       	cp	r26, r10
    19d2:	bb 05       	cpc	r27, r11
    19d4:	b9 f7       	brne	.-18     	; 0x19c4 <_ZL5proc1Pv+0x80>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    19d6:	89 81       	ldd	r24, Y+1	; 0x01
    19d8:	82 30       	cpi	r24, 0x02	; 2
    19da:	09 f0       	breq	.+2      	; 0x19de <_ZL5proc1Pv+0x9a>
    19dc:	53 c0       	rjmp	.+166    	; 0x1a84 <_ZL5proc1Pv+0x140>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    19de:	88 85       	ldd	r24, Y+8	; 0x08
    19e0:	90 e0       	ldi	r25, 0x00	; 0
    19e2:	98 2f       	mov	r25, r24
    19e4:	88 27       	eor	r24, r24
    19e6:	29 85       	ldd	r18, Y+9	; 0x09
    19e8:	82 2b       	or	r24, r18
    19ea:	90 93 54 03 	sts	0x0354, r25	; 0x800354 <count_number+0x1>
    19ee:	80 93 53 03 	sts	0x0353, r24	; 0x800353 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    19f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	98 2f       	mov	r25, r24
    19f8:	88 27       	eor	r24, r24
    19fa:	2b 85       	ldd	r18, Y+11	; 0x0b
    19fc:	82 2b       	or	r24, r18
    19fe:	90 93 52 03 	sts	0x0352, r25	; 0x800352 <current_temp+0x1>
    1a02:	80 93 51 03 	sts	0x0351, r24	; 0x800351 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    1a06:	2c 85       	ldd	r18, Y+12	; 0x0c
    1a08:	30 e0       	ldi	r19, 0x00	; 0
    1a0a:	32 2f       	mov	r19, r18
    1a0c:	22 27       	eor	r18, r18
    1a0e:	4d 85       	ldd	r20, Y+13	; 0x0d
    1a10:	24 2b       	or	r18, r20
    1a12:	30 93 50 03 	sts	0x0350, r19	; 0x800350 <current_pressure+0x1>
    1a16:	20 93 4f 03 	sts	0x034F, r18	; 0x80034f <current_pressure>
				mem4[TEMP] = current_temp;
    1a1a:	f8 01       	movw	r30, r16
    1a1c:	93 83       	std	Z+3, r25	; 0x03
    1a1e:	82 83       	std	Z+2, r24	; 0x02
				if(mem4[TARGET_COUNT_SENSOR]) //LOCAL SENSOR 
    1a20:	d3 01       	movw	r26, r6
    1a22:	8d 91       	ld	r24, X+
    1a24:	9c 91       	ld	r25, X
    1a26:	89 2b       	or	r24, r25
    1a28:	19 f0       	breq	.+6      	; 0x1a30 <_ZL5proc1Pv+0xec>
				{
					Alarm_Start();
    1a2a:	0e 94 e6 01 	call	0x3cc	; 0x3cc <Alarm_Start>
    1a2e:	09 c0       	rjmp	.+18     	; 0x1a42 <_ZL5proc1Pv+0xfe>
				}
				else //PLC
				{
					Alarm_Stop();
    1a30:	0e 94 e2 01 	call	0x3c4	; 0x3c4 <Alarm_Stop>
					mem4[COUNT] = count_number;
    1a34:	80 91 53 03 	lds	r24, 0x0353	; 0x800353 <count_number>
    1a38:	90 91 54 03 	lds	r25, 0x0354	; 0x800354 <count_number+0x1>
    1a3c:	f8 01       	movw	r30, r16
    1a3e:	97 83       	std	Z+7, r25	; 0x07
    1a40:	86 83       	std	Z+6, r24	; 0x06
				}
				mem4[PRESSURE] = current_pressure;
    1a42:	80 91 4f 03 	lds	r24, 0x034F	; 0x80034f <current_pressure>
    1a46:	90 91 50 03 	lds	r25, 0x0350	; 0x800350 <current_pressure+0x1>
    1a4a:	d8 01       	movw	r26, r16
    1a4c:	15 96       	adiw	r26, 0x05	; 5
    1a4e:	9c 93       	st	X, r25
    1a50:	8e 93       	st	-X, r24
    1a52:	14 97       	sbiw	r26, 0x04	; 4
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    1a54:	50 96       	adiw	r26, 0x10	; 16
    1a56:	2d 91       	ld	r18, X+
    1a58:	3c 91       	ld	r19, X
    1a5a:	51 97       	sbiw	r26, 0x11	; 17
    1a5c:	16 96       	adiw	r26, 0x06	; 6
    1a5e:	8d 91       	ld	r24, X+
    1a60:	9c 91       	ld	r25, X
    1a62:	17 97       	sbiw	r26, 0x07	; 7
    1a64:	28 17       	cp	r18, r24
    1a66:	39 07       	cpc	r19, r25
    1a68:	09 f0       	breq	.+2      	; 0x1a6c <_ZL5proc1Pv+0x128>
    1a6a:	94 cf       	rjmp	.-216    	; 0x1994 <_ZL5proc1Pv+0x50>
    1a6c:	52 96       	adiw	r26, 0x12	; 18
    1a6e:	8d 91       	ld	r24, X+
    1a70:	9c 91       	ld	r25, X
    1a72:	53 97       	sbiw	r26, 0x13	; 19
    1a74:	89 2b       	or	r24, r25
    1a76:	09 f0       	breq	.+2      	; 0x1a7a <_ZL5proc1Pv+0x136>
    1a78:	8d cf       	rjmp	.-230    	; 0x1994 <_ZL5proc1Pv+0x50>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1a7a:	53 96       	adiw	r26, 0x13	; 19
    1a7c:	5c 92       	st	X, r5
    1a7e:	4e 92       	st	-X, r4
    1a80:	52 97       	sbiw	r26, 0x12	; 18
    1a82:	88 cf       	rjmp	.-240    	; 0x1994 <_ZL5proc1Pv+0x50>
				}
			}
			else
			{
				cbi(PORTB,7);
    1a84:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    1a86:	46 e0       	ldi	r20, 0x06	; 6
    1a88:	61 e0       	ldi	r22, 0x01	; 1
    1a8a:	8d e5       	ldi	r24, 0x5D	; 93
    1a8c:	93 e0       	ldi	r25, 0x03	; 3
    1a8e:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    1a92:	45 e0       	ldi	r20, 0x05	; 5
    1a94:	50 e0       	ldi	r21, 0x00	; 0
    1a96:	6d e5       	ldi	r22, 0x5D	; 93
    1a98:	73 e0       	ldi	r23, 0x03	; 3
    1a9a:	c6 01       	movw	r24, r12
    1a9c:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    1aa0:	f4 01       	movw	r30, r8
    1aa2:	80 81       	ld	r24, Z
    1aa4:	8f 77       	andi	r24, 0x7F	; 127
    1aa6:	80 83       	st	Z, r24
				sb->SerialFlush();
    1aa8:	c6 01       	movw	r24, r12
    1aaa:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    1aae:	d4 01       	movw	r26, r8
    1ab0:	8c 91       	ld	r24, X
    1ab2:	80 68       	ori	r24, 0x80	; 128
    1ab4:	8c 93       	st	X, r24
				sbi(PORTB,7);
    1ab6:	c7 9a       	sbi	0x18, 7	; 24
    1ab8:	6d cf       	rjmp	.-294    	; 0x1994 <_ZL5proc1Pv+0x50>

00001aba <_ZL4procPv>:
	{
		chatter_flag = 1;
	}
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1aba:	cf 93       	push	r28
    1abc:	df 93       	push	r29
    1abe:	cd b7       	in	r28, 0x3d	; 61
    1ac0:	de b7       	in	r29, 0x3e	; 62
    1ac2:	2a 97       	sbiw	r28, 0x0a	; 10
    1ac4:	0f b6       	in	r0, 0x3f	; 63
    1ac6:	f8 94       	cli
    1ac8:	de bf       	out	0x3e, r29	; 62
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	cd bf       	out	0x3d, r28	; 61
    1ace:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    1ad0:	d1 2c       	mov	r13, r1
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1ad2:	03 e0       	ldi	r16, 0x03	; 3
    1ad4:	13 e0       	ldi	r17, 0x03	; 3
			chatter_flag = 2;
    1ad6:	68 94       	set
    1ad8:	77 24       	eor	r7, r7
    1ada:	71 f8       	bld	r7, 1
    1adc:	4e 01       	movw	r8, r28
    1ade:	8c e0       	ldi	r24, 0x0C	; 12
    1ae0:	88 0e       	add	r8, r24
    1ae2:	91 1c       	adc	r9, r1
    1ae4:	68 94       	set
    1ae6:	33 24       	eor	r3, r3
    1ae8:	34 f8       	bld	r3, 4
    1aea:	66 24       	eor	r6, r6
    1aec:	63 94       	inc	r6
    1aee:	5e 01       	movw	r10, r28
    1af0:	a9 e0       	ldi	r26, 0x09	; 9
    1af2:	aa 0e       	add	r10, r26
    1af4:	b1 1c       	adc	r11, r1
    1af6:	0f 2e       	mov	r0, r31
    1af8:	f5 e0       	ldi	r31, 0x05	; 5
    1afa:	4f 2e       	mov	r4, r31
    1afc:	f0 2d       	mov	r31, r0
							sb->SerialWrite((char*)&exception,sizeof(exception));
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1afe:	68 94       	set
    1b00:	55 24       	eor	r5, r5
    1b02:	52 f8       	bld	r5, 2
    1b04:	0e c0       	rjmp	.+28     	; 0x1b22 <_ZL4procPv+0x68>
    1b06:	c6 2c       	mov	r12, r6
    1b08:	d6 2c       	mov	r13, r6
    1b0a:	0b c0       	rjmp	.+22     	; 0x1b22 <_ZL4procPv+0x68>
    1b0c:	c6 2c       	mov	r12, r6
    1b0e:	d6 2c       	mov	r13, r6
    1b10:	08 c0       	rjmp	.+16     	; 0x1b22 <_ZL4procPv+0x68>
    1b12:	c5 2c       	mov	r12, r5
    1b14:	d6 2c       	mov	r13, r6
    1b16:	05 c0       	rjmp	.+10     	; 0x1b22 <_ZL4procPv+0x68>
    1b18:	c4 2c       	mov	r12, r4
    1b1a:	d6 2c       	mov	r13, r6
    1b1c:	02 c0       	rjmp	.+4      	; 0x1b22 <_ZL4procPv+0x68>
    1b1e:	c3 2c       	mov	r12, r3
    1b20:	d6 2c       	mov	r13, r6
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	register uint16_t i;
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
    1b22:	80 b3       	in	r24, 0x10	; 16
    1b24:	8e 3f       	cpi	r24, 0xFE	; 254
    1b26:	29 f4       	brne	.+10     	; 0x1b32 <_ZL4procPv+0x78>
    1b28:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <chatter_flag>
    1b2c:	81 30       	cpi	r24, 0x01	; 1
    1b2e:	09 f4       	brne	.+2      	; 0x1b32 <_ZL4procPv+0x78>
    1b30:	15 c1       	rjmp	.+554    	; 0x1d5c <_ZL4procPv+0x2a2>
		{
			mem4[COUNT]++;                // Remove Chattering 
			chatter_flag = 2;
		}
		if(PIND == 0xff && chatter_flag == 2)//
    1b32:	80 b3       	in	r24, 0x10	; 16
    1b34:	8f 3f       	cpi	r24, 0xFF	; 255
    1b36:	29 f4       	brne	.+10     	; 0x1b42 <_ZL4procPv+0x88>
    1b38:	80 91 fe 02 	lds	r24, 0x02FE	; 0x8002fe <chatter_flag>
    1b3c:	82 30       	cpi	r24, 0x02	; 2
    1b3e:	09 f4       	brne	.+2      	; 0x1b42 <_ZL4procPv+0x88>
    1b40:	19 c1       	rjmp	.+562    	; 0x1d74 <_ZL4procPv+0x2ba>
		{
			vTaskDelay(20);
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
    1b42:	f8 01       	movw	r30, r16
    1b44:	84 85       	ldd	r24, Z+12	; 0x0c
    1b46:	95 85       	ldd	r25, Z+13	; 0x0d
    1b48:	cc 97       	sbiw	r24, 0x3c	; 60
    1b4a:	94 f0       	brlt	.+36     	; 0x1b70 <_ZL4procPv+0xb6>
		{
			mem4[SEC] = 0;
    1b4c:	15 86       	std	Z+13, r1	; 0x0d
    1b4e:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    1b50:	82 85       	ldd	r24, Z+10	; 0x0a
    1b52:	93 85       	ldd	r25, Z+11	; 0x0b
    1b54:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    1b56:	8c 33       	cpi	r24, 0x3C	; 60
    1b58:	91 05       	cpc	r25, r1
    1b5a:	1c f4       	brge	.+6      	; 0x1b62 <_ZL4procPv+0xa8>
			chatter_flag = 0;
		}
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    1b5c:	93 87       	std	Z+11, r25	; 0x0b
    1b5e:	82 87       	std	Z+10, r24	; 0x0a
    1b60:	07 c0       	rjmp	.+14     	; 0x1b70 <_ZL4procPv+0xb6>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    1b62:	13 86       	std	Z+11, r1	; 0x0b
    1b64:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    1b66:	80 85       	ldd	r24, Z+8	; 0x08
    1b68:	91 85       	ldd	r25, Z+9	; 0x09
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	91 87       	std	Z+9, r25	; 0x09
    1b6e:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    1b70:	d1 10       	cpse	r13, r1
    1b72:	4d c0       	rjmp	.+154    	; 0x1c0e <_ZL4procPv+0x154>
		{
			if(sb->SerialAvailable() >= 2)
    1b74:	c7 01       	movw	r24, r14
    1b76:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1b7a:	82 30       	cpi	r24, 0x02	; 2
    1b7c:	90 f2       	brcs	.-92     	; 0x1b22 <_ZL4procPv+0x68>
			{
				for(i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    1b7e:	c7 01       	movw	r24, r14
    1b80:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1b84:	89 83       	std	Y+1, r24	; 0x01
    1b86:	c7 01       	movw	r24, r14
    1b88:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1b8c:	8a 83       	std	Y+2, r24	; 0x02
					#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
					#endif
				}
				if(buf1[0] != 0x01)
    1b8e:	99 81       	ldd	r25, Y+1	; 0x01
    1b90:	91 30       	cpi	r25, 0x01	; 1
    1b92:	61 f4       	brne	.+24     	; 0x1bac <_ZL4procPv+0xf2>
				{
				//	read_Flag = 0;
					goto FREAM_ERROR;
				}
				if(buf1[1] == 0x01)
    1b94:	81 30       	cpi	r24, 0x01	; 1
    1b96:	09 f4       	brne	.+2      	; 0x1b9a <_ZL4procPv+0xe0>
    1b98:	3f c0       	rjmp	.+126    	; 0x1c18 <_ZL4procPv+0x15e>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    1b9a:	84 30       	cpi	r24, 0x04	; 4
    1b9c:	09 f4       	brne	.+2      	; 0x1ba0 <_ZL4procPv+0xe6>
    1b9e:	53 c0       	rjmp	.+166    	; 0x1c46 <_ZL4procPv+0x18c>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    1ba0:	85 30       	cpi	r24, 0x05	; 5
    1ba2:	09 f4       	brne	.+2      	; 0x1ba6 <_ZL4procPv+0xec>
    1ba4:	8b c0       	rjmp	.+278    	; 0x1cbc <_ZL4procPv+0x202>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1ba6:	80 31       	cpi	r24, 0x10	; 16
    1ba8:	09 f4       	brne	.+2      	; 0x1bac <_ZL4procPv+0xf2>
    1baa:	ae c0       	rjmp	.+348    	; 0x1d08 <_ZL4procPv+0x24e>
				{
					FREAM_ERROR:
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    1bac:	46 2d       	mov	r20, r6
    1bae:	66 2d       	mov	r22, r6
    1bb0:	8d e5       	ldi	r24, 0x5D	; 93
    1bb2:	93 e0       	ldi	r25, 0x03	; 3
    1bb4:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
					cbi(PORTB,7);
    1bb8:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);
    1bba:	57 98       	cbi	0x0a, 7	; 10
					dev->getInterfaceAddr(UART0)->Stop_Device();                                                                                                                                                                                                                
    1bbc:	60 e0       	ldi	r22, 0x00	; 0
    1bbe:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1bc2:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1bc6:	0e 94 9d 03 	call	0x73a	; 0x73a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1bca:	dc 01       	movw	r26, r24
    1bcc:	ed 91       	ld	r30, X+
    1bce:	fc 91       	ld	r31, X
    1bd0:	00 84       	ldd	r0, Z+8	; 0x08
    1bd2:	f1 85       	ldd	r31, Z+9	; 0x09
    1bd4:	e0 2d       	mov	r30, r0
    1bd6:	09 95       	icall
					sb->SerialFlush();
    1bd8:	c7 01       	movw	r24, r14
    1bda:	0e 94 cf 01 	call	0x39e	; 0x39e <_ZN12SerialBuffer11SerialFlushEv>
					dev->getInterfaceAddr(UART0)->Start_Device();
    1bde:	60 e0       	ldi	r22, 0x00	; 0
    1be0:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1be4:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1be8:	0e 94 9d 03 	call	0x73a	; 0x73a <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
    1bec:	dc 01       	movw	r26, r24
    1bee:	ed 91       	ld	r30, X+
    1bf0:	fc 91       	ld	r31, X
    1bf2:	02 84       	ldd	r0, Z+10	; 0x0a
    1bf4:	f3 85       	ldd	r31, Z+11	; 0x0b
    1bf6:	e0 2d       	mov	r30, r0
    1bf8:	09 95       	icall
					sbi(UCSR0B,RXCIE0);
    1bfa:	57 9a       	sbi	0x0a, 7	; 10
					sb->SerialWrite((char*)&exception,sizeof(exception));
    1bfc:	45 e0       	ldi	r20, 0x05	; 5
    1bfe:	50 e0       	ldi	r21, 0x00	; 0
    1c00:	6d e5       	ldi	r22, 0x5D	; 93
    1c02:	73 e0       	ldi	r23, 0x03	; 3
    1c04:	c7 01       	movw	r24, r14
    1c06:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    1c0a:	c7 9a       	sbi	0x18, 7	; 24
    1c0c:	8a cf       	rjmp	.-236    	; 0x1b22 <_ZL4procPv+0x68>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1c0e:	b1 e0       	ldi	r27, 0x01	; 1
    1c10:	db 12       	cpse	r13, r27
    1c12:	87 cf       	rjmp	.-242    	; 0x1b22 <_ZL4procPv+0x68>
		{
			if(function_code == 0x01)  
    1c14:	cb 12       	cpse	r12, r27
    1c16:	14 c0       	rjmp	.+40     	; 0x1c40 <_ZL4procPv+0x186>
			{
				if(sb->SerialAvailable() >= 6)
    1c18:	c7 01       	movw	r24, r14
    1c1a:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1c1e:	86 30       	cpi	r24, 0x06	; 6
    1c20:	08 f4       	brcc	.+2      	; 0x1c24 <_ZL4procPv+0x16a>
    1c22:	71 cf       	rjmp	.-286    	; 0x1b06 <_ZL4procPv+0x4c>
    1c24:	6e 01       	movw	r12, r28
    1c26:	e3 e0       	ldi	r30, 0x03	; 3
    1c28:	ce 0e       	add	r12, r30
    1c2a:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1c2c:	c7 01       	movw	r24, r14
    1c2e:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1c32:	d6 01       	movw	r26, r12
    1c34:	8d 93       	st	X+, r24
    1c36:	6d 01       	movw	r12, r26
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1c38:	aa 16       	cp	r10, r26
    1c3a:	bb 06       	cpc	r11, r27
    1c3c:	b9 f7       	brne	.-18     	; 0x1c2c <_ZL4procPv+0x172>
    1c3e:	66 cf       	rjmp	.-308    	; 0x1b0c <_ZL4procPv+0x52>
						#endif
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1c40:	b4 e0       	ldi	r27, 0x04	; 4
    1c42:	cb 12       	cpse	r12, r27
    1c44:	38 c0       	rjmp	.+112    	; 0x1cb6 <_ZL4procPv+0x1fc>
			{
				if(sb->SerialAvailable() >= 6)
    1c46:	c7 01       	movw	r24, r14
    1c48:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1c4c:	86 30       	cpi	r24, 0x06	; 6
    1c4e:	08 f4       	brcc	.+2      	; 0x1c52 <_ZL4procPv+0x198>
    1c50:	60 cf       	rjmp	.-320    	; 0x1b12 <_ZL4procPv+0x58>
    1c52:	6e 01       	movw	r12, r28
    1c54:	e3 e0       	ldi	r30, 0x03	; 3
    1c56:	ce 0e       	add	r12, r30
    1c58:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1c5a:	c7 01       	movw	r24, r14
    1c5c:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1c60:	d6 01       	movw	r26, r12
    1c62:	8d 93       	st	X+, r24
    1c64:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1c66:	aa 16       	cp	r10, r26
    1c68:	bb 06       	cpc	r11, r27
    1c6a:	b9 f7       	brne	.-18     	; 0x1c5a <_ZL4procPv+0x1a0>
						#if PACKET_DEBUG
							sb1->SerialWrite(buf1[i]);
						#endif
					}
					int tempadr =((0xff & buf1[2] << 8) | 0xff & buf1[3]);
					if(tempadr > MAX_ENUM)  //주소 사이즈 체크 
    1c6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	87 97       	sbiw	r24, 0x27	; 39
    1c72:	84 f0       	brlt	.+32     	; 0x1c94 <_ZL4procPv+0x1da>
					{
							GetExceptionCode(&exception,0x01,0x02);
    1c74:	47 2d       	mov	r20, r7
    1c76:	66 2d       	mov	r22, r6
    1c78:	8d e5       	ldi	r24, 0x5D	; 93
    1c7a:	93 e0       	ldi	r25, 0x03	; 3
    1c7c:	0e 94 ff 00 	call	0x1fe	; 0x1fe <_Z16GetExceptionCodeP16RspExceptionCodecc>
							sb->SerialWrite((char*)&exception,sizeof(exception));
    1c80:	45 e0       	ldi	r20, 0x05	; 5
    1c82:	50 e0       	ldi	r21, 0x00	; 0
    1c84:	6d e5       	ldi	r22, 0x5D	; 93
    1c86:	73 e0       	ldi	r23, 0x03	; 3
    1c88:	c7 01       	movw	r24, r14
    1c8a:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1c8e:	c5 2c       	mov	r12, r5
    1c90:	d6 2c       	mov	r13, r6
    1c92:	47 cf       	rjmp	.-370    	; 0x1b22 <_ZL4procPv+0x68>
					}
					else
					{
							GetFunc04Data(buf1,&func04,mem4);
    1c94:	a8 01       	movw	r20, r16
    1c96:	6d e6       	ldi	r22, 0x6D	; 109
    1c98:	73 e0       	ldi	r23, 0x03	; 3
    1c9a:	ce 01       	movw	r24, r28
    1c9c:	01 96       	adiw	r24, 0x01	; 1
    1c9e:	0e 94 82 00 	call	0x104	; 0x104 <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
							sb->SerialWrite((char*)&func04,sizeof(func04));
    1ca2:	47 e0       	ldi	r20, 0x07	; 7
    1ca4:	50 e0       	ldi	r21, 0x00	; 0
    1ca6:	6d e6       	ldi	r22, 0x6D	; 109
    1ca8:	73 e0       	ldi	r23, 0x03	; 3
    1caa:	c7 01       	movw	r24, r14
    1cac:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1cb0:	c5 2c       	mov	r12, r5
							read_Flag = 0;
    1cb2:	d1 2c       	mov	r13, r1
    1cb4:	36 cf       	rjmp	.-404    	; 0x1b22 <_ZL4procPv+0x68>
					}

				}
			}
			else if(function_code == 0x05) //터치 버튼 
    1cb6:	b5 e0       	ldi	r27, 0x05	; 5
    1cb8:	cb 12       	cpse	r12, r27
    1cba:	23 c0       	rjmp	.+70     	; 0x1d02 <_ZL4procPv+0x248>
			{
				if(sb->SerialAvailable() >= 6)
    1cbc:	c7 01       	movw	r24, r14
    1cbe:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1cc2:	86 30       	cpi	r24, 0x06	; 6
    1cc4:	08 f4       	brcc	.+2      	; 0x1cc8 <_ZL4procPv+0x20e>
    1cc6:	28 cf       	rjmp	.-432    	; 0x1b18 <_ZL4procPv+0x5e>
    1cc8:	6e 01       	movw	r12, r28
    1cca:	e3 e0       	ldi	r30, 0x03	; 3
    1ccc:	ce 0e       	add	r12, r30
    1cce:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1cd0:	c7 01       	movw	r24, r14
    1cd2:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1cd6:	d6 01       	movw	r26, r12
    1cd8:	8d 93       	st	X+, r24
    1cda:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(i=2;i<8;i++)
    1cdc:	aa 16       	cp	r10, r26
    1cde:	bb 06       	cpc	r11, r27
    1ce0:	b9 f7       	brne	.-18     	; 0x1cd0 <_ZL4procPv+0x216>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFunc05Data(buf1,&func05);
    1ce2:	64 e7       	ldi	r22, 0x74	; 116
    1ce4:	73 e0       	ldi	r23, 0x03	; 3
    1ce6:	ce 01       	movw	r24, r28
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	0e 94 a3 00 	call	0x146	; 0x146 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    1cee:	48 e0       	ldi	r20, 0x08	; 8
    1cf0:	50 e0       	ldi	r21, 0x00	; 0
    1cf2:	64 e7       	ldi	r22, 0x74	; 116
    1cf4:	73 e0       	ldi	r23, 0x03	; 3
    1cf6:	c7 01       	movw	r24, r14
    1cf8:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1cfc:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    1cfe:	d1 2c       	mov	r13, r1
    1d00:	10 cf       	rjmp	.-480    	; 0x1b22 <_ZL4procPv+0x68>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1d02:	b0 e1       	ldi	r27, 0x10	; 16
    1d04:	cb 12       	cpse	r12, r27
    1d06:	0d cf       	rjmp	.-486    	; 0x1b22 <_ZL4procPv+0x68>
			{
				if(sb->SerialAvailable() >= 9)
    1d08:	c7 01       	movw	r24, r14
    1d0a:	0e 94 c4 01 	call	0x388	; 0x388 <_ZN12SerialBuffer15SerialAvailableEv>
    1d0e:	89 30       	cpi	r24, 0x09	; 9
    1d10:	08 f4       	brcc	.+2      	; 0x1d14 <_ZL4procPv+0x25a>
    1d12:	05 cf       	rjmp	.-502    	; 0x1b1e <_ZL4procPv+0x64>
    1d14:	6e 01       	movw	r12, r28
    1d16:	e3 e0       	ldi	r30, 0x03	; 3
    1d18:	ce 0e       	add	r12, r30
    1d1a:	d1 1c       	adc	r13, r1
				{
					for(i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    1d1c:	c7 01       	movw	r24, r14
    1d1e:	0e 94 98 01 	call	0x330	; 0x330 <_ZN12SerialBuffer10SerialReadEv>
    1d22:	d6 01       	movw	r26, r12
    1d24:	8d 93       	st	X+, r24
    1d26:	6d 01       	movw	r12, r26
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(i=2;i<11;i++)
    1d28:	8a 16       	cp	r8, r26
    1d2a:	9b 06       	cpc	r9, r27
    1d2c:	b9 f7       	brne	.-18     	; 0x1d1c <_ZL4procPv+0x262>
						buf1[i] = sb->SerialRead();
						#if PACKET_DEBUG
						sb1->SerialWrite(buf1[i]);
						#endif
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1d2e:	a8 01       	movw	r20, r16
    1d30:	62 e6       	ldi	r22, 0x62	; 98
    1d32:	73 e0       	ldi	r23, 0x03	; 3
    1d34:	ce 01       	movw	r24, r28
    1d36:	01 96       	adiw	r24, 0x01	; 1
    1d38:	0e 94 bc 00 	call	0x178	; 0x178 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1d3c:	65 e5       	ldi	r22, 0x55	; 85
    1d3e:	73 e0       	ldi	r23, 0x03	; 3
    1d40:	ce 01       	movw	r24, r28
    1d42:	01 96       	adiw	r24, 0x01	; 1
    1d44:	0e 94 e6 00 	call	0x1cc	; 0x1cc <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    1d48:	48 e0       	ldi	r20, 0x08	; 8
    1d4a:	50 e0       	ldi	r21, 0x00	; 0
    1d4c:	65 e5       	ldi	r22, 0x55	; 85
    1d4e:	73 e0       	ldi	r23, 0x03	; 3
    1d50:	c7 01       	movw	r24, r14
    1d52:	0e 94 5c 01 	call	0x2b8	; 0x2b8 <_ZN12SerialBuffer11SerialWriteEPKci>
    1d56:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    1d58:	d1 2c       	mov	r13, r1
    1d5a:	e3 ce       	rjmp	.-570    	; 0x1b22 <_ZL4procPv+0x68>
	while(1)
	{
		//mem4[COUNT] = PIND;
		if(PIND == 0xfe && chatter_flag == 1)//
		{
			mem4[COUNT]++;                // Remove Chattering 
    1d5c:	f8 01       	movw	r30, r16
    1d5e:	86 81       	ldd	r24, Z+6	; 0x06
    1d60:	97 81       	ldd	r25, Z+7	; 0x07
    1d62:	01 96       	adiw	r24, 0x01	; 1
    1d64:	97 83       	std	Z+7, r25	; 0x07
    1d66:	86 83       	std	Z+6, r24	; 0x06
			chatter_flag = 2;
    1d68:	70 92 fe 02 	sts	0x02FE, r7	; 0x8002fe <chatter_flag>
		}
		if(PIND == 0xff && chatter_flag == 2)//
    1d6c:	80 b3       	in	r24, 0x10	; 16
    1d6e:	8f 3f       	cpi	r24, 0xFF	; 255
    1d70:	09 f0       	breq	.+2      	; 0x1d74 <_ZL4procPv+0x2ba>
    1d72:	e7 ce       	rjmp	.-562    	; 0x1b42 <_ZL4procPv+0x88>
		{
			vTaskDelay(20);
    1d74:	84 e1       	ldi	r24, 0x14	; 20
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <vTaskDelay>
			chatter_flag = 0;
    1d7c:	10 92 fe 02 	sts	0x02FE, r1	; 0x8002fe <chatter_flag>
    1d80:	e0 ce       	rjmp	.-576    	; 0x1b42 <_ZL4procPv+0x88>

00001d82 <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    1d82:	80 91 7c 03 	lds	r24, 0x037C	; 0x80037c <DataStruct>
    1d86:	90 91 7d 03 	lds	r25, 0x037D	; 0x80037d <DataStruct+0x1>
    1d8a:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    1d8e:	c5 9a       	sbi	0x18, 5	; 24
    1d90:	08 95       	ret

00001d92 <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    1d92:	80 91 7e 03 	lds	r24, 0x037E	; 0x80037e <DataStruct+0x2>
    1d96:	90 91 7f 03 	lds	r25, 0x037F	; 0x80037f <DataStruct+0x3>
    1d9a:	0e 94 37 01 	call	0x26e	; 0x26e <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    1d9e:	c6 9a       	sbi	0x18, 6	; 24
    1da0:	08 95       	ret

00001da2 <_Z16Count_Sensor_ISR8Dev_typej>:
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
void Count_Sensor_ISR(Dev_type Device,uint16_t Arg)
{
	Alarm_Open(ALARM0,20,Set_Alarm);
    1da2:	4b e5       	ldi	r20, 0x5B	; 91
    1da4:	59 e0       	ldi	r21, 0x09	; 9
    1da6:	64 e1       	ldi	r22, 0x14	; 20
    1da8:	70 e0       	ldi	r23, 0x00	; 0
    1daa:	80 e0       	ldi	r24, 0x00	; 0
    1dac:	0c 94 ea 01 	jmp	0x3d4	; 0x3d4 <Alarm_Open>
    1db0:	08 95       	ret

00001db2 <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    1db2:	cf 93       	push	r28
    1db4:	df 93       	push	r29
	dev = new Dev_Manager();
    1db6:	80 e1       	ldi	r24, 0x10	; 16
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	0e 94 46 03 	call	0x68c	; 0x68c <_ZN11Dev_ManagernwEj>
    1dbe:	ec 01       	movw	r28, r24
    1dc0:	0e 94 13 03 	call	0x626	; 0x626 <_ZN11Dev_ManagerC1Ev>
    1dc4:	d0 93 87 03 	sts	0x0387, r29	; 0x800387 <dev+0x1>
    1dc8:	c0 93 86 03 	sts	0x0386, r28	; 0x800386 <dev>
	lcd = new Char_LCD2004A();
    1dcc:	82 e0       	ldi	r24, 0x02	; 2
    1dce:	90 e0       	ldi	r25, 0x00	; 0
    1dd0:	0e 94 fe 02 	call	0x5fc	; 0x5fc <_ZN13Char_LCD2004AnwEj>
    1dd4:	ec 01       	movw	r28, r24
    1dd6:	0e 94 ce 02 	call	0x59c	; 0x59c <_ZN13Char_LCD2004AC1Ev>
    1dda:	d0 93 85 03 	sts	0x0385, r29	; 0x800385 <lcd+0x1>
    1dde:	c0 93 84 03 	sts	0x0384, r28	; 0x800384 <lcd>
	dev->Register_Dev(new UartDriver,UART0);
    1de2:	88 e0       	ldi	r24, 0x08	; 8
    1de4:	90 e0       	ldi	r25, 0x00	; 0
    1de6:	0e 94 58 05 	call	0xab0	; 0xab0 <_ZN10UartDrivernwEj>
    1dea:	ec 01       	movw	r28, r24
    1dec:	0e 94 44 05 	call	0xa88	; 0xa88 <_ZN10UartDriverC1Ev>
    1df0:	40 e0       	ldi	r20, 0x00	; 0
    1df2:	be 01       	movw	r22, r28
    1df4:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1df8:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1dfc:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    1e00:	88 e0       	ldi	r24, 0x08	; 8
    1e02:	90 e0       	ldi	r25, 0x00	; 0
    1e04:	0e 94 b5 04 	call	0x96a	; 0x96a <_ZN11RS485DrivernwEj>
    1e08:	ec 01       	movw	r28, r24
    1e0a:	0e 94 a1 04 	call	0x942	; 0x942 <_ZN11RS485DriverC1Ev>
    1e0e:	41 e0       	ldi	r20, 0x01	; 1
    1e10:	be 01       	movw	r22, r28
    1e12:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e16:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e1a:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    1e1e:	82 e0       	ldi	r24, 0x02	; 2
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	0e 94 7d 04 	call	0x8fa	; 0x8fa <_ZN5TimernwEj>
    1e26:	ec 01       	movw	r28, r24
    1e28:	0e 94 77 04 	call	0x8ee	; 0x8ee <_ZN5TimerC1Ev>
    1e2c:	42 e0       	ldi	r20, 0x02	; 2
    1e2e:	be 01       	movw	r22, r28
    1e30:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e34:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e38:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Count_Sensor,COUNT_SENSOR);
    1e3c:	82 e0       	ldi	r24, 0x02	; 2
    1e3e:	90 e0       	ldi	r25, 0x00	; 0
    1e40:	0e 94 10 03 	call	0x620	; 0x620 <_ZN12Count_SensornwEj>
#include "FreeRTOS.h"
#include "semphr.h"
#define malloc(size) pvPortMalloc(size)
#define free(ptr) vPortFree(ptr)

class Count_Sensor : public DeviceDriveInterFace
    1e44:	2b e1       	ldi	r18, 0x1B	; 27
    1e46:	31 e0       	ldi	r19, 0x01	; 1
    1e48:	fc 01       	movw	r30, r24
    1e4a:	31 83       	std	Z+1, r19	; 0x01
    1e4c:	20 83       	st	Z, r18
    1e4e:	43 e0       	ldi	r20, 0x03	; 3
    1e50:	bc 01       	movw	r22, r24
    1e52:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e56:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e5a:	0e 94 3d 03 	call	0x67a	; 0x67a <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Device_Init(UART0);
    1e5e:	60 e0       	ldi	r22, 0x00	; 0
    1e60:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e64:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e68:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    1e6c:	61 e0       	ldi	r22, 0x01	; 1
    1e6e:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e72:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e76:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    1e7a:	62 e0       	ldi	r22, 0x02	; 2
    1e7c:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e80:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e84:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(COUNT_SENSOR);
    1e88:	63 e0       	ldi	r22, 0x03	; 3
    1e8a:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1e8e:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1e92:	0e 94 71 03 	call	0x6e2	; 0x6e2 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    1e96:	4c e8       	ldi	r20, 0x8C	; 140
    1e98:	51 e0       	ldi	r21, 0x01	; 1
    1e9a:	60 e0       	ldi	r22, 0x00	; 0
    1e9c:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1ea0:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1ea4:	0e 94 5d 03 	call	0x6ba	; 0x6ba <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1ea8:	42 eb       	ldi	r20, 0xB2	; 178
    1eaa:	51 e0       	ldi	r21, 0x01	; 1
    1eac:	61 e0       	ldi	r22, 0x01	; 1
    1eae:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1eb2:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1eb6:	0e 94 5d 03 	call	0x6ba	; 0x6ba <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	08 95       	ret

00001ec0 <main>:

uint8_t chatter_flag = 0; //채터링 방지 플래그 변수
//uint8_t use_external_count_sensor = 0; // 0 PLC  1 EXTERNAL COUTN SENSOR

int main( void )
{
    1ec0:	cf 92       	push	r12
    1ec2:	df 92       	push	r13
    1ec4:	ef 92       	push	r14
    1ec6:	ff 92       	push	r15
    1ec8:	0f 93       	push	r16
    1eca:	cf 93       	push	r28
    1ecc:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    1ece:	80 e0       	ldi	r24, 0x00	; 0
    1ed0:	90 e0       	ldi	r25, 0x00	; 0
    1ed2:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <eeprom_read_byte>
    1ed6:	d8 2e       	mov	r13, r24
    1ed8:	90 e0       	ldi	r25, 0x00	; 0
    1eda:	90 93 44 03 	sts	0x0344, r25	; 0x800344 <mem4+0x41>
    1ede:	80 93 43 03 	sts	0x0343, r24	; 0x800343 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    1ee2:	81 e0       	ldi	r24, 0x01	; 1
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <eeprom_read_byte>
    1eea:	d8 2f       	mov	r29, r24
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	90 93 46 03 	sts	0x0346, r25	; 0x800346 <mem4+0x43>
    1ef2:	80 93 45 03 	sts	0x0345, r24	; 0x800345 <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    1ef6:	82 e0       	ldi	r24, 0x02	; 2
    1ef8:	90 e0       	ldi	r25, 0x00	; 0
    1efa:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <eeprom_read_byte>
    1efe:	c8 2f       	mov	r28, r24
    1f00:	90 e0       	ldi	r25, 0x00	; 0
    1f02:	90 93 48 03 	sts	0x0348, r25	; 0x800348 <mem4+0x45>
    1f06:	80 93 47 03 	sts	0x0347, r24	; 0x800347 <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    1f0a:	83 e0       	ldi	r24, 0x03	; 3
    1f0c:	90 e0       	ldi	r25, 0x00	; 0
    1f0e:	0e 94 b8 1d 	call	0x3b70	; 0x3b70 <eeprom_read_byte>
    1f12:	28 2f       	mov	r18, r24
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	30 93 4a 03 	sts	0x034A, r19	; 0x80034a <mem4+0x47>
    1f1a:	20 93 49 03 	sts	0x0349, r18	; 0x800349 <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    1f1e:	ef ef       	ldi	r30, 0xFF	; 255
    1f20:	f2 e0       	ldi	r31, 0x02	; 2
    1f22:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    1f24:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    1f26:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    1f28:	83 83       	std	Z+3, r24	; 0x03

int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1f2a:	f8 94       	cli
	
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1f2c:	42 df       	rcall	.-380    	; 0x1db2 <_Z8Init_Devv>
    1f2e:	41 ec       	ldi	r20, 0xC1	; 193
    1f30:	5e e0       	ldi	r21, 0x0E	; 14
    1f32:	60 e0       	ldi	r22, 0x00	; 0
    1f34:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1f38:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1f3c:	0e 94 83 03 	call	0x706	; 0x706 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1f40:	49 ec       	ldi	r20, 0xC9	; 201
    1f42:	5e e0       	ldi	r21, 0x0E	; 14
    1f44:	61 e0       	ldi	r22, 0x01	; 1
    1f46:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1f4a:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1f4e:	0e 94 83 03 	call	0x706	; 0x706 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    1f52:	41 e5       	ldi	r20, 0x51	; 81
    1f54:	59 e0       	ldi	r21, 0x09	; 9
    1f56:	62 e0       	ldi	r22, 0x02	; 2
    1f58:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1f5c:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1f60:	0e 94 83 03 	call	0x706	; 0x706 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(COUNT_SENSOR,Count_Sensor_ISR);
    1f64:	41 ed       	ldi	r20, 0xD1	; 209
    1f66:	5e e0       	ldi	r21, 0x0E	; 14
    1f68:	63 e0       	ldi	r22, 0x03	; 3
    1f6a:	80 91 86 03 	lds	r24, 0x0386	; 0x800386 <dev>
    1f6e:	90 91 87 03 	lds	r25, 0x0387	; 0x800387 <dev+0x1>
    1f72:	0e 94 83 03 	call	0x706	; 0x706 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    1f76:	88 e8       	ldi	r24, 0x88	; 136
    1f78:	90 e0       	ldi	r25, 0x00	; 0
    1f7a:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1f7e:	6c 01       	movw	r12, r24
    1f80:	60 91 86 03 	lds	r22, 0x0386	; 0x800386 <dev>
    1f84:	70 91 87 03 	lds	r23, 0x0387	; 0x800387 <dev+0x1>
    1f88:	40 e0       	ldi	r20, 0x00	; 0
    1f8a:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1f8e:	c1 14       	cp	r12, r1
    1f90:	d1 04       	cpc	r13, r1
	{
		if(debug)
		{ 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1f92:	21 f4       	brne	.+8      	; 0x1f9c <main+0xdc>
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	0e 94 d1 1d 	call	0x3ba2	; 0x3ba2 <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		}
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1f9c:	88 e8       	ldi	r24, 0x88	; 136
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	0e 94 34 01 	call	0x268	; 0x268 <_ZN12SerialBuffernwEj>
    1fa4:	ec 01       	movw	r28, r24
    1fa6:	60 91 86 03 	lds	r22, 0x0386	; 0x800386 <dev>
    1faa:	70 91 87 03 	lds	r23, 0x0387	; 0x800387 <dev+0x1>
    1fae:	41 e0       	ldi	r20, 0x01	; 1
    1fb0:	0e 94 0f 01 	call	0x21e	; 0x21e <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    1fb4:	20 97       	sbiw	r28, 0x00	; 0
	{
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer Error\r\n");
		}
		exit(1);
    1fb6:	21 f4       	brne	.+8      	; 0x1fc0 <main+0x100>
    1fb8:	81 e0       	ldi	r24, 0x01	; 1
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	0e 94 d1 1d 	call	0x3ba2	; 0x3ba2 <_exit>
		if(debug)
		{
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		}
	}
	DataStruct[UART0] = sb;
    1fc0:	ec e7       	ldi	r30, 0x7C	; 124
    1fc2:	f3 e0       	ldi	r31, 0x03	; 3
    1fc4:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    1fc6:	c0 82       	st	Z, r12
    1fc8:	d3 83       	std	Z+3, r29	; 0x03
				else if(i == RS485)
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			}
		}
	}
	Alarm_Init(); //알람 초기화
    1fca:	c2 83       	std	Z+2, r28	; 0x02
    1fcc:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Alarm_Init>
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1fd0:	78 94       	sei
    1fd2:	e1 2c       	mov	r14, r1
    1fd4:	f1 2c       	mov	r15, r1
    1fd6:	02 e0       	ldi	r16, 0x02	; 2
    1fd8:	96 01       	movw	r18, r12
    1fda:	4e e5       	ldi	r20, 0x5E	; 94
    1fdc:	51 e0       	ldi	r21, 0x01	; 1
    1fde:	69 ed       	ldi	r22, 0xD9	; 217
    1fe0:	71 e0       	ldi	r23, 0x01	; 1
    1fe2:	8d e5       	ldi	r24, 0x5D	; 93
    1fe4:	9d e0       	ldi	r25, 0x0D	; 13
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    1fe6:	2b d5       	rcall	.+2646   	; 0x2a3e <xTaskCreate>
    1fe8:	9e 01       	movw	r18, r28
    1fea:	4e e5       	ldi	r20, 0x5E	; 94
    1fec:	51 e0       	ldi	r21, 0x01	; 1
    1fee:	6f ed       	ldi	r22, 0xDF	; 223
    1ff0:	71 e0       	ldi	r23, 0x01	; 1
    1ff2:	82 ea       	ldi	r24, 0xA2	; 162
    1ff4:	9c e0       	ldi	r25, 0x0C	; 12
				"Task3",      //테스크 이름
				500,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위0.
				NULL                   //태스크 핸들
				);
    1ff6:	23 d5       	rcall	.+2630   	; 0x2a3e <xTaskCreate>
    1ff8:	20 e0       	ldi	r18, 0x00	; 0
    1ffa:	30 e0       	ldi	r19, 0x00	; 0
    1ffc:	44 ef       	ldi	r20, 0xF4	; 244
    1ffe:	51 e0       	ldi	r21, 0x01	; 1
    2000:	65 ee       	ldi	r22, 0xE5	; 229
    2002:	71 e0       	ldi	r23, 0x01	; 1
    2004:	83 e6       	ldi	r24, 0x63	; 99
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    2006:	99 e0       	ldi	r25, 0x09	; 9
    2008:	1a d5       	rcall	.+2612   	; 0x2a3e <xTaskCreate>
	return 0;
}
    200a:	17 d6       	rcall	.+3118   	; 0x2c3a <vTaskStartScheduler>
    200c:	80 e0       	ldi	r24, 0x00	; 0
    200e:	90 e0       	ldi	r25, 0x00	; 0
    2010:	df 91       	pop	r29
    2012:	cf 91       	pop	r28
    2014:	0f 91       	pop	r16
    2016:	ff 90       	pop	r15
    2018:	ef 90       	pop	r14
    201a:	df 90       	pop	r13
    201c:	cf 90       	pop	r12
    201e:	08 95       	ret

00002020 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    2020:	08 95       	ret

00002022 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2022:	cf 93       	push	r28
    2024:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    2026:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    2028:	30 d6       	rcall	.+3168   	; 0x2c8a <vTaskSuspendAll>
    202a:	80 91 88 03 	lds	r24, 0x0388	; 0x800388 <pucAlignedHeap.2069>
    202e:	90 91 89 03 	lds	r25, 0x0389	; 0x800389 <pucAlignedHeap.2069+0x1>
    2032:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    2034:	31 f4       	brne	.+12     	; 0x2042 <pvPortMalloc+0x20>
    2036:	8d e8       	ldi	r24, 0x8D	; 141
    2038:	93 e0       	ldi	r25, 0x03	; 3
    203a:	90 93 89 03 	sts	0x0389, r25	; 0x800389 <pucAlignedHeap.2069+0x1>
    203e:	80 93 88 03 	sts	0x0388, r24	; 0x800388 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2042:	20 91 8a 03 	lds	r18, 0x038A	; 0x80038a <xNextFreeByte>
    2046:	30 91 8b 03 	lds	r19, 0x038B	; 0x80038b <xNextFreeByte+0x1>
    204a:	c9 01       	movw	r24, r18
    204c:	8c 0f       	add	r24, r28
    204e:	9d 1f       	adc	r25, r29
    2050:	8b 3f       	cpi	r24, 0xFB	; 251
    2052:	48 e0       	ldi	r20, 0x08	; 8
    2054:	94 07       	cpc	r25, r20
    2056:	70 f4       	brcc	.+28     	; 0x2074 <pvPortMalloc+0x52>
    2058:	28 17       	cp	r18, r24
    205a:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    205c:	70 f4       	brcc	.+28     	; 0x207a <pvPortMalloc+0x58>
    205e:	c0 91 88 03 	lds	r28, 0x0388	; 0x800388 <pucAlignedHeap.2069>
    2062:	d0 91 89 03 	lds	r29, 0x0389	; 0x800389 <pucAlignedHeap.2069+0x1>
    2066:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    2068:	d3 1f       	adc	r29, r19
    206a:	90 93 8b 03 	sts	0x038B, r25	; 0x80038b <xNextFreeByte+0x1>
    206e:	80 93 8a 03 	sts	0x038A, r24	; 0x80038a <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    2072:	05 c0       	rjmp	.+10     	; 0x207e <pvPortMalloc+0x5c>
    2074:	c0 e0       	ldi	r28, 0x00	; 0
    2076:	d0 e0       	ldi	r29, 0x00	; 0
    2078:	02 c0       	rjmp	.+4      	; 0x207e <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    207a:	c0 e0       	ldi	r28, 0x00	; 0
    207c:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    207e:	c2 d6       	rcall	.+3460   	; 0x2e04 <xTaskResumeAll>
    2080:	ce 01       	movw	r24, r28
    2082:	df 91       	pop	r29
    2084:	cf 91       	pop	r28
    2086:	08 95       	ret

00002088 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2088:	08 95       	ret

0000208a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    208a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    208c:	03 96       	adiw	r24, 0x03	; 3
    208e:	92 83       	std	Z+2, r25	; 0x02
    2090:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2092:	2f ef       	ldi	r18, 0xFF	; 255
    2094:	3f ef       	ldi	r19, 0xFF	; 255
    2096:	34 83       	std	Z+4, r19	; 0x04
    2098:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    209a:	96 83       	std	Z+6, r25	; 0x06
    209c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    209e:	90 87       	std	Z+8, r25	; 0x08
    20a0:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    20a2:	10 82       	st	Z, r1
    20a4:	08 95       	ret

000020a6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    20a6:	fc 01       	movw	r30, r24
    20a8:	11 86       	std	Z+9, r1	; 0x09
    20aa:	10 86       	std	Z+8, r1	; 0x08
    20ac:	08 95       	ret

000020ae <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    20ae:	cf 93       	push	r28
    20b0:	df 93       	push	r29
    20b2:	9c 01       	movw	r18, r24
    20b4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    20b6:	dc 01       	movw	r26, r24
    20b8:	11 96       	adiw	r26, 0x01	; 1
    20ba:	cd 91       	ld	r28, X+
    20bc:	dc 91       	ld	r29, X
    20be:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    20c0:	d3 83       	std	Z+3, r29	; 0x03
    20c2:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    20c4:	8c 81       	ldd	r24, Y+4	; 0x04
    20c6:	9d 81       	ldd	r25, Y+5	; 0x05
    20c8:	95 83       	std	Z+5, r25	; 0x05
    20ca:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    20cc:	8c 81       	ldd	r24, Y+4	; 0x04
    20ce:	9d 81       	ldd	r25, Y+5	; 0x05
    20d0:	dc 01       	movw	r26, r24
    20d2:	13 96       	adiw	r26, 0x03	; 3
    20d4:	7c 93       	st	X, r23
    20d6:	6e 93       	st	-X, r22
    20d8:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    20da:	7d 83       	std	Y+5, r23	; 0x05
    20dc:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    20de:	31 87       	std	Z+9, r19	; 0x09
    20e0:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    20e2:	f9 01       	movw	r30, r18
    20e4:	80 81       	ld	r24, Z
    20e6:	8f 5f       	subi	r24, 0xFF	; 255
    20e8:	80 83       	st	Z, r24
}
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	08 95       	ret

000020f0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    20f0:	cf 93       	push	r28
    20f2:	df 93       	push	r29
    20f4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    20f6:	48 81       	ld	r20, Y
    20f8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    20fa:	4f 3f       	cpi	r20, 0xFF	; 255
    20fc:	2f ef       	ldi	r18, 0xFF	; 255
    20fe:	52 07       	cpc	r21, r18
    2100:	21 f4       	brne	.+8      	; 0x210a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2102:	fc 01       	movw	r30, r24
    2104:	a7 81       	ldd	r26, Z+7	; 0x07
    2106:	b0 85       	ldd	r27, Z+8	; 0x08
    2108:	0d c0       	rjmp	.+26     	; 0x2124 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    210a:	dc 01       	movw	r26, r24
    210c:	13 96       	adiw	r26, 0x03	; 3
    210e:	01 c0       	rjmp	.+2      	; 0x2112 <vListInsert+0x22>
    2110:	df 01       	movw	r26, r30
    2112:	12 96       	adiw	r26, 0x02	; 2
    2114:	ed 91       	ld	r30, X+
    2116:	fc 91       	ld	r31, X
    2118:	13 97       	sbiw	r26, 0x03	; 3
    211a:	20 81       	ld	r18, Z
    211c:	31 81       	ldd	r19, Z+1	; 0x01
    211e:	42 17       	cp	r20, r18
    2120:	53 07       	cpc	r21, r19
    2122:	b0 f7       	brcc	.-20     	; 0x2110 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    2124:	12 96       	adiw	r26, 0x02	; 2
    2126:	ed 91       	ld	r30, X+
    2128:	fc 91       	ld	r31, X
    212a:	13 97       	sbiw	r26, 0x03	; 3
    212c:	fb 83       	std	Y+3, r31	; 0x03
    212e:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    2130:	d5 83       	std	Z+5, r29	; 0x05
    2132:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    2134:	bd 83       	std	Y+5, r27	; 0x05
    2136:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    2138:	13 96       	adiw	r26, 0x03	; 3
    213a:	dc 93       	st	X, r29
    213c:	ce 93       	st	-X, r28
    213e:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2140:	99 87       	std	Y+9, r25	; 0x09
    2142:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2144:	fc 01       	movw	r30, r24
    2146:	20 81       	ld	r18, Z
    2148:	2f 5f       	subi	r18, 0xFF	; 255
    214a:	20 83       	st	Z, r18
}
    214c:	df 91       	pop	r29
    214e:	cf 91       	pop	r28
    2150:	08 95       	ret

00002152 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    2152:	cf 93       	push	r28
    2154:	df 93       	push	r29
    2156:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    2158:	a0 85       	ldd	r26, Z+8	; 0x08
    215a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    215c:	c2 81       	ldd	r28, Z+2	; 0x02
    215e:	d3 81       	ldd	r29, Z+3	; 0x03
    2160:	84 81       	ldd	r24, Z+4	; 0x04
    2162:	95 81       	ldd	r25, Z+5	; 0x05
    2164:	9d 83       	std	Y+5, r25	; 0x05
    2166:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    2168:	c4 81       	ldd	r28, Z+4	; 0x04
    216a:	d5 81       	ldd	r29, Z+5	; 0x05
    216c:	82 81       	ldd	r24, Z+2	; 0x02
    216e:	93 81       	ldd	r25, Z+3	; 0x03
    2170:	9b 83       	std	Y+3, r25	; 0x03
    2172:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2174:	11 96       	adiw	r26, 0x01	; 1
    2176:	8d 91       	ld	r24, X+
    2178:	9c 91       	ld	r25, X
    217a:	12 97       	sbiw	r26, 0x02	; 2
    217c:	e8 17       	cp	r30, r24
    217e:	f9 07       	cpc	r31, r25
    2180:	31 f4       	brne	.+12     	; 0x218e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    2182:	84 81       	ldd	r24, Z+4	; 0x04
    2184:	95 81       	ldd	r25, Z+5	; 0x05
    2186:	12 96       	adiw	r26, 0x02	; 2
    2188:	9c 93       	st	X, r25
    218a:	8e 93       	st	-X, r24
    218c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    218e:	11 86       	std	Z+9, r1	; 0x09
    2190:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    2192:	8c 91       	ld	r24, X
    2194:	81 50       	subi	r24, 0x01	; 1
    2196:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    2198:	df 91       	pop	r29
    219a:	cf 91       	pop	r28
    219c:	08 95       	ret

0000219e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    219e:	31 e1       	ldi	r19, 0x11	; 17
    21a0:	fc 01       	movw	r30, r24
    21a2:	30 83       	st	Z, r19
    21a4:	31 97       	sbiw	r30, 0x01	; 1
    21a6:	22 e2       	ldi	r18, 0x22	; 34
    21a8:	20 83       	st	Z, r18
    21aa:	31 97       	sbiw	r30, 0x01	; 1
    21ac:	a3 e3       	ldi	r26, 0x33	; 51
    21ae:	a0 83       	st	Z, r26
    21b0:	31 97       	sbiw	r30, 0x01	; 1
    21b2:	60 83       	st	Z, r22
    21b4:	31 97       	sbiw	r30, 0x01	; 1
    21b6:	70 83       	st	Z, r23
    21b8:	31 97       	sbiw	r30, 0x01	; 1
    21ba:	10 82       	st	Z, r1
    21bc:	31 97       	sbiw	r30, 0x01	; 1
    21be:	60 e8       	ldi	r22, 0x80	; 128
    21c0:	60 83       	st	Z, r22
    21c2:	31 97       	sbiw	r30, 0x01	; 1
    21c4:	10 82       	st	Z, r1
    21c6:	31 97       	sbiw	r30, 0x01	; 1
    21c8:	62 e0       	ldi	r22, 0x02	; 2
    21ca:	60 83       	st	Z, r22
    21cc:	31 97       	sbiw	r30, 0x01	; 1
    21ce:	63 e0       	ldi	r22, 0x03	; 3
    21d0:	60 83       	st	Z, r22
    21d2:	31 97       	sbiw	r30, 0x01	; 1
    21d4:	64 e0       	ldi	r22, 0x04	; 4
    21d6:	60 83       	st	Z, r22
    21d8:	31 97       	sbiw	r30, 0x01	; 1
    21da:	65 e0       	ldi	r22, 0x05	; 5
    21dc:	60 83       	st	Z, r22
    21de:	31 97       	sbiw	r30, 0x01	; 1
    21e0:	66 e0       	ldi	r22, 0x06	; 6
    21e2:	60 83       	st	Z, r22
    21e4:	31 97       	sbiw	r30, 0x01	; 1
    21e6:	67 e0       	ldi	r22, 0x07	; 7
    21e8:	60 83       	st	Z, r22
    21ea:	31 97       	sbiw	r30, 0x01	; 1
    21ec:	68 e0       	ldi	r22, 0x08	; 8
    21ee:	60 83       	st	Z, r22
    21f0:	31 97       	sbiw	r30, 0x01	; 1
    21f2:	69 e0       	ldi	r22, 0x09	; 9
    21f4:	60 83       	st	Z, r22
    21f6:	31 97       	sbiw	r30, 0x01	; 1
    21f8:	60 e1       	ldi	r22, 0x10	; 16
    21fa:	60 83       	st	Z, r22
    21fc:	31 97       	sbiw	r30, 0x01	; 1
    21fe:	30 83       	st	Z, r19
    2200:	31 97       	sbiw	r30, 0x01	; 1
    2202:	32 e1       	ldi	r19, 0x12	; 18
    2204:	30 83       	st	Z, r19
    2206:	31 97       	sbiw	r30, 0x01	; 1
    2208:	33 e1       	ldi	r19, 0x13	; 19
    220a:	30 83       	st	Z, r19
    220c:	31 97       	sbiw	r30, 0x01	; 1
    220e:	34 e1       	ldi	r19, 0x14	; 20
    2210:	30 83       	st	Z, r19
    2212:	31 97       	sbiw	r30, 0x01	; 1
    2214:	35 e1       	ldi	r19, 0x15	; 21
    2216:	30 83       	st	Z, r19
    2218:	31 97       	sbiw	r30, 0x01	; 1
    221a:	36 e1       	ldi	r19, 0x16	; 22
    221c:	30 83       	st	Z, r19
    221e:	31 97       	sbiw	r30, 0x01	; 1
    2220:	37 e1       	ldi	r19, 0x17	; 23
    2222:	30 83       	st	Z, r19
    2224:	31 97       	sbiw	r30, 0x01	; 1
    2226:	38 e1       	ldi	r19, 0x18	; 24
    2228:	30 83       	st	Z, r19
    222a:	31 97       	sbiw	r30, 0x01	; 1
    222c:	39 e1       	ldi	r19, 0x19	; 25
    222e:	30 83       	st	Z, r19
    2230:	31 97       	sbiw	r30, 0x01	; 1
    2232:	30 e2       	ldi	r19, 0x20	; 32
    2234:	30 83       	st	Z, r19
    2236:	31 97       	sbiw	r30, 0x01	; 1
    2238:	31 e2       	ldi	r19, 0x21	; 33
    223a:	30 83       	st	Z, r19
    223c:	31 97       	sbiw	r30, 0x01	; 1
    223e:	20 83       	st	Z, r18
    2240:	31 97       	sbiw	r30, 0x01	; 1
    2242:	23 e2       	ldi	r18, 0x23	; 35
    2244:	20 83       	st	Z, r18
    2246:	31 97       	sbiw	r30, 0x01	; 1
    2248:	40 83       	st	Z, r20
    224a:	31 97       	sbiw	r30, 0x01	; 1
    224c:	50 83       	st	Z, r21
    224e:	31 97       	sbiw	r30, 0x01	; 1
    2250:	26 e2       	ldi	r18, 0x26	; 38
    2252:	20 83       	st	Z, r18
    2254:	31 97       	sbiw	r30, 0x01	; 1
    2256:	27 e2       	ldi	r18, 0x27	; 39
    2258:	20 83       	st	Z, r18
    225a:	31 97       	sbiw	r30, 0x01	; 1
    225c:	28 e2       	ldi	r18, 0x28	; 40
    225e:	20 83       	st	Z, r18
    2260:	31 97       	sbiw	r30, 0x01	; 1
    2262:	29 e2       	ldi	r18, 0x29	; 41
    2264:	20 83       	st	Z, r18
    2266:	31 97       	sbiw	r30, 0x01	; 1
    2268:	20 e3       	ldi	r18, 0x30	; 48
    226a:	20 83       	st	Z, r18
    226c:	31 97       	sbiw	r30, 0x01	; 1
    226e:	21 e3       	ldi	r18, 0x31	; 49
    2270:	20 83       	st	Z, r18
    2272:	86 97       	sbiw	r24, 0x26	; 38
    2274:	08 95       	ret

00002276 <xPortStartScheduler>:
    2276:	1b bc       	out	0x2b, r1	; 43
    2278:	89 ef       	ldi	r24, 0xF9	; 249
    227a:	8a bd       	out	0x2a, r24	; 42
    227c:	8b e0       	ldi	r24, 0x0B	; 11
    227e:	8e bd       	out	0x2e, r24	; 46
    2280:	87 b7       	in	r24, 0x37	; 55
    2282:	80 61       	ori	r24, 0x10	; 16
    2284:	87 bf       	out	0x37, r24	; 55
    2286:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    228a:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    228e:	cd 91       	ld	r28, X+
    2290:	cd bf       	out	0x3d, r28	; 61
    2292:	dd 91       	ld	r29, X+
    2294:	de bf       	out	0x3e, r29	; 62
    2296:	ff 91       	pop	r31
    2298:	ef 91       	pop	r30
    229a:	df 91       	pop	r29
    229c:	cf 91       	pop	r28
    229e:	bf 91       	pop	r27
    22a0:	af 91       	pop	r26
    22a2:	9f 91       	pop	r25
    22a4:	8f 91       	pop	r24
    22a6:	7f 91       	pop	r23
    22a8:	6f 91       	pop	r22
    22aa:	5f 91       	pop	r21
    22ac:	4f 91       	pop	r20
    22ae:	3f 91       	pop	r19
    22b0:	2f 91       	pop	r18
    22b2:	1f 91       	pop	r17
    22b4:	0f 91       	pop	r16
    22b6:	ff 90       	pop	r15
    22b8:	ef 90       	pop	r14
    22ba:	df 90       	pop	r13
    22bc:	cf 90       	pop	r12
    22be:	bf 90       	pop	r11
    22c0:	af 90       	pop	r10
    22c2:	9f 90       	pop	r9
    22c4:	8f 90       	pop	r8
    22c6:	7f 90       	pop	r7
    22c8:	6f 90       	pop	r6
    22ca:	5f 90       	pop	r5
    22cc:	4f 90       	pop	r4
    22ce:	3f 90       	pop	r3
    22d0:	2f 90       	pop	r2
    22d2:	1f 90       	pop	r1
    22d4:	0f 90       	pop	r0
    22d6:	0f be       	out	0x3f, r0	; 63
    22d8:	0f 90       	pop	r0
    22da:	08 95       	ret
    22dc:	81 e0       	ldi	r24, 0x01	; 1
    22de:	08 95       	ret

000022e0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    22e0:	0f 92       	push	r0
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	f8 94       	cli
    22e6:	0f 92       	push	r0
    22e8:	1f 92       	push	r1
    22ea:	11 24       	eor	r1, r1
    22ec:	2f 92       	push	r2
    22ee:	3f 92       	push	r3
    22f0:	4f 92       	push	r4
    22f2:	5f 92       	push	r5
    22f4:	6f 92       	push	r6
    22f6:	7f 92       	push	r7
    22f8:	8f 92       	push	r8
    22fa:	9f 92       	push	r9
    22fc:	af 92       	push	r10
    22fe:	bf 92       	push	r11
    2300:	cf 92       	push	r12
    2302:	df 92       	push	r13
    2304:	ef 92       	push	r14
    2306:	ff 92       	push	r15
    2308:	0f 93       	push	r16
    230a:	1f 93       	push	r17
    230c:	2f 93       	push	r18
    230e:	3f 93       	push	r19
    2310:	4f 93       	push	r20
    2312:	5f 93       	push	r21
    2314:	6f 93       	push	r22
    2316:	7f 93       	push	r23
    2318:	8f 93       	push	r24
    231a:	9f 93       	push	r25
    231c:	af 93       	push	r26
    231e:	bf 93       	push	r27
    2320:	cf 93       	push	r28
    2322:	df 93       	push	r29
    2324:	ef 93       	push	r30
    2326:	ff 93       	push	r31
    2328:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    232c:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2330:	0d b6       	in	r0, 0x3d	; 61
    2332:	0d 92       	st	X+, r0
    2334:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    2336:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    2338:	25 d6       	rcall	.+3146   	; 0x2f84 <vTaskSwitchContext>
    233a:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    233e:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2342:	cd 91       	ld	r28, X+
    2344:	cd bf       	out	0x3d, r28	; 61
    2346:	dd 91       	ld	r29, X+
    2348:	de bf       	out	0x3e, r29	; 62
    234a:	ff 91       	pop	r31
    234c:	ef 91       	pop	r30
    234e:	df 91       	pop	r29
    2350:	cf 91       	pop	r28
    2352:	bf 91       	pop	r27
    2354:	af 91       	pop	r26
    2356:	9f 91       	pop	r25
    2358:	8f 91       	pop	r24
    235a:	7f 91       	pop	r23
    235c:	6f 91       	pop	r22
    235e:	5f 91       	pop	r21
    2360:	4f 91       	pop	r20
    2362:	3f 91       	pop	r19
    2364:	2f 91       	pop	r18
    2366:	1f 91       	pop	r17
    2368:	0f 91       	pop	r16
    236a:	ff 90       	pop	r15
    236c:	ef 90       	pop	r14
    236e:	df 90       	pop	r13
    2370:	cf 90       	pop	r12
    2372:	bf 90       	pop	r11
    2374:	af 90       	pop	r10
    2376:	9f 90       	pop	r9
    2378:	8f 90       	pop	r8
    237a:	7f 90       	pop	r7
    237c:	6f 90       	pop	r6
    237e:	5f 90       	pop	r5
    2380:	4f 90       	pop	r4
    2382:	3f 90       	pop	r3
    2384:	2f 90       	pop	r2
    2386:	1f 90       	pop	r1
    2388:	0f 90       	pop	r0
    238a:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    238c:	0f 90       	pop	r0
    238e:	08 95       	ret

00002390 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    2390:	0f 92       	push	r0
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	0f 92       	push	r0
    2398:	1f 92       	push	r1
    239a:	11 24       	eor	r1, r1
    239c:	2f 92       	push	r2
    239e:	3f 92       	push	r3
    23a0:	4f 92       	push	r4
    23a2:	5f 92       	push	r5
    23a4:	6f 92       	push	r6
    23a6:	7f 92       	push	r7
    23a8:	8f 92       	push	r8
    23aa:	9f 92       	push	r9
    23ac:	af 92       	push	r10
    23ae:	bf 92       	push	r11
    23b0:	cf 92       	push	r12
    23b2:	df 92       	push	r13
    23b4:	ef 92       	push	r14
    23b6:	ff 92       	push	r15
    23b8:	0f 93       	push	r16
    23ba:	1f 93       	push	r17
    23bc:	2f 93       	push	r18
    23be:	3f 93       	push	r19
    23c0:	4f 93       	push	r20
    23c2:	5f 93       	push	r21
    23c4:	6f 93       	push	r22
    23c6:	7f 93       	push	r23
    23c8:	8f 93       	push	r24
    23ca:	9f 93       	push	r25
    23cc:	af 93       	push	r26
    23ce:	bf 93       	push	r27
    23d0:	cf 93       	push	r28
    23d2:	df 93       	push	r29
    23d4:	ef 93       	push	r30
    23d6:	ff 93       	push	r31
    23d8:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    23dc:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    23e0:	0d b6       	in	r0, 0x3d	; 61
    23e2:	0d 92       	st	X+, r0
    23e4:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    23e6:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    23e8:	56 d4       	rcall	.+2220   	; 0x2c96 <xTaskIncrementTick>
    23ea:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    23ec:	cb d5       	rcall	.+2966   	; 0x2f84 <vTaskSwitchContext>
    23ee:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    23f2:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    23f6:	cd 91       	ld	r28, X+
    23f8:	cd bf       	out	0x3d, r28	; 61
    23fa:	dd 91       	ld	r29, X+
    23fc:	de bf       	out	0x3e, r29	; 62
    23fe:	ff 91       	pop	r31
    2400:	ef 91       	pop	r30
    2402:	df 91       	pop	r29
    2404:	cf 91       	pop	r28
    2406:	bf 91       	pop	r27
    2408:	af 91       	pop	r26
    240a:	9f 91       	pop	r25
    240c:	8f 91       	pop	r24
    240e:	7f 91       	pop	r23
    2410:	6f 91       	pop	r22
    2412:	5f 91       	pop	r21
    2414:	4f 91       	pop	r20
    2416:	3f 91       	pop	r19
    2418:	2f 91       	pop	r18
    241a:	1f 91       	pop	r17
    241c:	0f 91       	pop	r16
    241e:	ff 90       	pop	r15
    2420:	ef 90       	pop	r14
    2422:	df 90       	pop	r13
    2424:	cf 90       	pop	r12
    2426:	bf 90       	pop	r11
    2428:	af 90       	pop	r10
    242a:	9f 90       	pop	r9
    242c:	8f 90       	pop	r8
    242e:	7f 90       	pop	r7
    2430:	6f 90       	pop	r6
    2432:	5f 90       	pop	r5
    2434:	4f 90       	pop	r4
    2436:	3f 90       	pop	r3
    2438:	2f 90       	pop	r2
    243a:	1f 90       	pop	r1
    243c:	0f 90       	pop	r0
    243e:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    2440:	0f 90       	pop	r0
    2442:	08 95       	ret

00002444 <__vector_12>:
    2444:	a5 df       	rcall	.-182    	; 0x2390 <vPortYieldFromTick>
    2446:	18 95       	reti

00002448 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2448:	0f 93       	push	r16
    244a:	1f 93       	push	r17
    244c:	cf 93       	push	r28
    244e:	df 93       	push	r29
    2450:	ec 01       	movw	r28, r24
    2452:	04 2f       	mov	r16, r20
    2454:	1a 8d       	ldd	r17, Y+26	; 0x1a
    2456:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2458:	41 11       	cpse	r20, r1
    245a:	0b c0       	rjmp	.+22     	; 0x2472 <prvCopyDataToQueue+0x2a>
    245c:	88 81       	ld	r24, Y
    245e:	99 81       	ldd	r25, Y+1	; 0x01
    2460:	89 2b       	or	r24, r25
    2462:	09 f0       	breq	.+2      	; 0x2466 <prvCopyDataToQueue+0x1e>
    2464:	41 c0       	rjmp	.+130    	; 0x24e8 <prvCopyDataToQueue+0xa0>
    2466:	8a 81       	ldd	r24, Y+2	; 0x02
    2468:	9b 81       	ldd	r25, Y+3	; 0x03
    246a:	0b d7       	rcall	.+3606   	; 0x3282 <xTaskPriorityDisinherit>
    246c:	1b 82       	std	Y+3, r1	; 0x03
    246e:	1a 82       	std	Y+2, r1	; 0x02
    2470:	42 c0       	rjmp	.+132    	; 0x24f6 <prvCopyDataToQueue+0xae>
    2472:	01 11       	cpse	r16, r1
    2474:	17 c0       	rjmp	.+46     	; 0x24a4 <prvCopyDataToQueue+0x5c>
    2476:	50 e0       	ldi	r21, 0x00	; 0
    2478:	8c 81       	ldd	r24, Y+4	; 0x04
    247a:	9d 81       	ldd	r25, Y+5	; 0x05
    247c:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <memcpy>
    2480:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2482:	8c 81       	ldd	r24, Y+4	; 0x04
    2484:	9d 81       	ldd	r25, Y+5	; 0x05
    2486:	82 0f       	add	r24, r18
    2488:	91 1d       	adc	r25, r1
    248a:	9d 83       	std	Y+5, r25	; 0x05
    248c:	8c 83       	std	Y+4, r24	; 0x04
    248e:	2a 81       	ldd	r18, Y+2	; 0x02
    2490:	3b 81       	ldd	r19, Y+3	; 0x03
    2492:	82 17       	cp	r24, r18
    2494:	93 07       	cpc	r25, r19
    2496:	50 f1       	brcs	.+84     	; 0x24ec <prvCopyDataToQueue+0xa4>
    2498:	88 81       	ld	r24, Y
    249a:	99 81       	ldd	r25, Y+1	; 0x01
    249c:	9d 83       	std	Y+5, r25	; 0x05
    249e:	8c 83       	std	Y+4, r24	; 0x04
    24a0:	80 e0       	ldi	r24, 0x00	; 0
    24a2:	29 c0       	rjmp	.+82     	; 0x24f6 <prvCopyDataToQueue+0xae>
    24a4:	50 e0       	ldi	r21, 0x00	; 0
    24a6:	8e 81       	ldd	r24, Y+6	; 0x06
    24a8:	9f 81       	ldd	r25, Y+7	; 0x07
    24aa:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <memcpy>
    24ae:	8c 8d       	ldd	r24, Y+28	; 0x1c
    24b0:	90 e0       	ldi	r25, 0x00	; 0
    24b2:	91 95       	neg	r25
    24b4:	81 95       	neg	r24
    24b6:	91 09       	sbc	r25, r1
    24b8:	2e 81       	ldd	r18, Y+6	; 0x06
    24ba:	3f 81       	ldd	r19, Y+7	; 0x07
    24bc:	28 0f       	add	r18, r24
    24be:	39 1f       	adc	r19, r25
    24c0:	3f 83       	std	Y+7, r19	; 0x07
    24c2:	2e 83       	std	Y+6, r18	; 0x06
    24c4:	48 81       	ld	r20, Y
    24c6:	59 81       	ldd	r21, Y+1	; 0x01
    24c8:	24 17       	cp	r18, r20
    24ca:	35 07       	cpc	r19, r21
    24cc:	30 f4       	brcc	.+12     	; 0x24da <prvCopyDataToQueue+0x92>
    24ce:	2a 81       	ldd	r18, Y+2	; 0x02
    24d0:	3b 81       	ldd	r19, Y+3	; 0x03
    24d2:	82 0f       	add	r24, r18
    24d4:	93 1f       	adc	r25, r19
    24d6:	9f 83       	std	Y+7, r25	; 0x07
    24d8:	8e 83       	std	Y+6, r24	; 0x06
    24da:	02 30       	cpi	r16, 0x02	; 2
    24dc:	49 f4       	brne	.+18     	; 0x24f0 <prvCopyDataToQueue+0xa8>
    24de:	11 23       	and	r17, r17
    24e0:	49 f0       	breq	.+18     	; 0x24f4 <prvCopyDataToQueue+0xac>
    24e2:	11 50       	subi	r17, 0x01	; 1
    24e4:	80 e0       	ldi	r24, 0x00	; 0
    24e6:	07 c0       	rjmp	.+14     	; 0x24f6 <prvCopyDataToQueue+0xae>
    24e8:	80 e0       	ldi	r24, 0x00	; 0
    24ea:	05 c0       	rjmp	.+10     	; 0x24f6 <prvCopyDataToQueue+0xae>
    24ec:	80 e0       	ldi	r24, 0x00	; 0
    24ee:	03 c0       	rjmp	.+6      	; 0x24f6 <prvCopyDataToQueue+0xae>
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	01 c0       	rjmp	.+2      	; 0x24f6 <prvCopyDataToQueue+0xae>
    24f4:	80 e0       	ldi	r24, 0x00	; 0
    24f6:	1f 5f       	subi	r17, 0xFF	; 255
    24f8:	1a 8f       	std	Y+26, r17	; 0x1a
    24fa:	df 91       	pop	r29
    24fc:	cf 91       	pop	r28
    24fe:	1f 91       	pop	r17
    2500:	0f 91       	pop	r16
    2502:	08 95       	ret

00002504 <prvCopyDataFromQueue>:
    2504:	fc 01       	movw	r30, r24
    2506:	44 8d       	ldd	r20, Z+28	; 0x1c
    2508:	44 23       	and	r20, r20
    250a:	a9 f0       	breq	.+42     	; 0x2536 <prvCopyDataFromQueue+0x32>
    250c:	50 e0       	ldi	r21, 0x00	; 0
    250e:	26 81       	ldd	r18, Z+6	; 0x06
    2510:	37 81       	ldd	r19, Z+7	; 0x07
    2512:	24 0f       	add	r18, r20
    2514:	35 1f       	adc	r19, r21
    2516:	37 83       	std	Z+7, r19	; 0x07
    2518:	26 83       	std	Z+6, r18	; 0x06
    251a:	82 81       	ldd	r24, Z+2	; 0x02
    251c:	93 81       	ldd	r25, Z+3	; 0x03
    251e:	28 17       	cp	r18, r24
    2520:	39 07       	cpc	r19, r25
    2522:	20 f0       	brcs	.+8      	; 0x252c <prvCopyDataFromQueue+0x28>
    2524:	80 81       	ld	r24, Z
    2526:	91 81       	ldd	r25, Z+1	; 0x01
    2528:	97 83       	std	Z+7, r25	; 0x07
    252a:	86 83       	std	Z+6, r24	; 0x06
    252c:	cb 01       	movw	r24, r22
    252e:	66 81       	ldd	r22, Z+6	; 0x06
    2530:	77 81       	ldd	r23, Z+7	; 0x07
    2532:	0c 94 d4 1a 	jmp	0x35a8	; 0x35a8 <memcpy>
    2536:	08 95       	ret

00002538 <prvUnlockQueue>:
    2538:	ef 92       	push	r14
    253a:	ff 92       	push	r15
    253c:	0f 93       	push	r16
    253e:	1f 93       	push	r17
    2540:	cf 93       	push	r28
    2542:	8c 01       	movw	r16, r24
    2544:	0f b6       	in	r0, 0x3f	; 63
    2546:	f8 94       	cli
    2548:	0f 92       	push	r0
    254a:	fc 01       	movw	r30, r24
    254c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    254e:	1c 16       	cp	r1, r28
    2550:	9c f4       	brge	.+38     	; 0x2578 <prvUnlockQueue+0x40>
    2552:	81 89       	ldd	r24, Z+17	; 0x11
    2554:	81 11       	cpse	r24, r1
    2556:	06 c0       	rjmp	.+12     	; 0x2564 <prvUnlockQueue+0x2c>
    2558:	0f c0       	rjmp	.+30     	; 0x2578 <prvUnlockQueue+0x40>
    255a:	f8 01       	movw	r30, r16
    255c:	81 89       	ldd	r24, Z+17	; 0x11
    255e:	81 11       	cpse	r24, r1
    2560:	05 c0       	rjmp	.+10     	; 0x256c <prvUnlockQueue+0x34>
    2562:	0a c0       	rjmp	.+20     	; 0x2578 <prvUnlockQueue+0x40>
    2564:	78 01       	movw	r14, r16
    2566:	f1 e1       	ldi	r31, 0x11	; 17
    2568:	ef 0e       	add	r14, r31
    256a:	f1 1c       	adc	r15, r1
    256c:	c7 01       	movw	r24, r14
    256e:	9a d5       	rcall	.+2868   	; 0x30a4 <xTaskRemoveFromEventList>
    2570:	81 11       	cpse	r24, r1
    2572:	21 d6       	rcall	.+3138   	; 0x31b6 <vTaskMissedYield>
    2574:	c1 50       	subi	r28, 0x01	; 1
    2576:	89 f7       	brne	.-30     	; 0x255a <prvUnlockQueue+0x22>
    2578:	8f ef       	ldi	r24, 0xFF	; 255
    257a:	f8 01       	movw	r30, r16
    257c:	86 8f       	std	Z+30, r24	; 0x1e
    257e:	0f 90       	pop	r0
    2580:	0f be       	out	0x3f, r0	; 63
    2582:	0f b6       	in	r0, 0x3f	; 63
    2584:	f8 94       	cli
    2586:	0f 92       	push	r0
    2588:	c5 8d       	ldd	r28, Z+29	; 0x1d
    258a:	1c 16       	cp	r1, r28
    258c:	9c f4       	brge	.+38     	; 0x25b4 <prvUnlockQueue+0x7c>
    258e:	80 85       	ldd	r24, Z+8	; 0x08
    2590:	81 11       	cpse	r24, r1
    2592:	06 c0       	rjmp	.+12     	; 0x25a0 <prvUnlockQueue+0x68>
    2594:	0f c0       	rjmp	.+30     	; 0x25b4 <prvUnlockQueue+0x7c>
    2596:	f8 01       	movw	r30, r16
    2598:	80 85       	ldd	r24, Z+8	; 0x08
    259a:	81 11       	cpse	r24, r1
    259c:	05 c0       	rjmp	.+10     	; 0x25a8 <prvUnlockQueue+0x70>
    259e:	0a c0       	rjmp	.+20     	; 0x25b4 <prvUnlockQueue+0x7c>
    25a0:	78 01       	movw	r14, r16
    25a2:	f8 e0       	ldi	r31, 0x08	; 8
    25a4:	ef 0e       	add	r14, r31
    25a6:	f1 1c       	adc	r15, r1
    25a8:	c7 01       	movw	r24, r14
    25aa:	7c d5       	rcall	.+2808   	; 0x30a4 <xTaskRemoveFromEventList>
    25ac:	81 11       	cpse	r24, r1
    25ae:	03 d6       	rcall	.+3078   	; 0x31b6 <vTaskMissedYield>
    25b0:	c1 50       	subi	r28, 0x01	; 1
    25b2:	89 f7       	brne	.-30     	; 0x2596 <prvUnlockQueue+0x5e>
    25b4:	8f ef       	ldi	r24, 0xFF	; 255
    25b6:	f8 01       	movw	r30, r16
    25b8:	85 8f       	std	Z+29, r24	; 0x1d
    25ba:	0f 90       	pop	r0
    25bc:	0f be       	out	0x3f, r0	; 63
    25be:	cf 91       	pop	r28
    25c0:	1f 91       	pop	r17
    25c2:	0f 91       	pop	r16
    25c4:	ff 90       	pop	r15
    25c6:	ef 90       	pop	r14
    25c8:	08 95       	ret

000025ca <xQueueGenericReset>:
    25ca:	cf 93       	push	r28
    25cc:	df 93       	push	r29
    25ce:	ec 01       	movw	r28, r24
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	0f 92       	push	r0
    25d6:	48 81       	ld	r20, Y
    25d8:	59 81       	ldd	r21, Y+1	; 0x01
    25da:	2c 8d       	ldd	r18, Y+28	; 0x1c
    25dc:	30 e0       	ldi	r19, 0x00	; 0
    25de:	7b 8d       	ldd	r23, Y+27	; 0x1b
    25e0:	72 9f       	mul	r23, r18
    25e2:	c0 01       	movw	r24, r0
    25e4:	73 9f       	mul	r23, r19
    25e6:	90 0d       	add	r25, r0
    25e8:	11 24       	eor	r1, r1
    25ea:	fa 01       	movw	r30, r20
    25ec:	e8 0f       	add	r30, r24
    25ee:	f9 1f       	adc	r31, r25
    25f0:	fb 83       	std	Y+3, r31	; 0x03
    25f2:	ea 83       	std	Y+2, r30	; 0x02
    25f4:	1a 8e       	std	Y+26, r1	; 0x1a
    25f6:	5d 83       	std	Y+5, r21	; 0x05
    25f8:	4c 83       	std	Y+4, r20	; 0x04
    25fa:	82 1b       	sub	r24, r18
    25fc:	93 0b       	sbc	r25, r19
    25fe:	84 0f       	add	r24, r20
    2600:	95 1f       	adc	r25, r21
    2602:	9f 83       	std	Y+7, r25	; 0x07
    2604:	8e 83       	std	Y+6, r24	; 0x06
    2606:	8f ef       	ldi	r24, 0xFF	; 255
    2608:	8d 8f       	std	Y+29, r24	; 0x1d
    260a:	8e 8f       	std	Y+30, r24	; 0x1e
    260c:	61 11       	cpse	r22, r1
    260e:	0a c0       	rjmp	.+20     	; 0x2624 <xQueueGenericReset+0x5a>
    2610:	88 85       	ldd	r24, Y+8	; 0x08
    2612:	88 23       	and	r24, r24
    2614:	69 f0       	breq	.+26     	; 0x2630 <xQueueGenericReset+0x66>
    2616:	ce 01       	movw	r24, r28
    2618:	08 96       	adiw	r24, 0x08	; 8
    261a:	44 d5       	rcall	.+2696   	; 0x30a4 <xTaskRemoveFromEventList>
    261c:	88 23       	and	r24, r24
    261e:	41 f0       	breq	.+16     	; 0x2630 <xQueueGenericReset+0x66>
    2620:	5f de       	rcall	.-834    	; 0x22e0 <vPortYield>
    2622:	06 c0       	rjmp	.+12     	; 0x2630 <xQueueGenericReset+0x66>
    2624:	ce 01       	movw	r24, r28
    2626:	08 96       	adiw	r24, 0x08	; 8
    2628:	30 dd       	rcall	.-1440   	; 0x208a <vListInitialise>
    262a:	ce 01       	movw	r24, r28
    262c:	41 96       	adiw	r24, 0x11	; 17
    262e:	2d dd       	rcall	.-1446   	; 0x208a <vListInitialise>
    2630:	0f 90       	pop	r0
    2632:	0f be       	out	0x3f, r0	; 63
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	df 91       	pop	r29
    2638:	cf 91       	pop	r28
    263a:	08 95       	ret

0000263c <xQueueGenericCreate>:
    263c:	0f 93       	push	r16
    263e:	1f 93       	push	r17
    2640:	cf 93       	push	r28
    2642:	df 93       	push	r29
    2644:	08 2f       	mov	r16, r24
    2646:	16 2f       	mov	r17, r22
    2648:	66 23       	and	r22, r22
    264a:	b1 f0       	breq	.+44     	; 0x2678 <xQueueGenericCreate+0x3c>
    264c:	86 9f       	mul	r24, r22
    264e:	c0 01       	movw	r24, r0
    2650:	11 24       	eor	r1, r1
    2652:	4f 96       	adiw	r24, 0x1f	; 31
    2654:	e6 dc       	rcall	.-1588   	; 0x2022 <pvPortMalloc>
    2656:	ec 01       	movw	r28, r24
    2658:	00 97       	sbiw	r24, 0x00	; 0
    265a:	39 f4       	brne	.+14     	; 0x266a <xQueueGenericCreate+0x2e>
    265c:	13 c0       	rjmp	.+38     	; 0x2684 <xQueueGenericCreate+0x48>
    265e:	0b 8f       	std	Y+27, r16	; 0x1b
    2660:	1c 8f       	std	Y+28, r17	; 0x1c
    2662:	61 e0       	ldi	r22, 0x01	; 1
    2664:	ce 01       	movw	r24, r28
    2666:	b1 df       	rcall	.-158    	; 0x25ca <xQueueGenericReset>
    2668:	0d c0       	rjmp	.+26     	; 0x2684 <xQueueGenericCreate+0x48>
    266a:	4f 96       	adiw	r24, 0x1f	; 31
    266c:	99 83       	std	Y+1, r25	; 0x01
    266e:	88 83       	st	Y, r24
    2670:	f6 cf       	rjmp	.-20     	; 0x265e <xQueueGenericCreate+0x22>
    2672:	d9 83       	std	Y+1, r29	; 0x01
    2674:	c8 83       	st	Y, r28
    2676:	f3 cf       	rjmp	.-26     	; 0x265e <xQueueGenericCreate+0x22>
    2678:	8f e1       	ldi	r24, 0x1F	; 31
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	d2 dc       	rcall	.-1628   	; 0x2022 <pvPortMalloc>
    267e:	ec 01       	movw	r28, r24
    2680:	89 2b       	or	r24, r25
    2682:	b9 f7       	brne	.-18     	; 0x2672 <xQueueGenericCreate+0x36>
    2684:	ce 01       	movw	r24, r28
    2686:	df 91       	pop	r29
    2688:	cf 91       	pop	r28
    268a:	1f 91       	pop	r17
    268c:	0f 91       	pop	r16
    268e:	08 95       	ret

00002690 <xQueueGenericSend>:
    2690:	9f 92       	push	r9
    2692:	af 92       	push	r10
    2694:	bf 92       	push	r11
    2696:	cf 92       	push	r12
    2698:	df 92       	push	r13
    269a:	ef 92       	push	r14
    269c:	ff 92       	push	r15
    269e:	0f 93       	push	r16
    26a0:	1f 93       	push	r17
    26a2:	cf 93       	push	r28
    26a4:	df 93       	push	r29
    26a6:	00 d0       	rcall	.+0      	; 0x26a8 <xQueueGenericSend+0x18>
    26a8:	00 d0       	rcall	.+0      	; 0x26aa <xQueueGenericSend+0x1a>
    26aa:	1f 92       	push	r1
    26ac:	cd b7       	in	r28, 0x3d	; 61
    26ae:	de b7       	in	r29, 0x3e	; 62
    26b0:	8c 01       	movw	r16, r24
    26b2:	6b 01       	movw	r12, r22
    26b4:	5d 83       	std	Y+5, r21	; 0x05
    26b6:	4c 83       	std	Y+4, r20	; 0x04
    26b8:	a2 2e       	mov	r10, r18
    26ba:	b1 2c       	mov	r11, r1
    26bc:	99 24       	eor	r9, r9
    26be:	93 94       	inc	r9
    26c0:	7c 01       	movw	r14, r24
    26c2:	88 e0       	ldi	r24, 0x08	; 8
    26c4:	e8 0e       	add	r14, r24
    26c6:	f1 1c       	adc	r15, r1
    26c8:	0f b6       	in	r0, 0x3f	; 63
    26ca:	f8 94       	cli
    26cc:	0f 92       	push	r0
    26ce:	f8 01       	movw	r30, r16
    26d0:	92 8d       	ldd	r25, Z+26	; 0x1a
    26d2:	83 8d       	ldd	r24, Z+27	; 0x1b
    26d4:	98 17       	cp	r25, r24
    26d6:	18 f0       	brcs	.+6      	; 0x26de <xQueueGenericSend+0x4e>
    26d8:	f2 e0       	ldi	r31, 0x02	; 2
    26da:	af 12       	cpse	r10, r31
    26dc:	15 c0       	rjmp	.+42     	; 0x2708 <xQueueGenericSend+0x78>
    26de:	4a 2d       	mov	r20, r10
    26e0:	b6 01       	movw	r22, r12
    26e2:	c8 01       	movw	r24, r16
    26e4:	b1 de       	rcall	.-670    	; 0x2448 <prvCopyDataToQueue>
    26e6:	f8 01       	movw	r30, r16
    26e8:	91 89       	ldd	r25, Z+17	; 0x11
    26ea:	99 23       	and	r25, r25
    26ec:	39 f0       	breq	.+14     	; 0x26fc <xQueueGenericSend+0x6c>
    26ee:	c8 01       	movw	r24, r16
    26f0:	41 96       	adiw	r24, 0x11	; 17
    26f2:	d8 d4       	rcall	.+2480   	; 0x30a4 <xTaskRemoveFromEventList>
    26f4:	88 23       	and	r24, r24
    26f6:	21 f0       	breq	.+8      	; 0x2700 <xQueueGenericSend+0x70>
    26f8:	f3 dd       	rcall	.-1050   	; 0x22e0 <vPortYield>
    26fa:	02 c0       	rjmp	.+4      	; 0x2700 <xQueueGenericSend+0x70>
    26fc:	81 11       	cpse	r24, r1
    26fe:	f0 dd       	rcall	.-1056   	; 0x22e0 <vPortYield>
    2700:	0f 90       	pop	r0
    2702:	0f be       	out	0x3f, r0	; 63
    2704:	81 e0       	ldi	r24, 0x01	; 1
    2706:	45 c0       	rjmp	.+138    	; 0x2792 <xQueueGenericSend+0x102>
    2708:	8c 81       	ldd	r24, Y+4	; 0x04
    270a:	9d 81       	ldd	r25, Y+5	; 0x05
    270c:	89 2b       	or	r24, r25
    270e:	21 f4       	brne	.+8      	; 0x2718 <xQueueGenericSend+0x88>
    2710:	0f 90       	pop	r0
    2712:	0f be       	out	0x3f, r0	; 63
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	3d c0       	rjmp	.+122    	; 0x2792 <xQueueGenericSend+0x102>
    2718:	b1 10       	cpse	r11, r1
    271a:	04 c0       	rjmp	.+8      	; 0x2724 <xQueueGenericSend+0x94>
    271c:	ce 01       	movw	r24, r28
    271e:	01 96       	adiw	r24, 0x01	; 1
    2720:	07 d5       	rcall	.+2574   	; 0x3130 <vTaskSetTimeOutState>
    2722:	b9 2c       	mov	r11, r9
    2724:	0f 90       	pop	r0
    2726:	0f be       	out	0x3f, r0	; 63
    2728:	b0 d2       	rcall	.+1376   	; 0x2c8a <vTaskSuspendAll>
    272a:	0f b6       	in	r0, 0x3f	; 63
    272c:	f8 94       	cli
    272e:	0f 92       	push	r0
    2730:	f8 01       	movw	r30, r16
    2732:	85 8d       	ldd	r24, Z+29	; 0x1d
    2734:	8f 3f       	cpi	r24, 0xFF	; 255
    2736:	09 f4       	brne	.+2      	; 0x273a <xQueueGenericSend+0xaa>
    2738:	15 8e       	std	Z+29, r1	; 0x1d
    273a:	f8 01       	movw	r30, r16
    273c:	86 8d       	ldd	r24, Z+30	; 0x1e
    273e:	8f 3f       	cpi	r24, 0xFF	; 255
    2740:	09 f4       	brne	.+2      	; 0x2744 <xQueueGenericSend+0xb4>
    2742:	16 8e       	std	Z+30, r1	; 0x1e
    2744:	0f 90       	pop	r0
    2746:	0f be       	out	0x3f, r0	; 63
    2748:	be 01       	movw	r22, r28
    274a:	6c 5f       	subi	r22, 0xFC	; 252
    274c:	7f 4f       	sbci	r23, 0xFF	; 255
    274e:	ce 01       	movw	r24, r28
    2750:	01 96       	adiw	r24, 0x01	; 1
    2752:	f9 d4       	rcall	.+2546   	; 0x3146 <xTaskCheckForTimeOut>
    2754:	81 11       	cpse	r24, r1
    2756:	19 c0       	rjmp	.+50     	; 0x278a <xQueueGenericSend+0xfa>
    2758:	0f b6       	in	r0, 0x3f	; 63
    275a:	f8 94       	cli
    275c:	0f 92       	push	r0
    275e:	f8 01       	movw	r30, r16
    2760:	92 8d       	ldd	r25, Z+26	; 0x1a
    2762:	0f 90       	pop	r0
    2764:	0f be       	out	0x3f, r0	; 63
    2766:	83 8d       	ldd	r24, Z+27	; 0x1b
    2768:	98 13       	cpse	r25, r24
    276a:	0b c0       	rjmp	.+22     	; 0x2782 <xQueueGenericSend+0xf2>
    276c:	6c 81       	ldd	r22, Y+4	; 0x04
    276e:	7d 81       	ldd	r23, Y+5	; 0x05
    2770:	c7 01       	movw	r24, r14
    2772:	88 d4       	rcall	.+2320   	; 0x3084 <vTaskPlaceOnEventList>
    2774:	c8 01       	movw	r24, r16
    2776:	e0 de       	rcall	.-576    	; 0x2538 <prvUnlockQueue>
    2778:	45 d3       	rcall	.+1674   	; 0x2e04 <xTaskResumeAll>
    277a:	81 11       	cpse	r24, r1
    277c:	a5 cf       	rjmp	.-182    	; 0x26c8 <xQueueGenericSend+0x38>
    277e:	b0 dd       	rcall	.-1184   	; 0x22e0 <vPortYield>
    2780:	a3 cf       	rjmp	.-186    	; 0x26c8 <xQueueGenericSend+0x38>
    2782:	c8 01       	movw	r24, r16
    2784:	d9 de       	rcall	.-590    	; 0x2538 <prvUnlockQueue>
    2786:	3e d3       	rcall	.+1660   	; 0x2e04 <xTaskResumeAll>
    2788:	9f cf       	rjmp	.-194    	; 0x26c8 <xQueueGenericSend+0x38>
    278a:	c8 01       	movw	r24, r16
    278c:	d5 de       	rcall	.-598    	; 0x2538 <prvUnlockQueue>
    278e:	3a d3       	rcall	.+1652   	; 0x2e04 <xTaskResumeAll>
    2790:	80 e0       	ldi	r24, 0x00	; 0
    2792:	0f 90       	pop	r0
    2794:	0f 90       	pop	r0
    2796:	0f 90       	pop	r0
    2798:	0f 90       	pop	r0
    279a:	0f 90       	pop	r0
    279c:	df 91       	pop	r29
    279e:	cf 91       	pop	r28
    27a0:	1f 91       	pop	r17
    27a2:	0f 91       	pop	r16
    27a4:	ff 90       	pop	r15
    27a6:	ef 90       	pop	r14
    27a8:	df 90       	pop	r13
    27aa:	cf 90       	pop	r12
    27ac:	bf 90       	pop	r11
    27ae:	af 90       	pop	r10
    27b0:	9f 90       	pop	r9
    27b2:	08 95       	ret

000027b4 <xQueueCreateMutex>:
    27b4:	cf 93       	push	r28
    27b6:	df 93       	push	r29
    27b8:	48 2f       	mov	r20, r24
    27ba:	60 e0       	ldi	r22, 0x00	; 0
    27bc:	81 e0       	ldi	r24, 0x01	; 1
    27be:	3e df       	rcall	.-388    	; 0x263c <xQueueGenericCreate>
    27c0:	ec 01       	movw	r28, r24
    27c2:	00 97       	sbiw	r24, 0x00	; 0
    27c4:	59 f0       	breq	.+22     	; 0x27dc <xQueueCreateMutex+0x28>
    27c6:	1b 82       	std	Y+3, r1	; 0x03
    27c8:	1a 82       	std	Y+2, r1	; 0x02
    27ca:	19 82       	std	Y+1, r1	; 0x01
    27cc:	18 82       	st	Y, r1
    27ce:	1e 82       	std	Y+6, r1	; 0x06
    27d0:	20 e0       	ldi	r18, 0x00	; 0
    27d2:	40 e0       	ldi	r20, 0x00	; 0
    27d4:	50 e0       	ldi	r21, 0x00	; 0
    27d6:	60 e0       	ldi	r22, 0x00	; 0
    27d8:	70 e0       	ldi	r23, 0x00	; 0
    27da:	5a df       	rcall	.-332    	; 0x2690 <xQueueGenericSend>
    27dc:	ce 01       	movw	r24, r28
    27de:	df 91       	pop	r29
    27e0:	cf 91       	pop	r28
    27e2:	08 95       	ret

000027e4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    27e4:	8f 92       	push	r8
    27e6:	9f 92       	push	r9
    27e8:	af 92       	push	r10
    27ea:	bf 92       	push	r11
    27ec:	cf 92       	push	r12
    27ee:	df 92       	push	r13
    27f0:	ef 92       	push	r14
    27f2:	ff 92       	push	r15
    27f4:	0f 93       	push	r16
    27f6:	1f 93       	push	r17
    27f8:	cf 93       	push	r28
    27fa:	df 93       	push	r29
    27fc:	00 d0       	rcall	.+0      	; 0x27fe <xQueueGenericReceive+0x1a>
    27fe:	00 d0       	rcall	.+0      	; 0x2800 <xQueueGenericReceive+0x1c>
    2800:	1f 92       	push	r1
    2802:	cd b7       	in	r28, 0x3d	; 61
    2804:	de b7       	in	r29, 0x3e	; 62
    2806:	8c 01       	movw	r16, r24
    2808:	5b 01       	movw	r10, r22
    280a:	5d 83       	std	Y+5, r21	; 0x05
    280c:	4c 83       	std	Y+4, r20	; 0x04
    280e:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2810:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2812:	99 24       	eor	r9, r9
    2814:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2816:	6c 01       	movw	r12, r24
    2818:	81 e1       	ldi	r24, 0x11	; 17
    281a:	c8 0e       	add	r12, r24
    281c:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    281e:	0f b6       	in	r0, 0x3f	; 63
    2820:	f8 94       	cli
    2822:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2824:	f8 01       	movw	r30, r16
    2826:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2828:	ff 20       	and	r15, r15
    282a:	61 f1       	breq	.+88     	; 0x2884 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    282c:	c6 80       	ldd	r12, Z+6	; 0x06
    282e:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2830:	b5 01       	movw	r22, r10
    2832:	c8 01       	movw	r24, r16
    2834:	67 de       	rcall	.-818    	; 0x2504 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2836:	81 10       	cpse	r8, r1
    2838:	16 c0       	rjmp	.+44     	; 0x2866 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    283a:	fa 94       	dec	r15
    283c:	f8 01       	movw	r30, r16
    283e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2840:	80 81       	ld	r24, Z
    2842:	91 81       	ldd	r25, Z+1	; 0x01
    2844:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2846:	21 f4       	brne	.+8      	; 0x2850 <xQueueGenericReceive+0x6c>
    2848:	5c d5       	rcall	.+2744   	; 0x3302 <pvTaskIncrementMutexHeldCount>
    284a:	f8 01       	movw	r30, r16
    284c:	93 83       	std	Z+3, r25	; 0x03
    284e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2850:	f8 01       	movw	r30, r16
    2852:	80 85       	ldd	r24, Z+8	; 0x08
    2854:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2856:	91 f0       	breq	.+36     	; 0x287c <xQueueGenericReceive+0x98>
    2858:	c8 01       	movw	r24, r16
    285a:	08 96       	adiw	r24, 0x08	; 8
    285c:	23 d4       	rcall	.+2118   	; 0x30a4 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    285e:	88 23       	and	r24, r24
    2860:	69 f0       	breq	.+26     	; 0x287c <xQueueGenericReceive+0x98>
    2862:	3e dd       	rcall	.-1412   	; 0x22e0 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2864:	0b c0       	rjmp	.+22     	; 0x287c <xQueueGenericReceive+0x98>
    2866:	f8 01       	movw	r30, r16
    2868:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    286a:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    286c:	81 89       	ldd	r24, Z+17	; 0x11
    286e:	88 23       	and	r24, r24
    2870:	29 f0       	breq	.+10     	; 0x287c <xQueueGenericReceive+0x98>
    2872:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2874:	41 96       	adiw	r24, 0x11	; 17
    2876:	16 d4       	rcall	.+2092   	; 0x30a4 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2878:	81 11       	cpse	r24, r1
    287a:	32 dd       	rcall	.-1436   	; 0x22e0 <vPortYield>
				return pdPASS;
    287c:	0f 90       	pop	r0
    287e:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2880:	81 e0       	ldi	r24, 0x01	; 1
    2882:	58 c0       	rjmp	.+176    	; 0x2934 <xQueueGenericReceive+0x150>
    2884:	8c 81       	ldd	r24, Y+4	; 0x04
    2886:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2888:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    288a:	21 f4       	brne	.+8      	; 0x2894 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    288c:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    288e:	0f be       	out	0x3f, r0	; 63
    2890:	80 e0       	ldi	r24, 0x00	; 0
    2892:	50 c0       	rjmp	.+160    	; 0x2934 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    2894:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2896:	04 c0       	rjmp	.+8      	; 0x28a0 <xQueueGenericReceive+0xbc>
    2898:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    289a:	01 96       	adiw	r24, 0x01	; 1
    289c:	49 d4       	rcall	.+2194   	; 0x3130 <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    289e:	e9 2c       	mov	r14, r9
    28a0:	0f 90       	pop	r0
    28a2:	0f be       	out	0x3f, r0	; 63
    28a4:	f2 d1       	rcall	.+996    	; 0x2c8a <vTaskSuspendAll>
    28a6:	0f b6       	in	r0, 0x3f	; 63
    28a8:	f8 94       	cli
    28aa:	0f 92       	push	r0
    28ac:	f8 01       	movw	r30, r16
    28ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    28b0:	8f 3f       	cpi	r24, 0xFF	; 255
    28b2:	09 f4       	brne	.+2      	; 0x28b6 <xQueueGenericReceive+0xd2>
    28b4:	15 8e       	std	Z+29, r1	; 0x1d
    28b6:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    28b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    28ba:	8f 3f       	cpi	r24, 0xFF	; 255
    28bc:	09 f4       	brne	.+2      	; 0x28c0 <xQueueGenericReceive+0xdc>
    28be:	16 8e       	std	Z+30, r1	; 0x1e
    28c0:	0f 90       	pop	r0
    28c2:	0f be       	out	0x3f, r0	; 63
    28c4:	be 01       	movw	r22, r28
    28c6:	6c 5f       	subi	r22, 0xFC	; 252
    28c8:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    28ca:	ce 01       	movw	r24, r28
    28cc:	01 96       	adiw	r24, 0x01	; 1
    28ce:	3b d4       	rcall	.+2166   	; 0x3146 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    28d0:	81 11       	cpse	r24, r1
    28d2:	24 c0       	rjmp	.+72     	; 0x291c <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    28d4:	0f b6       	in	r0, 0x3f	; 63
    28d6:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    28d8:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28da:	f8 01       	movw	r30, r16
    28dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    28de:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    28e0:	0f be       	out	0x3f, r0	; 63
    28e2:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    28e4:	17 c0       	rjmp	.+46     	; 0x2914 <xQueueGenericReceive+0x130>
    28e6:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    28e8:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    28ea:	89 2b       	or	r24, r25
    28ec:	41 f4       	brne	.+16     	; 0x28fe <xQueueGenericReceive+0x11a>
    28ee:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    28f0:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    28f2:	0f 92       	push	r0
    28f4:	82 81       	ldd	r24, Z+2	; 0x02
    28f6:	93 81       	ldd	r25, Z+3	; 0x03
    28f8:	62 d4       	rcall	.+2244   	; 0x31be <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    28fa:	0f 90       	pop	r0
    28fc:	0f be       	out	0x3f, r0	; 63
    28fe:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2900:	7d 81       	ldd	r23, Y+5	; 0x05
    2902:	c6 01       	movw	r24, r12
    2904:	bf d3       	rcall	.+1918   	; 0x3084 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    2906:	c8 01       	movw	r24, r16
    2908:	17 de       	rcall	.-978    	; 0x2538 <prvUnlockQueue>
    290a:	7c d2       	rcall	.+1272   	; 0x2e04 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    290c:	81 11       	cpse	r24, r1
    290e:	87 cf       	rjmp	.-242    	; 0x281e <xQueueGenericReceive+0x3a>
    2910:	e7 dc       	rcall	.-1586   	; 0x22e0 <vPortYield>
			( void ) xTaskResumeAll();
    2912:	85 cf       	rjmp	.-246    	; 0x281e <xQueueGenericReceive+0x3a>
    2914:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2916:	10 de       	rcall	.-992    	; 0x2538 <prvUnlockQueue>
    2918:	75 d2       	rcall	.+1258   	; 0x2e04 <xTaskResumeAll>
    291a:	81 cf       	rjmp	.-254    	; 0x281e <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    291c:	c8 01       	movw	r24, r16
    291e:	0c de       	rcall	.-1000   	; 0x2538 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2920:	71 d2       	rcall	.+1250   	; 0x2e04 <xTaskResumeAll>
    2922:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2924:	f8 94       	cli
    2926:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    2928:	f8 01       	movw	r30, r16
    292a:	82 8d       	ldd	r24, Z+26	; 0x1a
    292c:	0f 90       	pop	r0
    292e:	0f be       	out	0x3f, r0	; 63
    2930:	81 11       	cpse	r24, r1
    2932:	75 cf       	rjmp	.-278    	; 0x281e <xQueueGenericReceive+0x3a>
    2934:	0f 90       	pop	r0
    2936:	0f 90       	pop	r0
    2938:	0f 90       	pop	r0
    293a:	0f 90       	pop	r0
    293c:	0f 90       	pop	r0
    293e:	df 91       	pop	r29
    2940:	cf 91       	pop	r28
    2942:	1f 91       	pop	r17
    2944:	0f 91       	pop	r16
    2946:	ff 90       	pop	r15
    2948:	ef 90       	pop	r14
    294a:	df 90       	pop	r13
    294c:	cf 90       	pop	r12
    294e:	bf 90       	pop	r11
    2950:	af 90       	pop	r10
    2952:	9f 90       	pop	r9
    2954:	8f 90       	pop	r8
    2956:	08 95       	ret

00002958 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    2958:	e0 91 b4 0c 	lds	r30, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    295c:	f0 91 b5 0c 	lds	r31, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    2960:	80 81       	ld	r24, Z
    2962:	81 11       	cpse	r24, r1
    2964:	07 c0       	rjmp	.+14     	; 0x2974 <prvResetNextTaskUnblockTime+0x1c>
    2966:	8f ef       	ldi	r24, 0xFF	; 255
    2968:	9f ef       	ldi	r25, 0xFF	; 255
    296a:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <xNextTaskUnblockTime+0x1>
    296e:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <xNextTaskUnblockTime>
    2972:	08 95       	ret
    2974:	e0 91 b4 0c 	lds	r30, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    2978:	f0 91 b5 0c 	lds	r31, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    297c:	05 80       	ldd	r0, Z+5	; 0x05
    297e:	f6 81       	ldd	r31, Z+6	; 0x06
    2980:	e0 2d       	mov	r30, r0
    2982:	06 80       	ldd	r0, Z+6	; 0x06
    2984:	f7 81       	ldd	r31, Z+7	; 0x07
    2986:	e0 2d       	mov	r30, r0
    2988:	82 81       	ldd	r24, Z+2	; 0x02
    298a:	93 81       	ldd	r25, Z+3	; 0x03
    298c:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2990:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <xNextTaskUnblockTime>
    2994:	08 95       	ret

00002996 <prvAddCurrentTaskToDelayedList>:
    2996:	ff 92       	push	r15
    2998:	0f 93       	push	r16
    299a:	1f 93       	push	r17
    299c:	cf 93       	push	r28
    299e:	df 93       	push	r29
    29a0:	ec 01       	movw	r28, r24
    29a2:	f6 2e       	mov	r15, r22
    29a4:	00 91 93 0c 	lds	r16, 0x0C93	; 0x800c93 <xTickCount>
    29a8:	10 91 94 0c 	lds	r17, 0x0C94	; 0x800c94 <xTickCount+0x1>
    29ac:	80 91 ec 0c 	lds	r24, 0x0CEC	; 0x800cec <pxCurrentTCB>
    29b0:	90 91 ed 0c 	lds	r25, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    29b4:	02 96       	adiw	r24, 0x02	; 2
    29b6:	cd db       	rcall	.-2150   	; 0x2152 <uxListRemove>
    29b8:	cf 3f       	cpi	r28, 0xFF	; 255
    29ba:	8f ef       	ldi	r24, 0xFF	; 255
    29bc:	d8 07       	cpc	r29, r24
    29be:	61 f4       	brne	.+24     	; 0x29d8 <prvAddCurrentTaskToDelayedList+0x42>
    29c0:	ff 20       	and	r15, r15
    29c2:	51 f0       	breq	.+20     	; 0x29d8 <prvAddCurrentTaskToDelayedList+0x42>
    29c4:	60 91 ec 0c 	lds	r22, 0x0CEC	; 0x800cec <pxCurrentTCB>
    29c8:	70 91 ed 0c 	lds	r23, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    29cc:	6e 5f       	subi	r22, 0xFE	; 254
    29ce:	7f 4f       	sbci	r23, 0xFF	; 255
    29d0:	86 e9       	ldi	r24, 0x96	; 150
    29d2:	9c e0       	ldi	r25, 0x0C	; 12
    29d4:	6c db       	rcall	.-2344   	; 0x20ae <vListInsertEnd>
    29d6:	2d c0       	rjmp	.+90     	; 0x2a32 <prvAddCurrentTaskToDelayedList+0x9c>
    29d8:	c0 0f       	add	r28, r16
    29da:	d1 1f       	adc	r29, r17
    29dc:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    29e0:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    29e4:	d3 83       	std	Z+3, r29	; 0x03
    29e6:	c2 83       	std	Z+2, r28	; 0x02
    29e8:	c0 17       	cp	r28, r16
    29ea:	d1 07       	cpc	r29, r17
    29ec:	60 f4       	brcc	.+24     	; 0x2a06 <prvAddCurrentTaskToDelayedList+0x70>
    29ee:	60 91 ec 0c 	lds	r22, 0x0CEC	; 0x800cec <pxCurrentTCB>
    29f2:	70 91 ed 0c 	lds	r23, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    29f6:	80 91 b2 0c 	lds	r24, 0x0CB2	; 0x800cb2 <pxOverflowDelayedTaskList>
    29fa:	90 91 b3 0c 	lds	r25, 0x0CB3	; 0x800cb3 <pxOverflowDelayedTaskList+0x1>
    29fe:	6e 5f       	subi	r22, 0xFE	; 254
    2a00:	7f 4f       	sbci	r23, 0xFF	; 255
    2a02:	76 db       	rcall	.-2324   	; 0x20f0 <vListInsert>
    2a04:	16 c0       	rjmp	.+44     	; 0x2a32 <prvAddCurrentTaskToDelayedList+0x9c>
    2a06:	60 91 ec 0c 	lds	r22, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2a0a:	70 91 ed 0c 	lds	r23, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2a0e:	80 91 b4 0c 	lds	r24, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    2a12:	90 91 b5 0c 	lds	r25, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    2a16:	6e 5f       	subi	r22, 0xFE	; 254
    2a18:	7f 4f       	sbci	r23, 0xFF	; 255
    2a1a:	6a db       	rcall	.-2348   	; 0x20f0 <vListInsert>
    2a1c:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <xNextTaskUnblockTime>
    2a20:	90 91 8c 0c 	lds	r25, 0x0C8C	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2a24:	c8 17       	cp	r28, r24
    2a26:	d9 07       	cpc	r29, r25
    2a28:	20 f4       	brcc	.+8      	; 0x2a32 <prvAddCurrentTaskToDelayedList+0x9c>
    2a2a:	d0 93 8c 0c 	sts	0x0C8C, r29	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2a2e:	c0 93 8b 0c 	sts	0x0C8B, r28	; 0x800c8b <xNextTaskUnblockTime>
    2a32:	df 91       	pop	r29
    2a34:	cf 91       	pop	r28
    2a36:	1f 91       	pop	r17
    2a38:	0f 91       	pop	r16
    2a3a:	ff 90       	pop	r15
    2a3c:	08 95       	ret

00002a3e <xTaskCreate>:
    2a3e:	4f 92       	push	r4
    2a40:	5f 92       	push	r5
    2a42:	6f 92       	push	r6
    2a44:	7f 92       	push	r7
    2a46:	8f 92       	push	r8
    2a48:	9f 92       	push	r9
    2a4a:	af 92       	push	r10
    2a4c:	bf 92       	push	r11
    2a4e:	cf 92       	push	r12
    2a50:	df 92       	push	r13
    2a52:	ef 92       	push	r14
    2a54:	ff 92       	push	r15
    2a56:	0f 93       	push	r16
    2a58:	cf 93       	push	r28
    2a5a:	df 93       	push	r29
    2a5c:	4c 01       	movw	r8, r24
    2a5e:	6b 01       	movw	r12, r22
    2a60:	5a 01       	movw	r10, r20
    2a62:	29 01       	movw	r4, r18
    2a64:	ca 01       	movw	r24, r20
    2a66:	dd da       	rcall	.-2630   	; 0x2022 <pvPortMalloc>
    2a68:	3c 01       	movw	r6, r24
    2a6a:	89 2b       	or	r24, r25
    2a6c:	09 f4       	brne	.+2      	; 0x2a70 <xTaskCreate+0x32>
    2a6e:	d4 c0       	rjmp	.+424    	; 0x2c18 <xTaskCreate+0x1da>
    2a70:	88 e2       	ldi	r24, 0x28	; 40
    2a72:	90 e0       	ldi	r25, 0x00	; 0
    2a74:	d6 da       	rcall	.-2644   	; 0x2022 <pvPortMalloc>
    2a76:	ec 01       	movw	r28, r24
    2a78:	89 2b       	or	r24, r25
    2a7a:	71 f0       	breq	.+28     	; 0x2a98 <xTaskCreate+0x5a>
    2a7c:	78 8e       	std	Y+24, r7	; 0x18
    2a7e:	6f 8a       	std	Y+23, r6	; 0x17
    2a80:	81 e0       	ldi	r24, 0x01	; 1
    2a82:	a8 1a       	sub	r10, r24
    2a84:	b1 08       	sbc	r11, r1
    2a86:	6a 0c       	add	r6, r10
    2a88:	7b 1c       	adc	r7, r11
    2a8a:	d6 01       	movw	r26, r12
    2a8c:	8c 91       	ld	r24, X
    2a8e:	89 8f       	std	Y+25, r24	; 0x19
    2a90:	8c 91       	ld	r24, X
    2a92:	81 11       	cpse	r24, r1
    2a94:	04 c0       	rjmp	.+8      	; 0x2a9e <xTaskCreate+0x60>
    2a96:	17 c0       	rjmp	.+46     	; 0x2ac6 <xTaskCreate+0x88>
    2a98:	c3 01       	movw	r24, r6
    2a9a:	f6 da       	rcall	.-2580   	; 0x2088 <vPortFree>
    2a9c:	bd c0       	rjmp	.+378    	; 0x2c18 <xTaskCreate+0x1da>
    2a9e:	ae 01       	movw	r20, r28
    2aa0:	46 5e       	subi	r20, 0xE6	; 230
    2aa2:	5f 4f       	sbci	r21, 0xFF	; 255
    2aa4:	f6 01       	movw	r30, r12
    2aa6:	31 96       	adiw	r30, 0x01	; 1
    2aa8:	b8 e0       	ldi	r27, 0x08	; 8
    2aaa:	cb 0e       	add	r12, r27
    2aac:	d1 1c       	adc	r13, r1
    2aae:	cf 01       	movw	r24, r30
    2ab0:	21 91       	ld	r18, Z+
    2ab2:	da 01       	movw	r26, r20
    2ab4:	2d 93       	st	X+, r18
    2ab6:	ad 01       	movw	r20, r26
    2ab8:	dc 01       	movw	r26, r24
    2aba:	8c 91       	ld	r24, X
    2abc:	88 23       	and	r24, r24
    2abe:	19 f0       	breq	.+6      	; 0x2ac6 <xTaskCreate+0x88>
    2ac0:	ec 15       	cp	r30, r12
    2ac2:	fd 05       	cpc	r31, r13
    2ac4:	a1 f7       	brne	.-24     	; 0x2aae <xTaskCreate+0x70>
    2ac6:	18 a2       	std	Y+32, r1	; 0x20
    2ac8:	04 30       	cpi	r16, 0x04	; 4
    2aca:	08 f0       	brcs	.+2      	; 0x2ace <xTaskCreate+0x90>
    2acc:	03 e0       	ldi	r16, 0x03	; 3
    2ace:	0e 8b       	std	Y+22, r16	; 0x16
    2ad0:	09 a3       	std	Y+33, r16	; 0x21
    2ad2:	1a a2       	std	Y+34, r1	; 0x22
    2ad4:	6e 01       	movw	r12, r28
    2ad6:	b2 e0       	ldi	r27, 0x02	; 2
    2ad8:	cb 0e       	add	r12, r27
    2ada:	d1 1c       	adc	r13, r1
    2adc:	c6 01       	movw	r24, r12
    2ade:	e3 da       	rcall	.-2618   	; 0x20a6 <vListInitialiseItem>
    2ae0:	ce 01       	movw	r24, r28
    2ae2:	0c 96       	adiw	r24, 0x0c	; 12
    2ae4:	e0 da       	rcall	.-2624   	; 0x20a6 <vListInitialiseItem>
    2ae6:	d9 87       	std	Y+9, r29	; 0x09
    2ae8:	c8 87       	std	Y+8, r28	; 0x08
    2aea:	84 e0       	ldi	r24, 0x04	; 4
    2aec:	90 e0       	ldi	r25, 0x00	; 0
    2aee:	80 1b       	sub	r24, r16
    2af0:	91 09       	sbc	r25, r1
    2af2:	9d 87       	std	Y+13, r25	; 0x0d
    2af4:	8c 87       	std	Y+12, r24	; 0x0c
    2af6:	db 8b       	std	Y+19, r29	; 0x13
    2af8:	ca 8b       	std	Y+18, r28	; 0x12
    2afa:	1b a2       	std	Y+35, r1	; 0x23
    2afc:	1c a2       	std	Y+36, r1	; 0x24
    2afe:	1d a2       	std	Y+37, r1	; 0x25
    2b00:	1e a2       	std	Y+38, r1	; 0x26
    2b02:	1f a2       	std	Y+39, r1	; 0x27
    2b04:	a2 01       	movw	r20, r4
    2b06:	b4 01       	movw	r22, r8
    2b08:	c3 01       	movw	r24, r6
    2b0a:	49 db       	rcall	.-2414   	; 0x219e <pxPortInitialiseStack>
    2b0c:	99 83       	std	Y+1, r25	; 0x01
    2b0e:	88 83       	st	Y, r24
    2b10:	e1 14       	cp	r14, r1
    2b12:	f1 04       	cpc	r15, r1
    2b14:	19 f0       	breq	.+6      	; 0x2b1c <xTaskCreate+0xde>
    2b16:	f7 01       	movw	r30, r14
    2b18:	d1 83       	std	Z+1, r29	; 0x01
    2b1a:	c0 83       	st	Z, r28
    2b1c:	0f b6       	in	r0, 0x3f	; 63
    2b1e:	f8 94       	cli
    2b20:	0f 92       	push	r0
    2b22:	80 91 95 0c 	lds	r24, 0x0C95	; 0x800c95 <uxCurrentNumberOfTasks>
    2b26:	8f 5f       	subi	r24, 0xFF	; 255
    2b28:	80 93 95 0c 	sts	0x0C95, r24	; 0x800c95 <uxCurrentNumberOfTasks>
    2b2c:	80 91 ec 0c 	lds	r24, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2b30:	90 91 ed 0c 	lds	r25, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2b34:	89 2b       	or	r24, r25
    2b36:	89 f5       	brne	.+98     	; 0x2b9a <xTaskCreate+0x15c>
    2b38:	d0 93 ed 0c 	sts	0x0CED, r29	; 0x800ced <pxCurrentTCB+0x1>
    2b3c:	c0 93 ec 0c 	sts	0x0CEC, r28	; 0x800cec <pxCurrentTCB>
    2b40:	80 91 95 0c 	lds	r24, 0x0C95	; 0x800c95 <uxCurrentNumberOfTasks>
    2b44:	81 30       	cpi	r24, 0x01	; 1
    2b46:	09 f0       	breq	.+2      	; 0x2b4a <xTaskCreate+0x10c>
    2b48:	38 c0       	rjmp	.+112    	; 0x2bba <xTaskCreate+0x17c>
    2b4a:	88 ec       	ldi	r24, 0xC8	; 200
    2b4c:	9c e0       	ldi	r25, 0x0C	; 12
    2b4e:	9d da       	rcall	.-2758   	; 0x208a <vListInitialise>
    2b50:	81 ed       	ldi	r24, 0xD1	; 209
    2b52:	9c e0       	ldi	r25, 0x0C	; 12
    2b54:	9a da       	rcall	.-2764   	; 0x208a <vListInitialise>
    2b56:	8a ed       	ldi	r24, 0xDA	; 218
    2b58:	9c e0       	ldi	r25, 0x0C	; 12
    2b5a:	97 da       	rcall	.-2770   	; 0x208a <vListInitialise>
    2b5c:	83 ee       	ldi	r24, 0xE3	; 227
    2b5e:	9c e0       	ldi	r25, 0x0C	; 12
    2b60:	94 da       	rcall	.-2776   	; 0x208a <vListInitialise>
    2b62:	8f eb       	ldi	r24, 0xBF	; 191
    2b64:	9c e0       	ldi	r25, 0x0C	; 12
    2b66:	91 da       	rcall	.-2782   	; 0x208a <vListInitialise>
    2b68:	86 eb       	ldi	r24, 0xB6	; 182
    2b6a:	9c e0       	ldi	r25, 0x0C	; 12
    2b6c:	8e da       	rcall	.-2788   	; 0x208a <vListInitialise>
    2b6e:	89 ea       	ldi	r24, 0xA9	; 169
    2b70:	9c e0       	ldi	r25, 0x0C	; 12
    2b72:	8b da       	rcall	.-2794   	; 0x208a <vListInitialise>
    2b74:	80 ea       	ldi	r24, 0xA0	; 160
    2b76:	9c e0       	ldi	r25, 0x0C	; 12
    2b78:	88 da       	rcall	.-2800   	; 0x208a <vListInitialise>
    2b7a:	86 e9       	ldi	r24, 0x96	; 150
    2b7c:	9c e0       	ldi	r25, 0x0C	; 12
    2b7e:	85 da       	rcall	.-2806   	; 0x208a <vListInitialise>
    2b80:	8f eb       	ldi	r24, 0xBF	; 191
    2b82:	9c e0       	ldi	r25, 0x0C	; 12
    2b84:	90 93 b5 0c 	sts	0x0CB5, r25	; 0x800cb5 <pxDelayedTaskList+0x1>
    2b88:	80 93 b4 0c 	sts	0x0CB4, r24	; 0x800cb4 <pxDelayedTaskList>
    2b8c:	86 eb       	ldi	r24, 0xB6	; 182
    2b8e:	9c e0       	ldi	r25, 0x0C	; 12
    2b90:	90 93 b3 0c 	sts	0x0CB3, r25	; 0x800cb3 <pxOverflowDelayedTaskList+0x1>
    2b94:	80 93 b2 0c 	sts	0x0CB2, r24	; 0x800cb2 <pxOverflowDelayedTaskList>
    2b98:	10 c0       	rjmp	.+32     	; 0x2bba <xTaskCreate+0x17c>
    2b9a:	80 91 91 0c 	lds	r24, 0x0C91	; 0x800c91 <xSchedulerRunning>
    2b9e:	81 11       	cpse	r24, r1
    2ba0:	0c c0       	rjmp	.+24     	; 0x2bba <xTaskCreate+0x17c>
    2ba2:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2ba6:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2baa:	96 89       	ldd	r25, Z+22	; 0x16
    2bac:	8e 89       	ldd	r24, Y+22	; 0x16
    2bae:	89 17       	cp	r24, r25
    2bb0:	20 f0       	brcs	.+8      	; 0x2bba <xTaskCreate+0x17c>
    2bb2:	d0 93 ed 0c 	sts	0x0CED, r29	; 0x800ced <pxCurrentTCB+0x1>
    2bb6:	c0 93 ec 0c 	sts	0x0CEC, r28	; 0x800cec <pxCurrentTCB>
    2bba:	80 91 8d 0c 	lds	r24, 0x0C8D	; 0x800c8d <uxTaskNumber>
    2bbe:	8f 5f       	subi	r24, 0xFF	; 255
    2bc0:	80 93 8d 0c 	sts	0x0C8D, r24	; 0x800c8d <uxTaskNumber>
    2bc4:	8e 89       	ldd	r24, Y+22	; 0x16
    2bc6:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    2bca:	98 17       	cp	r25, r24
    2bcc:	10 f4       	brcc	.+4      	; 0x2bd2 <xTaskCreate+0x194>
    2bce:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	9c 01       	movw	r18, r24
    2bd6:	22 0f       	add	r18, r18
    2bd8:	33 1f       	adc	r19, r19
    2bda:	22 0f       	add	r18, r18
    2bdc:	33 1f       	adc	r19, r19
    2bde:	22 0f       	add	r18, r18
    2be0:	33 1f       	adc	r19, r19
    2be2:	82 0f       	add	r24, r18
    2be4:	93 1f       	adc	r25, r19
    2be6:	b6 01       	movw	r22, r12
    2be8:	88 53       	subi	r24, 0x38	; 56
    2bea:	93 4f       	sbci	r25, 0xF3	; 243
    2bec:	60 da       	rcall	.-2880   	; 0x20ae <vListInsertEnd>
    2bee:	0f 90       	pop	r0
    2bf0:	0f be       	out	0x3f, r0	; 63
    2bf2:	80 91 91 0c 	lds	r24, 0x0C91	; 0x800c91 <xSchedulerRunning>
    2bf6:	88 23       	and	r24, r24
    2bf8:	59 f0       	breq	.+22     	; 0x2c10 <xTaskCreate+0x1d2>
    2bfa:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2bfe:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2c02:	96 89       	ldd	r25, Z+22	; 0x16
    2c04:	8e 89       	ldd	r24, Y+22	; 0x16
    2c06:	98 17       	cp	r25, r24
    2c08:	28 f4       	brcc	.+10     	; 0x2c14 <xTaskCreate+0x1d6>
    2c0a:	6a db       	rcall	.-2348   	; 0x22e0 <vPortYield>
    2c0c:	81 e0       	ldi	r24, 0x01	; 1
    2c0e:	05 c0       	rjmp	.+10     	; 0x2c1a <xTaskCreate+0x1dc>
    2c10:	81 e0       	ldi	r24, 0x01	; 1
    2c12:	03 c0       	rjmp	.+6      	; 0x2c1a <xTaskCreate+0x1dc>
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	01 c0       	rjmp	.+2      	; 0x2c1a <xTaskCreate+0x1dc>
    2c18:	8f ef       	ldi	r24, 0xFF	; 255
    2c1a:	df 91       	pop	r29
    2c1c:	cf 91       	pop	r28
    2c1e:	0f 91       	pop	r16
    2c20:	ff 90       	pop	r15
    2c22:	ef 90       	pop	r14
    2c24:	df 90       	pop	r13
    2c26:	cf 90       	pop	r12
    2c28:	bf 90       	pop	r11
    2c2a:	af 90       	pop	r10
    2c2c:	9f 90       	pop	r9
    2c2e:	8f 90       	pop	r8
    2c30:	7f 90       	pop	r7
    2c32:	6f 90       	pop	r6
    2c34:	5f 90       	pop	r5
    2c36:	4f 90       	pop	r4
    2c38:	08 95       	ret

00002c3a <vTaskStartScheduler>:
    2c3a:	ef 92       	push	r14
    2c3c:	ff 92       	push	r15
    2c3e:	0f 93       	push	r16
    2c40:	0f 2e       	mov	r0, r31
    2c42:	f9 e8       	ldi	r31, 0x89	; 137
    2c44:	ef 2e       	mov	r14, r31
    2c46:	fc e0       	ldi	r31, 0x0C	; 12
    2c48:	ff 2e       	mov	r15, r31
    2c4a:	f0 2d       	mov	r31, r0
    2c4c:	00 e0       	ldi	r16, 0x00	; 0
    2c4e:	20 e0       	ldi	r18, 0x00	; 0
    2c50:	30 e0       	ldi	r19, 0x00	; 0
    2c52:	45 e5       	ldi	r20, 0x55	; 85
    2c54:	50 e0       	ldi	r21, 0x00	; 0
    2c56:	6b ee       	ldi	r22, 0xEB	; 235
    2c58:	71 e0       	ldi	r23, 0x01	; 1
    2c5a:	8b e8       	ldi	r24, 0x8B	; 139
    2c5c:	97 e1       	ldi	r25, 0x17	; 23
    2c5e:	ef de       	rcall	.-546    	; 0x2a3e <xTaskCreate>
    2c60:	81 30       	cpi	r24, 0x01	; 1
    2c62:	79 f4       	brne	.+30     	; 0x2c82 <vTaskStartScheduler+0x48>
    2c64:	f8 94       	cli
    2c66:	8f ef       	ldi	r24, 0xFF	; 255
    2c68:	9f ef       	ldi	r25, 0xFF	; 255
    2c6a:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2c6e:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <xNextTaskUnblockTime>
    2c72:	81 e0       	ldi	r24, 0x01	; 1
    2c74:	80 93 91 0c 	sts	0x0C91, r24	; 0x800c91 <xSchedulerRunning>
    2c78:	10 92 94 0c 	sts	0x0C94, r1	; 0x800c94 <xTickCount+0x1>
    2c7c:	10 92 93 0c 	sts	0x0C93, r1	; 0x800c93 <xTickCount>
    2c80:	fa da       	rcall	.-2572   	; 0x2276 <xPortStartScheduler>
    2c82:	0f 91       	pop	r16
    2c84:	ff 90       	pop	r15
    2c86:	ef 90       	pop	r14
    2c88:	08 95       	ret

00002c8a <vTaskSuspendAll>:
    2c8a:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    2c8e:	8f 5f       	subi	r24, 0xFF	; 255
    2c90:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <uxSchedulerSuspended>
    2c94:	08 95       	ret

00002c96 <xTaskIncrementTick>:
    2c96:	cf 92       	push	r12
    2c98:	df 92       	push	r13
    2c9a:	ef 92       	push	r14
    2c9c:	ff 92       	push	r15
    2c9e:	0f 93       	push	r16
    2ca0:	1f 93       	push	r17
    2ca2:	cf 93       	push	r28
    2ca4:	df 93       	push	r29
    2ca6:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    2caa:	81 11       	cpse	r24, r1
    2cac:	95 c0       	rjmp	.+298    	; 0x2dd8 <xTaskIncrementTick+0x142>
    2cae:	e0 90 93 0c 	lds	r14, 0x0C93	; 0x800c93 <xTickCount>
    2cb2:	f0 90 94 0c 	lds	r15, 0x0C94	; 0x800c94 <xTickCount+0x1>
    2cb6:	8f ef       	ldi	r24, 0xFF	; 255
    2cb8:	e8 1a       	sub	r14, r24
    2cba:	f8 0a       	sbc	r15, r24
    2cbc:	f0 92 94 0c 	sts	0x0C94, r15	; 0x800c94 <xTickCount+0x1>
    2cc0:	e0 92 93 0c 	sts	0x0C93, r14	; 0x800c93 <xTickCount>
    2cc4:	e1 14       	cp	r14, r1
    2cc6:	f1 04       	cpc	r15, r1
    2cc8:	b1 f4       	brne	.+44     	; 0x2cf6 <xTaskIncrementTick+0x60>
    2cca:	80 91 b4 0c 	lds	r24, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    2cce:	90 91 b5 0c 	lds	r25, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    2cd2:	20 91 b2 0c 	lds	r18, 0x0CB2	; 0x800cb2 <pxOverflowDelayedTaskList>
    2cd6:	30 91 b3 0c 	lds	r19, 0x0CB3	; 0x800cb3 <pxOverflowDelayedTaskList+0x1>
    2cda:	30 93 b5 0c 	sts	0x0CB5, r19	; 0x800cb5 <pxDelayedTaskList+0x1>
    2cde:	20 93 b4 0c 	sts	0x0CB4, r18	; 0x800cb4 <pxDelayedTaskList>
    2ce2:	90 93 b3 0c 	sts	0x0CB3, r25	; 0x800cb3 <pxOverflowDelayedTaskList+0x1>
    2ce6:	80 93 b2 0c 	sts	0x0CB2, r24	; 0x800cb2 <pxOverflowDelayedTaskList>
    2cea:	80 91 8e 0c 	lds	r24, 0x0C8E	; 0x800c8e <xNumOfOverflows>
    2cee:	8f 5f       	subi	r24, 0xFF	; 255
    2cf0:	80 93 8e 0c 	sts	0x0C8E, r24	; 0x800c8e <xNumOfOverflows>
    2cf4:	31 de       	rcall	.-926    	; 0x2958 <prvResetNextTaskUnblockTime>
    2cf6:	80 91 8b 0c 	lds	r24, 0x0C8B	; 0x800c8b <xNextTaskUnblockTime>
    2cfa:	90 91 8c 0c 	lds	r25, 0x0C8C	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2cfe:	e8 16       	cp	r14, r24
    2d00:	f9 06       	cpc	r15, r25
    2d02:	10 f4       	brcc	.+4      	; 0x2d08 <xTaskIncrementTick+0x72>
    2d04:	d1 2c       	mov	r13, r1
    2d06:	50 c0       	rjmp	.+160    	; 0x2da8 <xTaskIncrementTick+0x112>
    2d08:	d1 2c       	mov	r13, r1
    2d0a:	cc 24       	eor	r12, r12
    2d0c:	c3 94       	inc	r12
    2d0e:	e0 91 b4 0c 	lds	r30, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    2d12:	f0 91 b5 0c 	lds	r31, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    2d16:	80 81       	ld	r24, Z
    2d18:	81 11       	cpse	r24, r1
    2d1a:	07 c0       	rjmp	.+14     	; 0x2d2a <xTaskIncrementTick+0x94>
    2d1c:	8f ef       	ldi	r24, 0xFF	; 255
    2d1e:	9f ef       	ldi	r25, 0xFF	; 255
    2d20:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2d24:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <xNextTaskUnblockTime>
    2d28:	3f c0       	rjmp	.+126    	; 0x2da8 <xTaskIncrementTick+0x112>
    2d2a:	e0 91 b4 0c 	lds	r30, 0x0CB4	; 0x800cb4 <pxDelayedTaskList>
    2d2e:	f0 91 b5 0c 	lds	r31, 0x0CB5	; 0x800cb5 <pxDelayedTaskList+0x1>
    2d32:	05 80       	ldd	r0, Z+5	; 0x05
    2d34:	f6 81       	ldd	r31, Z+6	; 0x06
    2d36:	e0 2d       	mov	r30, r0
    2d38:	c6 81       	ldd	r28, Z+6	; 0x06
    2d3a:	d7 81       	ldd	r29, Z+7	; 0x07
    2d3c:	8a 81       	ldd	r24, Y+2	; 0x02
    2d3e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d40:	e8 16       	cp	r14, r24
    2d42:	f9 06       	cpc	r15, r25
    2d44:	28 f4       	brcc	.+10     	; 0x2d50 <xTaskIncrementTick+0xba>
    2d46:	90 93 8c 0c 	sts	0x0C8C, r25	; 0x800c8c <xNextTaskUnblockTime+0x1>
    2d4a:	80 93 8b 0c 	sts	0x0C8B, r24	; 0x800c8b <xNextTaskUnblockTime>
    2d4e:	2c c0       	rjmp	.+88     	; 0x2da8 <xTaskIncrementTick+0x112>
    2d50:	8e 01       	movw	r16, r28
    2d52:	0e 5f       	subi	r16, 0xFE	; 254
    2d54:	1f 4f       	sbci	r17, 0xFF	; 255
    2d56:	c8 01       	movw	r24, r16
    2d58:	fc d9       	rcall	.-3080   	; 0x2152 <uxListRemove>
    2d5a:	8c 89       	ldd	r24, Y+20	; 0x14
    2d5c:	9d 89       	ldd	r25, Y+21	; 0x15
    2d5e:	89 2b       	or	r24, r25
    2d60:	19 f0       	breq	.+6      	; 0x2d68 <xTaskIncrementTick+0xd2>
    2d62:	ce 01       	movw	r24, r28
    2d64:	0c 96       	adiw	r24, 0x0c	; 12
    2d66:	f5 d9       	rcall	.-3094   	; 0x2152 <uxListRemove>
    2d68:	8e 89       	ldd	r24, Y+22	; 0x16
    2d6a:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    2d6e:	98 17       	cp	r25, r24
    2d70:	10 f4       	brcc	.+4      	; 0x2d76 <xTaskIncrementTick+0xe0>
    2d72:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	9c 01       	movw	r18, r24
    2d7a:	22 0f       	add	r18, r18
    2d7c:	33 1f       	adc	r19, r19
    2d7e:	22 0f       	add	r18, r18
    2d80:	33 1f       	adc	r19, r19
    2d82:	22 0f       	add	r18, r18
    2d84:	33 1f       	adc	r19, r19
    2d86:	82 0f       	add	r24, r18
    2d88:	93 1f       	adc	r25, r19
    2d8a:	b8 01       	movw	r22, r16
    2d8c:	88 53       	subi	r24, 0x38	; 56
    2d8e:	93 4f       	sbci	r25, 0xF3	; 243
    2d90:	8e d9       	rcall	.-3300   	; 0x20ae <vListInsertEnd>
    2d92:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2d96:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2d9a:	9e 89       	ldd	r25, Y+22	; 0x16
    2d9c:	86 89       	ldd	r24, Z+22	; 0x16
    2d9e:	98 17       	cp	r25, r24
    2da0:	08 f4       	brcc	.+2      	; 0x2da4 <xTaskIncrementTick+0x10e>
    2da2:	b5 cf       	rjmp	.-150    	; 0x2d0e <xTaskIncrementTick+0x78>
    2da4:	dc 2c       	mov	r13, r12
    2da6:	b3 cf       	rjmp	.-154    	; 0x2d0e <xTaskIncrementTick+0x78>
    2da8:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2dac:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2db0:	86 89       	ldd	r24, Z+22	; 0x16
    2db2:	90 e0       	ldi	r25, 0x00	; 0
    2db4:	fc 01       	movw	r30, r24
    2db6:	ee 0f       	add	r30, r30
    2db8:	ff 1f       	adc	r31, r31
    2dba:	ee 0f       	add	r30, r30
    2dbc:	ff 1f       	adc	r31, r31
    2dbe:	ee 0f       	add	r30, r30
    2dc0:	ff 1f       	adc	r31, r31
    2dc2:	8e 0f       	add	r24, r30
    2dc4:	9f 1f       	adc	r25, r31
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	e8 53       	subi	r30, 0x38	; 56
    2dca:	f3 4f       	sbci	r31, 0xF3	; 243
    2dcc:	80 81       	ld	r24, Z
    2dce:	82 30       	cpi	r24, 0x02	; 2
    2dd0:	48 f0       	brcs	.+18     	; 0x2de4 <xTaskIncrementTick+0x14e>
    2dd2:	dd 24       	eor	r13, r13
    2dd4:	d3 94       	inc	r13
    2dd6:	06 c0       	rjmp	.+12     	; 0x2de4 <xTaskIncrementTick+0x14e>
    2dd8:	80 91 90 0c 	lds	r24, 0x0C90	; 0x800c90 <uxPendedTicks>
    2ddc:	8f 5f       	subi	r24, 0xFF	; 255
    2dde:	80 93 90 0c 	sts	0x0C90, r24	; 0x800c90 <uxPendedTicks>
    2de2:	d1 2c       	mov	r13, r1
    2de4:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <xYieldPending>
    2de8:	88 23       	and	r24, r24
    2dea:	11 f0       	breq	.+4      	; 0x2df0 <xTaskIncrementTick+0x15a>
    2dec:	dd 24       	eor	r13, r13
    2dee:	d3 94       	inc	r13
    2df0:	8d 2d       	mov	r24, r13
    2df2:	df 91       	pop	r29
    2df4:	cf 91       	pop	r28
    2df6:	1f 91       	pop	r17
    2df8:	0f 91       	pop	r16
    2dfa:	ff 90       	pop	r15
    2dfc:	ef 90       	pop	r14
    2dfe:	df 90       	pop	r13
    2e00:	cf 90       	pop	r12
    2e02:	08 95       	ret

00002e04 <xTaskResumeAll>:
    2e04:	df 92       	push	r13
    2e06:	ef 92       	push	r14
    2e08:	ff 92       	push	r15
    2e0a:	0f 93       	push	r16
    2e0c:	1f 93       	push	r17
    2e0e:	cf 93       	push	r28
    2e10:	df 93       	push	r29
    2e12:	0f b6       	in	r0, 0x3f	; 63
    2e14:	f8 94       	cli
    2e16:	0f 92       	push	r0
    2e18:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    2e1c:	81 50       	subi	r24, 0x01	; 1
    2e1e:	80 93 88 0c 	sts	0x0C88, r24	; 0x800c88 <uxSchedulerSuspended>
    2e22:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    2e26:	81 11       	cpse	r24, r1
    2e28:	59 c0       	rjmp	.+178    	; 0x2edc <xTaskResumeAll+0xd8>
    2e2a:	80 91 95 0c 	lds	r24, 0x0C95	; 0x800c95 <uxCurrentNumberOfTasks>
    2e2e:	81 11       	cpse	r24, r1
    2e30:	30 c0       	rjmp	.+96     	; 0x2e92 <xTaskResumeAll+0x8e>
    2e32:	57 c0       	rjmp	.+174    	; 0x2ee2 <xTaskResumeAll+0xde>
    2e34:	d7 01       	movw	r26, r14
    2e36:	15 96       	adiw	r26, 0x05	; 5
    2e38:	ed 91       	ld	r30, X+
    2e3a:	fc 91       	ld	r31, X
    2e3c:	16 97       	sbiw	r26, 0x06	; 6
    2e3e:	c6 81       	ldd	r28, Z+6	; 0x06
    2e40:	d7 81       	ldd	r29, Z+7	; 0x07
    2e42:	ce 01       	movw	r24, r28
    2e44:	0c 96       	adiw	r24, 0x0c	; 12
    2e46:	85 d9       	rcall	.-3318   	; 0x2152 <uxListRemove>
    2e48:	8e 01       	movw	r16, r28
    2e4a:	0e 5f       	subi	r16, 0xFE	; 254
    2e4c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e4e:	c8 01       	movw	r24, r16
    2e50:	80 d9       	rcall	.-3328   	; 0x2152 <uxListRemove>
    2e52:	8e 89       	ldd	r24, Y+22	; 0x16
    2e54:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    2e58:	98 17       	cp	r25, r24
    2e5a:	10 f4       	brcc	.+4      	; 0x2e60 <xTaskResumeAll+0x5c>
    2e5c:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    2e60:	90 e0       	ldi	r25, 0x00	; 0
    2e62:	9c 01       	movw	r18, r24
    2e64:	22 0f       	add	r18, r18
    2e66:	33 1f       	adc	r19, r19
    2e68:	22 0f       	add	r18, r18
    2e6a:	33 1f       	adc	r19, r19
    2e6c:	22 0f       	add	r18, r18
    2e6e:	33 1f       	adc	r19, r19
    2e70:	82 0f       	add	r24, r18
    2e72:	93 1f       	adc	r25, r19
    2e74:	b8 01       	movw	r22, r16
    2e76:	88 53       	subi	r24, 0x38	; 56
    2e78:	93 4f       	sbci	r25, 0xF3	; 243
    2e7a:	19 d9       	rcall	.-3534   	; 0x20ae <vListInsertEnd>
    2e7c:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2e80:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2e84:	9e 89       	ldd	r25, Y+22	; 0x16
    2e86:	86 89       	ldd	r24, Z+22	; 0x16
    2e88:	98 17       	cp	r25, r24
    2e8a:	68 f0       	brcs	.+26     	; 0x2ea6 <xTaskResumeAll+0xa2>
    2e8c:	d0 92 8f 0c 	sts	0x0C8F, r13	; 0x800c8f <xYieldPending>
    2e90:	0a c0       	rjmp	.+20     	; 0x2ea6 <xTaskResumeAll+0xa2>
    2e92:	c0 e0       	ldi	r28, 0x00	; 0
    2e94:	d0 e0       	ldi	r29, 0x00	; 0
    2e96:	0f 2e       	mov	r0, r31
    2e98:	f9 ea       	ldi	r31, 0xA9	; 169
    2e9a:	ef 2e       	mov	r14, r31
    2e9c:	fc e0       	ldi	r31, 0x0C	; 12
    2e9e:	ff 2e       	mov	r15, r31
    2ea0:	f0 2d       	mov	r31, r0
    2ea2:	dd 24       	eor	r13, r13
    2ea4:	d3 94       	inc	r13
    2ea6:	f7 01       	movw	r30, r14
    2ea8:	80 81       	ld	r24, Z
    2eaa:	81 11       	cpse	r24, r1
    2eac:	c3 cf       	rjmp	.-122    	; 0x2e34 <xTaskResumeAll+0x30>
    2eae:	cd 2b       	or	r28, r29
    2eb0:	09 f0       	breq	.+2      	; 0x2eb4 <xTaskResumeAll+0xb0>
    2eb2:	52 dd       	rcall	.-1372   	; 0x2958 <prvResetNextTaskUnblockTime>
    2eb4:	c0 91 90 0c 	lds	r28, 0x0C90	; 0x800c90 <uxPendedTicks>
    2eb8:	cc 23       	and	r28, r28
    2eba:	49 f0       	breq	.+18     	; 0x2ece <xTaskResumeAll+0xca>
    2ebc:	d1 e0       	ldi	r29, 0x01	; 1
    2ebe:	eb de       	rcall	.-554    	; 0x2c96 <xTaskIncrementTick>
    2ec0:	81 11       	cpse	r24, r1
    2ec2:	d0 93 8f 0c 	sts	0x0C8F, r29	; 0x800c8f <xYieldPending>
    2ec6:	c1 50       	subi	r28, 0x01	; 1
    2ec8:	d1 f7       	brne	.-12     	; 0x2ebe <xTaskResumeAll+0xba>
    2eca:	10 92 90 0c 	sts	0x0C90, r1	; 0x800c90 <uxPendedTicks>
    2ece:	80 91 8f 0c 	lds	r24, 0x0C8F	; 0x800c8f <xYieldPending>
    2ed2:	88 23       	and	r24, r24
    2ed4:	29 f0       	breq	.+10     	; 0x2ee0 <xTaskResumeAll+0xdc>
    2ed6:	04 da       	rcall	.-3064   	; 0x22e0 <vPortYield>
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	03 c0       	rjmp	.+6      	; 0x2ee2 <xTaskResumeAll+0xde>
    2edc:	80 e0       	ldi	r24, 0x00	; 0
    2ede:	01 c0       	rjmp	.+2      	; 0x2ee2 <xTaskResumeAll+0xde>
    2ee0:	80 e0       	ldi	r24, 0x00	; 0
    2ee2:	0f 90       	pop	r0
    2ee4:	0f be       	out	0x3f, r0	; 63
    2ee6:	df 91       	pop	r29
    2ee8:	cf 91       	pop	r28
    2eea:	1f 91       	pop	r17
    2eec:	0f 91       	pop	r16
    2eee:	ff 90       	pop	r15
    2ef0:	ef 90       	pop	r14
    2ef2:	df 90       	pop	r13
    2ef4:	08 95       	ret

00002ef6 <vTaskDelay>:
    2ef6:	cf 93       	push	r28
    2ef8:	df 93       	push	r29
    2efa:	ec 01       	movw	r28, r24
    2efc:	89 2b       	or	r24, r25
    2efe:	39 f0       	breq	.+14     	; 0x2f0e <vTaskDelay+0x18>
    2f00:	c4 de       	rcall	.-632    	; 0x2c8a <vTaskSuspendAll>
    2f02:	60 e0       	ldi	r22, 0x00	; 0
    2f04:	ce 01       	movw	r24, r28
    2f06:	47 dd       	rcall	.-1394   	; 0x2996 <prvAddCurrentTaskToDelayedList>
    2f08:	7d df       	rcall	.-262    	; 0x2e04 <xTaskResumeAll>
    2f0a:	81 11       	cpse	r24, r1
    2f0c:	01 c0       	rjmp	.+2      	; 0x2f10 <vTaskDelay+0x1a>
    2f0e:	e8 d9       	rcall	.-3120   	; 0x22e0 <vPortYield>
    2f10:	df 91       	pop	r29
    2f12:	cf 91       	pop	r28
    2f14:	08 95       	ret

00002f16 <prvIdleTask>:
    2f16:	00 ea       	ldi	r16, 0xA0	; 160
    2f18:	1c e0       	ldi	r17, 0x0C	; 12
    2f1a:	0f 2e       	mov	r0, r31
    2f1c:	f8 ec       	ldi	r31, 0xC8	; 200
    2f1e:	ef 2e       	mov	r14, r31
    2f20:	fc e0       	ldi	r31, 0x0C	; 12
    2f22:	ff 2e       	mov	r15, r31
    2f24:	f0 2d       	mov	r31, r0
    2f26:	24 c0       	rjmp	.+72     	; 0x2f70 <prvIdleTask+0x5a>
    2f28:	b0 de       	rcall	.-672    	; 0x2c8a <vTaskSuspendAll>
    2f2a:	d8 01       	movw	r26, r16
    2f2c:	cc 91       	ld	r28, X
    2f2e:	6a df       	rcall	.-300    	; 0x2e04 <xTaskResumeAll>
    2f30:	cc 23       	and	r28, r28
    2f32:	f1 f0       	breq	.+60     	; 0x2f70 <prvIdleTask+0x5a>
    2f34:	0f b6       	in	r0, 0x3f	; 63
    2f36:	f8 94       	cli
    2f38:	0f 92       	push	r0
    2f3a:	d8 01       	movw	r26, r16
    2f3c:	15 96       	adiw	r26, 0x05	; 5
    2f3e:	ed 91       	ld	r30, X+
    2f40:	fc 91       	ld	r31, X
    2f42:	16 97       	sbiw	r26, 0x06	; 6
    2f44:	c6 81       	ldd	r28, Z+6	; 0x06
    2f46:	d7 81       	ldd	r29, Z+7	; 0x07
    2f48:	ce 01       	movw	r24, r28
    2f4a:	02 96       	adiw	r24, 0x02	; 2
    2f4c:	02 d9       	rcall	.-3580   	; 0x2152 <uxListRemove>
    2f4e:	80 91 95 0c 	lds	r24, 0x0C95	; 0x800c95 <uxCurrentNumberOfTasks>
    2f52:	81 50       	subi	r24, 0x01	; 1
    2f54:	80 93 95 0c 	sts	0x0C95, r24	; 0x800c95 <uxCurrentNumberOfTasks>
    2f58:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <uxDeletedTasksWaitingCleanUp>
    2f5c:	81 50       	subi	r24, 0x01	; 1
    2f5e:	80 93 9f 0c 	sts	0x0C9F, r24	; 0x800c9f <uxDeletedTasksWaitingCleanUp>
    2f62:	0f 90       	pop	r0
    2f64:	0f be       	out	0x3f, r0	; 63
    2f66:	8f 89       	ldd	r24, Y+23	; 0x17
    2f68:	98 8d       	ldd	r25, Y+24	; 0x18
    2f6a:	8e d8       	rcall	.-3812   	; 0x2088 <vPortFree>
    2f6c:	ce 01       	movw	r24, r28
    2f6e:	8c d8       	rcall	.-3816   	; 0x2088 <vPortFree>
    2f70:	80 91 9f 0c 	lds	r24, 0x0C9F	; 0x800c9f <uxDeletedTasksWaitingCleanUp>
    2f74:	81 11       	cpse	r24, r1
    2f76:	d8 cf       	rjmp	.-80     	; 0x2f28 <prvIdleTask+0x12>
    2f78:	f7 01       	movw	r30, r14
    2f7a:	80 81       	ld	r24, Z
    2f7c:	82 30       	cpi	r24, 0x02	; 2
    2f7e:	c0 f3       	brcs	.-16     	; 0x2f70 <prvIdleTask+0x5a>
    2f80:	af d9       	rcall	.-3234   	; 0x22e0 <vPortYield>
    2f82:	f6 cf       	rjmp	.-20     	; 0x2f70 <prvIdleTask+0x5a>

00002f84 <vTaskSwitchContext>:
    2f84:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    2f88:	88 23       	and	r24, r24
    2f8a:	21 f0       	breq	.+8      	; 0x2f94 <vTaskSwitchContext+0x10>
    2f8c:	81 e0       	ldi	r24, 0x01	; 1
    2f8e:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <xYieldPending>
    2f92:	08 95       	ret
    2f94:	10 92 8f 0c 	sts	0x0C8F, r1	; 0x800c8f <xYieldPending>
    2f98:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2f9c:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2fa0:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2fa4:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2fa8:	2d 91       	ld	r18, X+
    2faa:	3c 91       	ld	r19, X
    2fac:	87 89       	ldd	r24, Z+23	; 0x17
    2fae:	90 8d       	ldd	r25, Z+24	; 0x18
    2fb0:	82 17       	cp	r24, r18
    2fb2:	93 07       	cpc	r25, r19
    2fb4:	58 f0       	brcs	.+22     	; 0x2fcc <vTaskSwitchContext+0x48>
    2fb6:	60 91 ec 0c 	lds	r22, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2fba:	70 91 ed 0c 	lds	r23, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2fbe:	80 91 ec 0c 	lds	r24, 0x0CEC	; 0x800cec <pxCurrentTCB>
    2fc2:	90 91 ed 0c 	lds	r25, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    2fc6:	67 5e       	subi	r22, 0xE7	; 231
    2fc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fca:	2a d8       	rcall	.-4012   	; 0x2020 <vApplicationStackOverflowHook>
    2fcc:	20 91 92 0c 	lds	r18, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    2fd0:	82 2f       	mov	r24, r18
    2fd2:	90 e0       	ldi	r25, 0x00	; 0
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	ee 0f       	add	r30, r30
    2fd8:	ff 1f       	adc	r31, r31
    2fda:	ee 0f       	add	r30, r30
    2fdc:	ff 1f       	adc	r31, r31
    2fde:	ee 0f       	add	r30, r30
    2fe0:	ff 1f       	adc	r31, r31
    2fe2:	e8 0f       	add	r30, r24
    2fe4:	f9 1f       	adc	r31, r25
    2fe6:	e8 53       	subi	r30, 0x38	; 56
    2fe8:	f3 4f       	sbci	r31, 0xF3	; 243
    2fea:	30 81       	ld	r19, Z
    2fec:	31 11       	cpse	r19, r1
    2fee:	11 c0       	rjmp	.+34     	; 0x3012 <vTaskSwitchContext+0x8e>
    2ff0:	21 50       	subi	r18, 0x01	; 1
    2ff2:	82 2f       	mov	r24, r18
    2ff4:	90 e0       	ldi	r25, 0x00	; 0
    2ff6:	fc 01       	movw	r30, r24
    2ff8:	ee 0f       	add	r30, r30
    2ffa:	ff 1f       	adc	r31, r31
    2ffc:	ee 0f       	add	r30, r30
    2ffe:	ff 1f       	adc	r31, r31
    3000:	ee 0f       	add	r30, r30
    3002:	ff 1f       	adc	r31, r31
    3004:	e8 0f       	add	r30, r24
    3006:	f9 1f       	adc	r31, r25
    3008:	e8 53       	subi	r30, 0x38	; 56
    300a:	f3 4f       	sbci	r31, 0xF3	; 243
    300c:	30 81       	ld	r19, Z
    300e:	33 23       	and	r19, r19
    3010:	79 f3       	breq	.-34     	; 0x2ff0 <vTaskSwitchContext+0x6c>
    3012:	ac 01       	movw	r20, r24
    3014:	44 0f       	add	r20, r20
    3016:	55 1f       	adc	r21, r21
    3018:	44 0f       	add	r20, r20
    301a:	55 1f       	adc	r21, r21
    301c:	44 0f       	add	r20, r20
    301e:	55 1f       	adc	r21, r21
    3020:	48 0f       	add	r20, r24
    3022:	59 1f       	adc	r21, r25
    3024:	da 01       	movw	r26, r20
    3026:	a8 53       	subi	r26, 0x38	; 56
    3028:	b3 4f       	sbci	r27, 0xF3	; 243
    302a:	11 96       	adiw	r26, 0x01	; 1
    302c:	ed 91       	ld	r30, X+
    302e:	fc 91       	ld	r31, X
    3030:	12 97       	sbiw	r26, 0x02	; 2
    3032:	02 80       	ldd	r0, Z+2	; 0x02
    3034:	f3 81       	ldd	r31, Z+3	; 0x03
    3036:	e0 2d       	mov	r30, r0
    3038:	12 96       	adiw	r26, 0x02	; 2
    303a:	fc 93       	st	X, r31
    303c:	ee 93       	st	-X, r30
    303e:	11 97       	sbiw	r26, 0x01	; 1
    3040:	45 53       	subi	r20, 0x35	; 53
    3042:	53 4f       	sbci	r21, 0xF3	; 243
    3044:	e4 17       	cp	r30, r20
    3046:	f5 07       	cpc	r31, r21
    3048:	29 f4       	brne	.+10     	; 0x3054 <vTaskSwitchContext+0xd0>
    304a:	42 81       	ldd	r20, Z+2	; 0x02
    304c:	53 81       	ldd	r21, Z+3	; 0x03
    304e:	fd 01       	movw	r30, r26
    3050:	52 83       	std	Z+2, r21	; 0x02
    3052:	41 83       	std	Z+1, r20	; 0x01
    3054:	fc 01       	movw	r30, r24
    3056:	ee 0f       	add	r30, r30
    3058:	ff 1f       	adc	r31, r31
    305a:	ee 0f       	add	r30, r30
    305c:	ff 1f       	adc	r31, r31
    305e:	ee 0f       	add	r30, r30
    3060:	ff 1f       	adc	r31, r31
    3062:	8e 0f       	add	r24, r30
    3064:	9f 1f       	adc	r25, r31
    3066:	fc 01       	movw	r30, r24
    3068:	e8 53       	subi	r30, 0x38	; 56
    306a:	f3 4f       	sbci	r31, 0xF3	; 243
    306c:	01 80       	ldd	r0, Z+1	; 0x01
    306e:	f2 81       	ldd	r31, Z+2	; 0x02
    3070:	e0 2d       	mov	r30, r0
    3072:	86 81       	ldd	r24, Z+6	; 0x06
    3074:	97 81       	ldd	r25, Z+7	; 0x07
    3076:	90 93 ed 0c 	sts	0x0CED, r25	; 0x800ced <pxCurrentTCB+0x1>
    307a:	80 93 ec 0c 	sts	0x0CEC, r24	; 0x800cec <pxCurrentTCB>
    307e:	20 93 92 0c 	sts	0x0C92, r18	; 0x800c92 <uxTopReadyPriority>
    3082:	08 95       	ret

00003084 <vTaskPlaceOnEventList>:
    3084:	cf 93       	push	r28
    3086:	df 93       	push	r29
    3088:	eb 01       	movw	r28, r22
    308a:	60 91 ec 0c 	lds	r22, 0x0CEC	; 0x800cec <pxCurrentTCB>
    308e:	70 91 ed 0c 	lds	r23, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    3092:	64 5f       	subi	r22, 0xF4	; 244
    3094:	7f 4f       	sbci	r23, 0xFF	; 255
    3096:	2c d8       	rcall	.-4008   	; 0x20f0 <vListInsert>
    3098:	61 e0       	ldi	r22, 0x01	; 1
    309a:	ce 01       	movw	r24, r28
    309c:	7c dc       	rcall	.-1800   	; 0x2996 <prvAddCurrentTaskToDelayedList>
    309e:	df 91       	pop	r29
    30a0:	cf 91       	pop	r28
    30a2:	08 95       	ret

000030a4 <xTaskRemoveFromEventList>:
    30a4:	0f 93       	push	r16
    30a6:	1f 93       	push	r17
    30a8:	cf 93       	push	r28
    30aa:	df 93       	push	r29
    30ac:	dc 01       	movw	r26, r24
    30ae:	15 96       	adiw	r26, 0x05	; 5
    30b0:	ed 91       	ld	r30, X+
    30b2:	fc 91       	ld	r31, X
    30b4:	16 97       	sbiw	r26, 0x06	; 6
    30b6:	c6 81       	ldd	r28, Z+6	; 0x06
    30b8:	d7 81       	ldd	r29, Z+7	; 0x07
    30ba:	8e 01       	movw	r16, r28
    30bc:	04 5f       	subi	r16, 0xF4	; 244
    30be:	1f 4f       	sbci	r17, 0xFF	; 255
    30c0:	c8 01       	movw	r24, r16
    30c2:	47 d8       	rcall	.-3954   	; 0x2152 <uxListRemove>
    30c4:	80 91 88 0c 	lds	r24, 0x0C88	; 0x800c88 <uxSchedulerSuspended>
    30c8:	81 11       	cpse	r24, r1
    30ca:	1b c0       	rjmp	.+54     	; 0x3102 <xTaskRemoveFromEventList+0x5e>
    30cc:	0a 50       	subi	r16, 0x0A	; 10
    30ce:	11 09       	sbc	r17, r1
    30d0:	c8 01       	movw	r24, r16
    30d2:	3f d8       	rcall	.-3970   	; 0x2152 <uxListRemove>
    30d4:	8e 89       	ldd	r24, Y+22	; 0x16
    30d6:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    30da:	98 17       	cp	r25, r24
    30dc:	10 f4       	brcc	.+4      	; 0x30e2 <xTaskRemoveFromEventList+0x3e>
    30de:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    30e2:	90 e0       	ldi	r25, 0x00	; 0
    30e4:	9c 01       	movw	r18, r24
    30e6:	22 0f       	add	r18, r18
    30e8:	33 1f       	adc	r19, r19
    30ea:	22 0f       	add	r18, r18
    30ec:	33 1f       	adc	r19, r19
    30ee:	22 0f       	add	r18, r18
    30f0:	33 1f       	adc	r19, r19
    30f2:	82 0f       	add	r24, r18
    30f4:	93 1f       	adc	r25, r19
    30f6:	b8 01       	movw	r22, r16
    30f8:	88 53       	subi	r24, 0x38	; 56
    30fa:	93 4f       	sbci	r25, 0xF3	; 243
    30fc:	0e 94 57 10 	call	0x20ae	; 0x20ae <vListInsertEnd>
    3100:	05 c0       	rjmp	.+10     	; 0x310c <xTaskRemoveFromEventList+0x68>
    3102:	b8 01       	movw	r22, r16
    3104:	89 ea       	ldi	r24, 0xA9	; 169
    3106:	9c e0       	ldi	r25, 0x0C	; 12
    3108:	0e 94 57 10 	call	0x20ae	; 0x20ae <vListInsertEnd>
    310c:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    3110:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    3114:	9e 89       	ldd	r25, Y+22	; 0x16
    3116:	86 89       	ldd	r24, Z+22	; 0x16
    3118:	89 17       	cp	r24, r25
    311a:	20 f4       	brcc	.+8      	; 0x3124 <xTaskRemoveFromEventList+0x80>
    311c:	81 e0       	ldi	r24, 0x01	; 1
    311e:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <xYieldPending>
    3122:	01 c0       	rjmp	.+2      	; 0x3126 <xTaskRemoveFromEventList+0x82>
    3124:	80 e0       	ldi	r24, 0x00	; 0
    3126:	df 91       	pop	r29
    3128:	cf 91       	pop	r28
    312a:	1f 91       	pop	r17
    312c:	0f 91       	pop	r16
    312e:	08 95       	ret

00003130 <vTaskSetTimeOutState>:
    3130:	20 91 8e 0c 	lds	r18, 0x0C8E	; 0x800c8e <xNumOfOverflows>
    3134:	fc 01       	movw	r30, r24
    3136:	20 83       	st	Z, r18
    3138:	20 91 93 0c 	lds	r18, 0x0C93	; 0x800c93 <xTickCount>
    313c:	30 91 94 0c 	lds	r19, 0x0C94	; 0x800c94 <xTickCount+0x1>
    3140:	32 83       	std	Z+2, r19	; 0x02
    3142:	21 83       	std	Z+1, r18	; 0x01
    3144:	08 95       	ret

00003146 <xTaskCheckForTimeOut>:
    3146:	0f b6       	in	r0, 0x3f	; 63
    3148:	f8 94       	cli
    314a:	0f 92       	push	r0
    314c:	40 91 93 0c 	lds	r20, 0x0C93	; 0x800c93 <xTickCount>
    3150:	50 91 94 0c 	lds	r21, 0x0C94	; 0x800c94 <xTickCount+0x1>
    3154:	db 01       	movw	r26, r22
    3156:	2d 91       	ld	r18, X+
    3158:	3c 91       	ld	r19, X
    315a:	2f 3f       	cpi	r18, 0xFF	; 255
    315c:	bf ef       	ldi	r27, 0xFF	; 255
    315e:	3b 07       	cpc	r19, r27
    3160:	11 f1       	breq	.+68     	; 0x31a6 <xTaskCheckForTimeOut+0x60>
    3162:	e0 91 8e 0c 	lds	r30, 0x0C8E	; 0x800c8e <xNumOfOverflows>
    3166:	dc 01       	movw	r26, r24
    3168:	fc 91       	ld	r31, X
    316a:	fe 17       	cp	r31, r30
    316c:	39 f0       	breq	.+14     	; 0x317c <xTaskCheckForTimeOut+0x36>
    316e:	11 96       	adiw	r26, 0x01	; 1
    3170:	ed 91       	ld	r30, X+
    3172:	fc 91       	ld	r31, X
    3174:	12 97       	sbiw	r26, 0x02	; 2
    3176:	4e 17       	cp	r20, r30
    3178:	5f 07       	cpc	r21, r31
    317a:	b8 f4       	brcc	.+46     	; 0x31aa <xTaskCheckForTimeOut+0x64>
    317c:	dc 01       	movw	r26, r24
    317e:	11 96       	adiw	r26, 0x01	; 1
    3180:	ed 91       	ld	r30, X+
    3182:	fc 91       	ld	r31, X
    3184:	12 97       	sbiw	r26, 0x02	; 2
    3186:	da 01       	movw	r26, r20
    3188:	ae 1b       	sub	r26, r30
    318a:	bf 0b       	sbc	r27, r31
    318c:	a2 17       	cp	r26, r18
    318e:	b3 07       	cpc	r27, r19
    3190:	70 f4       	brcc	.+28     	; 0x31ae <xTaskCheckForTimeOut+0x68>
    3192:	db 01       	movw	r26, r22
    3194:	e4 1b       	sub	r30, r20
    3196:	f5 0b       	sbc	r31, r21
    3198:	2e 0f       	add	r18, r30
    319a:	3f 1f       	adc	r19, r31
    319c:	2d 93       	st	X+, r18
    319e:	3c 93       	st	X, r19
    31a0:	c7 df       	rcall	.-114    	; 0x3130 <vTaskSetTimeOutState>
    31a2:	80 e0       	ldi	r24, 0x00	; 0
    31a4:	05 c0       	rjmp	.+10     	; 0x31b0 <xTaskCheckForTimeOut+0x6a>
    31a6:	80 e0       	ldi	r24, 0x00	; 0
    31a8:	03 c0       	rjmp	.+6      	; 0x31b0 <xTaskCheckForTimeOut+0x6a>
    31aa:	81 e0       	ldi	r24, 0x01	; 1
    31ac:	01 c0       	rjmp	.+2      	; 0x31b0 <xTaskCheckForTimeOut+0x6a>
    31ae:	81 e0       	ldi	r24, 0x01	; 1
    31b0:	0f 90       	pop	r0
    31b2:	0f be       	out	0x3f, r0	; 63
    31b4:	08 95       	ret

000031b6 <vTaskMissedYield>:
    31b6:	81 e0       	ldi	r24, 0x01	; 1
    31b8:	80 93 8f 0c 	sts	0x0C8F, r24	; 0x800c8f <xYieldPending>
    31bc:	08 95       	ret

000031be <vTaskPriorityInherit>:
    31be:	0f 93       	push	r16
    31c0:	1f 93       	push	r17
    31c2:	cf 93       	push	r28
    31c4:	df 93       	push	r29
    31c6:	fc 01       	movw	r30, r24
    31c8:	89 2b       	or	r24, r25
    31ca:	09 f4       	brne	.+2      	; 0x31ce <vTaskPriorityInherit+0x10>
    31cc:	55 c0       	rjmp	.+170    	; 0x3278 <vTaskPriorityInherit+0xba>
    31ce:	26 89       	ldd	r18, Z+22	; 0x16
    31d0:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    31d4:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    31d8:	56 96       	adiw	r26, 0x16	; 22
    31da:	8c 91       	ld	r24, X
    31dc:	28 17       	cp	r18, r24
    31de:	08 f0       	brcs	.+2      	; 0x31e2 <vTaskPriorityInherit+0x24>
    31e0:	4b c0       	rjmp	.+150    	; 0x3278 <vTaskPriorityInherit+0xba>
    31e2:	84 85       	ldd	r24, Z+12	; 0x0c
    31e4:	95 85       	ldd	r25, Z+13	; 0x0d
    31e6:	99 23       	and	r25, r25
    31e8:	64 f0       	brlt	.+24     	; 0x3202 <vTaskPriorityInherit+0x44>
    31ea:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    31ee:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    31f2:	56 96       	adiw	r26, 0x16	; 22
    31f4:	3c 91       	ld	r19, X
    31f6:	84 e0       	ldi	r24, 0x04	; 4
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	83 1b       	sub	r24, r19
    31fc:	91 09       	sbc	r25, r1
    31fe:	95 87       	std	Z+13, r25	; 0x0d
    3200:	84 87       	std	Z+12, r24	; 0x0c
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	c9 01       	movw	r24, r18
    3206:	88 0f       	add	r24, r24
    3208:	99 1f       	adc	r25, r25
    320a:	88 0f       	add	r24, r24
    320c:	99 1f       	adc	r25, r25
    320e:	88 0f       	add	r24, r24
    3210:	99 1f       	adc	r25, r25
    3212:	28 0f       	add	r18, r24
    3214:	39 1f       	adc	r19, r25
    3216:	28 53       	subi	r18, 0x38	; 56
    3218:	33 4f       	sbci	r19, 0xF3	; 243
    321a:	82 85       	ldd	r24, Z+10	; 0x0a
    321c:	93 85       	ldd	r25, Z+11	; 0x0b
    321e:	82 17       	cp	r24, r18
    3220:	93 07       	cpc	r25, r19
    3222:	19 f5       	brne	.+70     	; 0x326a <vTaskPriorityInherit+0xac>
    3224:	8f 01       	movw	r16, r30
    3226:	ef 01       	movw	r28, r30
    3228:	22 96       	adiw	r28, 0x02	; 2
    322a:	ce 01       	movw	r24, r28
    322c:	0e 94 a9 10 	call	0x2152	; 0x2152 <uxListRemove>
    3230:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    3234:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    3238:	86 89       	ldd	r24, Z+22	; 0x16
    323a:	f8 01       	movw	r30, r16
    323c:	86 8b       	std	Z+22, r24	; 0x16
    323e:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    3242:	98 17       	cp	r25, r24
    3244:	10 f4       	brcc	.+4      	; 0x324a <vTaskPriorityInherit+0x8c>
    3246:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    324a:	90 e0       	ldi	r25, 0x00	; 0
    324c:	9c 01       	movw	r18, r24
    324e:	22 0f       	add	r18, r18
    3250:	33 1f       	adc	r19, r19
    3252:	22 0f       	add	r18, r18
    3254:	33 1f       	adc	r19, r19
    3256:	22 0f       	add	r18, r18
    3258:	33 1f       	adc	r19, r19
    325a:	82 0f       	add	r24, r18
    325c:	93 1f       	adc	r25, r19
    325e:	be 01       	movw	r22, r28
    3260:	88 53       	subi	r24, 0x38	; 56
    3262:	93 4f       	sbci	r25, 0xF3	; 243
    3264:	0e 94 57 10 	call	0x20ae	; 0x20ae <vListInsertEnd>
    3268:	07 c0       	rjmp	.+14     	; 0x3278 <vTaskPriorityInherit+0xba>
    326a:	a0 91 ec 0c 	lds	r26, 0x0CEC	; 0x800cec <pxCurrentTCB>
    326e:	b0 91 ed 0c 	lds	r27, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    3272:	56 96       	adiw	r26, 0x16	; 22
    3274:	8c 91       	ld	r24, X
    3276:	86 8b       	std	Z+22, r24	; 0x16
    3278:	df 91       	pop	r29
    327a:	cf 91       	pop	r28
    327c:	1f 91       	pop	r17
    327e:	0f 91       	pop	r16
    3280:	08 95       	ret

00003282 <xTaskPriorityDisinherit>:
    3282:	0f 93       	push	r16
    3284:	1f 93       	push	r17
    3286:	cf 93       	push	r28
    3288:	df 93       	push	r29
    328a:	fc 01       	movw	r30, r24
    328c:	89 2b       	or	r24, r25
    328e:	79 f1       	breq	.+94     	; 0x32ee <xTaskPriorityDisinherit+0x6c>
    3290:	82 a1       	ldd	r24, Z+34	; 0x22
    3292:	81 50       	subi	r24, 0x01	; 1
    3294:	82 a3       	std	Z+34, r24	; 0x22
    3296:	26 89       	ldd	r18, Z+22	; 0x16
    3298:	91 a1       	ldd	r25, Z+33	; 0x21
    329a:	29 17       	cp	r18, r25
    329c:	51 f1       	breq	.+84     	; 0x32f2 <xTaskPriorityDisinherit+0x70>
    329e:	81 11       	cpse	r24, r1
    32a0:	2a c0       	rjmp	.+84     	; 0x32f6 <xTaskPriorityDisinherit+0x74>
    32a2:	ef 01       	movw	r28, r30
    32a4:	8f 01       	movw	r16, r30
    32a6:	0e 5f       	subi	r16, 0xFE	; 254
    32a8:	1f 4f       	sbci	r17, 0xFF	; 255
    32aa:	c8 01       	movw	r24, r16
    32ac:	0e 94 a9 10 	call	0x2152	; 0x2152 <uxListRemove>
    32b0:	89 a1       	ldd	r24, Y+33	; 0x21
    32b2:	8e 8b       	std	Y+22, r24	; 0x16
    32b4:	24 e0       	ldi	r18, 0x04	; 4
    32b6:	30 e0       	ldi	r19, 0x00	; 0
    32b8:	28 1b       	sub	r18, r24
    32ba:	31 09       	sbc	r19, r1
    32bc:	3d 87       	std	Y+13, r19	; 0x0d
    32be:	2c 87       	std	Y+12, r18	; 0x0c
    32c0:	90 91 92 0c 	lds	r25, 0x0C92	; 0x800c92 <uxTopReadyPriority>
    32c4:	98 17       	cp	r25, r24
    32c6:	10 f4       	brcc	.+4      	; 0x32cc <xTaskPriorityDisinherit+0x4a>
    32c8:	80 93 92 0c 	sts	0x0C92, r24	; 0x800c92 <uxTopReadyPriority>
    32cc:	90 e0       	ldi	r25, 0x00	; 0
    32ce:	9c 01       	movw	r18, r24
    32d0:	22 0f       	add	r18, r18
    32d2:	33 1f       	adc	r19, r19
    32d4:	22 0f       	add	r18, r18
    32d6:	33 1f       	adc	r19, r19
    32d8:	22 0f       	add	r18, r18
    32da:	33 1f       	adc	r19, r19
    32dc:	82 0f       	add	r24, r18
    32de:	93 1f       	adc	r25, r19
    32e0:	b8 01       	movw	r22, r16
    32e2:	88 53       	subi	r24, 0x38	; 56
    32e4:	93 4f       	sbci	r25, 0xF3	; 243
    32e6:	0e 94 57 10 	call	0x20ae	; 0x20ae <vListInsertEnd>
    32ea:	81 e0       	ldi	r24, 0x01	; 1
    32ec:	05 c0       	rjmp	.+10     	; 0x32f8 <xTaskPriorityDisinherit+0x76>
    32ee:	80 e0       	ldi	r24, 0x00	; 0
    32f0:	03 c0       	rjmp	.+6      	; 0x32f8 <xTaskPriorityDisinherit+0x76>
    32f2:	80 e0       	ldi	r24, 0x00	; 0
    32f4:	01 c0       	rjmp	.+2      	; 0x32f8 <xTaskPriorityDisinherit+0x76>
    32f6:	80 e0       	ldi	r24, 0x00	; 0
    32f8:	df 91       	pop	r29
    32fa:	cf 91       	pop	r28
    32fc:	1f 91       	pop	r17
    32fe:	0f 91       	pop	r16
    3300:	08 95       	ret

00003302 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    3302:	80 91 ec 0c 	lds	r24, 0x0CEC	; 0x800cec <pxCurrentTCB>
    3306:	90 91 ed 0c 	lds	r25, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    330a:	89 2b       	or	r24, r25
    330c:	39 f0       	breq	.+14     	; 0x331c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    330e:	e0 91 ec 0c 	lds	r30, 0x0CEC	; 0x800cec <pxCurrentTCB>
    3312:	f0 91 ed 0c 	lds	r31, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
    3316:	82 a1       	ldd	r24, Z+34	; 0x22
    3318:	8f 5f       	subi	r24, 0xFF	; 255
    331a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    331c:	80 91 ec 0c 	lds	r24, 0x0CEC	; 0x800cec <pxCurrentTCB>
    3320:	90 91 ed 0c 	lds	r25, 0x0CED	; 0x800ced <pxCurrentTCB+0x1>
	}
    3324:	08 95       	ret

00003326 <__subsf3>:
    3326:	50 58       	subi	r21, 0x80	; 128

00003328 <__addsf3>:
    3328:	bb 27       	eor	r27, r27
    332a:	aa 27       	eor	r26, r26
    332c:	0e d0       	rcall	.+28     	; 0x334a <__addsf3x>
    332e:	e0 c0       	rjmp	.+448    	; 0x34f0 <__fp_round>
    3330:	d1 d0       	rcall	.+418    	; 0x34d4 <__fp_pscA>
    3332:	30 f0       	brcs	.+12     	; 0x3340 <__addsf3+0x18>
    3334:	d6 d0       	rcall	.+428    	; 0x34e2 <__fp_pscB>
    3336:	20 f0       	brcs	.+8      	; 0x3340 <__addsf3+0x18>
    3338:	31 f4       	brne	.+12     	; 0x3346 <__addsf3+0x1e>
    333a:	9f 3f       	cpi	r25, 0xFF	; 255
    333c:	11 f4       	brne	.+4      	; 0x3342 <__addsf3+0x1a>
    333e:	1e f4       	brtc	.+6      	; 0x3346 <__addsf3+0x1e>
    3340:	c6 c0       	rjmp	.+396    	; 0x34ce <__fp_nan>
    3342:	0e f4       	brtc	.+2      	; 0x3346 <__addsf3+0x1e>
    3344:	e0 95       	com	r30
    3346:	e7 fb       	bst	r30, 7
    3348:	bc c0       	rjmp	.+376    	; 0x34c2 <__fp_inf>

0000334a <__addsf3x>:
    334a:	e9 2f       	mov	r30, r25
    334c:	e2 d0       	rcall	.+452    	; 0x3512 <__fp_split3>
    334e:	80 f3       	brcs	.-32     	; 0x3330 <__addsf3+0x8>
    3350:	ba 17       	cp	r27, r26
    3352:	62 07       	cpc	r22, r18
    3354:	73 07       	cpc	r23, r19
    3356:	84 07       	cpc	r24, r20
    3358:	95 07       	cpc	r25, r21
    335a:	18 f0       	brcs	.+6      	; 0x3362 <__addsf3x+0x18>
    335c:	71 f4       	brne	.+28     	; 0x337a <__addsf3x+0x30>
    335e:	9e f5       	brtc	.+102    	; 0x33c6 <__addsf3x+0x7c>
    3360:	fa c0       	rjmp	.+500    	; 0x3556 <__fp_zero>
    3362:	0e f4       	brtc	.+2      	; 0x3366 <__addsf3x+0x1c>
    3364:	e0 95       	com	r30
    3366:	0b 2e       	mov	r0, r27
    3368:	ba 2f       	mov	r27, r26
    336a:	a0 2d       	mov	r26, r0
    336c:	0b 01       	movw	r0, r22
    336e:	b9 01       	movw	r22, r18
    3370:	90 01       	movw	r18, r0
    3372:	0c 01       	movw	r0, r24
    3374:	ca 01       	movw	r24, r20
    3376:	a0 01       	movw	r20, r0
    3378:	11 24       	eor	r1, r1
    337a:	ff 27       	eor	r31, r31
    337c:	59 1b       	sub	r21, r25
    337e:	99 f0       	breq	.+38     	; 0x33a6 <__addsf3x+0x5c>
    3380:	59 3f       	cpi	r21, 0xF9	; 249
    3382:	50 f4       	brcc	.+20     	; 0x3398 <__addsf3x+0x4e>
    3384:	50 3e       	cpi	r21, 0xE0	; 224
    3386:	68 f1       	brcs	.+90     	; 0x33e2 <__addsf3x+0x98>
    3388:	1a 16       	cp	r1, r26
    338a:	f0 40       	sbci	r31, 0x00	; 0
    338c:	a2 2f       	mov	r26, r18
    338e:	23 2f       	mov	r18, r19
    3390:	34 2f       	mov	r19, r20
    3392:	44 27       	eor	r20, r20
    3394:	58 5f       	subi	r21, 0xF8	; 248
    3396:	f3 cf       	rjmp	.-26     	; 0x337e <__addsf3x+0x34>
    3398:	46 95       	lsr	r20
    339a:	37 95       	ror	r19
    339c:	27 95       	ror	r18
    339e:	a7 95       	ror	r26
    33a0:	f0 40       	sbci	r31, 0x00	; 0
    33a2:	53 95       	inc	r21
    33a4:	c9 f7       	brne	.-14     	; 0x3398 <__addsf3x+0x4e>
    33a6:	7e f4       	brtc	.+30     	; 0x33c6 <__addsf3x+0x7c>
    33a8:	1f 16       	cp	r1, r31
    33aa:	ba 0b       	sbc	r27, r26
    33ac:	62 0b       	sbc	r22, r18
    33ae:	73 0b       	sbc	r23, r19
    33b0:	84 0b       	sbc	r24, r20
    33b2:	ba f0       	brmi	.+46     	; 0x33e2 <__addsf3x+0x98>
    33b4:	91 50       	subi	r25, 0x01	; 1
    33b6:	a1 f0       	breq	.+40     	; 0x33e0 <__addsf3x+0x96>
    33b8:	ff 0f       	add	r31, r31
    33ba:	bb 1f       	adc	r27, r27
    33bc:	66 1f       	adc	r22, r22
    33be:	77 1f       	adc	r23, r23
    33c0:	88 1f       	adc	r24, r24
    33c2:	c2 f7       	brpl	.-16     	; 0x33b4 <__addsf3x+0x6a>
    33c4:	0e c0       	rjmp	.+28     	; 0x33e2 <__addsf3x+0x98>
    33c6:	ba 0f       	add	r27, r26
    33c8:	62 1f       	adc	r22, r18
    33ca:	73 1f       	adc	r23, r19
    33cc:	84 1f       	adc	r24, r20
    33ce:	48 f4       	brcc	.+18     	; 0x33e2 <__addsf3x+0x98>
    33d0:	87 95       	ror	r24
    33d2:	77 95       	ror	r23
    33d4:	67 95       	ror	r22
    33d6:	b7 95       	ror	r27
    33d8:	f7 95       	ror	r31
    33da:	9e 3f       	cpi	r25, 0xFE	; 254
    33dc:	08 f0       	brcs	.+2      	; 0x33e0 <__addsf3x+0x96>
    33de:	b3 cf       	rjmp	.-154    	; 0x3346 <__addsf3+0x1e>
    33e0:	93 95       	inc	r25
    33e2:	88 0f       	add	r24, r24
    33e4:	08 f0       	brcs	.+2      	; 0x33e8 <__addsf3x+0x9e>
    33e6:	99 27       	eor	r25, r25
    33e8:	ee 0f       	add	r30, r30
    33ea:	97 95       	ror	r25
    33ec:	87 95       	ror	r24
    33ee:	08 95       	ret

000033f0 <__fixunssfsi>:
    33f0:	98 d0       	rcall	.+304    	; 0x3522 <__fp_splitA>
    33f2:	88 f0       	brcs	.+34     	; 0x3416 <__fixunssfsi+0x26>
    33f4:	9f 57       	subi	r25, 0x7F	; 127
    33f6:	90 f0       	brcs	.+36     	; 0x341c <__fixunssfsi+0x2c>
    33f8:	b9 2f       	mov	r27, r25
    33fa:	99 27       	eor	r25, r25
    33fc:	b7 51       	subi	r27, 0x17	; 23
    33fe:	a0 f0       	brcs	.+40     	; 0x3428 <__fixunssfsi+0x38>
    3400:	d1 f0       	breq	.+52     	; 0x3436 <__fixunssfsi+0x46>
    3402:	66 0f       	add	r22, r22
    3404:	77 1f       	adc	r23, r23
    3406:	88 1f       	adc	r24, r24
    3408:	99 1f       	adc	r25, r25
    340a:	1a f0       	brmi	.+6      	; 0x3412 <__fixunssfsi+0x22>
    340c:	ba 95       	dec	r27
    340e:	c9 f7       	brne	.-14     	; 0x3402 <__fixunssfsi+0x12>
    3410:	12 c0       	rjmp	.+36     	; 0x3436 <__fixunssfsi+0x46>
    3412:	b1 30       	cpi	r27, 0x01	; 1
    3414:	81 f0       	breq	.+32     	; 0x3436 <__fixunssfsi+0x46>
    3416:	9f d0       	rcall	.+318    	; 0x3556 <__fp_zero>
    3418:	b1 e0       	ldi	r27, 0x01	; 1
    341a:	08 95       	ret
    341c:	9c c0       	rjmp	.+312    	; 0x3556 <__fp_zero>
    341e:	67 2f       	mov	r22, r23
    3420:	78 2f       	mov	r23, r24
    3422:	88 27       	eor	r24, r24
    3424:	b8 5f       	subi	r27, 0xF8	; 248
    3426:	39 f0       	breq	.+14     	; 0x3436 <__fixunssfsi+0x46>
    3428:	b9 3f       	cpi	r27, 0xF9	; 249
    342a:	cc f3       	brlt	.-14     	; 0x341e <__fixunssfsi+0x2e>
    342c:	86 95       	lsr	r24
    342e:	77 95       	ror	r23
    3430:	67 95       	ror	r22
    3432:	b3 95       	inc	r27
    3434:	d9 f7       	brne	.-10     	; 0x342c <__fixunssfsi+0x3c>
    3436:	3e f4       	brtc	.+14     	; 0x3446 <__fixunssfsi+0x56>
    3438:	90 95       	com	r25
    343a:	80 95       	com	r24
    343c:	70 95       	com	r23
    343e:	61 95       	neg	r22
    3440:	7f 4f       	sbci	r23, 0xFF	; 255
    3442:	8f 4f       	sbci	r24, 0xFF	; 255
    3444:	9f 4f       	sbci	r25, 0xFF	; 255
    3446:	08 95       	ret

00003448 <__floatunsisf>:
    3448:	e8 94       	clt
    344a:	09 c0       	rjmp	.+18     	; 0x345e <__floatsisf+0x12>

0000344c <__floatsisf>:
    344c:	97 fb       	bst	r25, 7
    344e:	3e f4       	brtc	.+14     	; 0x345e <__floatsisf+0x12>
    3450:	90 95       	com	r25
    3452:	80 95       	com	r24
    3454:	70 95       	com	r23
    3456:	61 95       	neg	r22
    3458:	7f 4f       	sbci	r23, 0xFF	; 255
    345a:	8f 4f       	sbci	r24, 0xFF	; 255
    345c:	9f 4f       	sbci	r25, 0xFF	; 255
    345e:	99 23       	and	r25, r25
    3460:	a9 f0       	breq	.+42     	; 0x348c <__floatsisf+0x40>
    3462:	f9 2f       	mov	r31, r25
    3464:	96 e9       	ldi	r25, 0x96	; 150
    3466:	bb 27       	eor	r27, r27
    3468:	93 95       	inc	r25
    346a:	f6 95       	lsr	r31
    346c:	87 95       	ror	r24
    346e:	77 95       	ror	r23
    3470:	67 95       	ror	r22
    3472:	b7 95       	ror	r27
    3474:	f1 11       	cpse	r31, r1
    3476:	f8 cf       	rjmp	.-16     	; 0x3468 <__floatsisf+0x1c>
    3478:	fa f4       	brpl	.+62     	; 0x34b8 <__floatsisf+0x6c>
    347a:	bb 0f       	add	r27, r27
    347c:	11 f4       	brne	.+4      	; 0x3482 <__floatsisf+0x36>
    347e:	60 ff       	sbrs	r22, 0
    3480:	1b c0       	rjmp	.+54     	; 0x34b8 <__floatsisf+0x6c>
    3482:	6f 5f       	subi	r22, 0xFF	; 255
    3484:	7f 4f       	sbci	r23, 0xFF	; 255
    3486:	8f 4f       	sbci	r24, 0xFF	; 255
    3488:	9f 4f       	sbci	r25, 0xFF	; 255
    348a:	16 c0       	rjmp	.+44     	; 0x34b8 <__floatsisf+0x6c>
    348c:	88 23       	and	r24, r24
    348e:	11 f0       	breq	.+4      	; 0x3494 <__floatsisf+0x48>
    3490:	96 e9       	ldi	r25, 0x96	; 150
    3492:	11 c0       	rjmp	.+34     	; 0x34b6 <__floatsisf+0x6a>
    3494:	77 23       	and	r23, r23
    3496:	21 f0       	breq	.+8      	; 0x34a0 <__floatsisf+0x54>
    3498:	9e e8       	ldi	r25, 0x8E	; 142
    349a:	87 2f       	mov	r24, r23
    349c:	76 2f       	mov	r23, r22
    349e:	05 c0       	rjmp	.+10     	; 0x34aa <__floatsisf+0x5e>
    34a0:	66 23       	and	r22, r22
    34a2:	71 f0       	breq	.+28     	; 0x34c0 <__floatsisf+0x74>
    34a4:	96 e8       	ldi	r25, 0x86	; 134
    34a6:	86 2f       	mov	r24, r22
    34a8:	70 e0       	ldi	r23, 0x00	; 0
    34aa:	60 e0       	ldi	r22, 0x00	; 0
    34ac:	2a f0       	brmi	.+10     	; 0x34b8 <__floatsisf+0x6c>
    34ae:	9a 95       	dec	r25
    34b0:	66 0f       	add	r22, r22
    34b2:	77 1f       	adc	r23, r23
    34b4:	88 1f       	adc	r24, r24
    34b6:	da f7       	brpl	.-10     	; 0x34ae <__floatsisf+0x62>
    34b8:	88 0f       	add	r24, r24
    34ba:	96 95       	lsr	r25
    34bc:	87 95       	ror	r24
    34be:	97 f9       	bld	r25, 7
    34c0:	08 95       	ret

000034c2 <__fp_inf>:
    34c2:	97 f9       	bld	r25, 7
    34c4:	9f 67       	ori	r25, 0x7F	; 127
    34c6:	80 e8       	ldi	r24, 0x80	; 128
    34c8:	70 e0       	ldi	r23, 0x00	; 0
    34ca:	60 e0       	ldi	r22, 0x00	; 0
    34cc:	08 95       	ret

000034ce <__fp_nan>:
    34ce:	9f ef       	ldi	r25, 0xFF	; 255
    34d0:	80 ec       	ldi	r24, 0xC0	; 192
    34d2:	08 95       	ret

000034d4 <__fp_pscA>:
    34d4:	00 24       	eor	r0, r0
    34d6:	0a 94       	dec	r0
    34d8:	16 16       	cp	r1, r22
    34da:	17 06       	cpc	r1, r23
    34dc:	18 06       	cpc	r1, r24
    34de:	09 06       	cpc	r0, r25
    34e0:	08 95       	ret

000034e2 <__fp_pscB>:
    34e2:	00 24       	eor	r0, r0
    34e4:	0a 94       	dec	r0
    34e6:	12 16       	cp	r1, r18
    34e8:	13 06       	cpc	r1, r19
    34ea:	14 06       	cpc	r1, r20
    34ec:	05 06       	cpc	r0, r21
    34ee:	08 95       	ret

000034f0 <__fp_round>:
    34f0:	09 2e       	mov	r0, r25
    34f2:	03 94       	inc	r0
    34f4:	00 0c       	add	r0, r0
    34f6:	11 f4       	brne	.+4      	; 0x34fc <__fp_round+0xc>
    34f8:	88 23       	and	r24, r24
    34fa:	52 f0       	brmi	.+20     	; 0x3510 <__fp_round+0x20>
    34fc:	bb 0f       	add	r27, r27
    34fe:	40 f4       	brcc	.+16     	; 0x3510 <__fp_round+0x20>
    3500:	bf 2b       	or	r27, r31
    3502:	11 f4       	brne	.+4      	; 0x3508 <__fp_round+0x18>
    3504:	60 ff       	sbrs	r22, 0
    3506:	04 c0       	rjmp	.+8      	; 0x3510 <__fp_round+0x20>
    3508:	6f 5f       	subi	r22, 0xFF	; 255
    350a:	7f 4f       	sbci	r23, 0xFF	; 255
    350c:	8f 4f       	sbci	r24, 0xFF	; 255
    350e:	9f 4f       	sbci	r25, 0xFF	; 255
    3510:	08 95       	ret

00003512 <__fp_split3>:
    3512:	57 fd       	sbrc	r21, 7
    3514:	90 58       	subi	r25, 0x80	; 128
    3516:	44 0f       	add	r20, r20
    3518:	55 1f       	adc	r21, r21
    351a:	59 f0       	breq	.+22     	; 0x3532 <__fp_splitA+0x10>
    351c:	5f 3f       	cpi	r21, 0xFF	; 255
    351e:	71 f0       	breq	.+28     	; 0x353c <__fp_splitA+0x1a>
    3520:	47 95       	ror	r20

00003522 <__fp_splitA>:
    3522:	88 0f       	add	r24, r24
    3524:	97 fb       	bst	r25, 7
    3526:	99 1f       	adc	r25, r25
    3528:	61 f0       	breq	.+24     	; 0x3542 <__fp_splitA+0x20>
    352a:	9f 3f       	cpi	r25, 0xFF	; 255
    352c:	79 f0       	breq	.+30     	; 0x354c <__fp_splitA+0x2a>
    352e:	87 95       	ror	r24
    3530:	08 95       	ret
    3532:	12 16       	cp	r1, r18
    3534:	13 06       	cpc	r1, r19
    3536:	14 06       	cpc	r1, r20
    3538:	55 1f       	adc	r21, r21
    353a:	f2 cf       	rjmp	.-28     	; 0x3520 <__fp_split3+0xe>
    353c:	46 95       	lsr	r20
    353e:	f1 df       	rcall	.-30     	; 0x3522 <__fp_splitA>
    3540:	08 c0       	rjmp	.+16     	; 0x3552 <__fp_splitA+0x30>
    3542:	16 16       	cp	r1, r22
    3544:	17 06       	cpc	r1, r23
    3546:	18 06       	cpc	r1, r24
    3548:	99 1f       	adc	r25, r25
    354a:	f1 cf       	rjmp	.-30     	; 0x352e <__fp_splitA+0xc>
    354c:	86 95       	lsr	r24
    354e:	71 05       	cpc	r23, r1
    3550:	61 05       	cpc	r22, r1
    3552:	08 94       	sec
    3554:	08 95       	ret

00003556 <__fp_zero>:
    3556:	e8 94       	clt

00003558 <__fp_szero>:
    3558:	bb 27       	eor	r27, r27
    355a:	66 27       	eor	r22, r22
    355c:	77 27       	eor	r23, r23
    355e:	cb 01       	movw	r24, r22
    3560:	97 f9       	bld	r25, 7
    3562:	08 95       	ret

00003564 <__udivmodsi4>:
    3564:	a1 e2       	ldi	r26, 0x21	; 33
    3566:	1a 2e       	mov	r1, r26
    3568:	aa 1b       	sub	r26, r26
    356a:	bb 1b       	sub	r27, r27
    356c:	fd 01       	movw	r30, r26
    356e:	0d c0       	rjmp	.+26     	; 0x358a <__udivmodsi4_ep>

00003570 <__udivmodsi4_loop>:
    3570:	aa 1f       	adc	r26, r26
    3572:	bb 1f       	adc	r27, r27
    3574:	ee 1f       	adc	r30, r30
    3576:	ff 1f       	adc	r31, r31
    3578:	a2 17       	cp	r26, r18
    357a:	b3 07       	cpc	r27, r19
    357c:	e4 07       	cpc	r30, r20
    357e:	f5 07       	cpc	r31, r21
    3580:	20 f0       	brcs	.+8      	; 0x358a <__udivmodsi4_ep>
    3582:	a2 1b       	sub	r26, r18
    3584:	b3 0b       	sbc	r27, r19
    3586:	e4 0b       	sbc	r30, r20
    3588:	f5 0b       	sbc	r31, r21

0000358a <__udivmodsi4_ep>:
    358a:	66 1f       	adc	r22, r22
    358c:	77 1f       	adc	r23, r23
    358e:	88 1f       	adc	r24, r24
    3590:	99 1f       	adc	r25, r25
    3592:	1a 94       	dec	r1
    3594:	69 f7       	brne	.-38     	; 0x3570 <__udivmodsi4_loop>
    3596:	60 95       	com	r22
    3598:	70 95       	com	r23
    359a:	80 95       	com	r24
    359c:	90 95       	com	r25
    359e:	9b 01       	movw	r18, r22
    35a0:	ac 01       	movw	r20, r24
    35a2:	bd 01       	movw	r22, r26
    35a4:	cf 01       	movw	r24, r30
    35a6:	08 95       	ret

000035a8 <memcpy>:
    35a8:	fb 01       	movw	r30, r22
    35aa:	dc 01       	movw	r26, r24
    35ac:	02 c0       	rjmp	.+4      	; 0x35b2 <memcpy+0xa>
    35ae:	01 90       	ld	r0, Z+
    35b0:	0d 92       	st	X+, r0
    35b2:	41 50       	subi	r20, 0x01	; 1
    35b4:	50 40       	sbci	r21, 0x00	; 0
    35b6:	d8 f7       	brcc	.-10     	; 0x35ae <memcpy+0x6>
    35b8:	08 95       	ret

000035ba <sprintf>:
    35ba:	0f 93       	push	r16
    35bc:	1f 93       	push	r17
    35be:	cf 93       	push	r28
    35c0:	df 93       	push	r29
    35c2:	cd b7       	in	r28, 0x3d	; 61
    35c4:	de b7       	in	r29, 0x3e	; 62
    35c6:	2e 97       	sbiw	r28, 0x0e	; 14
    35c8:	0f b6       	in	r0, 0x3f	; 63
    35ca:	f8 94       	cli
    35cc:	de bf       	out	0x3e, r29	; 62
    35ce:	0f be       	out	0x3f, r0	; 63
    35d0:	cd bf       	out	0x3d, r28	; 61
    35d2:	0d 89       	ldd	r16, Y+21	; 0x15
    35d4:	1e 89       	ldd	r17, Y+22	; 0x16
    35d6:	86 e0       	ldi	r24, 0x06	; 6
    35d8:	8c 83       	std	Y+4, r24	; 0x04
    35da:	1a 83       	std	Y+2, r17	; 0x02
    35dc:	09 83       	std	Y+1, r16	; 0x01
    35de:	8f ef       	ldi	r24, 0xFF	; 255
    35e0:	9f e7       	ldi	r25, 0x7F	; 127
    35e2:	9e 83       	std	Y+6, r25	; 0x06
    35e4:	8d 83       	std	Y+5, r24	; 0x05
    35e6:	ae 01       	movw	r20, r28
    35e8:	47 5e       	subi	r20, 0xE7	; 231
    35ea:	5f 4f       	sbci	r21, 0xFF	; 255
    35ec:	6f 89       	ldd	r22, Y+23	; 0x17
    35ee:	78 8d       	ldd	r23, Y+24	; 0x18
    35f0:	ce 01       	movw	r24, r28
    35f2:	01 96       	adiw	r24, 0x01	; 1
    35f4:	10 d0       	rcall	.+32     	; 0x3616 <vfprintf>
    35f6:	ef 81       	ldd	r30, Y+7	; 0x07
    35f8:	f8 85       	ldd	r31, Y+8	; 0x08
    35fa:	e0 0f       	add	r30, r16
    35fc:	f1 1f       	adc	r31, r17
    35fe:	10 82       	st	Z, r1
    3600:	2e 96       	adiw	r28, 0x0e	; 14
    3602:	0f b6       	in	r0, 0x3f	; 63
    3604:	f8 94       	cli
    3606:	de bf       	out	0x3e, r29	; 62
    3608:	0f be       	out	0x3f, r0	; 63
    360a:	cd bf       	out	0x3d, r28	; 61
    360c:	df 91       	pop	r29
    360e:	cf 91       	pop	r28
    3610:	1f 91       	pop	r17
    3612:	0f 91       	pop	r16
    3614:	08 95       	ret

00003616 <vfprintf>:
    3616:	2f 92       	push	r2
    3618:	3f 92       	push	r3
    361a:	4f 92       	push	r4
    361c:	5f 92       	push	r5
    361e:	6f 92       	push	r6
    3620:	7f 92       	push	r7
    3622:	8f 92       	push	r8
    3624:	9f 92       	push	r9
    3626:	af 92       	push	r10
    3628:	bf 92       	push	r11
    362a:	cf 92       	push	r12
    362c:	df 92       	push	r13
    362e:	ef 92       	push	r14
    3630:	ff 92       	push	r15
    3632:	0f 93       	push	r16
    3634:	1f 93       	push	r17
    3636:	cf 93       	push	r28
    3638:	df 93       	push	r29
    363a:	cd b7       	in	r28, 0x3d	; 61
    363c:	de b7       	in	r29, 0x3e	; 62
    363e:	2b 97       	sbiw	r28, 0x0b	; 11
    3640:	0f b6       	in	r0, 0x3f	; 63
    3642:	f8 94       	cli
    3644:	de bf       	out	0x3e, r29	; 62
    3646:	0f be       	out	0x3f, r0	; 63
    3648:	cd bf       	out	0x3d, r28	; 61
    364a:	6c 01       	movw	r12, r24
    364c:	7b 01       	movw	r14, r22
    364e:	8a 01       	movw	r16, r20
    3650:	fc 01       	movw	r30, r24
    3652:	17 82       	std	Z+7, r1	; 0x07
    3654:	16 82       	std	Z+6, r1	; 0x06
    3656:	83 81       	ldd	r24, Z+3	; 0x03
    3658:	81 ff       	sbrs	r24, 1
    365a:	bf c1       	rjmp	.+894    	; 0x39da <vfprintf+0x3c4>
    365c:	ce 01       	movw	r24, r28
    365e:	01 96       	adiw	r24, 0x01	; 1
    3660:	3c 01       	movw	r6, r24
    3662:	f6 01       	movw	r30, r12
    3664:	93 81       	ldd	r25, Z+3	; 0x03
    3666:	f7 01       	movw	r30, r14
    3668:	93 fd       	sbrc	r25, 3
    366a:	85 91       	lpm	r24, Z+
    366c:	93 ff       	sbrs	r25, 3
    366e:	81 91       	ld	r24, Z+
    3670:	7f 01       	movw	r14, r30
    3672:	88 23       	and	r24, r24
    3674:	09 f4       	brne	.+2      	; 0x3678 <vfprintf+0x62>
    3676:	ad c1       	rjmp	.+858    	; 0x39d2 <vfprintf+0x3bc>
    3678:	85 32       	cpi	r24, 0x25	; 37
    367a:	39 f4       	brne	.+14     	; 0x368a <vfprintf+0x74>
    367c:	93 fd       	sbrc	r25, 3
    367e:	85 91       	lpm	r24, Z+
    3680:	93 ff       	sbrs	r25, 3
    3682:	81 91       	ld	r24, Z+
    3684:	7f 01       	movw	r14, r30
    3686:	85 32       	cpi	r24, 0x25	; 37
    3688:	21 f4       	brne	.+8      	; 0x3692 <vfprintf+0x7c>
    368a:	b6 01       	movw	r22, r12
    368c:	90 e0       	ldi	r25, 0x00	; 0
    368e:	d6 d1       	rcall	.+940    	; 0x3a3c <fputc>
    3690:	e8 cf       	rjmp	.-48     	; 0x3662 <vfprintf+0x4c>
    3692:	91 2c       	mov	r9, r1
    3694:	21 2c       	mov	r2, r1
    3696:	31 2c       	mov	r3, r1
    3698:	ff e1       	ldi	r31, 0x1F	; 31
    369a:	f3 15       	cp	r31, r3
    369c:	d8 f0       	brcs	.+54     	; 0x36d4 <vfprintf+0xbe>
    369e:	8b 32       	cpi	r24, 0x2B	; 43
    36a0:	79 f0       	breq	.+30     	; 0x36c0 <vfprintf+0xaa>
    36a2:	38 f4       	brcc	.+14     	; 0x36b2 <vfprintf+0x9c>
    36a4:	80 32       	cpi	r24, 0x20	; 32
    36a6:	79 f0       	breq	.+30     	; 0x36c6 <vfprintf+0xb0>
    36a8:	83 32       	cpi	r24, 0x23	; 35
    36aa:	a1 f4       	brne	.+40     	; 0x36d4 <vfprintf+0xbe>
    36ac:	23 2d       	mov	r18, r3
    36ae:	20 61       	ori	r18, 0x10	; 16
    36b0:	1d c0       	rjmp	.+58     	; 0x36ec <vfprintf+0xd6>
    36b2:	8d 32       	cpi	r24, 0x2D	; 45
    36b4:	61 f0       	breq	.+24     	; 0x36ce <vfprintf+0xb8>
    36b6:	80 33       	cpi	r24, 0x30	; 48
    36b8:	69 f4       	brne	.+26     	; 0x36d4 <vfprintf+0xbe>
    36ba:	23 2d       	mov	r18, r3
    36bc:	21 60       	ori	r18, 0x01	; 1
    36be:	16 c0       	rjmp	.+44     	; 0x36ec <vfprintf+0xd6>
    36c0:	83 2d       	mov	r24, r3
    36c2:	82 60       	ori	r24, 0x02	; 2
    36c4:	38 2e       	mov	r3, r24
    36c6:	e3 2d       	mov	r30, r3
    36c8:	e4 60       	ori	r30, 0x04	; 4
    36ca:	3e 2e       	mov	r3, r30
    36cc:	2a c0       	rjmp	.+84     	; 0x3722 <vfprintf+0x10c>
    36ce:	f3 2d       	mov	r31, r3
    36d0:	f8 60       	ori	r31, 0x08	; 8
    36d2:	1d c0       	rjmp	.+58     	; 0x370e <vfprintf+0xf8>
    36d4:	37 fc       	sbrc	r3, 7
    36d6:	2d c0       	rjmp	.+90     	; 0x3732 <vfprintf+0x11c>
    36d8:	20 ed       	ldi	r18, 0xD0	; 208
    36da:	28 0f       	add	r18, r24
    36dc:	2a 30       	cpi	r18, 0x0A	; 10
    36de:	40 f0       	brcs	.+16     	; 0x36f0 <vfprintf+0xda>
    36e0:	8e 32       	cpi	r24, 0x2E	; 46
    36e2:	b9 f4       	brne	.+46     	; 0x3712 <vfprintf+0xfc>
    36e4:	36 fc       	sbrc	r3, 6
    36e6:	75 c1       	rjmp	.+746    	; 0x39d2 <vfprintf+0x3bc>
    36e8:	23 2d       	mov	r18, r3
    36ea:	20 64       	ori	r18, 0x40	; 64
    36ec:	32 2e       	mov	r3, r18
    36ee:	19 c0       	rjmp	.+50     	; 0x3722 <vfprintf+0x10c>
    36f0:	36 fe       	sbrs	r3, 6
    36f2:	06 c0       	rjmp	.+12     	; 0x3700 <vfprintf+0xea>
    36f4:	8a e0       	ldi	r24, 0x0A	; 10
    36f6:	98 9e       	mul	r9, r24
    36f8:	20 0d       	add	r18, r0
    36fa:	11 24       	eor	r1, r1
    36fc:	92 2e       	mov	r9, r18
    36fe:	11 c0       	rjmp	.+34     	; 0x3722 <vfprintf+0x10c>
    3700:	ea e0       	ldi	r30, 0x0A	; 10
    3702:	2e 9e       	mul	r2, r30
    3704:	20 0d       	add	r18, r0
    3706:	11 24       	eor	r1, r1
    3708:	22 2e       	mov	r2, r18
    370a:	f3 2d       	mov	r31, r3
    370c:	f0 62       	ori	r31, 0x20	; 32
    370e:	3f 2e       	mov	r3, r31
    3710:	08 c0       	rjmp	.+16     	; 0x3722 <vfprintf+0x10c>
    3712:	8c 36       	cpi	r24, 0x6C	; 108
    3714:	21 f4       	brne	.+8      	; 0x371e <vfprintf+0x108>
    3716:	83 2d       	mov	r24, r3
    3718:	80 68       	ori	r24, 0x80	; 128
    371a:	38 2e       	mov	r3, r24
    371c:	02 c0       	rjmp	.+4      	; 0x3722 <vfprintf+0x10c>
    371e:	88 36       	cpi	r24, 0x68	; 104
    3720:	41 f4       	brne	.+16     	; 0x3732 <vfprintf+0x11c>
    3722:	f7 01       	movw	r30, r14
    3724:	93 fd       	sbrc	r25, 3
    3726:	85 91       	lpm	r24, Z+
    3728:	93 ff       	sbrs	r25, 3
    372a:	81 91       	ld	r24, Z+
    372c:	7f 01       	movw	r14, r30
    372e:	81 11       	cpse	r24, r1
    3730:	b3 cf       	rjmp	.-154    	; 0x3698 <vfprintf+0x82>
    3732:	98 2f       	mov	r25, r24
    3734:	9f 7d       	andi	r25, 0xDF	; 223
    3736:	95 54       	subi	r25, 0x45	; 69
    3738:	93 30       	cpi	r25, 0x03	; 3
    373a:	28 f4       	brcc	.+10     	; 0x3746 <vfprintf+0x130>
    373c:	0c 5f       	subi	r16, 0xFC	; 252
    373e:	1f 4f       	sbci	r17, 0xFF	; 255
    3740:	9f e3       	ldi	r25, 0x3F	; 63
    3742:	99 83       	std	Y+1, r25	; 0x01
    3744:	0d c0       	rjmp	.+26     	; 0x3760 <vfprintf+0x14a>
    3746:	83 36       	cpi	r24, 0x63	; 99
    3748:	31 f0       	breq	.+12     	; 0x3756 <vfprintf+0x140>
    374a:	83 37       	cpi	r24, 0x73	; 115
    374c:	71 f0       	breq	.+28     	; 0x376a <vfprintf+0x154>
    374e:	83 35       	cpi	r24, 0x53	; 83
    3750:	09 f0       	breq	.+2      	; 0x3754 <vfprintf+0x13e>
    3752:	55 c0       	rjmp	.+170    	; 0x37fe <vfprintf+0x1e8>
    3754:	20 c0       	rjmp	.+64     	; 0x3796 <vfprintf+0x180>
    3756:	f8 01       	movw	r30, r16
    3758:	80 81       	ld	r24, Z
    375a:	89 83       	std	Y+1, r24	; 0x01
    375c:	0e 5f       	subi	r16, 0xFE	; 254
    375e:	1f 4f       	sbci	r17, 0xFF	; 255
    3760:	88 24       	eor	r8, r8
    3762:	83 94       	inc	r8
    3764:	91 2c       	mov	r9, r1
    3766:	53 01       	movw	r10, r6
    3768:	12 c0       	rjmp	.+36     	; 0x378e <vfprintf+0x178>
    376a:	28 01       	movw	r4, r16
    376c:	f2 e0       	ldi	r31, 0x02	; 2
    376e:	4f 0e       	add	r4, r31
    3770:	51 1c       	adc	r5, r1
    3772:	f8 01       	movw	r30, r16
    3774:	a0 80       	ld	r10, Z
    3776:	b1 80       	ldd	r11, Z+1	; 0x01
    3778:	36 fe       	sbrs	r3, 6
    377a:	03 c0       	rjmp	.+6      	; 0x3782 <vfprintf+0x16c>
    377c:	69 2d       	mov	r22, r9
    377e:	70 e0       	ldi	r23, 0x00	; 0
    3780:	02 c0       	rjmp	.+4      	; 0x3786 <vfprintf+0x170>
    3782:	6f ef       	ldi	r22, 0xFF	; 255
    3784:	7f ef       	ldi	r23, 0xFF	; 255
    3786:	c5 01       	movw	r24, r10
    3788:	4e d1       	rcall	.+668    	; 0x3a26 <strnlen>
    378a:	4c 01       	movw	r8, r24
    378c:	82 01       	movw	r16, r4
    378e:	f3 2d       	mov	r31, r3
    3790:	ff 77       	andi	r31, 0x7F	; 127
    3792:	3f 2e       	mov	r3, r31
    3794:	15 c0       	rjmp	.+42     	; 0x37c0 <vfprintf+0x1aa>
    3796:	28 01       	movw	r4, r16
    3798:	22 e0       	ldi	r18, 0x02	; 2
    379a:	42 0e       	add	r4, r18
    379c:	51 1c       	adc	r5, r1
    379e:	f8 01       	movw	r30, r16
    37a0:	a0 80       	ld	r10, Z
    37a2:	b1 80       	ldd	r11, Z+1	; 0x01
    37a4:	36 fe       	sbrs	r3, 6
    37a6:	03 c0       	rjmp	.+6      	; 0x37ae <vfprintf+0x198>
    37a8:	69 2d       	mov	r22, r9
    37aa:	70 e0       	ldi	r23, 0x00	; 0
    37ac:	02 c0       	rjmp	.+4      	; 0x37b2 <vfprintf+0x19c>
    37ae:	6f ef       	ldi	r22, 0xFF	; 255
    37b0:	7f ef       	ldi	r23, 0xFF	; 255
    37b2:	c5 01       	movw	r24, r10
    37b4:	2d d1       	rcall	.+602    	; 0x3a10 <strnlen_P>
    37b6:	4c 01       	movw	r8, r24
    37b8:	f3 2d       	mov	r31, r3
    37ba:	f0 68       	ori	r31, 0x80	; 128
    37bc:	3f 2e       	mov	r3, r31
    37be:	82 01       	movw	r16, r4
    37c0:	33 fc       	sbrc	r3, 3
    37c2:	19 c0       	rjmp	.+50     	; 0x37f6 <vfprintf+0x1e0>
    37c4:	82 2d       	mov	r24, r2
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	88 16       	cp	r8, r24
    37ca:	99 06       	cpc	r9, r25
    37cc:	a0 f4       	brcc	.+40     	; 0x37f6 <vfprintf+0x1e0>
    37ce:	b6 01       	movw	r22, r12
    37d0:	80 e2       	ldi	r24, 0x20	; 32
    37d2:	90 e0       	ldi	r25, 0x00	; 0
    37d4:	33 d1       	rcall	.+614    	; 0x3a3c <fputc>
    37d6:	2a 94       	dec	r2
    37d8:	f5 cf       	rjmp	.-22     	; 0x37c4 <vfprintf+0x1ae>
    37da:	f5 01       	movw	r30, r10
    37dc:	37 fc       	sbrc	r3, 7
    37de:	85 91       	lpm	r24, Z+
    37e0:	37 fe       	sbrs	r3, 7
    37e2:	81 91       	ld	r24, Z+
    37e4:	5f 01       	movw	r10, r30
    37e6:	b6 01       	movw	r22, r12
    37e8:	90 e0       	ldi	r25, 0x00	; 0
    37ea:	28 d1       	rcall	.+592    	; 0x3a3c <fputc>
    37ec:	21 10       	cpse	r2, r1
    37ee:	2a 94       	dec	r2
    37f0:	21 e0       	ldi	r18, 0x01	; 1
    37f2:	82 1a       	sub	r8, r18
    37f4:	91 08       	sbc	r9, r1
    37f6:	81 14       	cp	r8, r1
    37f8:	91 04       	cpc	r9, r1
    37fa:	79 f7       	brne	.-34     	; 0x37da <vfprintf+0x1c4>
    37fc:	e1 c0       	rjmp	.+450    	; 0x39c0 <vfprintf+0x3aa>
    37fe:	84 36       	cpi	r24, 0x64	; 100
    3800:	11 f0       	breq	.+4      	; 0x3806 <vfprintf+0x1f0>
    3802:	89 36       	cpi	r24, 0x69	; 105
    3804:	39 f5       	brne	.+78     	; 0x3854 <vfprintf+0x23e>
    3806:	f8 01       	movw	r30, r16
    3808:	37 fe       	sbrs	r3, 7
    380a:	07 c0       	rjmp	.+14     	; 0x381a <vfprintf+0x204>
    380c:	60 81       	ld	r22, Z
    380e:	71 81       	ldd	r23, Z+1	; 0x01
    3810:	82 81       	ldd	r24, Z+2	; 0x02
    3812:	93 81       	ldd	r25, Z+3	; 0x03
    3814:	0c 5f       	subi	r16, 0xFC	; 252
    3816:	1f 4f       	sbci	r17, 0xFF	; 255
    3818:	08 c0       	rjmp	.+16     	; 0x382a <vfprintf+0x214>
    381a:	60 81       	ld	r22, Z
    381c:	71 81       	ldd	r23, Z+1	; 0x01
    381e:	07 2e       	mov	r0, r23
    3820:	00 0c       	add	r0, r0
    3822:	88 0b       	sbc	r24, r24
    3824:	99 0b       	sbc	r25, r25
    3826:	0e 5f       	subi	r16, 0xFE	; 254
    3828:	1f 4f       	sbci	r17, 0xFF	; 255
    382a:	f3 2d       	mov	r31, r3
    382c:	ff 76       	andi	r31, 0x6F	; 111
    382e:	3f 2e       	mov	r3, r31
    3830:	97 ff       	sbrs	r25, 7
    3832:	09 c0       	rjmp	.+18     	; 0x3846 <vfprintf+0x230>
    3834:	90 95       	com	r25
    3836:	80 95       	com	r24
    3838:	70 95       	com	r23
    383a:	61 95       	neg	r22
    383c:	7f 4f       	sbci	r23, 0xFF	; 255
    383e:	8f 4f       	sbci	r24, 0xFF	; 255
    3840:	9f 4f       	sbci	r25, 0xFF	; 255
    3842:	f0 68       	ori	r31, 0x80	; 128
    3844:	3f 2e       	mov	r3, r31
    3846:	2a e0       	ldi	r18, 0x0A	; 10
    3848:	30 e0       	ldi	r19, 0x00	; 0
    384a:	a3 01       	movw	r20, r6
    384c:	33 d1       	rcall	.+614    	; 0x3ab4 <__ultoa_invert>
    384e:	88 2e       	mov	r8, r24
    3850:	86 18       	sub	r8, r6
    3852:	44 c0       	rjmp	.+136    	; 0x38dc <vfprintf+0x2c6>
    3854:	85 37       	cpi	r24, 0x75	; 117
    3856:	31 f4       	brne	.+12     	; 0x3864 <vfprintf+0x24e>
    3858:	23 2d       	mov	r18, r3
    385a:	2f 7e       	andi	r18, 0xEF	; 239
    385c:	b2 2e       	mov	r11, r18
    385e:	2a e0       	ldi	r18, 0x0A	; 10
    3860:	30 e0       	ldi	r19, 0x00	; 0
    3862:	25 c0       	rjmp	.+74     	; 0x38ae <vfprintf+0x298>
    3864:	93 2d       	mov	r25, r3
    3866:	99 7f       	andi	r25, 0xF9	; 249
    3868:	b9 2e       	mov	r11, r25
    386a:	8f 36       	cpi	r24, 0x6F	; 111
    386c:	c1 f0       	breq	.+48     	; 0x389e <vfprintf+0x288>
    386e:	18 f4       	brcc	.+6      	; 0x3876 <vfprintf+0x260>
    3870:	88 35       	cpi	r24, 0x58	; 88
    3872:	79 f0       	breq	.+30     	; 0x3892 <vfprintf+0x27c>
    3874:	ae c0       	rjmp	.+348    	; 0x39d2 <vfprintf+0x3bc>
    3876:	80 37       	cpi	r24, 0x70	; 112
    3878:	19 f0       	breq	.+6      	; 0x3880 <vfprintf+0x26a>
    387a:	88 37       	cpi	r24, 0x78	; 120
    387c:	21 f0       	breq	.+8      	; 0x3886 <vfprintf+0x270>
    387e:	a9 c0       	rjmp	.+338    	; 0x39d2 <vfprintf+0x3bc>
    3880:	e9 2f       	mov	r30, r25
    3882:	e0 61       	ori	r30, 0x10	; 16
    3884:	be 2e       	mov	r11, r30
    3886:	b4 fe       	sbrs	r11, 4
    3888:	0d c0       	rjmp	.+26     	; 0x38a4 <vfprintf+0x28e>
    388a:	fb 2d       	mov	r31, r11
    388c:	f4 60       	ori	r31, 0x04	; 4
    388e:	bf 2e       	mov	r11, r31
    3890:	09 c0       	rjmp	.+18     	; 0x38a4 <vfprintf+0x28e>
    3892:	34 fe       	sbrs	r3, 4
    3894:	0a c0       	rjmp	.+20     	; 0x38aa <vfprintf+0x294>
    3896:	29 2f       	mov	r18, r25
    3898:	26 60       	ori	r18, 0x06	; 6
    389a:	b2 2e       	mov	r11, r18
    389c:	06 c0       	rjmp	.+12     	; 0x38aa <vfprintf+0x294>
    389e:	28 e0       	ldi	r18, 0x08	; 8
    38a0:	30 e0       	ldi	r19, 0x00	; 0
    38a2:	05 c0       	rjmp	.+10     	; 0x38ae <vfprintf+0x298>
    38a4:	20 e1       	ldi	r18, 0x10	; 16
    38a6:	30 e0       	ldi	r19, 0x00	; 0
    38a8:	02 c0       	rjmp	.+4      	; 0x38ae <vfprintf+0x298>
    38aa:	20 e1       	ldi	r18, 0x10	; 16
    38ac:	32 e0       	ldi	r19, 0x02	; 2
    38ae:	f8 01       	movw	r30, r16
    38b0:	b7 fe       	sbrs	r11, 7
    38b2:	07 c0       	rjmp	.+14     	; 0x38c2 <vfprintf+0x2ac>
    38b4:	60 81       	ld	r22, Z
    38b6:	71 81       	ldd	r23, Z+1	; 0x01
    38b8:	82 81       	ldd	r24, Z+2	; 0x02
    38ba:	93 81       	ldd	r25, Z+3	; 0x03
    38bc:	0c 5f       	subi	r16, 0xFC	; 252
    38be:	1f 4f       	sbci	r17, 0xFF	; 255
    38c0:	06 c0       	rjmp	.+12     	; 0x38ce <vfprintf+0x2b8>
    38c2:	60 81       	ld	r22, Z
    38c4:	71 81       	ldd	r23, Z+1	; 0x01
    38c6:	80 e0       	ldi	r24, 0x00	; 0
    38c8:	90 e0       	ldi	r25, 0x00	; 0
    38ca:	0e 5f       	subi	r16, 0xFE	; 254
    38cc:	1f 4f       	sbci	r17, 0xFF	; 255
    38ce:	a3 01       	movw	r20, r6
    38d0:	f1 d0       	rcall	.+482    	; 0x3ab4 <__ultoa_invert>
    38d2:	88 2e       	mov	r8, r24
    38d4:	86 18       	sub	r8, r6
    38d6:	fb 2d       	mov	r31, r11
    38d8:	ff 77       	andi	r31, 0x7F	; 127
    38da:	3f 2e       	mov	r3, r31
    38dc:	36 fe       	sbrs	r3, 6
    38de:	0d c0       	rjmp	.+26     	; 0x38fa <vfprintf+0x2e4>
    38e0:	23 2d       	mov	r18, r3
    38e2:	2e 7f       	andi	r18, 0xFE	; 254
    38e4:	a2 2e       	mov	r10, r18
    38e6:	89 14       	cp	r8, r9
    38e8:	58 f4       	brcc	.+22     	; 0x3900 <vfprintf+0x2ea>
    38ea:	34 fe       	sbrs	r3, 4
    38ec:	0b c0       	rjmp	.+22     	; 0x3904 <vfprintf+0x2ee>
    38ee:	32 fc       	sbrc	r3, 2
    38f0:	09 c0       	rjmp	.+18     	; 0x3904 <vfprintf+0x2ee>
    38f2:	83 2d       	mov	r24, r3
    38f4:	8e 7e       	andi	r24, 0xEE	; 238
    38f6:	a8 2e       	mov	r10, r24
    38f8:	05 c0       	rjmp	.+10     	; 0x3904 <vfprintf+0x2ee>
    38fa:	b8 2c       	mov	r11, r8
    38fc:	a3 2c       	mov	r10, r3
    38fe:	03 c0       	rjmp	.+6      	; 0x3906 <vfprintf+0x2f0>
    3900:	b8 2c       	mov	r11, r8
    3902:	01 c0       	rjmp	.+2      	; 0x3906 <vfprintf+0x2f0>
    3904:	b9 2c       	mov	r11, r9
    3906:	a4 fe       	sbrs	r10, 4
    3908:	0f c0       	rjmp	.+30     	; 0x3928 <vfprintf+0x312>
    390a:	fe 01       	movw	r30, r28
    390c:	e8 0d       	add	r30, r8
    390e:	f1 1d       	adc	r31, r1
    3910:	80 81       	ld	r24, Z
    3912:	80 33       	cpi	r24, 0x30	; 48
    3914:	21 f4       	brne	.+8      	; 0x391e <vfprintf+0x308>
    3916:	9a 2d       	mov	r25, r10
    3918:	99 7e       	andi	r25, 0xE9	; 233
    391a:	a9 2e       	mov	r10, r25
    391c:	09 c0       	rjmp	.+18     	; 0x3930 <vfprintf+0x31a>
    391e:	a2 fe       	sbrs	r10, 2
    3920:	06 c0       	rjmp	.+12     	; 0x392e <vfprintf+0x318>
    3922:	b3 94       	inc	r11
    3924:	b3 94       	inc	r11
    3926:	04 c0       	rjmp	.+8      	; 0x3930 <vfprintf+0x31a>
    3928:	8a 2d       	mov	r24, r10
    392a:	86 78       	andi	r24, 0x86	; 134
    392c:	09 f0       	breq	.+2      	; 0x3930 <vfprintf+0x31a>
    392e:	b3 94       	inc	r11
    3930:	a3 fc       	sbrc	r10, 3
    3932:	10 c0       	rjmp	.+32     	; 0x3954 <vfprintf+0x33e>
    3934:	a0 fe       	sbrs	r10, 0
    3936:	06 c0       	rjmp	.+12     	; 0x3944 <vfprintf+0x32e>
    3938:	b2 14       	cp	r11, r2
    393a:	80 f4       	brcc	.+32     	; 0x395c <vfprintf+0x346>
    393c:	28 0c       	add	r2, r8
    393e:	92 2c       	mov	r9, r2
    3940:	9b 18       	sub	r9, r11
    3942:	0d c0       	rjmp	.+26     	; 0x395e <vfprintf+0x348>
    3944:	b2 14       	cp	r11, r2
    3946:	58 f4       	brcc	.+22     	; 0x395e <vfprintf+0x348>
    3948:	b6 01       	movw	r22, r12
    394a:	80 e2       	ldi	r24, 0x20	; 32
    394c:	90 e0       	ldi	r25, 0x00	; 0
    394e:	76 d0       	rcall	.+236    	; 0x3a3c <fputc>
    3950:	b3 94       	inc	r11
    3952:	f8 cf       	rjmp	.-16     	; 0x3944 <vfprintf+0x32e>
    3954:	b2 14       	cp	r11, r2
    3956:	18 f4       	brcc	.+6      	; 0x395e <vfprintf+0x348>
    3958:	2b 18       	sub	r2, r11
    395a:	02 c0       	rjmp	.+4      	; 0x3960 <vfprintf+0x34a>
    395c:	98 2c       	mov	r9, r8
    395e:	21 2c       	mov	r2, r1
    3960:	a4 fe       	sbrs	r10, 4
    3962:	0f c0       	rjmp	.+30     	; 0x3982 <vfprintf+0x36c>
    3964:	b6 01       	movw	r22, r12
    3966:	80 e3       	ldi	r24, 0x30	; 48
    3968:	90 e0       	ldi	r25, 0x00	; 0
    396a:	68 d0       	rcall	.+208    	; 0x3a3c <fputc>
    396c:	a2 fe       	sbrs	r10, 2
    396e:	16 c0       	rjmp	.+44     	; 0x399c <vfprintf+0x386>
    3970:	a1 fc       	sbrc	r10, 1
    3972:	03 c0       	rjmp	.+6      	; 0x397a <vfprintf+0x364>
    3974:	88 e7       	ldi	r24, 0x78	; 120
    3976:	90 e0       	ldi	r25, 0x00	; 0
    3978:	02 c0       	rjmp	.+4      	; 0x397e <vfprintf+0x368>
    397a:	88 e5       	ldi	r24, 0x58	; 88
    397c:	90 e0       	ldi	r25, 0x00	; 0
    397e:	b6 01       	movw	r22, r12
    3980:	0c c0       	rjmp	.+24     	; 0x399a <vfprintf+0x384>
    3982:	8a 2d       	mov	r24, r10
    3984:	86 78       	andi	r24, 0x86	; 134
    3986:	51 f0       	breq	.+20     	; 0x399c <vfprintf+0x386>
    3988:	a1 fe       	sbrs	r10, 1
    398a:	02 c0       	rjmp	.+4      	; 0x3990 <vfprintf+0x37a>
    398c:	8b e2       	ldi	r24, 0x2B	; 43
    398e:	01 c0       	rjmp	.+2      	; 0x3992 <vfprintf+0x37c>
    3990:	80 e2       	ldi	r24, 0x20	; 32
    3992:	a7 fc       	sbrc	r10, 7
    3994:	8d e2       	ldi	r24, 0x2D	; 45
    3996:	b6 01       	movw	r22, r12
    3998:	90 e0       	ldi	r25, 0x00	; 0
    399a:	50 d0       	rcall	.+160    	; 0x3a3c <fputc>
    399c:	89 14       	cp	r8, r9
    399e:	30 f4       	brcc	.+12     	; 0x39ac <vfprintf+0x396>
    39a0:	b6 01       	movw	r22, r12
    39a2:	80 e3       	ldi	r24, 0x30	; 48
    39a4:	90 e0       	ldi	r25, 0x00	; 0
    39a6:	4a d0       	rcall	.+148    	; 0x3a3c <fputc>
    39a8:	9a 94       	dec	r9
    39aa:	f8 cf       	rjmp	.-16     	; 0x399c <vfprintf+0x386>
    39ac:	8a 94       	dec	r8
    39ae:	f3 01       	movw	r30, r6
    39b0:	e8 0d       	add	r30, r8
    39b2:	f1 1d       	adc	r31, r1
    39b4:	80 81       	ld	r24, Z
    39b6:	b6 01       	movw	r22, r12
    39b8:	90 e0       	ldi	r25, 0x00	; 0
    39ba:	40 d0       	rcall	.+128    	; 0x3a3c <fputc>
    39bc:	81 10       	cpse	r8, r1
    39be:	f6 cf       	rjmp	.-20     	; 0x39ac <vfprintf+0x396>
    39c0:	22 20       	and	r2, r2
    39c2:	09 f4       	brne	.+2      	; 0x39c6 <vfprintf+0x3b0>
    39c4:	4e ce       	rjmp	.-868    	; 0x3662 <vfprintf+0x4c>
    39c6:	b6 01       	movw	r22, r12
    39c8:	80 e2       	ldi	r24, 0x20	; 32
    39ca:	90 e0       	ldi	r25, 0x00	; 0
    39cc:	37 d0       	rcall	.+110    	; 0x3a3c <fputc>
    39ce:	2a 94       	dec	r2
    39d0:	f7 cf       	rjmp	.-18     	; 0x39c0 <vfprintf+0x3aa>
    39d2:	f6 01       	movw	r30, r12
    39d4:	86 81       	ldd	r24, Z+6	; 0x06
    39d6:	97 81       	ldd	r25, Z+7	; 0x07
    39d8:	02 c0       	rjmp	.+4      	; 0x39de <vfprintf+0x3c8>
    39da:	8f ef       	ldi	r24, 0xFF	; 255
    39dc:	9f ef       	ldi	r25, 0xFF	; 255
    39de:	2b 96       	adiw	r28, 0x0b	; 11
    39e0:	0f b6       	in	r0, 0x3f	; 63
    39e2:	f8 94       	cli
    39e4:	de bf       	out	0x3e, r29	; 62
    39e6:	0f be       	out	0x3f, r0	; 63
    39e8:	cd bf       	out	0x3d, r28	; 61
    39ea:	df 91       	pop	r29
    39ec:	cf 91       	pop	r28
    39ee:	1f 91       	pop	r17
    39f0:	0f 91       	pop	r16
    39f2:	ff 90       	pop	r15
    39f4:	ef 90       	pop	r14
    39f6:	df 90       	pop	r13
    39f8:	cf 90       	pop	r12
    39fa:	bf 90       	pop	r11
    39fc:	af 90       	pop	r10
    39fe:	9f 90       	pop	r9
    3a00:	8f 90       	pop	r8
    3a02:	7f 90       	pop	r7
    3a04:	6f 90       	pop	r6
    3a06:	5f 90       	pop	r5
    3a08:	4f 90       	pop	r4
    3a0a:	3f 90       	pop	r3
    3a0c:	2f 90       	pop	r2
    3a0e:	08 95       	ret

00003a10 <strnlen_P>:
    3a10:	fc 01       	movw	r30, r24
    3a12:	05 90       	lpm	r0, Z+
    3a14:	61 50       	subi	r22, 0x01	; 1
    3a16:	70 40       	sbci	r23, 0x00	; 0
    3a18:	01 10       	cpse	r0, r1
    3a1a:	d8 f7       	brcc	.-10     	; 0x3a12 <strnlen_P+0x2>
    3a1c:	80 95       	com	r24
    3a1e:	90 95       	com	r25
    3a20:	8e 0f       	add	r24, r30
    3a22:	9f 1f       	adc	r25, r31
    3a24:	08 95       	ret

00003a26 <strnlen>:
    3a26:	fc 01       	movw	r30, r24
    3a28:	61 50       	subi	r22, 0x01	; 1
    3a2a:	70 40       	sbci	r23, 0x00	; 0
    3a2c:	01 90       	ld	r0, Z+
    3a2e:	01 10       	cpse	r0, r1
    3a30:	d8 f7       	brcc	.-10     	; 0x3a28 <strnlen+0x2>
    3a32:	80 95       	com	r24
    3a34:	90 95       	com	r25
    3a36:	8e 0f       	add	r24, r30
    3a38:	9f 1f       	adc	r25, r31
    3a3a:	08 95       	ret

00003a3c <fputc>:
    3a3c:	0f 93       	push	r16
    3a3e:	1f 93       	push	r17
    3a40:	cf 93       	push	r28
    3a42:	df 93       	push	r29
    3a44:	fb 01       	movw	r30, r22
    3a46:	23 81       	ldd	r18, Z+3	; 0x03
    3a48:	21 fd       	sbrc	r18, 1
    3a4a:	03 c0       	rjmp	.+6      	; 0x3a52 <fputc+0x16>
    3a4c:	8f ef       	ldi	r24, 0xFF	; 255
    3a4e:	9f ef       	ldi	r25, 0xFF	; 255
    3a50:	2c c0       	rjmp	.+88     	; 0x3aaa <fputc+0x6e>
    3a52:	22 ff       	sbrs	r18, 2
    3a54:	16 c0       	rjmp	.+44     	; 0x3a82 <fputc+0x46>
    3a56:	46 81       	ldd	r20, Z+6	; 0x06
    3a58:	57 81       	ldd	r21, Z+7	; 0x07
    3a5a:	24 81       	ldd	r18, Z+4	; 0x04
    3a5c:	35 81       	ldd	r19, Z+5	; 0x05
    3a5e:	42 17       	cp	r20, r18
    3a60:	53 07       	cpc	r21, r19
    3a62:	44 f4       	brge	.+16     	; 0x3a74 <fputc+0x38>
    3a64:	a0 81       	ld	r26, Z
    3a66:	b1 81       	ldd	r27, Z+1	; 0x01
    3a68:	9d 01       	movw	r18, r26
    3a6a:	2f 5f       	subi	r18, 0xFF	; 255
    3a6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a6e:	31 83       	std	Z+1, r19	; 0x01
    3a70:	20 83       	st	Z, r18
    3a72:	8c 93       	st	X, r24
    3a74:	26 81       	ldd	r18, Z+6	; 0x06
    3a76:	37 81       	ldd	r19, Z+7	; 0x07
    3a78:	2f 5f       	subi	r18, 0xFF	; 255
    3a7a:	3f 4f       	sbci	r19, 0xFF	; 255
    3a7c:	37 83       	std	Z+7, r19	; 0x07
    3a7e:	26 83       	std	Z+6, r18	; 0x06
    3a80:	14 c0       	rjmp	.+40     	; 0x3aaa <fputc+0x6e>
    3a82:	8b 01       	movw	r16, r22
    3a84:	ec 01       	movw	r28, r24
    3a86:	fb 01       	movw	r30, r22
    3a88:	00 84       	ldd	r0, Z+8	; 0x08
    3a8a:	f1 85       	ldd	r31, Z+9	; 0x09
    3a8c:	e0 2d       	mov	r30, r0
    3a8e:	09 95       	icall
    3a90:	89 2b       	or	r24, r25
    3a92:	e1 f6       	brne	.-72     	; 0x3a4c <fputc+0x10>
    3a94:	d8 01       	movw	r26, r16
    3a96:	16 96       	adiw	r26, 0x06	; 6
    3a98:	8d 91       	ld	r24, X+
    3a9a:	9c 91       	ld	r25, X
    3a9c:	17 97       	sbiw	r26, 0x07	; 7
    3a9e:	01 96       	adiw	r24, 0x01	; 1
    3aa0:	17 96       	adiw	r26, 0x07	; 7
    3aa2:	9c 93       	st	X, r25
    3aa4:	8e 93       	st	-X, r24
    3aa6:	16 97       	sbiw	r26, 0x06	; 6
    3aa8:	ce 01       	movw	r24, r28
    3aaa:	df 91       	pop	r29
    3aac:	cf 91       	pop	r28
    3aae:	1f 91       	pop	r17
    3ab0:	0f 91       	pop	r16
    3ab2:	08 95       	ret

00003ab4 <__ultoa_invert>:
    3ab4:	fa 01       	movw	r30, r20
    3ab6:	aa 27       	eor	r26, r26
    3ab8:	28 30       	cpi	r18, 0x08	; 8
    3aba:	51 f1       	breq	.+84     	; 0x3b10 <__ultoa_invert+0x5c>
    3abc:	20 31       	cpi	r18, 0x10	; 16
    3abe:	81 f1       	breq	.+96     	; 0x3b20 <__ultoa_invert+0x6c>
    3ac0:	e8 94       	clt
    3ac2:	6f 93       	push	r22
    3ac4:	6e 7f       	andi	r22, 0xFE	; 254
    3ac6:	6e 5f       	subi	r22, 0xFE	; 254
    3ac8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aca:	8f 4f       	sbci	r24, 0xFF	; 255
    3acc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ace:	af 4f       	sbci	r26, 0xFF	; 255
    3ad0:	b1 e0       	ldi	r27, 0x01	; 1
    3ad2:	3e d0       	rcall	.+124    	; 0x3b50 <__ultoa_invert+0x9c>
    3ad4:	b4 e0       	ldi	r27, 0x04	; 4
    3ad6:	3c d0       	rcall	.+120    	; 0x3b50 <__ultoa_invert+0x9c>
    3ad8:	67 0f       	add	r22, r23
    3ada:	78 1f       	adc	r23, r24
    3adc:	89 1f       	adc	r24, r25
    3ade:	9a 1f       	adc	r25, r26
    3ae0:	a1 1d       	adc	r26, r1
    3ae2:	68 0f       	add	r22, r24
    3ae4:	79 1f       	adc	r23, r25
    3ae6:	8a 1f       	adc	r24, r26
    3ae8:	91 1d       	adc	r25, r1
    3aea:	a1 1d       	adc	r26, r1
    3aec:	6a 0f       	add	r22, r26
    3aee:	71 1d       	adc	r23, r1
    3af0:	81 1d       	adc	r24, r1
    3af2:	91 1d       	adc	r25, r1
    3af4:	a1 1d       	adc	r26, r1
    3af6:	20 d0       	rcall	.+64     	; 0x3b38 <__ultoa_invert+0x84>
    3af8:	09 f4       	brne	.+2      	; 0x3afc <__ultoa_invert+0x48>
    3afa:	68 94       	set
    3afc:	3f 91       	pop	r19
    3afe:	2a e0       	ldi	r18, 0x0A	; 10
    3b00:	26 9f       	mul	r18, r22
    3b02:	11 24       	eor	r1, r1
    3b04:	30 19       	sub	r19, r0
    3b06:	30 5d       	subi	r19, 0xD0	; 208
    3b08:	31 93       	st	Z+, r19
    3b0a:	de f6       	brtc	.-74     	; 0x3ac2 <__ultoa_invert+0xe>
    3b0c:	cf 01       	movw	r24, r30
    3b0e:	08 95       	ret
    3b10:	46 2f       	mov	r20, r22
    3b12:	47 70       	andi	r20, 0x07	; 7
    3b14:	40 5d       	subi	r20, 0xD0	; 208
    3b16:	41 93       	st	Z+, r20
    3b18:	b3 e0       	ldi	r27, 0x03	; 3
    3b1a:	0f d0       	rcall	.+30     	; 0x3b3a <__ultoa_invert+0x86>
    3b1c:	c9 f7       	brne	.-14     	; 0x3b10 <__ultoa_invert+0x5c>
    3b1e:	f6 cf       	rjmp	.-20     	; 0x3b0c <__ultoa_invert+0x58>
    3b20:	46 2f       	mov	r20, r22
    3b22:	4f 70       	andi	r20, 0x0F	; 15
    3b24:	40 5d       	subi	r20, 0xD0	; 208
    3b26:	4a 33       	cpi	r20, 0x3A	; 58
    3b28:	18 f0       	brcs	.+6      	; 0x3b30 <__ultoa_invert+0x7c>
    3b2a:	49 5d       	subi	r20, 0xD9	; 217
    3b2c:	31 fd       	sbrc	r19, 1
    3b2e:	40 52       	subi	r20, 0x20	; 32
    3b30:	41 93       	st	Z+, r20
    3b32:	02 d0       	rcall	.+4      	; 0x3b38 <__ultoa_invert+0x84>
    3b34:	a9 f7       	brne	.-22     	; 0x3b20 <__ultoa_invert+0x6c>
    3b36:	ea cf       	rjmp	.-44     	; 0x3b0c <__ultoa_invert+0x58>
    3b38:	b4 e0       	ldi	r27, 0x04	; 4
    3b3a:	a6 95       	lsr	r26
    3b3c:	97 95       	ror	r25
    3b3e:	87 95       	ror	r24
    3b40:	77 95       	ror	r23
    3b42:	67 95       	ror	r22
    3b44:	ba 95       	dec	r27
    3b46:	c9 f7       	brne	.-14     	; 0x3b3a <__ultoa_invert+0x86>
    3b48:	00 97       	sbiw	r24, 0x00	; 0
    3b4a:	61 05       	cpc	r22, r1
    3b4c:	71 05       	cpc	r23, r1
    3b4e:	08 95       	ret
    3b50:	9b 01       	movw	r18, r22
    3b52:	ac 01       	movw	r20, r24
    3b54:	0a 2e       	mov	r0, r26
    3b56:	06 94       	lsr	r0
    3b58:	57 95       	ror	r21
    3b5a:	47 95       	ror	r20
    3b5c:	37 95       	ror	r19
    3b5e:	27 95       	ror	r18
    3b60:	ba 95       	dec	r27
    3b62:	c9 f7       	brne	.-14     	; 0x3b56 <__ultoa_invert+0xa2>
    3b64:	62 0f       	add	r22, r18
    3b66:	73 1f       	adc	r23, r19
    3b68:	84 1f       	adc	r24, r20
    3b6a:	95 1f       	adc	r25, r21
    3b6c:	a0 1d       	adc	r26, r0
    3b6e:	08 95       	ret

00003b70 <eeprom_read_byte>:
    3b70:	e1 99       	sbic	0x1c, 1	; 28
    3b72:	fe cf       	rjmp	.-4      	; 0x3b70 <eeprom_read_byte>
    3b74:	9f bb       	out	0x1f, r25	; 31
    3b76:	8e bb       	out	0x1e, r24	; 30
    3b78:	e0 9a       	sbi	0x1c, 0	; 28
    3b7a:	99 27       	eor	r25, r25
    3b7c:	8d b3       	in	r24, 0x1d	; 29
    3b7e:	08 95       	ret

00003b80 <eeprom_update_byte>:
    3b80:	26 2f       	mov	r18, r22

00003b82 <eeprom_update_r18>:
    3b82:	e1 99       	sbic	0x1c, 1	; 28
    3b84:	fe cf       	rjmp	.-4      	; 0x3b82 <eeprom_update_r18>
    3b86:	9f bb       	out	0x1f, r25	; 31
    3b88:	8e bb       	out	0x1e, r24	; 30
    3b8a:	e0 9a       	sbi	0x1c, 0	; 28
    3b8c:	01 97       	sbiw	r24, 0x01	; 1
    3b8e:	0d b2       	in	r0, 0x1d	; 29
    3b90:	02 16       	cp	r0, r18
    3b92:	31 f0       	breq	.+12     	; 0x3ba0 <eeprom_update_r18+0x1e>
    3b94:	2d bb       	out	0x1d, r18	; 29
    3b96:	0f b6       	in	r0, 0x3f	; 63
    3b98:	f8 94       	cli
    3b9a:	e2 9a       	sbi	0x1c, 2	; 28
    3b9c:	e1 9a       	sbi	0x1c, 1	; 28
    3b9e:	0f be       	out	0x3f, r0	; 63
    3ba0:	08 95       	ret

00003ba2 <_exit>:
    3ba2:	f8 94       	cli

00003ba4 <__stop_program>:
    3ba4:	ff cf       	rjmp	.-2      	; 0x3ba4 <__stop_program>
