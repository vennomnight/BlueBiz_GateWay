
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000090  00800100  00002b50  00002be4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002b50  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c1d  00800190  00800190  00002c74  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002c74  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002ca4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000007c8  00000000  00000000  00002ce8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a738  00000000  00000000  000034b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002c13  00000000  00000000  0000dbe8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004b99  00000000  00000000  000107fb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001530  00000000  00000000  00015394  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002fdf  00000000  00000000  000168c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000790c  00000000  00000000  000198a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007f8  00000000  00000000  000211af  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__dtors_end>
       2:	00 00       	nop
       4:	6f c0       	rjmp	.+222    	; 0xe4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c0       	rjmp	.+218    	; 0xe4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c0       	rjmp	.+214    	; 0xe4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c0       	rjmp	.+210    	; 0xe4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c0       	rjmp	.+206    	; 0xe4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c0       	rjmp	.+202    	; 0xe4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c0       	rjmp	.+198    	; 0xe4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c0       	rjmp	.+194    	; 0xe4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c0       	rjmp	.+190    	; 0xe4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c0       	rjmp	.+186    	; 0xe4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c0       	rjmp	.+182    	; 0xe4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 03 0e 	jmp	0x1c06	; 0x1c06 <__vector_12>
      34:	57 c0       	rjmp	.+174    	; 0xe4 <__bad_interrupt>
      36:	00 00       	nop
      38:	55 c0       	rjmp	.+170    	; 0xe4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	53 c0       	rjmp	.+166    	; 0xe4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c0       	rjmp	.+162    	; 0xe4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c0       	rjmp	.+158    	; 0xe4 <__bad_interrupt>
      46:	00 00       	nop
      48:	5a c2       	rjmp	.+1204   	; 0x4fe <__vector_18>
      4a:	00 00       	nop
      4c:	4b c0       	rjmp	.+150    	; 0xe4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c0       	rjmp	.+146    	; 0xe4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c0       	rjmp	.+142    	; 0xe4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c0       	rjmp	.+138    	; 0xe4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c0       	rjmp	.+134    	; 0xe4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c0       	rjmp	.+130    	; 0xe4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c0       	rjmp	.+126    	; 0xe4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c0       	rjmp	.+122    	; 0xe4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c0       	rjmp	.+118    	; 0xe4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a7 c2       	rjmp	.+1358   	; 0x5c0 <__vector_28>
      72:	00 00       	nop
      74:	37 c0       	rjmp	.+110    	; 0xe4 <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c2       	rjmp	.+1252   	; 0x55e <__vector_30>
      7a:	00 00       	nop
      7c:	33 c0       	rjmp	.+102    	; 0xe4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c0       	rjmp	.+98     	; 0xe4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c0       	rjmp	.+94     	; 0xe4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c0       	rjmp	.+90     	; 0xe4 <__bad_interrupt>
	...

0000008c <__ctors_start>:
      8c:	2c 03       	fmul	r18, r20

0000008e <__ctors_end>:
      8e:	30 03       	mulsu	r19, r16

00000090 <__dtors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d0 e1       	ldi	r29, 0x10	; 16
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e0 e5       	ldi	r30, 0x50	; 80
      a4:	fb e2       	ldi	r31, 0x2B	; 43
      a6:	00 e0       	ldi	r16, 0x00	; 0
      a8:	0b bf       	out	0x3b, r16	; 59
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x14>
      ac:	07 90       	elpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a0 39       	cpi	r26, 0x90	; 144
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0x10>

000000b6 <__do_clear_bss>:
      b6:	2d e0       	ldi	r18, 0x0D	; 13
      b8:	a0 e9       	ldi	r26, 0x90	; 144
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ad 3a       	cpi	r26, 0xAD	; 173
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>

000000c6 <__do_global_ctors>:
      c6:	10 e0       	ldi	r17, 0x00	; 0
      c8:	c7 e4       	ldi	r28, 0x47	; 71
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      cc:	04 c0       	rjmp	.+8      	; 0xd6 <__do_global_ctors+0x10>
      ce:	21 97       	sbiw	r28, 0x01	; 1
      d0:	fe 01       	movw	r30, r28
      d2:	0e 94 71 15 	call	0x2ae2	; 0x2ae2 <__tablejump2__>
      d6:	c6 34       	cpi	r28, 0x46	; 70
      d8:	d1 07       	cpc	r29, r17
      da:	c9 f7       	brne	.-14     	; 0xce <__do_global_ctors+0x8>
      dc:	0e 94 4a 0b 	call	0x1694	; 0x1694 <main>
      e0:	0c 94 9c 15 	jmp	0x2b38	; 0x2b38 <__do_global_dtors>

000000e4 <__bad_interrupt>:
      e4:	8d cf       	rjmp	.-230    	; 0x0 <__vectors>

000000e6 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      e6:	fc 01       	movw	r30, r24
      e8:	68 0f       	add	r22, r24
      ea:	79 1f       	adc	r23, r25
      ec:	8f ef       	ldi	r24, 0xFF	; 255
      ee:	9f ef       	ldi	r25, 0xFF	; 255
      f0:	e6 17       	cp	r30, r22
      f2:	f7 07       	cpc	r31, r23
      f4:	99 f0       	breq	.+38     	; 0x11c <_Z5CRC16Phi+0x36>
      f6:	21 91       	ld	r18, Z+
      f8:	82 27       	eor	r24, r18
      fa:	28 e0       	ldi	r18, 0x08	; 8
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	ac 01       	movw	r20, r24
     100:	41 70       	andi	r20, 0x01	; 1
     102:	55 27       	eor	r21, r21
     104:	96 95       	lsr	r25
     106:	87 95       	ror	r24
     108:	45 2b       	or	r20, r21
     10a:	21 f0       	breq	.+8      	; 0x114 <_Z5CRC16Phi+0x2e>
     10c:	41 e0       	ldi	r20, 0x01	; 1
     10e:	84 27       	eor	r24, r20
     110:	40 ea       	ldi	r20, 0xA0	; 160
     112:	94 27       	eor	r25, r20
     114:	21 50       	subi	r18, 0x01	; 1
     116:	31 09       	sbc	r19, r1
     118:	91 f7       	brne	.-28     	; 0xfe <_Z5CRC16Phi+0x18>
     11a:	ea cf       	rjmp	.-44     	; 0xf0 <_Z5CRC16Phi+0xa>
     11c:	08 95       	ret

0000011e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	dc 01       	movw	r26, r24
     124:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     126:	8c 91       	ld	r24, X
     128:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     12a:	11 96       	adiw	r26, 0x01	; 1
     12c:	8c 91       	ld	r24, X
     12e:	11 97       	sbiw	r26, 0x01	; 1
     130:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     132:	13 96       	adiw	r26, 0x03	; 3
     134:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     136:	92 e0       	ldi	r25, 0x02	; 2
     138:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     13a:	e8 2f       	mov	r30, r24
     13c:	f0 e0       	ldi	r31, 0x00	; 0
     13e:	ee 0f       	add	r30, r30
     140:	ff 1f       	adc	r31, r31
     142:	e4 0f       	add	r30, r20
     144:	f5 1f       	adc	r31, r21
     146:	81 81       	ldd	r24, Z+1	; 0x01
     148:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     14a:	80 81       	ld	r24, Z
     14c:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     14e:	65 e0       	ldi	r22, 0x05	; 5
     150:	70 e0       	ldi	r23, 0x00	; 0
     152:	ce 01       	movw	r24, r28
     154:	c8 df       	rcall	.-112    	; 0xe6 <_Z5CRC16Phi>
	function04->CRC = crc16;
     156:	9e 83       	std	Y+6, r25	; 0x06
     158:	8d 83       	std	Y+5, r24	; 0x05
}
     15a:	df 91       	pop	r29
     15c:	cf 91       	pop	r28
     15e:	08 95       	ret

00000160 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	fc 01       	movw	r30, r24
     166:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     168:	80 81       	ld	r24, Z
     16a:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     170:	82 81       	ldd	r24, Z+2	; 0x02
     172:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     174:	83 81       	ldd	r24, Z+3	; 0x03
     176:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     178:	84 81       	ldd	r24, Z+4	; 0x04
     17a:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     17c:	85 81       	ldd	r24, Z+5	; 0x05
     17e:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     180:	66 e0       	ldi	r22, 0x06	; 6
     182:	70 e0       	ldi	r23, 0x00	; 0
     184:	ce 01       	movw	r24, r28
     186:	af df       	rcall	.-162    	; 0xe6 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     188:	9f 83       	std	Y+7, r25	; 0x07
     18a:	8e 83       	std	Y+6, r24	; 0x06
}
     18c:	df 91       	pop	r29
     18e:	cf 91       	pop	r28
     190:	08 95       	ret

00000192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     192:	cf 93       	push	r28
     194:	df 93       	push	r29
     196:	fc 01       	movw	r30, r24
     198:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     19a:	80 81       	ld	r24, Z
     19c:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     19e:	81 81       	ldd	r24, Z+1	; 0x01
     1a0:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1a2:	82 81       	ldd	r24, Z+2	; 0x02
     1a4:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1a6:	83 81       	ldd	r24, Z+3	; 0x03
     1a8:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1aa:	94 81       	ldd	r25, Z+4	; 0x04
     1ac:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1ae:	95 81       	ldd	r25, Z+5	; 0x05
     1b0:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1b2:	96 81       	ldd	r25, Z+6	; 0x06
     1b4:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1b6:	27 81       	ldd	r18, Z+7	; 0x07
     1b8:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1ba:	90 85       	ldd	r25, Z+8	; 0x08
     1bc:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1be:	e8 2f       	mov	r30, r24
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	ee 0f       	add	r30, r30
     1c4:	ff 1f       	adc	r31, r31
     1c6:	e4 0f       	add	r30, r20
     1c8:	f5 1f       	adc	r31, r21
     1ca:	89 2f       	mov	r24, r25
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	92 2b       	or	r25, r18
     1d0:	91 83       	std	Z+1, r25	; 0x01
     1d2:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1d4:	69 e0       	ldi	r22, 0x09	; 9
     1d6:	70 e0       	ldi	r23, 0x00	; 0
     1d8:	ce 01       	movw	r24, r28
     1da:	85 df       	rcall	.-246    	; 0xe6 <_Z5CRC16Phi>
	function10->CRC = crc16;
     1dc:	9a 87       	std	Y+10, r25	; 0x0a
     1de:	89 87       	std	Y+9, r24	; 0x09
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1e6:	cf 93       	push	r28
     1e8:	df 93       	push	r29
     1ea:	fc 01       	movw	r30, r24
     1ec:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1ee:	80 81       	ld	r24, Z
     1f0:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1f2:	81 81       	ldd	r24, Z+1	; 0x01
     1f4:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1f6:	82 81       	ldd	r24, Z+2	; 0x02
     1f8:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1fa:	83 81       	ldd	r24, Z+3	; 0x03
     1fc:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1fe:	84 81       	ldd	r24, Z+4	; 0x04
     200:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     202:	85 81       	ldd	r24, Z+5	; 0x05
     204:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	70 e0       	ldi	r23, 0x00	; 0
     20a:	ce 01       	movw	r24, r28
     20c:	6c df       	rcall	.-296    	; 0xe6 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     20e:	9f 83       	std	Y+7, r25	; 0x07
     210:	8e 83       	std	Y+6, r24	; 0x06
}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     21e:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     220:	81 e8       	ldi	r24, 0x81	; 129
     222:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     224:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	70 e0       	ldi	r23, 0x00	; 0
     22a:	ce 01       	movw	r24, r28
     22c:	5c df       	rcall	.-328    	; 0xe6 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     22e:	9c 83       	std	Y+4, r25	; 0x04
     230:	8b 83       	std	Y+3, r24	; 0x03
}
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	ec 01       	movw	r28, r24
     240:	cb 01       	movw	r24, r22
     242:	14 2f       	mov	r17, r20
     244:	fe 01       	movw	r30, r28
     246:	ea 57       	subi	r30, 0x7A	; 122
     248:	ff 4f       	sbci	r31, 0xFF	; 255
     24a:	71 83       	std	Z+1, r23	; 0x01
     24c:	60 83       	st	Z, r22
     24e:	64 2f       	mov	r22, r20
     250:	40 d1       	rcall	.+640    	; 0x4d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     252:	88 23       	and	r24, r24
     254:	71 f0       	breq	.+28     	; 0x272 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     256:	fe 01       	movw	r30, r28
     258:	eb 57       	subi	r30, 0x7B	; 123
     25a:	ff 4f       	sbci	r31, 0xFF	; 255
     25c:	10 83       	st	Z, r17
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	34 97       	sbiw	r30, 0x04	; 4
     264:	11 82       	std	Z+1, r1	; 0x01
     266:	10 82       	st	Z, r1
     268:	ce 57       	subi	r28, 0x7E	; 126
     26a:	df 4f       	sbci	r29, 0xFF	; 255
     26c:	19 82       	std	Y+1, r1	; 0x01
     26e:	18 82       	st	Y, r1
     270:	04 c0       	rjmp	.+8      	; 0x27a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     272:	ca 57       	subi	r28, 0x7A	; 122
     274:	df 4f       	sbci	r29, 0xFF	; 255
     276:	19 82       	std	Y+1, r1	; 0x01
     278:	18 82       	st	Y, r1
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	1f 91       	pop	r17
     280:	08 95       	ret

00000282 <_ZN12SerialBuffernwEj>:
     282:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <pvPortMalloc>
     286:	08 95       	ret

00000288 <_ZN12SerialBuffer11SerialstoreEc>:
     288:	fc 01       	movw	r30, r24
     28a:	e0 58       	subi	r30, 0x80	; 128
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	20 81       	ld	r18, Z
     290:	2f 5f       	subi	r18, 0xFF	; 255
     292:	2f 77       	andi	r18, 0x7F	; 127
     294:	19 f4       	brne	.+6      	; 0x29c <_ZN12SerialBuffer11SerialstoreEc+0x14>
     296:	11 82       	std	Z+1, r1	; 0x01
     298:	10 82       	st	Z, r1
     29a:	21 e0       	ldi	r18, 0x01	; 1
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	fc 01       	movw	r30, r24
     2a0:	ee 57       	subi	r30, 0x7E	; 126
     2a2:	ff 4f       	sbci	r31, 0xFF	; 255
     2a4:	40 81       	ld	r20, Z
     2a6:	51 81       	ldd	r21, Z+1	; 0x01
     2a8:	24 17       	cp	r18, r20
     2aa:	35 07       	cpc	r19, r21
     2ac:	89 f0       	breq	.+34     	; 0x2d0 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     2ae:	dc 01       	movw	r26, r24
     2b0:	a0 58       	subi	r26, 0x80	; 128
     2b2:	bf 4f       	sbci	r27, 0xFF	; 255
     2b4:	ed 91       	ld	r30, X+
     2b6:	fc 91       	ld	r31, X
     2b8:	11 97       	sbiw	r26, 0x01	; 1
     2ba:	e8 0f       	add	r30, r24
     2bc:	f9 1f       	adc	r31, r25
     2be:	61 83       	std	Z+1, r22	; 0x01
     2c0:	2d 93       	st	X+, r18
     2c2:	3c 93       	st	X, r19
     2c4:	fc 01       	movw	r30, r24
     2c6:	ec 57       	subi	r30, 0x7C	; 124
     2c8:	ff 4f       	sbci	r31, 0xFF	; 255
     2ca:	80 81       	ld	r24, Z
     2cc:	8f 5f       	subi	r24, 0xFF	; 255
     2ce:	80 83       	st	Z, r24
     2d0:	08 95       	ret

000002d2 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2d2:	af 92       	push	r10
     2d4:	bf 92       	push	r11
     2d6:	cf 92       	push	r12
     2d8:	df 92       	push	r13
     2da:	ef 92       	push	r14
     2dc:	ff 92       	push	r15
     2de:	0f 93       	push	r16
     2e0:	1f 93       	push	r17
     2e2:	cf 93       	push	r28
     2e4:	8c 01       	movw	r16, r24
     2e6:	6b 01       	movw	r12, r22
     2e8:	7a 01       	movw	r14, r20
     2ea:	dc 01       	movw	r26, r24
     2ec:	ab 57       	subi	r26, 0x7B	; 123
     2ee:	bf 4f       	sbci	r27, 0xFF	; 255
     2f0:	fc 01       	movw	r30, r24
     2f2:	ea 57       	subi	r30, 0x7A	; 122
     2f4:	ff 4f       	sbci	r31, 0xFF	; 255
     2f6:	6c 91       	ld	r22, X
     2f8:	80 81       	ld	r24, Z
     2fa:	91 81       	ldd	r25, Z+1	; 0x01
     2fc:	f7 d0       	rcall	.+494    	; 0x4ec <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2fe:	89 2b       	or	r24, r25
     300:	d1 f0       	breq	.+52     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     302:	1e 14       	cp	r1, r14
     304:	1f 04       	cpc	r1, r15
     306:	bc f4       	brge	.+46     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     308:	c0 e0       	ldi	r28, 0x00	; 0
     30a:	58 01       	movw	r10, r16
     30c:	85 e8       	ldi	r24, 0x85	; 133
     30e:	a8 0e       	add	r10, r24
     310:	b1 1c       	adc	r11, r1
     312:	0a 57       	subi	r16, 0x7A	; 122
     314:	1f 4f       	sbci	r17, 0xFF	; 255
     316:	f6 01       	movw	r30, r12
     318:	ec 0f       	add	r30, r28
     31a:	f1 1d       	adc	r31, r1
     31c:	40 81       	ld	r20, Z
     31e:	f5 01       	movw	r30, r10
     320:	60 81       	ld	r22, Z
     322:	f8 01       	movw	r30, r16
     324:	80 81       	ld	r24, Z
     326:	91 81       	ldd	r25, Z+1	; 0x01
     328:	8d d0       	rcall	.+282    	; 0x444 <_ZN11Dev_Manager5WriteE8Dev_typec>
     32a:	cf 5f       	subi	r28, 0xFF	; 255
     32c:	2c 2f       	mov	r18, r28
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	2e 15       	cp	r18, r14
     332:	3f 05       	cpc	r19, r15
     334:	84 f3       	brlt	.-32     	; 0x316 <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	df 90       	pop	r13
     342:	cf 90       	pop	r12
     344:	bf 90       	pop	r11
     346:	af 90       	pop	r10
     348:	08 95       	ret

0000034a <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     34a:	fc 01       	movw	r30, r24
     34c:	ee 57       	subi	r30, 0x7E	; 126
     34e:	ff 4f       	sbci	r31, 0xFF	; 255
     350:	20 81       	ld	r18, Z
     352:	31 81       	ldd	r19, Z+1	; 0x01
     354:	32 97       	sbiw	r30, 0x02	; 2
     356:	40 81       	ld	r20, Z
     358:	51 81       	ldd	r21, Z+1	; 0x01
     35a:	42 17       	cp	r20, r18
     35c:	53 07       	cpc	r21, r19
     35e:	e9 f0       	breq	.+58     	; 0x39a <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     360:	2f 5f       	subi	r18, 0xFF	; 255
     362:	3f 4f       	sbci	r19, 0xFF	; 255
     364:	fc 01       	movw	r30, r24
     366:	e2 0f       	add	r30, r18
     368:	f3 1f       	adc	r31, r19
     36a:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     36c:	2f 77       	andi	r18, 0x7F	; 127
     36e:	33 27       	eor	r19, r19
     370:	fc 01       	movw	r30, r24
     372:	ee 57       	subi	r30, 0x7E	; 126
     374:	ff 4f       	sbci	r31, 0xFF	; 255
     376:	31 83       	std	Z+1, r19	; 0x01
     378:	20 83       	st	Z, r18
		if (ib.tail == num)
     37a:	32 96       	adiw	r30, 0x02	; 2
     37c:	60 81       	ld	r22, Z
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	26 17       	cp	r18, r22
     382:	37 07       	cpc	r19, r23
     384:	61 f4       	brne	.+24     	; 0x39e <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     386:	32 97       	sbiw	r30, 0x02	; 2
     388:	11 82       	std	Z+1, r1	; 0x01
     38a:	10 82       	st	Z, r1
			ib.head = 0;
     38c:	32 97       	sbiw	r30, 0x02	; 2
     38e:	11 82       	std	Z+1, r1	; 0x01
     390:	10 82       	st	Z, r1
			num = 0;
     392:	34 96       	adiw	r30, 0x04	; 4
     394:	10 82       	st	Z, r1
		}
		return data;
     396:	84 2f       	mov	r24, r20
     398:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     39a:	8f ef       	ldi	r24, 0xFF	; 255
     39c:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     39e:	84 2f       	mov	r24, r20
	}
}
     3a0:	08 95       	ret

000003a2 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     3a2:	dc 01       	movw	r26, r24
     3a4:	a0 58       	subi	r26, 0x80	; 128
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ee 57       	subi	r30, 0x7E	; 126
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	8c 91       	ld	r24, X
     3b0:	90 81       	ld	r25, Z
     3b2:	89 1b       	sub	r24, r25
}
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	08 95       	ret

000003b8 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     3b8:	fc 01       	movw	r30, r24
     3ba:	ee 57       	subi	r30, 0x7E	; 126
     3bc:	ff 4f       	sbci	r31, 0xFF	; 255
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	ib.head = 0;
     3c2:	32 97       	sbiw	r30, 0x02	; 2
     3c4:	11 82       	std	Z+1, r1	; 0x01
     3c6:	10 82       	st	Z, r1
	num = 0;
     3c8:	34 96       	adiw	r30, 0x04	; 4
     3ca:	10 82       	st	Z, r1
     3cc:	08 95       	ret

000003ce <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     3ce:	26 e0       	ldi	r18, 0x06	; 6
     3d0:	dc 01       	movw	r26, r24
     3d2:	e2 2f       	mov	r30, r18
     3d4:	1d 92       	st	X+, r1
     3d6:	ea 95       	dec	r30
     3d8:	e9 f7       	brne	.-6      	; 0x3d4 <_ZN11Dev_ManagerC1Ev+0x6>
     3da:	fc 01       	movw	r30, r24
     3dc:	36 96       	adiw	r30, 0x06	; 6
     3de:	df 01       	movw	r26, r30
     3e0:	1d 92       	st	X+, r1
     3e2:	2a 95       	dec	r18
     3e4:	e9 f7       	brne	.-6      	; 0x3e0 <_ZN11Dev_ManagerC1Ev+0x12>
     3e6:	90 93 91 01 	sts	0x0191, r25	; 0x800191 <__data_end+0x1>
     3ea:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <__data_end>
     3ee:	08 95       	ret

000003f0 <_ZN11Dev_ManagerD1Ev>:
     3f0:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <__data_end+0x1>
     3f4:	10 92 90 01 	sts	0x0190, r1	; 0x800190 <__data_end>
     3f8:	08 95       	ret

000003fa <_ZN11Dev_Manager11getInstanceEv>:
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <__data_end>
     402:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <__data_end+0x1>
     406:	89 2b       	or	r24, r25
     408:	51 f4       	brne	.+20     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <pvPortMalloc>
     412:	ec 01       	movw	r28, r24
     414:	dc df       	rcall	.-72     	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     416:	d0 93 91 01 	sts	0x0191, r29	; 0x800191 <__data_end+0x1>
     41a:	c0 93 90 01 	sts	0x0190, r28	; 0x800190 <__data_end>
     41e:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <__data_end>
     422:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <__data_end+0x1>
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	08 95       	ret

0000042c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     42c:	50 e0       	ldi	r21, 0x00	; 0
     42e:	44 0f       	add	r20, r20
     430:	55 1f       	adc	r21, r21
     432:	84 0f       	add	r24, r20
     434:	95 1f       	adc	r25, r21
     436:	fc 01       	movw	r30, r24
     438:	71 83       	std	Z+1, r23	; 0x01
     43a:	60 83       	st	Z, r22
     43c:	08 95       	ret

0000043e <_ZN11Dev_ManagernwEj>:
     43e:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <pvPortMalloc>
     442:	08 95       	ret

00000444 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     444:	26 2f       	mov	r18, r22
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	22 0f       	add	r18, r18
     44a:	33 1f       	adc	r19, r19
     44c:	82 0f       	add	r24, r18
     44e:	93 1f       	adc	r25, r19
     450:	dc 01       	movw	r26, r24
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	00 97       	sbiw	r24, 0x00	; 0
     458:	41 f0       	breq	.+16     	; 0x46a <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     45a:	64 2f       	mov	r22, r20
     45c:	dc 01       	movw	r26, r24
     45e:	ed 91       	ld	r30, X+
     460:	fc 91       	ld	r31, X
     462:	06 80       	ldd	r0, Z+6	; 0x06
     464:	f7 81       	ldd	r31, Z+7	; 0x07
     466:	e0 2d       	mov	r30, r0
     468:	09 95       	icall
     46a:	08 95       	ret

0000046c <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     46c:	26 2f       	mov	r18, r22
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	22 0f       	add	r18, r18
     472:	33 1f       	adc	r19, r19
     474:	82 0f       	add	r24, r18
     476:	93 1f       	adc	r25, r19
     478:	dc 01       	movw	r26, r24
     47a:	8d 91       	ld	r24, X+
     47c:	9c 91       	ld	r25, X
     47e:	00 97       	sbiw	r24, 0x00	; 0
     480:	41 f0       	breq	.+16     	; 0x492 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     482:	ba 01       	movw	r22, r20
     484:	dc 01       	movw	r26, r24
     486:	ed 91       	ld	r30, X+
     488:	fc 91       	ld	r31, X
     48a:	04 80       	ldd	r0, Z+4	; 0x04
     48c:	f5 81       	ldd	r31, Z+5	; 0x05
     48e:	e0 2d       	mov	r30, r0
     490:	09 95       	icall
     492:	08 95       	ret

00000494 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     494:	70 e0       	ldi	r23, 0x00	; 0
     496:	66 0f       	add	r22, r22
     498:	77 1f       	adc	r23, r23
     49a:	86 0f       	add	r24, r22
     49c:	97 1f       	adc	r25, r23
     49e:	dc 01       	movw	r26, r24
     4a0:	8d 91       	ld	r24, X+
     4a2:	9c 91       	ld	r25, X
     4a4:	00 97       	sbiw	r24, 0x00	; 0
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     4a8:	dc 01       	movw	r26, r24
     4aa:	ed 91       	ld	r30, X+
     4ac:	fc 91       	ld	r31, X
     4ae:	01 90       	ld	r0, Z+
     4b0:	f0 81       	ld	r31, Z
     4b2:	e0 2d       	mov	r30, r0
     4b4:	09 95       	icall
     4b6:	08 95       	ret

000004b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     4b8:	e6 2f       	mov	r30, r22
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 0f       	add	r30, r24
     4c2:	f9 1f       	adc	r31, r25
     4c4:	80 81       	ld	r24, Z
     4c6:	91 81       	ldd	r25, Z+1	; 0x01
     4c8:	89 2b       	or	r24, r25
     4ca:	11 f0       	breq	.+4      	; 0x4d0 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     4cc:	57 83       	std	Z+7, r21	; 0x07
     4ce:	46 83       	std	Z+6, r20	; 0x06
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	66 0f       	add	r22, r22
     4d6:	77 1f       	adc	r23, r23
     4d8:	fc 01       	movw	r30, r24
     4da:	e6 0f       	add	r30, r22
     4dc:	f7 1f       	adc	r31, r23
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	20 81       	ld	r18, Z
     4e2:	31 81       	ldd	r19, Z+1	; 0x01
     4e4:	23 2b       	or	r18, r19
     4e6:	09 f4       	brne	.+2      	; 0x4ea <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	08 95       	ret

000004ec <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
const DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     4ec:	70 e0       	ldi	r23, 0x00	; 0
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	86 0f       	add	r24, r22
     4f4:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     4f6:	fc 01       	movw	r30, r24
     4f8:	80 81       	ld	r24, Z
     4fa:	91 81       	ldd	r25, Z+1	; 0x01
     4fc:	08 95       	ret

000004fe <__vector_18>:
ISR(USART0_RX_vect)
{
     4fe:	1f 92       	push	r1
     500:	0f 92       	push	r0
     502:	0f b6       	in	r0, 0x3f	; 63
     504:	0f 92       	push	r0
     506:	11 24       	eor	r1, r1
     508:	0b b6       	in	r0, 0x3b	; 59
     50a:	0f 92       	push	r0
     50c:	2f 93       	push	r18
     50e:	3f 93       	push	r19
     510:	4f 93       	push	r20
     512:	5f 93       	push	r21
     514:	6f 93       	push	r22
     516:	7f 93       	push	r23
     518:	8f 93       	push	r24
     51a:	9f 93       	push	r25
     51c:	af 93       	push	r26
     51e:	bf 93       	push	r27
     520:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     522:	ff 93       	push	r31
     524:	6a df       	rcall	.-300    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     526:	6c b1       	in	r22, 0x0c	; 12
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	dc 01       	movw	r26, r24
     52c:	16 96       	adiw	r26, 0x06	; 6
     52e:	ed 91       	ld	r30, X+
     530:	fc 91       	ld	r31, X
     532:	17 97       	sbiw	r26, 0x07	; 7
     534:	80 e0       	ldi	r24, 0x00	; 0
}
     536:	09 95       	icall
     538:	ff 91       	pop	r31
     53a:	ef 91       	pop	r30
     53c:	bf 91       	pop	r27
     53e:	af 91       	pop	r26
     540:	9f 91       	pop	r25
     542:	8f 91       	pop	r24
     544:	7f 91       	pop	r23
     546:	6f 91       	pop	r22
     548:	5f 91       	pop	r21
     54a:	4f 91       	pop	r20
     54c:	3f 91       	pop	r19
     54e:	2f 91       	pop	r18
     550:	0f 90       	pop	r0
     552:	0b be       	out	0x3b, r0	; 59
     554:	0f 90       	pop	r0
     556:	0f be       	out	0x3f, r0	; 63
     558:	0f 90       	pop	r0
     55a:	1f 90       	pop	r1
     55c:	18 95       	reti

0000055e <__vector_30>:
ISR(USART1_RX_vect)
{
     55e:	1f 92       	push	r1
     560:	0f 92       	push	r0
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	0f 92       	push	r0
     566:	11 24       	eor	r1, r1
     568:	0b b6       	in	r0, 0x3b	; 59
     56a:	0f 92       	push	r0
     56c:	2f 93       	push	r18
     56e:	3f 93       	push	r19
     570:	4f 93       	push	r20
     572:	5f 93       	push	r21
     574:	6f 93       	push	r22
     576:	7f 93       	push	r23
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
     57c:	af 93       	push	r26
     57e:	bf 93       	push	r27
     580:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     582:	ff 93       	push	r31
     584:	3a df       	rcall	.-396    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     586:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	dc 01       	movw	r26, r24
     58e:	18 96       	adiw	r26, 0x08	; 8
     590:	ed 91       	ld	r30, X+
     592:	fc 91       	ld	r31, X
     594:	19 97       	sbiw	r26, 0x09	; 9
     596:	81 e0       	ldi	r24, 0x01	; 1
}
     598:	09 95       	icall
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	bf 91       	pop	r27
     5a0:	af 91       	pop	r26
     5a2:	9f 91       	pop	r25
     5a4:	8f 91       	pop	r24
     5a6:	7f 91       	pop	r23
     5a8:	6f 91       	pop	r22
     5aa:	5f 91       	pop	r21
     5ac:	4f 91       	pop	r20
     5ae:	3f 91       	pop	r19
     5b0:	2f 91       	pop	r18
     5b2:	0f 90       	pop	r0
     5b4:	0b be       	out	0x3b, r0	; 59
     5b6:	0f 90       	pop	r0
     5b8:	0f be       	out	0x3f, r0	; 63
     5ba:	0f 90       	pop	r0
     5bc:	1f 90       	pop	r1
     5be:	18 95       	reti

000005c0 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     5c0:	1f 92       	push	r1
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	0f 92       	push	r0
     5c8:	11 24       	eor	r1, r1
     5ca:	0b b6       	in	r0, 0x3b	; 59
     5cc:	0f 92       	push	r0
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,0);
     5e4:	ff 93       	push	r31
     5e6:	09 df       	rcall	.-494    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     5e8:	dc 01       	movw	r26, r24
     5ea:	1a 96       	adiw	r26, 0x0a	; 10
     5ec:	ed 91       	ld	r30, X+
     5ee:	fc 91       	ld	r31, X
     5f0:	1b 97       	sbiw	r26, 0x0b	; 11
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	82 e0       	ldi	r24, 0x02	; 2
     5f8:	09 95       	icall
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	bf 91       	pop	r27
     600:	af 91       	pop	r26
     602:	9f 91       	pop	r25
     604:	8f 91       	pop	r24
     606:	7f 91       	pop	r23
     608:	6f 91       	pop	r22
     60a:	5f 91       	pop	r21
     60c:	4f 91       	pop	r20
     60e:	3f 91       	pop	r19
     610:	2f 91       	pop	r18
     612:	0f 90       	pop	r0
     614:	0b be       	out	0x3b, r0	; 59
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0
     61c:	1f 90       	pop	r1
     61e:	18 95       	reti

00000620 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:
{
	return malloc(size);
}
void Timer::operator delete(void* ptr)
{
	free(ptr);
     620:	08 95       	ret

00000622 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
     622:	08 95       	ret

00000624 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
     624:	08 95       	ret

00000626 <_ZN5Timer11Device_InitEv>:
     626:	80 e4       	ldi	r24, 0x40	; 64
     628:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
     632:	88 e0       	ldi	r24, 0x08	; 8
     634:	9d e3       	ldi	r25, 0x3D	; 61
     636:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     63a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     63e:	82 e0       	ldi	r24, 0x02	; 2
     640:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     644:	08 95       	ret

00000646 <_ZN5TimerC1Ev>:
     646:	2b e0       	ldi	r18, 0x0B	; 11
     648:	31 e0       	ldi	r19, 0x01	; 1
     64a:	fc 01       	movw	r30, r24
     64c:	31 83       	std	Z+1, r19	; 0x01
     64e:	20 83       	st	Z, r18
     650:	08 95       	ret

00000652 <_ZN5TimernwEj>:
     652:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <pvPortMalloc>
     656:	08 95       	ret

00000658 <_GLOBAL__sub_I_dev1>:
 *
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"
Dev_Manager dev1;
     658:	82 e9       	ldi	r24, 0x92	; 146
     65a:	91 e0       	ldi	r25, 0x01	; 1
     65c:	b8 ce       	rjmp	.-656    	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     65e:	08 95       	ret

00000660 <_GLOBAL__sub_D_dev1>:
     660:	82 e9       	ldi	r24, 0x92	; 146
     662:	91 e0       	ldi	r25, 0x01	; 1
     664:	c5 ce       	rjmp	.-630    	; 0x3f0 <_ZN11Dev_ManagerD1Ev>
     666:	08 95       	ret

00000668 <_ZN11RS485Driver11Device_InitEv>:
	//PORTF=0X00;	//RS485 rx Enable
}

void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	ec 01       	movw	r28, r24
     66e:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     672:	88 e9       	ldi	r24, 0x98	; 152
     674:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     678:	86 e0       	ldi	r24, 0x06	; 6
     67a:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     67e:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     682:	87 e6       	ldi	r24, 0x67	; 103
     684:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     688:	81 e0       	ldi	r24, 0x01	; 1
     68a:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <xQueueCreateMutex>
     68e:	9d 83       	std	Y+5, r25	; 0x05
     690:	8c 83       	std	Y+4, r24	; 0x04
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <xQueueCreateMutex>
     698:	9b 83       	std	Y+3, r25	; 0x03
     69a:	8a 83       	std	Y+2, r24	; 0x02
     69c:	df 91       	pop	r29
     69e:	cf 91       	pop	r28
     6a0:	08 95       	ret

000006a2 <_ZN11RS485DriverC1Ev>:
     6a2:	27 e1       	ldi	r18, 0x17	; 23
     6a4:	31 e0       	ldi	r19, 0x01	; 1
     6a6:	fc 01       	movw	r30, r24
     6a8:	31 83       	std	Z+1, r19	; 0x01
     6aa:	20 83       	st	Z, r18
     6ac:	20 91 9e 01 	lds	r18, 0x019E	; 0x80019e <_ZN11RS485Driver4instE>
     6b0:	30 91 9f 01 	lds	r19, 0x019F	; 0x80019f <_ZN11RS485Driver4instE+0x1>
     6b4:	23 2b       	or	r18, r19
     6b6:	21 f4       	brne	.+8      	; 0x6c0 <_ZN11RS485DriverC1Ev+0x1e>
     6b8:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <_ZN11RS485Driver4instE+0x1>
     6bc:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <_ZN11RS485Driver4instE>
     6c0:	08 95       	ret

000006c2 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     6c2:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <pvPortMalloc>
}
     6c6:	08 95       	ret

000006c8 <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	ec 01       	movw	r28, r24
     6d0:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	44 e6       	ldi	r20, 0x64	; 100
     6d6:	50 e0       	ldi	r21, 0x00	; 0
     6d8:	60 e0       	ldi	r22, 0x00	; 0
     6da:	70 e0       	ldi	r23, 0x00	; 0
     6dc:	8a 81       	ldd	r24, Y+2	; 0x02
     6de:	9b 81       	ldd	r25, Y+3	; 0x03
     6e0:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <xQueueGenericReceive>
     6e4:	81 30       	cpi	r24, 0x01	; 1
     6e6:	81 f4       	brne	.+32     	; 0x708 <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     6e8:	eb e9       	ldi	r30, 0x9B	; 155
     6ea:	f0 e0       	ldi	r31, 0x00	; 0
     6ec:	80 81       	ld	r24, Z
     6ee:	85 ff       	sbrs	r24, 5
     6f0:	fd cf       	rjmp	.-6      	; 0x6ec <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     6f2:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     6f6:	20 e0       	ldi	r18, 0x00	; 0
     6f8:	40 e0       	ldi	r20, 0x00	; 0
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	60 e0       	ldi	r22, 0x00	; 0
     6fe:	70 e0       	ldi	r23, 0x00	; 0
     700:	8a 81       	ldd	r24, Y+2	; 0x02
     702:	9b 81       	ldd	r25, Y+3	; 0x03
     704:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <xQueueGenericSend>
	}
}
     708:	df 91       	pop	r29
     70a:	cf 91       	pop	r28
     70c:	1f 91       	pop	r17
     70e:	08 95       	ret

00000710 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     710:	db cf       	rjmp	.-74     	; 0x6c8 <_ZN11RS485Driver12UART_PutcharEc>
     712:	08 95       	ret

00000714 <_ZN11RS485Driver14UART_PutStringEPKc>:
     714:	0f 93       	push	r16
     716:	1f 93       	push	r17
     718:	cf 93       	push	r28
     71a:	df 93       	push	r29
     71c:	8c 01       	movw	r16, r24
     71e:	eb 01       	movw	r28, r22
     720:	20 e0       	ldi	r18, 0x00	; 0
     722:	44 e6       	ldi	r20, 0x64	; 100
     724:	50 e0       	ldi	r21, 0x00	; 0
     726:	60 e0       	ldi	r22, 0x00	; 0
     728:	70 e0       	ldi	r23, 0x00	; 0
     72a:	fc 01       	movw	r30, r24
     72c:	84 81       	ldd	r24, Z+4	; 0x04
     72e:	95 81       	ldd	r25, Z+5	; 0x05
     730:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <xQueueGenericReceive>
     734:	81 30       	cpi	r24, 0x01	; 1
     736:	99 f4       	brne	.+38     	; 0x75e <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     738:	68 81       	ld	r22, Y
     73a:	66 23       	and	r22, r22
     73c:	31 f0       	breq	.+12     	; 0x74a <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     73e:	21 96       	adiw	r28, 0x01	; 1
     740:	c8 01       	movw	r24, r16
     742:	c2 df       	rcall	.-124    	; 0x6c8 <_ZN11RS485Driver12UART_PutcharEc>
     744:	69 91       	ld	r22, Y+
     746:	61 11       	cpse	r22, r1
     748:	fb cf       	rjmp	.-10     	; 0x740 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     74a:	20 e0       	ldi	r18, 0x00	; 0
     74c:	40 e0       	ldi	r20, 0x00	; 0
     74e:	50 e0       	ldi	r21, 0x00	; 0
     750:	60 e0       	ldi	r22, 0x00	; 0
     752:	70 e0       	ldi	r23, 0x00	; 0
     754:	f8 01       	movw	r30, r16
     756:	84 81       	ldd	r24, Z+4	; 0x04
     758:	95 81       	ldd	r25, Z+5	; 0x05
     75a:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <xQueueGenericSend>
     75e:	df 91       	pop	r29
     760:	cf 91       	pop	r28
     762:	1f 91       	pop	r17
     764:	0f 91       	pop	r16
     766:	08 95       	ret

00000768 <_ZN11RS485Driver13Device_WritesEPKc>:
     768:	d5 cf       	rjmp	.-86     	; 0x714 <_ZN11RS485Driver14UART_PutStringEPKc>
     76a:	08 95       	ret

0000076c <_ZN10UartDriver11Device_InitEv>:

}

void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     76c:	cf 93       	push	r28
     76e:	df 93       	push	r29
     770:	ec 01       	movw	r28, r24
     772:	88 e9       	ldi	r24, 0x98	; 152
     774:	8a b9       	out	0x0a, r24	; 10
     776:	86 e0       	ldi	r24, 0x06	; 6
     778:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     77c:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     780:	8f ec       	ldi	r24, 0xCF	; 207
     782:	89 b9       	out	0x09, r24	; 9
     784:	81 e0       	ldi	r24, 0x01	; 1
     786:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <xQueueCreateMutex>
     78a:	9d 83       	std	Y+5, r25	; 0x05
     78c:	8c 83       	std	Y+4, r24	; 0x04
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <xQueueCreateMutex>
     794:	9b 83       	std	Y+3, r25	; 0x03
     796:	8a 83       	std	Y+2, r24	; 0x02
     798:	df 91       	pop	r29
     79a:	cf 91       	pop	r28
     79c:	08 95       	ret

0000079e <_ZN10UartDriverC1Ev>:
     79e:	23 e2       	ldi	r18, 0x23	; 35
     7a0:	31 e0       	ldi	r19, 0x01	; 1
     7a2:	fc 01       	movw	r30, r24
     7a4:	31 83       	std	Z+1, r19	; 0x01
     7a6:	20 83       	st	Z, r18
     7a8:	20 91 a0 01 	lds	r18, 0x01A0	; 0x8001a0 <_ZN10UartDriver4instE>
     7ac:	30 91 a1 01 	lds	r19, 0x01A1	; 0x8001a1 <_ZN10UartDriver4instE+0x1>
     7b0:	23 2b       	or	r18, r19
     7b2:	21 f4       	brne	.+8      	; 0x7bc <_ZN10UartDriverC1Ev+0x1e>
     7b4:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <_ZN10UartDriver4instE+0x1>
     7b8:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <_ZN10UartDriver4instE>
     7bc:	08 95       	ret

000007be <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     7be:	0c 94 f2 0b 	jmp	0x17e4	; 0x17e4 <pvPortMalloc>
}
     7c2:	08 95       	ret

000007c4 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     7c4:	1f 93       	push	r17
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	ec 01       	movw	r28, r24
     7cc:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     7ce:	20 e0       	ldi	r18, 0x00	; 0
     7d0:	44 e6       	ldi	r20, 0x64	; 100
     7d2:	50 e0       	ldi	r21, 0x00	; 0
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	8a 81       	ldd	r24, Y+2	; 0x02
     7da:	9b 81       	ldd	r25, Y+3	; 0x03
     7dc:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <xQueueGenericReceive>
     7e0:	81 30       	cpi	r24, 0x01	; 1
     7e2:	61 f4       	brne	.+24     	; 0x7fc <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     7e4:	5d 9b       	sbis	0x0b, 5	; 11
     7e6:	fe cf       	rjmp	.-4      	; 0x7e4 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     7e8:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	40 e0       	ldi	r20, 0x00	; 0
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	8a 81       	ldd	r24, Y+2	; 0x02
     7f6:	9b 81       	ldd	r25, Y+3	; 0x03
     7f8:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <xQueueGenericSend>
	}
}
     7fc:	df 91       	pop	r29
     7fe:	cf 91       	pop	r28
     800:	1f 91       	pop	r17
     802:	08 95       	ret

00000804 <_ZN10UartDriver12Device_WriteEc>:
     804:	df cf       	rjmp	.-66     	; 0x7c4 <_ZN10UartDriver12UART_PutcharEc>
     806:	08 95       	ret

00000808 <_ZN10UartDriver14UART_PutStringEPKc>:
     808:	0f 93       	push	r16
     80a:	1f 93       	push	r17
     80c:	cf 93       	push	r28
     80e:	df 93       	push	r29
     810:	8c 01       	movw	r16, r24
     812:	eb 01       	movw	r28, r22
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	44 e6       	ldi	r20, 0x64	; 100
     818:	50 e0       	ldi	r21, 0x00	; 0
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	70 e0       	ldi	r23, 0x00	; 0
     81e:	fc 01       	movw	r30, r24
     820:	84 81       	ldd	r24, Z+4	; 0x04
     822:	95 81       	ldd	r25, Z+5	; 0x05
     824:	0e 94 d0 0f 	call	0x1fa0	; 0x1fa0 <xQueueGenericReceive>
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	99 f4       	brne	.+38     	; 0x852 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     82c:	68 81       	ld	r22, Y
     82e:	66 23       	and	r22, r22
     830:	31 f0       	breq	.+12     	; 0x83e <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     832:	21 96       	adiw	r28, 0x01	; 1
     834:	c8 01       	movw	r24, r16
     836:	c6 df       	rcall	.-116    	; 0x7c4 <_ZN10UartDriver12UART_PutcharEc>
     838:	69 91       	ld	r22, Y+
     83a:	61 11       	cpse	r22, r1
     83c:	fb cf       	rjmp	.-10     	; 0x834 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     83e:	20 e0       	ldi	r18, 0x00	; 0
     840:	40 e0       	ldi	r20, 0x00	; 0
     842:	50 e0       	ldi	r21, 0x00	; 0
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	f8 01       	movw	r30, r16
     84a:	84 81       	ldd	r24, Z+4	; 0x04
     84c:	95 81       	ldd	r25, Z+5	; 0x05
     84e:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <xQueueGenericSend>
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	0f 91       	pop	r16
     85a:	08 95       	ret

0000085c <_ZN10UartDriver13Device_WritesEPKc>:
     85c:	d5 cf       	rjmp	.-86     	; 0x808 <_ZN10UartDriver14UART_PutStringEPKc>
     85e:	08 95       	ret

00000860 <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     860:	c0 98       	cbi	0x18, 0	; 24
     862:	96 2f       	mov	r25, r22
     864:	6f 71       	andi	r22, 0x1F	; 31
     866:	86 2b       	or	r24, r22
     868:	8f b9       	out	0x0f, r24	; 15
     86a:	77 9b       	sbis	0x0e, 7	; 14
     86c:	fe cf       	rjmp	.-4      	; 0x86a <_Z14enc28j60ReadOphh+0xa>
     86e:	1f b8       	out	0x0f, r1	; 15
     870:	77 9b       	sbis	0x0e, 7	; 14
     872:	fe cf       	rjmp	.-4      	; 0x870 <_Z14enc28j60ReadOphh+0x10>
     874:	99 23       	and	r25, r25
     876:	1c f4       	brge	.+6      	; 0x87e <_Z14enc28j60ReadOphh+0x1e>
     878:	1f b8       	out	0x0f, r1	; 15
     87a:	77 9b       	sbis	0x0e, 7	; 14
     87c:	fe cf       	rjmp	.-4      	; 0x87a <_Z14enc28j60ReadOphh+0x1a>
     87e:	c0 9a       	sbi	0x18, 0	; 24
     880:	8f b1       	in	r24, 0x0f	; 15
     882:	08 95       	ret

00000884 <_Z15enc28j60WriteOphhh>:
     884:	c0 98       	cbi	0x18, 0	; 24
     886:	6f 71       	andi	r22, 0x1F	; 31
     888:	86 2b       	or	r24, r22
     88a:	8f b9       	out	0x0f, r24	; 15
     88c:	77 9b       	sbis	0x0e, 7	; 14
     88e:	fe cf       	rjmp	.-4      	; 0x88c <_Z15enc28j60WriteOphhh+0x8>
     890:	4f b9       	out	0x0f, r20	; 15
     892:	77 9b       	sbis	0x0e, 7	; 14
     894:	fe cf       	rjmp	.-4      	; 0x892 <_Z15enc28j60WriteOphhh+0xe>
     896:	c0 9a       	sbi	0x18, 0	; 24
     898:	08 95       	ret

0000089a <_Z18enc28j60ReadBufferjPh>:
     89a:	fb 01       	movw	r30, r22
     89c:	c0 98       	cbi	0x18, 0	; 24
     89e:	2a e3       	ldi	r18, 0x3A	; 58
     8a0:	2f b9       	out	0x0f, r18	; 15
     8a2:	77 9b       	sbis	0x0e, 7	; 14
     8a4:	fe cf       	rjmp	.-4      	; 0x8a2 <_Z18enc28j60ReadBufferjPh+0x8>
     8a6:	00 97       	sbiw	r24, 0x00	; 0
     8a8:	61 f0       	breq	.+24     	; 0x8c2 <_Z18enc28j60ReadBufferjPh+0x28>
     8aa:	df 01       	movw	r26, r30
     8ac:	a8 0f       	add	r26, r24
     8ae:	b9 1f       	adc	r27, r25
     8b0:	1f b8       	out	0x0f, r1	; 15
     8b2:	77 9b       	sbis	0x0e, 7	; 14
     8b4:	fe cf       	rjmp	.-4      	; 0x8b2 <_Z18enc28j60ReadBufferjPh+0x18>
     8b6:	9f b1       	in	r25, 0x0f	; 15
     8b8:	91 93       	st	Z+, r25
     8ba:	ae 17       	cp	r26, r30
     8bc:	bf 07       	cpc	r27, r31
     8be:	c1 f7       	brne	.-16     	; 0x8b0 <_Z18enc28j60ReadBufferjPh+0x16>
     8c0:	01 c0       	rjmp	.+2      	; 0x8c4 <_Z18enc28j60ReadBufferjPh+0x2a>
     8c2:	df 01       	movw	r26, r30
     8c4:	1c 92       	st	X, r1
     8c6:	c0 9a       	sbi	0x18, 0	; 24
     8c8:	08 95       	ret

000008ca <_Z19enc28j60WriteBufferjPh>:
     8ca:	fb 01       	movw	r30, r22
     8cc:	c0 98       	cbi	0x18, 0	; 24
     8ce:	2a e7       	ldi	r18, 0x7A	; 122
     8d0:	2f b9       	out	0x0f, r18	; 15
     8d2:	77 9b       	sbis	0x0e, 7	; 14
     8d4:	fe cf       	rjmp	.-4      	; 0x8d2 <_Z19enc28j60WriteBufferjPh+0x8>
     8d6:	00 97       	sbiw	r24, 0x00	; 0
     8d8:	61 f0       	breq	.+24     	; 0x8f2 <_Z19enc28j60WriteBufferjPh+0x28>
     8da:	9f 01       	movw	r18, r30
     8dc:	28 0f       	add	r18, r24
     8de:	39 1f       	adc	r19, r25
     8e0:	03 c0       	rjmp	.+6      	; 0x8e8 <_Z19enc28j60WriteBufferjPh+0x1e>
     8e2:	2e 17       	cp	r18, r30
     8e4:	3f 07       	cpc	r19, r31
     8e6:	29 f0       	breq	.+10     	; 0x8f2 <_Z19enc28j60WriteBufferjPh+0x28>
     8e8:	91 91       	ld	r25, Z+
     8ea:	9f b9       	out	0x0f, r25	; 15
     8ec:	77 9b       	sbis	0x0e, 7	; 14
     8ee:	fe cf       	rjmp	.-4      	; 0x8ec <_Z19enc28j60WriteBufferjPh+0x22>
     8f0:	f8 cf       	rjmp	.-16     	; 0x8e2 <_Z19enc28j60WriteBufferjPh+0x18>
     8f2:	c0 9a       	sbi	0x18, 0	; 24
     8f4:	08 95       	ret

000008f6 <_Z15enc28j60SetBankh>:
     8f6:	1f 93       	push	r17
     8f8:	cf 93       	push	r28
     8fa:	df 93       	push	r29
     8fc:	18 2f       	mov	r17, r24
     8fe:	10 76       	andi	r17, 0x60	; 96
     900:	c1 2f       	mov	r28, r17
     902:	d0 e0       	ldi	r29, 0x00	; 0
     904:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <_ZL12Enc28j60Bank>
     908:	90 e0       	ldi	r25, 0x00	; 0
     90a:	c8 17       	cp	r28, r24
     90c:	d9 07       	cpc	r29, r25
     90e:	a1 f0       	breq	.+40     	; 0x938 <_Z15enc28j60SetBankh+0x42>
     910:	43 e0       	ldi	r20, 0x03	; 3
     912:	6f e1       	ldi	r22, 0x1F	; 31
     914:	80 ea       	ldi	r24, 0xA0	; 160
     916:	b6 df       	rcall	.-148    	; 0x884 <_Z15enc28j60WriteOphhh>
     918:	ae 01       	movw	r20, r28
     91a:	55 95       	asr	r21
     91c:	47 95       	ror	r20
     91e:	55 95       	asr	r21
     920:	47 95       	ror	r20
     922:	55 95       	asr	r21
     924:	47 95       	ror	r20
     926:	55 95       	asr	r21
     928:	47 95       	ror	r20
     92a:	55 95       	asr	r21
     92c:	47 95       	ror	r20
     92e:	6f e1       	ldi	r22, 0x1F	; 31
     930:	80 e8       	ldi	r24, 0x80	; 128
     932:	a8 df       	rcall	.-176    	; 0x884 <_Z15enc28j60WriteOphhh>
     934:	10 93 a4 01 	sts	0x01A4, r17	; 0x8001a4 <_ZL12Enc28j60Bank>
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	1f 91       	pop	r17
     93e:	08 95       	ret

00000940 <_Z12enc28j60Readh>:
     940:	cf 93       	push	r28
     942:	c8 2f       	mov	r28, r24
     944:	d8 df       	rcall	.-80     	; 0x8f6 <_Z15enc28j60SetBankh>
     946:	6c 2f       	mov	r22, r28
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	8a df       	rcall	.-236    	; 0x860 <_Z14enc28j60ReadOphh>
     94c:	cf 91       	pop	r28
     94e:	08 95       	ret

00000950 <_Z13enc28j60Writehh>:
     950:	cf 93       	push	r28
     952:	df 93       	push	r29
     954:	c8 2f       	mov	r28, r24
     956:	d6 2f       	mov	r29, r22
     958:	ce df       	rcall	.-100    	; 0x8f6 <_Z15enc28j60SetBankh>
     95a:	4d 2f       	mov	r20, r29
     95c:	6c 2f       	mov	r22, r28
     95e:	80 e4       	ldi	r24, 0x40	; 64
     960:	91 df       	rcall	.-222    	; 0x884 <_Z15enc28j60WriteOphhh>
     962:	df 91       	pop	r29
     964:	cf 91       	pop	r28
     966:	08 95       	ret

00000968 <_Z16enc28j60PhyWritehj>:
     968:	cf 93       	push	r28
     96a:	df 93       	push	r29
     96c:	d6 2f       	mov	r29, r22
     96e:	c7 2f       	mov	r28, r23
     970:	68 2f       	mov	r22, r24
     972:	84 ed       	ldi	r24, 0xD4	; 212
     974:	ed df       	rcall	.-38     	; 0x950 <_Z13enc28j60Writehh>
     976:	6d 2f       	mov	r22, r29
     978:	86 ed       	ldi	r24, 0xD6	; 214
     97a:	ea df       	rcall	.-44     	; 0x950 <_Z13enc28j60Writehh>
     97c:	6c 2f       	mov	r22, r28
     97e:	87 ed       	ldi	r24, 0xD7	; 215
     980:	e7 df       	rcall	.-50     	; 0x950 <_Z13enc28j60Writehh>
     982:	8a ee       	ldi	r24, 0xEA	; 234
     984:	dd df       	rcall	.-70     	; 0x940 <_Z12enc28j60Readh>
     986:	80 ff       	sbrs	r24, 0
     988:	04 c0       	rjmp	.+8      	; 0x992 <_Z16enc28j60PhyWritehj+0x2a>
     98a:	85 e0       	ldi	r24, 0x05	; 5
     98c:	8a 95       	dec	r24
     98e:	f1 f7       	brne	.-4      	; 0x98c <_Z16enc28j60PhyWritehj+0x24>
     990:	f8 cf       	rjmp	.-16     	; 0x982 <_Z16enc28j60PhyWritehj+0x1a>
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	08 95       	ret

00000998 <_Z14enc28j60clkouth>:
     998:	68 2f       	mov	r22, r24
     99a:	67 70       	andi	r22, 0x07	; 7
     99c:	85 e7       	ldi	r24, 0x75	; 117
     99e:	d8 cf       	rjmp	.-80     	; 0x950 <_Z13enc28j60Writehh>
     9a0:	08 95       	ret

000009a2 <_Z12enc28j60InitPh>:
     9a2:	cf 93       	push	r28
     9a4:	df 93       	push	r29
     9a6:	ec 01       	movw	r28, r24
     9a8:	b8 9a       	sbi	0x17, 0	; 23
     9aa:	c0 9a       	sbi	0x18, 0	; 24
     9ac:	a6 d2       	rcall	.+1356   	; 0xefa <_Z8spi_initv>
     9ae:	4f ef       	ldi	r20, 0xFF	; 255
     9b0:	60 e0       	ldi	r22, 0x00	; 0
     9b2:	8f ef       	ldi	r24, 0xFF	; 255
     9b4:	67 df       	rcall	.-306    	; 0x884 <_Z15enc28j60WriteOphhh>
     9b6:	82 e3       	ldi	r24, 0x32	; 50
     9b8:	90 e0       	ldi	r25, 0x00	; 0
     9ba:	a9 d2       	rcall	.+1362   	; 0xf0e <_Z8delay_msj>
     9bc:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
     9c0:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <_ZL13NextPacketPtr>
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	88 e0       	ldi	r24, 0x08	; 8
     9c8:	c3 df       	rcall	.-122    	; 0x950 <_Z13enc28j60Writehh>
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	89 e0       	ldi	r24, 0x09	; 9
     9ce:	c0 df       	rcall	.-128    	; 0x950 <_Z13enc28j60Writehh>
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	8c e0       	ldi	r24, 0x0C	; 12
     9d4:	bd df       	rcall	.-134    	; 0x950 <_Z13enc28j60Writehh>
     9d6:	60 e0       	ldi	r22, 0x00	; 0
     9d8:	8d e0       	ldi	r24, 0x0D	; 13
     9da:	ba df       	rcall	.-140    	; 0x950 <_Z13enc28j60Writehh>
     9dc:	6e ef       	ldi	r22, 0xFE	; 254
     9de:	8a e0       	ldi	r24, 0x0A	; 10
     9e0:	b7 df       	rcall	.-146    	; 0x950 <_Z13enc28j60Writehh>
     9e2:	69 e1       	ldi	r22, 0x19	; 25
     9e4:	8b e0       	ldi	r24, 0x0B	; 11
     9e6:	b4 df       	rcall	.-152    	; 0x950 <_Z13enc28j60Writehh>
     9e8:	6f ef       	ldi	r22, 0xFF	; 255
     9ea:	84 e0       	ldi	r24, 0x04	; 4
     9ec:	b1 df       	rcall	.-158    	; 0x950 <_Z13enc28j60Writehh>
     9ee:	69 e1       	ldi	r22, 0x19	; 25
     9f0:	85 e0       	ldi	r24, 0x05	; 5
     9f2:	ae df       	rcall	.-164    	; 0x950 <_Z13enc28j60Writehh>
     9f4:	6f ef       	ldi	r22, 0xFF	; 255
     9f6:	86 e0       	ldi	r24, 0x06	; 6
     9f8:	ab df       	rcall	.-170    	; 0x950 <_Z13enc28j60Writehh>
     9fa:	6f e1       	ldi	r22, 0x1F	; 31
     9fc:	87 e0       	ldi	r24, 0x07	; 7
     9fe:	a8 df       	rcall	.-176    	; 0x950 <_Z13enc28j60Writehh>
     a00:	60 eb       	ldi	r22, 0xB0	; 176
     a02:	88 e3       	ldi	r24, 0x38	; 56
     a04:	a5 df       	rcall	.-182    	; 0x950 <_Z13enc28j60Writehh>
     a06:	6f e3       	ldi	r22, 0x3F	; 63
     a08:	88 e2       	ldi	r24, 0x28	; 40
     a0a:	a2 df       	rcall	.-188    	; 0x950 <_Z13enc28j60Writehh>
     a0c:	60 e3       	ldi	r22, 0x30	; 48
     a0e:	89 e2       	ldi	r24, 0x29	; 41
     a10:	9f df       	rcall	.-194    	; 0x950 <_Z13enc28j60Writehh>
     a12:	69 ef       	ldi	r22, 0xF9	; 249
     a14:	80 e3       	ldi	r24, 0x30	; 48
     a16:	9c df       	rcall	.-200    	; 0x950 <_Z13enc28j60Writehh>
     a18:	67 ef       	ldi	r22, 0xF7	; 247
     a1a:	81 e3       	ldi	r24, 0x31	; 49
     a1c:	99 df       	rcall	.-206    	; 0x950 <_Z13enc28j60Writehh>
     a1e:	6d e0       	ldi	r22, 0x0D	; 13
     a20:	80 ec       	ldi	r24, 0xC0	; 192
     a22:	96 df       	rcall	.-212    	; 0x950 <_Z13enc28j60Writehh>
     a24:	60 e0       	ldi	r22, 0x00	; 0
     a26:	81 ec       	ldi	r24, 0xC1	; 193
     a28:	93 df       	rcall	.-218    	; 0x950 <_Z13enc28j60Writehh>
     a2a:	42 e3       	ldi	r20, 0x32	; 50
     a2c:	62 ec       	ldi	r22, 0xC2	; 194
     a2e:	80 e8       	ldi	r24, 0x80	; 128
     a30:	29 df       	rcall	.-430    	; 0x884 <_Z15enc28j60WriteOphhh>
     a32:	62 e1       	ldi	r22, 0x12	; 18
     a34:	86 ec       	ldi	r24, 0xC6	; 198
     a36:	8c df       	rcall	.-232    	; 0x950 <_Z13enc28j60Writehh>
     a38:	6c e0       	ldi	r22, 0x0C	; 12
     a3a:	87 ec       	ldi	r24, 0xC7	; 199
     a3c:	89 df       	rcall	.-238    	; 0x950 <_Z13enc28j60Writehh>
     a3e:	62 e1       	ldi	r22, 0x12	; 18
     a40:	84 ec       	ldi	r24, 0xC4	; 196
     a42:	86 df       	rcall	.-244    	; 0x950 <_Z13enc28j60Writehh>
     a44:	6c ed       	ldi	r22, 0xDC	; 220
     a46:	8a ec       	ldi	r24, 0xCA	; 202
     a48:	83 df       	rcall	.-250    	; 0x950 <_Z13enc28j60Writehh>
     a4a:	65 e0       	ldi	r22, 0x05	; 5
     a4c:	8b ec       	ldi	r24, 0xCB	; 203
     a4e:	80 df       	rcall	.-256    	; 0x950 <_Z13enc28j60Writehh>
     a50:	68 81       	ld	r22, Y
     a52:	84 ee       	ldi	r24, 0xE4	; 228
     a54:	7d df       	rcall	.-262    	; 0x950 <_Z13enc28j60Writehh>
     a56:	69 81       	ldd	r22, Y+1	; 0x01
     a58:	85 ee       	ldi	r24, 0xE5	; 229
     a5a:	7a df       	rcall	.-268    	; 0x950 <_Z13enc28j60Writehh>
     a5c:	6a 81       	ldd	r22, Y+2	; 0x02
     a5e:	82 ee       	ldi	r24, 0xE2	; 226
     a60:	77 df       	rcall	.-274    	; 0x950 <_Z13enc28j60Writehh>
     a62:	6b 81       	ldd	r22, Y+3	; 0x03
     a64:	83 ee       	ldi	r24, 0xE3	; 227
     a66:	74 df       	rcall	.-280    	; 0x950 <_Z13enc28j60Writehh>
     a68:	6c 81       	ldd	r22, Y+4	; 0x04
     a6a:	80 ee       	ldi	r24, 0xE0	; 224
     a6c:	71 df       	rcall	.-286    	; 0x950 <_Z13enc28j60Writehh>
     a6e:	6d 81       	ldd	r22, Y+5	; 0x05
     a70:	81 ee       	ldi	r24, 0xE1	; 225
     a72:	6e df       	rcall	.-292    	; 0x950 <_Z13enc28j60Writehh>
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	71 e0       	ldi	r23, 0x01	; 1
     a78:	80 e1       	ldi	r24, 0x10	; 16
     a7a:	76 df       	rcall	.-276    	; 0x968 <_Z16enc28j60PhyWritehj>
     a7c:	8f e1       	ldi	r24, 0x1F	; 31
     a7e:	3b df       	rcall	.-394    	; 0x8f6 <_Z15enc28j60SetBankh>
     a80:	40 ec       	ldi	r20, 0xC0	; 192
     a82:	6b e1       	ldi	r22, 0x1B	; 27
     a84:	80 e8       	ldi	r24, 0x80	; 128
     a86:	fe de       	rcall	.-516    	; 0x884 <_Z15enc28j60WriteOphhh>
     a88:	44 e0       	ldi	r20, 0x04	; 4
     a8a:	6f e1       	ldi	r22, 0x1F	; 31
     a8c:	80 e8       	ldi	r24, 0x80	; 128
     a8e:	fa de       	rcall	.-524    	; 0x884 <_Z15enc28j60WriteOphhh>
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	08 95       	ret

00000a96 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	cf 93       	push	r28
     a9c:	df 93       	push	r29
     a9e:	ec 01       	movw	r28, r24
     aa0:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     aa2:	6f ef       	ldi	r22, 0xFF	; 255
     aa4:	82 e0       	ldi	r24, 0x02	; 2
     aa6:	54 df       	rcall	.-344    	; 0x950 <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     aa8:	69 e1       	ldi	r22, 0x19	; 25
     aaa:	83 e0       	ldi	r24, 0x03	; 3
     aac:	51 df       	rcall	.-350    	; 0x950 <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     aae:	6c 2f       	mov	r22, r28
     ab0:	61 50       	subi	r22, 0x01	; 1
     ab2:	86 e0       	ldi	r24, 0x06	; 6
     ab4:	4d df       	rcall	.-358    	; 0x950 <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     ab6:	ce 01       	movw	r24, r28
     ab8:	81 50       	subi	r24, 0x01	; 1
     aba:	96 4e       	sbci	r25, 0xE6	; 230
     abc:	69 2f       	mov	r22, r25
     abe:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     ac0:	47 df       	rcall	.-370    	; 0x950 <_Z13enc28j60Writehh>
     ac2:	40 e0       	ldi	r20, 0x00	; 0
     ac4:	60 e0       	ldi	r22, 0x00	; 0
     ac6:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     ac8:	dd de       	rcall	.-582    	; 0x884 <_Z15enc28j60WriteOphhh>
     aca:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     acc:	ce 01       	movw	r24, r28
     ace:	fd de       	rcall	.-518    	; 0x8ca <_Z19enc28j60WriteBufferjPh>
     ad0:	48 e0       	ldi	r20, 0x08	; 8
     ad2:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     ad4:	80 e8       	ldi	r24, 0x80	; 128
     ad6:	d6 de       	rcall	.-596    	; 0x884 <_Z15enc28j60WriteOphhh>
     ad8:	8c e1       	ldi	r24, 0x1C	; 28
     ada:	32 df       	rcall	.-412    	; 0x940 <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     adc:	81 ff       	sbrs	r24, 1
     ade:	04 c0       	rjmp	.+8      	; 0xae8 <_Z18enc28j60PacketSendjPh+0x52>
     ae0:	48 e0       	ldi	r20, 0x08	; 8
     ae2:	6f e1       	ldi	r22, 0x1F	; 31
     ae4:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     ae6:	ce de       	rcall	.-612    	; 0x884 <_Z15enc28j60WriteOphhh>
     ae8:	df 91       	pop	r29
     aea:	cf 91       	pop	r28
     aec:	1f 91       	pop	r17
     aee:	0f 91       	pop	r16
     af0:	08 95       	ret

00000af2 <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     af2:	9f 92       	push	r9
     af4:	af 92       	push	r10
     af6:	bf 92       	push	r11
     af8:	cf 92       	push	r12
     afa:	df 92       	push	r13
     afc:	ef 92       	push	r14
     afe:	ff 92       	push	r15
     b00:	0f 93       	push	r16
     b02:	1f 93       	push	r17
     b04:	cf 93       	push	r28
     b06:	df 93       	push	r29
     b08:	5c 01       	movw	r10, r24
     b0a:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     b0c:	89 e3       	ldi	r24, 0x39	; 57
     b0e:	18 df       	rcall	.-464    	; 0x940 <_Z12enc28j60Readh>
     b10:	88 23       	and	r24, r24
     b12:	09 f4       	brne	.+2      	; 0xb16 <_Z21enc28j60PacketReceivejPh+0x24>
     b14:	45 c0       	rjmp	.+138    	; 0xba0 <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     b16:	60 91 a2 01 	lds	r22, 0x01A2	; 0x8001a2 <_ZL13NextPacketPtr>
     b1a:	c0 91 a3 01 	lds	r28, 0x01A3	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
     b1e:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     b20:	17 df       	rcall	.-466    	; 0x950 <_Z13enc28j60Writehh>
     b22:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b24:	81 e0       	ldi	r24, 0x01	; 1
     b26:	14 df       	rcall	.-472    	; 0x950 <_Z13enc28j60Writehh>
     b28:	60 e0       	ldi	r22, 0x00	; 0
     b2a:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b2c:	99 de       	rcall	.-718    	; 0x860 <_Z14enc28j60ReadOphh>
     b2e:	c8 2f       	mov	r28, r24
     b30:	60 e0       	ldi	r22, 0x00	; 0
     b32:	8a e3       	ldi	r24, 0x3A	; 58
     b34:	95 de       	rcall	.-726    	; 0x860 <_Z14enc28j60ReadOphh>
     b36:	d0 e0       	ldi	r29, 0x00	; 0
     b38:	d8 2b       	or	r29, r24
     b3a:	d0 93 a3 01 	sts	0x01A3, r29	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b3e:	c0 93 a2 01 	sts	0x01A2, r28	; 0x8001a2 <_ZL13NextPacketPtr>
     b42:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b44:	8a e3       	ldi	r24, 0x3A	; 58
     b46:	8c de       	rcall	.-744    	; 0x860 <_Z14enc28j60ReadOphh>
     b48:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b4a:	60 e0       	ldi	r22, 0x00	; 0
     b4c:	8a e3       	ldi	r24, 0x3A	; 58
     b4e:	88 de       	rcall	.-752    	; 0x860 <_Z14enc28j60ReadOphh>
     b50:	98 2e       	mov	r9, r24
     b52:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     b54:	8a e3       	ldi	r24, 0x3A	; 58
     b56:	84 de       	rcall	.-760    	; 0x860 <_Z14enc28j60ReadOphh>
     b58:	c8 2e       	mov	r12, r24
     b5a:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     b5c:	8a e3       	ldi	r24, 0x3A	; 58
     b5e:	80 de       	rcall	.-768    	; 0x860 <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     b60:	c7 fe       	sbrs	r12, 7
     b62:	0f c0       	rjmp	.+30     	; 0xb82 <_Z21enc28j60PacketReceivejPh+0x90>
     b64:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b66:	a8 1a       	sub	r10, r24
     b68:	b1 08       	sbc	r11, r1
     b6a:	10 e0       	ldi	r17, 0x00	; 0
     b6c:	19 29       	or	r17, r9
     b6e:	04 50       	subi	r16, 0x04	; 4
     b70:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     b72:	a0 16       	cp	r10, r16
     b74:	b1 06       	cpc	r11, r17
     b76:	08 f4       	brcc	.+2      	; 0xb7a <_Z21enc28j60PacketReceivejPh+0x88>
     b78:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     b7a:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     b7c:	c8 01       	movw	r24, r16
     b7e:	8d de       	rcall	.-742    	; 0x89a <_Z18enc28j60ReadBufferjPh>
     b80:	02 c0       	rjmp	.+4      	; 0xb86 <_Z21enc28j60PacketReceivejPh+0x94>
     b82:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     b84:	10 e0       	ldi	r17, 0x00	; 0
     b86:	6c 2f       	mov	r22, r28
     b88:	8c e0       	ldi	r24, 0x0C	; 12
     b8a:	e2 de       	rcall	.-572    	; 0x950 <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     b8c:	6d 2f       	mov	r22, r29
     b8e:	8d e0       	ldi	r24, 0x0D	; 13
     b90:	df de       	rcall	.-578    	; 0x950 <_Z13enc28j60Writehh>
     b92:	40 e4       	ldi	r20, 0x40	; 64
     b94:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     b96:	80 e8       	ldi	r24, 0x80	; 128
     b98:	75 de       	rcall	.-790    	; 0x884 <_Z15enc28j60WriteOphhh>
     b9a:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     b9c:	91 2f       	mov	r25, r17
     b9e:	02 c0       	rjmp	.+4      	; 0xba4 <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	df 91       	pop	r29
     ba6:	cf 91       	pop	r28
     ba8:	1f 91       	pop	r17
     baa:	0f 91       	pop	r16
     bac:	ff 90       	pop	r15
     bae:	ef 90       	pop	r14
     bb0:	df 90       	pop	r13
     bb2:	cf 90       	pop	r12
     bb4:	bf 90       	pop	r11
     bb6:	af 90       	pop	r10
     bb8:	9f 90       	pop	r9
     bba:	08 95       	ret

00000bbc <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     bbc:	cf 92       	push	r12
     bbe:	df 92       	push	r13
     bc0:	ef 92       	push	r14
     bc2:	ff 92       	push	r15
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	ec 01       	movw	r28, r24
     bca:	db 01       	movw	r26, r22
     bcc:	41 30       	cpi	r20, 0x01	; 1
     bce:	61 f4       	brne	.+24     	; 0xbe8 <_Z8checksumPhjh+0x2c>
     bd0:	6b 01       	movw	r12, r22
     bd2:	88 e0       	ldi	r24, 0x08	; 8
     bd4:	c8 1a       	sub	r12, r24
     bd6:	d1 08       	sbc	r13, r1
     bd8:	e1 2c       	mov	r14, r1
     bda:	f1 2c       	mov	r15, r1
     bdc:	81 e1       	ldi	r24, 0x11	; 17
     bde:	c8 0e       	add	r12, r24
     be0:	d1 1c       	adc	r13, r1
     be2:	e1 1c       	adc	r14, r1
     be4:	f1 1c       	adc	r15, r1
     be6:	11 c0       	rjmp	.+34     	; 0xc0a <_Z8checksumPhjh+0x4e>
     be8:	42 30       	cpi	r20, 0x02	; 2
     bea:	61 f4       	brne	.+24     	; 0xc04 <_Z8checksumPhjh+0x48>
     bec:	6b 01       	movw	r12, r22
     bee:	88 e0       	ldi	r24, 0x08	; 8
     bf0:	c8 1a       	sub	r12, r24
     bf2:	d1 08       	sbc	r13, r1
     bf4:	e1 2c       	mov	r14, r1
     bf6:	f1 2c       	mov	r15, r1
     bf8:	86 e0       	ldi	r24, 0x06	; 6
     bfa:	c8 0e       	add	r12, r24
     bfc:	d1 1c       	adc	r13, r1
     bfe:	e1 1c       	adc	r14, r1
     c00:	f1 1c       	adc	r15, r1
     c02:	03 c0       	rjmp	.+6      	; 0xc0a <_Z8checksumPhjh+0x4e>
     c04:	c1 2c       	mov	r12, r1
     c06:	d1 2c       	mov	r13, r1
     c08:	76 01       	movw	r14, r12
     c0a:	a2 30       	cpi	r26, 0x02	; 2
     c0c:	b1 05       	cpc	r27, r1
     c0e:	f0 f0       	brcs	.+60     	; 0xc4c <_Z8checksumPhjh+0x90>
     c10:	9d 01       	movw	r18, r26
     c12:	fe 01       	movw	r30, r28
     c14:	40 81       	ld	r20, Z
     c16:	50 e0       	ldi	r21, 0x00	; 0
     c18:	60 e0       	ldi	r22, 0x00	; 0
     c1a:	70 e0       	ldi	r23, 0x00	; 0
     c1c:	76 2f       	mov	r23, r22
     c1e:	65 2f       	mov	r22, r21
     c20:	54 2f       	mov	r21, r20
     c22:	44 27       	eor	r20, r20
     c24:	81 81       	ldd	r24, Z+1	; 0x01
     c26:	48 2b       	or	r20, r24
     c28:	c4 0e       	add	r12, r20
     c2a:	d5 1e       	adc	r13, r21
     c2c:	e6 1e       	adc	r14, r22
     c2e:	f7 1e       	adc	r15, r23
     c30:	32 96       	adiw	r30, 0x02	; 2
     c32:	22 50       	subi	r18, 0x02	; 2
     c34:	31 09       	sbc	r19, r1
     c36:	22 30       	cpi	r18, 0x02	; 2
     c38:	31 05       	cpc	r19, r1
     c3a:	60 f7       	brcc	.-40     	; 0xc14 <_Z8checksumPhjh+0x58>
     c3c:	cd 01       	movw	r24, r26
     c3e:	02 97       	sbiw	r24, 0x02	; 2
     c40:	8e 7f       	andi	r24, 0xFE	; 254
     c42:	02 96       	adiw	r24, 0x02	; 2
     c44:	c8 0f       	add	r28, r24
     c46:	d9 1f       	adc	r29, r25
     c48:	a1 70       	andi	r26, 0x01	; 1
     c4a:	bb 27       	eor	r27, r27
     c4c:	ab 2b       	or	r26, r27
     c4e:	61 f0       	breq	.+24     	; 0xc68 <_Z8checksumPhjh+0xac>
     c50:	88 81       	ld	r24, Y
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	a0 e0       	ldi	r26, 0x00	; 0
     c56:	b0 e0       	ldi	r27, 0x00	; 0
     c58:	ba 2f       	mov	r27, r26
     c5a:	a9 2f       	mov	r26, r25
     c5c:	98 2f       	mov	r25, r24
     c5e:	88 27       	eor	r24, r24
     c60:	c8 0e       	add	r12, r24
     c62:	d9 1e       	adc	r13, r25
     c64:	ea 1e       	adc	r14, r26
     c66:	fb 1e       	adc	r15, r27
     c68:	a7 01       	movw	r20, r14
     c6a:	66 27       	eor	r22, r22
     c6c:	77 27       	eor	r23, r23
     c6e:	41 15       	cp	r20, r1
     c70:	51 05       	cpc	r21, r1
     c72:	61 05       	cpc	r22, r1
     c74:	71 05       	cpc	r23, r1
     c76:	71 f0       	breq	.+28     	; 0xc94 <_Z8checksumPhjh+0xd8>
     c78:	ee 24       	eor	r14, r14
     c7a:	ff 24       	eor	r15, r15
     c7c:	c4 0e       	add	r12, r20
     c7e:	d5 1e       	adc	r13, r21
     c80:	e6 1e       	adc	r14, r22
     c82:	f7 1e       	adc	r15, r23
     c84:	a7 01       	movw	r20, r14
     c86:	66 27       	eor	r22, r22
     c88:	77 27       	eor	r23, r23
     c8a:	41 15       	cp	r20, r1
     c8c:	51 05       	cpc	r21, r1
     c8e:	61 05       	cpc	r22, r1
     c90:	71 05       	cpc	r23, r1
     c92:	91 f7       	brne	.-28     	; 0xc78 <_Z8checksumPhjh+0xbc>
     c94:	c6 01       	movw	r24, r12
     c96:	80 95       	com	r24
     c98:	90 95       	com	r25
     c9a:	df 91       	pop	r29
     c9c:	cf 91       	pop	r28
     c9e:	ff 90       	pop	r15
     ca0:	ef 90       	pop	r14
     ca2:	df 90       	pop	r13
     ca4:	cf 90       	pop	r12
     ca6:	08 95       	ret

00000ca8 <_Z19init_ip_arp_udp_tcpPhS_h>:
     ca8:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     cac:	a6 2f       	mov	r26, r22
     cae:	b7 2f       	mov	r27, r23
     cb0:	e5 ea       	ldi	r30, 0xA5	; 165
     cb2:	f1 e0       	ldi	r31, 0x01	; 1
     cb4:	49 ea       	ldi	r20, 0xA9	; 169
     cb6:	51 e0       	ldi	r21, 0x01	; 1
     cb8:	2d 91       	ld	r18, X+
     cba:	21 93       	st	Z+, r18
     cbc:	e4 17       	cp	r30, r20
     cbe:	f5 07       	cpc	r31, r21
     cc0:	d9 f7       	brne	.-10     	; 0xcb8 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     cc2:	a8 2f       	mov	r26, r24
     cc4:	b9 2f       	mov	r27, r25
     cc6:	e9 ea       	ldi	r30, 0xA9	; 169
     cc8:	f1 e0       	ldi	r31, 0x01	; 1
     cca:	2f ea       	ldi	r18, 0xAF	; 175
     ccc:	31 e0       	ldi	r19, 0x01	; 1
     cce:	8d 91       	ld	r24, X+
     cd0:	81 93       	st	Z+, r24
     cd2:	e2 17       	cp	r30, r18
     cd4:	f3 07       	cpc	r31, r19
     cd6:	d9 f7       	brne	.-10     	; 0xcce <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     cd8:	08 95       	ret

00000cda <_Z25eth_type_is_arp_and_my_ipPhj>:
     cda:	69 32       	cpi	r22, 0x29	; 41
     cdc:	71 05       	cpc	r23, r1
     cde:	c8 f0       	brcs	.+50     	; 0xd12 <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     ce0:	fc 01       	movw	r30, r24
     ce2:	24 85       	ldd	r18, Z+12	; 0x0c
     ce4:	28 30       	cpi	r18, 0x08	; 8
     ce6:	b9 f4       	brne	.+46     	; 0xd16 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     ce8:	25 85       	ldd	r18, Z+13	; 0x0d
     cea:	26 30       	cpi	r18, 0x06	; 6
     cec:	b1 f4       	brne	.+44     	; 0xd1a <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     cee:	36 a1       	ldd	r19, Z+38	; 0x26
     cf0:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <_ZL6ipaddr>
     cf4:	32 13       	cpse	r19, r18
     cf6:	13 c0       	rjmp	.+38     	; 0xd1e <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     cf8:	b7 96       	adiw	r30, 0x27	; 39
     cfa:	a6 ea       	ldi	r26, 0xA6	; 166
     cfc:	b1 e0       	ldi	r27, 0x01	; 1
     cfe:	8a 96       	adiw	r24, 0x2a	; 42
     d00:	31 91       	ld	r19, Z+
     d02:	2d 91       	ld	r18, X+
     d04:	32 13       	cpse	r19, r18
     d06:	0d c0       	rjmp	.+26     	; 0xd22 <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     d08:	e8 17       	cp	r30, r24
     d0a:	f9 07       	cpc	r31, r25
     d0c:	c9 f7       	brne	.-14     	; 0xd00 <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     d0e:	81 e0       	ldi	r24, 0x01	; 1
     d10:	08 95       	ret
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	08 95       	ret
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	08 95       	ret
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	08 95       	ret
     d1e:	80 e0       	ldi	r24, 0x00	; 0
     d20:	08 95       	ret
     d22:	80 e0       	ldi	r24, 0x00	; 0
     d24:	08 95       	ret

00000d26 <_Z24eth_type_is_ip_and_my_ipPhj>:
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	fc 01       	movw	r30, r24
     d2c:	6a 32       	cpi	r22, 0x2A	; 42
     d2e:	71 05       	cpc	r23, r1
     d30:	e0 f0       	brcs	.+56     	; 0xd6a <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     d32:	84 85       	ldd	r24, Z+12	; 0x0c
     d34:	88 30       	cpi	r24, 0x08	; 8
     d36:	d9 f4       	brne	.+54     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     d38:	85 85       	ldd	r24, Z+13	; 0x0d
     d3a:	81 11       	cpse	r24, r1
     d3c:	1a c0       	rjmp	.+52     	; 0xd72 <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     d3e:	96 85       	ldd	r25, Z+14	; 0x0e
     d40:	95 34       	cpi	r25, 0x45	; 69
     d42:	c1 f4       	brne	.+48     	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d44:	26 8d       	ldd	r18, Z+30	; 0x1e
     d46:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <_ZL6ipaddr>
     d4a:	29 13       	cpse	r18, r25
     d4c:	13 c0       	rjmp	.+38     	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d4e:	df 01       	movw	r26, r30
     d50:	5f 96       	adiw	r26, 0x1f	; 31
     d52:	c6 ea       	ldi	r28, 0xA6	; 166
     d54:	d1 e0       	ldi	r29, 0x01	; 1
     d56:	b2 96       	adiw	r30, 0x22	; 34
     d58:	2d 91       	ld	r18, X+
     d5a:	99 91       	ld	r25, Y+
     d5c:	29 13       	cpse	r18, r25
     d5e:	0a c0       	rjmp	.+20     	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d60:	ae 17       	cp	r26, r30
     d62:	bf 07       	cpc	r27, r31
     d64:	c9 f7       	brne	.-14     	; 0xd58 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     d66:	81 e0       	ldi	r24, 0x01	; 1
     d68:	05 c0       	rjmp	.+10     	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	03 c0       	rjmp	.+6      	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	01 c0       	rjmp	.+2      	; 0xd74 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d72:	80 e0       	ldi	r24, 0x00	; 0
     d74:	df 91       	pop	r29
     d76:	cf 91       	pop	r28
     d78:	08 95       	ret

00000d7a <_Z8make_ethPh>:
     d7a:	fc 01       	movw	r30, r24
     d7c:	a9 ea       	ldi	r26, 0xA9	; 169
     d7e:	b1 e0       	ldi	r27, 0x01	; 1
     d80:	9c 01       	movw	r18, r24
     d82:	2a 5f       	subi	r18, 0xFA	; 250
     d84:	3f 4f       	sbci	r19, 0xFF	; 255
     d86:	86 81       	ldd	r24, Z+6	; 0x06
     d88:	81 93       	st	Z+, r24
     d8a:	8d 91       	ld	r24, X+
     d8c:	85 83       	std	Z+5, r24	; 0x05
     d8e:	e2 17       	cp	r30, r18
     d90:	f3 07       	cpc	r31, r19
     d92:	c9 f7       	brne	.-14     	; 0xd86 <_Z8make_ethPh+0xc>
     d94:	08 95       	ret

00000d96 <_Z20fill_ip_hdr_checksumPh>:
     d96:	cf 93       	push	r28
     d98:	df 93       	push	r29
     d9a:	ec 01       	movw	r28, r24
     d9c:	18 8e       	std	Y+24, r1	; 0x18
     d9e:	19 8e       	std	Y+25, r1	; 0x19
     da0:	80 e4       	ldi	r24, 0x40	; 64
     da2:	8c 8b       	std	Y+20, r24	; 0x14
     da4:	1d 8a       	std	Y+21, r1	; 0x15
     da6:	8e 8b       	std	Y+22, r24	; 0x16
     da8:	40 e0       	ldi	r20, 0x00	; 0
     daa:	64 e1       	ldi	r22, 0x14	; 20
     dac:	70 e0       	ldi	r23, 0x00	; 0
     dae:	ce 01       	movw	r24, r28
     db0:	0e 96       	adiw	r24, 0x0e	; 14
     db2:	04 df       	rcall	.-504    	; 0xbbc <_Z8checksumPhjh>
     db4:	98 8f       	std	Y+24, r25	; 0x18
     db6:	89 8f       	std	Y+25, r24	; 0x19
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	08 95       	ret

00000dbe <_Z7make_ipPh>:
     dbe:	ac 01       	movw	r20, r24
     dc0:	a5 ea       	ldi	r26, 0xA5	; 165
     dc2:	b1 e0       	ldi	r27, 0x01	; 1
     dc4:	fc 01       	movw	r30, r24
     dc6:	7a 96       	adiw	r30, 0x1a	; 26
     dc8:	29 ea       	ldi	r18, 0xA9	; 169
     dca:	31 e0       	ldi	r19, 0x01	; 1
     dcc:	90 81       	ld	r25, Z
     dce:	94 83       	std	Z+4, r25	; 0x04
     dd0:	9d 91       	ld	r25, X+
     dd2:	91 93       	st	Z+, r25
     dd4:	a2 17       	cp	r26, r18
     dd6:	b3 07       	cpc	r27, r19
     dd8:	c9 f7       	brne	.-14     	; 0xdcc <_Z7make_ipPh+0xe>
     dda:	ca 01       	movw	r24, r20
     ddc:	dc cf       	rjmp	.-72     	; 0xd96 <_Z20fill_ip_hdr_checksumPh>
     dde:	08 95       	ret

00000de0 <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
     de4:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
     de6:	c9 df       	rcall	.-110    	; 0xd7a <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
     de8:	1c 8a       	std	Y+20, r1	; 0x14
     dea:	82 e0       	ldi	r24, 0x02	; 2
     dec:	8d 8b       	std	Y+21, r24	; 0x15
     dee:	a9 ea       	ldi	r26, 0xA9	; 169
     df0:	b1 e0       	ldi	r27, 0x01	; 1
     df2:	fe 01       	movw	r30, r28
     df4:	76 96       	adiw	r30, 0x16	; 22
     df6:	2f ea       	ldi	r18, 0xAF	; 175
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
     df8:	31 e0       	ldi	r19, 0x01	; 1
     dfa:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
     dfc:	82 87       	std	Z+10, r24	; 0x0a
     dfe:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
     e00:	81 93       	st	Z+, r24
     e02:	a2 17       	cp	r26, r18
     e04:	b3 07       	cpc	r27, r19
     e06:	c9 f7       	brne	.-14     	; 0xdfa <_Z28make_arp_answer_from_requestPh+0x1a>
     e08:	a5 ea       	ldi	r26, 0xA5	; 165
     e0a:	b1 e0       	ldi	r27, 0x01	; 1
     e0c:	fe 01       	movw	r30, r28
     e0e:	7c 96       	adiw	r30, 0x1c	; 28
     e10:	29 ea       	ldi	r18, 0xA9	; 169
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
     e12:	31 e0       	ldi	r19, 0x01	; 1
     e14:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
     e16:	82 87       	std	Z+10, r24	; 0x0a
     e18:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
     e1a:	81 93       	st	Z+, r24
     e1c:	a2 17       	cp	r26, r18
     e1e:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
     e20:	c9 f7       	brne	.-14     	; 0xe14 <_Z28make_arp_answer_from_requestPh+0x34>
     e22:	be 01       	movw	r22, r28
     e24:	8a e2       	ldi	r24, 0x2A	; 42
     e26:	90 e0       	ldi	r25, 0x00	; 0
}
     e28:	36 de       	rcall	.-916    	; 0xa96 <_Z18enc28j60PacketSendjPh>
     e2a:	df 91       	pop	r29
     e2c:	cf 91       	pop	r28
     e2e:	08 95       	ret

00000e30 <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
     e30:	0f 93       	push	r16
     e32:	1f 93       	push	r17
     e34:	cf 93       	push	r28
     e36:	df 93       	push	r29
     e38:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
     e3a:	8b 01       	movw	r16, r22
     e3c:	9e df       	rcall	.-196    	; 0xd7a <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
     e3e:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
     e40:	be df       	rcall	.-132    	; 0xdbe <_Z7make_ipPh>
     e42:	1a a2       	std	Y+34, r1	; 0x22
     e44:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
     e46:	88 3f       	cpi	r24, 0xF8	; 248
     e48:	18 f0       	brcs	.+6      	; 0xe50 <_Z28make_echo_reply_from_requestPhj+0x20>
     e4a:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
     e4c:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
     e4e:	9d a3       	std	Y+37, r25	; 0x25
     e50:	88 5f       	subi	r24, 0xF8	; 248
     e52:	8c a3       	std	Y+36, r24	; 0x24
}
     e54:	be 01       	movw	r22, r28
     e56:	c8 01       	movw	r24, r16
     e58:	1e de       	rcall	.-964    	; 0xa96 <_Z18enc28j60PacketSendjPh>
     e5a:	df 91       	pop	r29
     e5c:	cf 91       	pop	r28
     e5e:	1f 91       	pop	r17
     e60:	0f 91       	pop	r16
     e62:	08 95       	ret

00000e64 <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
     e64:	df 92       	push	r13
     e66:	ef 92       	push	r14
     e68:	ff 92       	push	r15
     e6a:	0f 93       	push	r16
     e6c:	1f 93       	push	r17
     e6e:	cf 93       	push	r28
     e70:	df 93       	push	r29
     e72:	ec 01       	movw	r28, r24
     e74:	d6 2e       	mov	r13, r22
     e76:	e7 2e       	mov	r14, r23
     e78:	04 2f       	mov	r16, r20
     e7a:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
     e7c:	f3 2e       	mov	r15, r19
     e7e:	7d df       	rcall	.-262    	; 0xd7a <_Z8make_ethPh>
     e80:	0d 3d       	cpi	r16, 0xDD	; 221
     e82:	08 f0       	brcs	.+2      	; 0xe86 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
     e84:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
     e86:	18 8a       	std	Y+16, r1	; 0x10
     e88:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
     e8a:	80 0f       	add	r24, r16
     e8c:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
     e8e:	ce 01       	movw	r24, r28
     e90:	96 df       	rcall	.-212    	; 0xdbe <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
     e92:	8a a1       	ldd	r24, Y+34	; 0x22
     e94:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
     e96:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
     e98:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
     e9a:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
     e9c:	1b a3       	std	Y+35, r17	; 0x23
     e9e:	1e a2       	std	Y+38, r1	; 0x26
     ea0:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
     ea2:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
     ea4:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
     ea6:	18 a6       	std	Y+40, r1	; 0x28
     ea8:	19 a6       	std	Y+41, r1	; 0x29
     eaa:	00 23       	and	r16, r16
     eac:	81 f0       	breq	.+32     	; 0xece <_Z27make_udp_reply_from_requestPhPchj+0x6a>
     eae:	ad 2d       	mov	r26, r13
     eb0:	be 2d       	mov	r27, r14
     eb2:	fe 01       	movw	r30, r28
     eb4:	ba 96       	adiw	r30, 0x2a	; 42
     eb6:	2f ef       	ldi	r18, 0xFF	; 255
     eb8:	20 0f       	add	r18, r16
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	25 5d       	subi	r18, 0xD5	; 213
     ebe:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
     ec0:	2c 0f       	add	r18, r28
     ec2:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
     ec4:	9d 91       	ld	r25, X+
     ec6:	91 93       	st	Z+, r25
     ec8:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
     eca:	f3 07       	cpc	r31, r19
     ecc:	d9 f7       	brne	.-10     	; 0xec4 <_Z27make_udp_reply_from_requestPhPchj+0x60>
     ece:	10 e0       	ldi	r17, 0x00	; 0
     ed0:	b8 01       	movw	r22, r16
     ed2:	60 5f       	subi	r22, 0xF0	; 240
     ed4:	7f 4f       	sbci	r23, 0xFF	; 255
     ed6:	41 e0       	ldi	r20, 0x01	; 1
     ed8:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
     eda:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
     edc:	6f de       	rcall	.-802    	; 0xbbc <_Z8checksumPhjh>
     ede:	98 a7       	std	Y+40, r25	; 0x28
     ee0:	89 a7       	std	Y+41, r24	; 0x29
     ee2:	be 01       	movw	r22, r28
}
     ee4:	c8 01       	movw	r24, r16
     ee6:	8a 96       	adiw	r24, 0x2a	; 42
     ee8:	d6 dd       	rcall	.-1108   	; 0xa96 <_Z18enc28j60PacketSendjPh>
     eea:	df 91       	pop	r29
     eec:	cf 91       	pop	r28
     eee:	1f 91       	pop	r17
     ef0:	0f 91       	pop	r16
     ef2:	ff 90       	pop	r15
     ef4:	ef 90       	pop	r14
     ef6:	df 90       	pop	r13
     ef8:	08 95       	ret

00000efa <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
     efa:	87 b3       	in	r24, 0x17	; 23
     efc:	86 60       	ori	r24, 0x06	; 6
     efe:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
     f00:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
     f02:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
     f04:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
     f06:	80 e5       	ldi	r24, 0x50	; 80
     f08:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
     f0a:	70 9a       	sbi	0x0e, 0	; 14
     f0c:	08 95       	ret

00000f0e <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f0e:	00 97       	sbiw	r24, 0x00	; 0
     f10:	41 f0       	breq	.+16     	; 0xf22 <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f12:	ef eb       	ldi	r30, 0xBF	; 191
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	f1 f7       	brne	.-4      	; 0xf16 <_Z8delay_msj+0x8>
     f1a:	00 c0       	rjmp	.+0      	; 0xf1c <_Z8delay_msj+0xe>
     f1c:	00 00       	nop
                _delay_ms(0.96);
                ms--;
     f1e:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f20:	c1 f7       	brne	.-16     	; 0xf12 <_Z8delay_msj+0x4>
     f22:	08 95       	ret

00000f24 <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
     f24:	e8 ec       	ldi	r30, 0xC8	; 200
     f26:	f3 e0       	ldi	r31, 0x03	; 3
     f28:	84 85       	ldd	r24, Z+12	; 0x0c
     f2a:	95 85       	ldd	r25, Z+13	; 0x0d
     f2c:	01 96       	adiw	r24, 0x01	; 1
     f2e:	95 87       	std	Z+13, r25	; 0x0d
     f30:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
     f32:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
     f34:	c6 98       	cbi	0x18, 6	; 24
     f36:	08 95       	ret

00000f38 <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	cd b7       	in	r28, 0x3d	; 61
     f3e:	de b7       	in	r29, 0x3e	; 62
     f40:	a2 97       	sbiw	r28, 0x22	; 34
     f42:	0f b6       	in	r0, 0x3f	; 63
     f44:	f8 94       	cli
     f46:	de bf       	out	0x3e, r29	; 62
     f48:	0f be       	out	0x3f, r0	; 63
     f4a:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
     f4c:	04 ec       	ldi	r16, 0xC4	; 196
     f4e:	13 e0       	ldi	r17, 0x03	; 3
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if(cmp_mem[0] != mem4[IPV4_0] | cmp_mem[1] != mem4[IPV4_1] | cmp_mem[2] != mem4[IPV4_2] | cmp_mem[3] != mem4[IPV4_3])
     f50:	0f 2e       	mov	r0, r31
     f52:	f8 e0       	ldi	r31, 0x08	; 8
     f54:	4f 2e       	mov	r4, r31
     f56:	f4 e0       	ldi	r31, 0x04	; 4
     f58:	5f 2e       	mov	r5, r31
     f5a:	f0 2d       	mov	r31, r0
     f5c:	0f 2e       	mov	r0, r31
     f5e:	fa e0       	ldi	r31, 0x0A	; 10
     f60:	cf 2e       	mov	r12, r31
     f62:	f4 e0       	ldi	r31, 0x04	; 4
     f64:	df 2e       	mov	r13, r31
     f66:	f0 2d       	mov	r31, r0
     f68:	0f 2e       	mov	r0, r31
     f6a:	fc e0       	ldi	r31, 0x0C	; 12
     f6c:	ef 2e       	mov	r14, r31
     f6e:	f4 e0       	ldi	r31, 0x04	; 4
     f70:	ff 2e       	mov	r15, r31
     f72:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
     f74:	ce 01       	movw	r24, r28
     f76:	01 96       	adiw	r24, 0x01	; 1
     f78:	9f 8f       	std	Y+31, r25	; 0x1f
     f7a:	8e 8f       	std	Y+30, r24	; 0x1e
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if(cmp_mem[0] != mem4[IPV4_0] | cmp_mem[1] != mem4[IPV4_1] | cmp_mem[2] != mem4[IPV4_2] | cmp_mem[3] != mem4[IPV4_3])
     f7c:	33 24       	eor	r3, r3
     f7e:	33 94       	inc	r3
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
     f80:	f8 01       	movw	r30, r16
     f82:	80 81       	ld	r24, Z
     f84:	91 81       	ldd	r25, Z+1	; 0x01
     f86:	a2 81       	ldd	r26, Z+2	; 0x02
     f88:	b3 81       	ldd	r27, Z+3	; 0x03
     f8a:	80 93 c0 03 	sts	0x03C0, r24	; 0x8003c0 <_ZZL5proc2PvE4myip>
     f8e:	90 93 c1 03 	sts	0x03C1, r25	; 0x8003c1 <_ZZL5proc2PvE4myip+0x1>
     f92:	a0 93 c2 03 	sts	0x03C2, r26	; 0x8003c2 <_ZZL5proc2PvE4myip+0x2>
     f96:	b0 93 c3 03 	sts	0x03C3, r27	; 0x8003c3 <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
     f9a:	8f ef       	ldi	r24, 0xFF	; 255
     f9c:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
     f9e:	88 bb       	out	0x18, r24	; 24
    char str[30];
	 enc28j60Init(mymac);
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
     fa4:	fe dc       	rcall	.-1540   	; 0x9a2 <_Z12enc28j60InitPh>
     fa6:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
     fa8:	f7 dc       	rcall	.-1554   	; 0x998 <_Z14enc28j60clkouth>
     faa:	8a e0       	ldi	r24, 0x0A	; 10
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
     fb2:	66 e7       	ldi	r22, 0x76	; 118
     fb4:	74 e0       	ldi	r23, 0x04	; 4
     fb6:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
     fb8:	d7 dc       	rcall	.-1618   	; 0x968 <_Z16enc28j60PhyWritehj>
     fba:	84 e1       	ldi	r24, 0x14	; 20
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
     fc2:	40 e5       	ldi	r20, 0x50	; 80
     fc4:	60 ec       	ldi	r22, 0xC0	; 192
     fc6:	73 e0       	ldi	r23, 0x03	; 3
     fc8:	81 e0       	ldi	r24, 0x01	; 1
     fca:	91 e0       	ldi	r25, 0x01	; 1

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
     fcc:	6d de       	rcall	.-806    	; 0xca8 <_Z19init_ip_arp_udp_tcpPhS_h>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if(cmp_mem[0] != mem4[IPV4_0] | cmp_mem[1] != mem4[IPV4_1] | cmp_mem[2] != mem4[IPV4_2] | cmp_mem[3] != mem4[IPV4_3])
     fce:	18 a2       	std	Y+32, r1	; 0x20
     fd0:	21 2c       	mov	r2, r1
     fd2:	0f 2e       	mov	r0, r31
     fd4:	fe e0       	ldi	r31, 0x0E	; 14
     fd6:	af 2e       	mov	r10, r31
     fd8:	f4 e0       	ldi	r31, 0x04	; 4
     fda:	bf 2e       	mov	r11, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
     fdc:	f0 2d       	mov	r31, r0
     fde:	0f 2e       	mov	r0, r31
     fe0:	ff ea       	ldi	r31, 0xAF	; 175
     fe2:	6f 2e       	mov	r6, r31
     fe4:	f1 e0       	ldi	r31, 0x01	; 1
     fe6:	7f 2e       	mov	r7, r31
     fe8:	f0 2d       	mov	r31, r0
     fea:	0f 2e       	mov	r0, r31
     fec:	f8 ec       	ldi	r31, 0xC8	; 200
     fee:	8f 2e       	mov	r8, r31
     ff0:	f3 e0       	ldi	r31, 0x03	; 3
     ff2:	9f 2e       	mov	r9, r31
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if(cmp_mem[0] != mem4[IPV4_0] | cmp_mem[1] != mem4[IPV4_1] | cmp_mem[2] != mem4[IPV4_2] | cmp_mem[3] != mem4[IPV4_3])
     ff4:	f0 2d       	mov	r31, r0
     ff6:	d8 01       	movw	r26, r16
     ff8:	8c 91       	ld	r24, X
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	f2 01       	movw	r30, r4
     ffe:	60 81       	ld	r22, Z
    1000:	71 81       	ldd	r23, Z+1	; 0x01
    1002:	11 96       	adiw	r26, 0x01	; 1
    1004:	4c 91       	ld	r20, X
    1006:	50 e0       	ldi	r21, 0x00	; 0
    1008:	33 2d       	mov	r19, r3
    100a:	f6 01       	movw	r30, r12
    100c:	a0 81       	ld	r26, Z
    100e:	b1 81       	ldd	r27, Z+1	; 0x01
    1010:	4a 17       	cp	r20, r26
    1012:	5b 07       	cpc	r21, r27
    1014:	09 f4       	brne	.+2      	; 0x1018 <_ZL5proc2Pv+0xe0>
    1016:	32 2d       	mov	r19, r2
    1018:	23 2d       	mov	r18, r3
    101a:	86 17       	cp	r24, r22
    101c:	97 07       	cpc	r25, r23
    101e:	09 f4       	brne	.+2      	; 0x1022 <_ZL5proc2Pv+0xea>
    1020:	22 2d       	mov	r18, r2
    1022:	f3 2f       	mov	r31, r19
    1024:	f2 2b       	or	r31, r18
    1026:	d8 01       	movw	r26, r16
    1028:	12 96       	adiw	r26, 0x02	; 2
    102a:	2c 91       	ld	r18, X
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	e3 2d       	mov	r30, r3
    1030:	d7 01       	movw	r26, r14
    1032:	4d 91       	ld	r20, X+
    1034:	5c 91       	ld	r21, X
    1036:	24 17       	cp	r18, r20
    1038:	35 07       	cpc	r19, r21
    103a:	09 f4       	brne	.+2      	; 0x103e <_ZL5proc2Pv+0x106>
    103c:	e2 2d       	mov	r30, r2
    103e:	ef 2b       	or	r30, r31
    1040:	71 f4       	brne	.+28     	; 0x105e <_ZL5proc2Pv+0x126>
    1042:	f8 01       	movw	r30, r16
    1044:	23 81       	ldd	r18, Z+3	; 0x03
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	e3 2d       	mov	r30, r3
    104a:	d5 01       	movw	r26, r10
    104c:	4d 91       	ld	r20, X+
    104e:	5c 91       	ld	r21, X
    1050:	24 17       	cp	r18, r20
    1052:	35 07       	cpc	r19, r21
    1054:	09 f4       	brne	.+2      	; 0x1058 <_ZL5proc2Pv+0x120>
    1056:	e2 2d       	mov	r30, r2
    1058:	ee 23       	and	r30, r30
    105a:	09 f4       	brne	.+2      	; 0x105e <_ZL5proc2Pv+0x126>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    105c:	46 c0       	rjmp	.+140    	; 0x10ea <_ZL5proc2Pv+0x1b2>
    105e:	86 17       	cp	r24, r22
    1060:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    1062:	41 f0       	breq	.+16     	; 0x1074 <_ZL5proc2Pv+0x13c>
    1064:	80 e0       	ldi	r24, 0x00	; 0
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    106c:	f2 01       	movw	r30, r4
    106e:	80 81       	ld	r24, Z
    1070:	d8 01       	movw	r26, r16
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    1072:	8c 93       	st	X, r24
    1074:	f6 01       	movw	r30, r12
    1076:	60 81       	ld	r22, Z
    1078:	71 81       	ldd	r23, Z+1	; 0x01
    107a:	d8 01       	movw	r26, r16
    107c:	11 96       	adiw	r26, 0x01	; 1
    107e:	8c 91       	ld	r24, X
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	86 17       	cp	r24, r22
    1084:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    1086:	49 f0       	breq	.+18     	; 0x109a <_ZL5proc2Pv+0x162>
    1088:	81 e0       	ldi	r24, 0x01	; 1
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    1090:	f6 01       	movw	r30, r12
    1092:	80 81       	ld	r24, Z
    1094:	d8 01       	movw	r26, r16
    1096:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    1098:	8c 93       	st	X, r24
    109a:	f7 01       	movw	r30, r14
    109c:	60 81       	ld	r22, Z
    109e:	71 81       	ldd	r23, Z+1	; 0x01
    10a0:	d8 01       	movw	r26, r16
    10a2:	12 96       	adiw	r26, 0x02	; 2
    10a4:	8c 91       	ld	r24, X
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	86 17       	cp	r24, r22
    10aa:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    10ac:	49 f0       	breq	.+18     	; 0x10c0 <_ZL5proc2Pv+0x188>
    10ae:	82 e0       	ldi	r24, 0x02	; 2
    10b0:	90 e0       	ldi	r25, 0x00	; 0
    10b2:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    10b6:	f7 01       	movw	r30, r14
    10b8:	80 81       	ld	r24, Z
    10ba:	d8 01       	movw	r26, r16
    10bc:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    10be:	8c 93       	st	X, r24
    10c0:	60 91 0e 04 	lds	r22, 0x040E	; 0x80040e <mem4+0x46>
    10c4:	70 91 0f 04 	lds	r23, 0x040F	; 0x80040f <mem4+0x47>
    10c8:	f8 01       	movw	r30, r16
    10ca:	83 81       	ldd	r24, Z+3	; 0x03
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	86 17       	cp	r24, r22
    10d0:	97 07       	cpc	r25, r23
    10d2:	09 f4       	brne	.+2      	; 0x10d6 <_ZL5proc2Pv+0x19e>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    10d4:	55 cf       	rjmp	.-342    	; 0xf80 <_ZL5proc2Pv+0x48>
    10d6:	83 e0       	ldi	r24, 0x03	; 3
    10d8:	90 e0       	ldi	r25, 0x00	; 0
    10da:	0e 94 8b 15 	call	0x2b16	; 0x2b16 <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    10de:	80 91 0e 04 	lds	r24, 0x040E	; 0x80040e <mem4+0x46>
    10e2:	d8 01       	movw	r26, r16
    10e4:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    10e6:	8c 93       	st	X, r24
    10e8:	49 cf       	rjmp	.-366    	; 0xf7c <_ZL5proc2Pv+0x44>
    10ea:	6f eb       	ldi	r22, 0xBF	; 191
    10ec:	71 e0       	ldi	r23, 0x01	; 1
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	92 e0       	ldi	r25, 0x02	; 2
    10f2:	ff dc       	rcall	.-1538   	; 0xaf2 <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    10f4:	9a a3       	std	Y+34, r25	; 0x22
    10f6:	89 a3       	std	Y+33, r24	; 0x21
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    10f8:	00 97       	sbiw	r24, 0x00	; 0
    10fa:	09 f4       	brne	.+2      	; 0x10fe <_ZL5proc2Pv+0x1c6>
    10fc:	70 c0       	rjmp	.+224    	; 0x11de <__stack+0xdf>
    10fe:	bc 01       	movw	r22, r24
    1100:	8f eb       	ldi	r24, 0xBF	; 191
    1102:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
    1104:	ea dd       	rcall	.-1068   	; 0xcda <_Z25eth_type_is_arp_and_my_ipPhj>
    1106:	88 23       	and	r24, r24
    1108:	21 f0       	breq	.+8      	; 0x1112 <__stack+0x13>
			 continue;
    110a:	8f eb       	ldi	r24, 0xBF	; 191
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    110c:	91 e0       	ldi	r25, 0x01	; 1
    110e:	68 de       	rcall	.-816    	; 0xde0 <_Z28make_arp_answer_from_requestPh>
    1110:	72 cf       	rjmp	.-284    	; 0xff6 <_ZL5proc2Pv+0xbe>
    1112:	69 a1       	ldd	r22, Y+33	; 0x21
    1114:	7a a1       	ldd	r23, Y+34	; 0x22
    1116:	8f eb       	ldi	r24, 0xBF	; 191
    1118:	91 e0       	ldi	r25, 0x01	; 1
    111a:	05 de       	rcall	.-1014   	; 0xd26 <_Z24eth_type_is_ip_and_my_ipPhj>
    111c:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    111e:	09 f4       	brne	.+2      	; 0x1122 <__stack+0x23>
    1120:	6a cf       	rjmp	.-300    	; 0xff6 <_ZL5proc2Pv+0xbe>
    1122:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <_ZZL5proc2PvE3buf+0x17>
    1126:	81 30       	cpi	r24, 0x01	; 1
    1128:	51 f4       	brne	.+20     	; 0x113e <__stack+0x3f>
		 {
			make_echo_reply_from_request(buf,plen);
    112a:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <_ZZL5proc2PvE3buf+0x22>
    112e:	88 30       	cpi	r24, 0x08	; 8
    1130:	31 f4       	brne	.+12     	; 0x113e <__stack+0x3f>
    1132:	69 a1       	ldd	r22, Y+33	; 0x21
    1134:	7a a1       	ldd	r23, Y+34	; 0x22
			continue;
    1136:	8f eb       	ldi	r24, 0xBF	; 191
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    1138:	91 e0       	ldi	r25, 0x01	; 1
    113a:	7a de       	rcall	.-780    	; 0xe30 <_Z28make_echo_reply_from_requestPhj>
    113c:	5c cf       	rjmp	.-328    	; 0xff6 <_ZL5proc2Pv+0xbe>
    113e:	80 91 e9 01 	lds	r24, 0x01E9	; 0x8001e9 <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
    1142:	81 33       	cpi	r24, 0x31	; 49
    1144:	09 f0       	breq	.+2      	; 0x1148 <__stack+0x49>
    1146:	4b c0       	rjmp	.+150    	; 0x11de <__stack+0xdf>
    1148:	ee 8d       	ldd	r30, Y+30	; 0x1e
    114a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    114c:	8d e1       	ldi	r24, 0x1D	; 29
			 char loop = buf[UDP_DATA_P + 1];
    114e:	11 92       	st	Z+, r1
    1150:	8a 95       	dec	r24
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    1152:	e9 f7       	brne	.-6      	; 0x114e <__stack+0x4f>
    1154:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <_ZZL5proc2PvE3buf+0x2b>
    1158:	80 53       	subi	r24, 0x30	; 48
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	01 96       	adiw	r24, 0x01	; 1
    115e:	82 30       	cpi	r24, 0x02	; 2
    1160:	91 05       	cpc	r25, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    1162:	0c f0       	brlt	.+2      	; 0x1166 <__stack+0x67>
    1164:	87 c0       	rjmp	.+270    	; 0x1274 <__stack+0x175>
    1166:	22 c0       	rjmp	.+68     	; 0x11ac <__stack+0xad>
    1168:	f9 01       	movw	r30, r18
    116a:	e1 54       	subi	r30, 0x41	; 65
    116c:	fe 4f       	sbci	r31, 0xFE	; 254
    116e:	63 a5       	ldd	r22, Z+43	; 0x2b
    1170:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    1172:	e2 0f       	add	r30, r18
    1174:	f3 1f       	adc	r31, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    1176:	60 83       	st	Z, r22
    1178:	40 fd       	sbrc	r20, 0
    117a:	12 c0       	rjmp	.+36     	; 0x11a0 <__stack+0xa1>
    117c:	e5 2f       	mov	r30, r21
    117e:	f0 e0       	ldi	r31, 0x00	; 0
    1180:	ee 0f       	add	r30, r30
    1182:	ff 1f       	adc	r31, r31
    1184:	e4 52       	subi	r30, 0x24	; 36
    1186:	fc 4f       	sbci	r31, 0xFC	; 252
    1188:	af ef       	ldi	r26, 0xFF	; 255
    118a:	bf ef       	ldi	r27, 0xFF	; 255
    118c:	ac 0f       	add	r26, r28
    118e:	bd 1f       	adc	r27, r29
    1190:	a2 0f       	add	r26, r18
    1192:	b3 1f       	adc	r27, r19
    1194:	2c 91       	ld	r18, X
    1196:	30 e0       	ldi	r19, 0x00	; 0
					num++;
    1198:	36 2b       	or	r19, r22
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    119a:	31 83       	std	Z+1, r19	; 0x01
    119c:	20 83       	st	Z, r18
    119e:	5f 5f       	subi	r21, 0xFF	; 255
    11a0:	4f 5f       	subi	r20, 0xFF	; 255
    11a2:	24 2f       	mov	r18, r20
    11a4:	30 e0       	ldi	r19, 0x00	; 0
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    11a6:	28 17       	cp	r18, r24
    11a8:	39 07       	cpc	r19, r25
    11aa:	f4 f2       	brlt	.-68     	; 0x1168 <__stack+0x69>
    11ac:	d4 01       	movw	r26, r8
    11ae:	d0 96       	adiw	r26, 0x30	; 48
    11b0:	8d 91       	ld	r24, X+
    11b2:	9c 91       	ld	r25, X
    11b4:	d1 97       	sbiw	r26, 0x31	; 49
    11b6:	51 96       	adiw	r26, 0x11	; 17
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    11b8:	9c 93       	st	X, r25
    11ba:	8e 93       	st	-X, r24
    11bc:	50 97       	sbiw	r26, 0x10	; 16
    11be:	dd 96       	adiw	r26, 0x3d	; 61
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    11c0:	9c 93       	st	X, r25
    11c2:	8e 93       	st	-X, r24
    11c4:	dc 97       	sbiw	r26, 0x3c	; 60
    11c6:	d9 96       	adiw	r26, 0x39	; 57
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    11c8:	9c 93       	st	X, r25
    11ca:	8e 93       	st	-X, r24
    11cc:	d8 97       	sbiw	r26, 0x38	; 56
    11ce:	d7 96       	adiw	r26, 0x37	; 55
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    11d0:	9c 93       	st	X, r25
    11d2:	8e 93       	st	-X, r24
    11d4:	d6 97       	sbiw	r26, 0x36	; 54
    11d6:	df 96       	adiw	r26, 0x3f	; 63
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    11d8:	9c 93       	st	X, r25
    11da:	8e 93       	st	-X, r24
    11dc:	de 97       	sbiw	r26, 0x3e	; 62
			 if(led_flag)
    11de:	b8 a1       	ldd	r27, Y+32	; 0x20
    11e0:	b0 95       	com	r27
			 {
				 PORTB = sbi(PORTB,4);
    11e2:	b8 a3       	std	Y+32, r27	; 0x20
    11e4:	bb 23       	and	r27, r27
    11e6:	29 f0       	breq	.+10     	; 0x11f2 <__stack+0xf3>
    11e8:	88 b3       	in	r24, 0x18	; 24
    11ea:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    11ec:	88 bb       	out	0x18, r24	; 24
    11ee:	88 bb       	out	0x18, r24	; 24
    11f0:	04 c0       	rjmp	.+8      	; 0x11fa <__stack+0xfb>
    11f2:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    11f4:	8f 7e       	andi	r24, 0xEF	; 239
    11f6:	88 bb       	out	0x18, r24	; 24
    11f8:	88 bb       	out	0x18, r24	; 24
    11fa:	f4 01       	movw	r30, r8
    11fc:	82 81       	ldd	r24, Z+2	; 0x02
    11fe:	93 81       	ldd	r25, Z+3	; 0x03
    1200:	d3 01       	movw	r26, r6
			 data[1] = mem4[COUNT];
    1202:	11 96       	adiw	r26, 0x01	; 1
    1204:	9c 93       	st	X, r25
    1206:	8e 93       	st	-X, r24
    1208:	86 81       	ldd	r24, Z+6	; 0x06
    120a:	97 81       	ldd	r25, Z+7	; 0x07
    120c:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    120e:	9c 93       	st	X, r25
    1210:	8e 93       	st	-X, r24
    1212:	12 97       	sbiw	r26, 0x02	; 2
    1214:	84 81       	ldd	r24, Z+4	; 0x04
    1216:	95 81       	ldd	r25, Z+5	; 0x05
    1218:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    121a:	9c 93       	st	X, r25
    121c:	8e 93       	st	-X, r24
    121e:	14 97       	sbiw	r26, 0x04	; 4
    1220:	80 89       	ldd	r24, Z+16	; 0x10
    1222:	91 89       	ldd	r25, Z+17	; 0x11
    1224:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    1226:	9c 93       	st	X, r25
    1228:	8e 93       	st	-X, r24
    122a:	16 97       	sbiw	r26, 0x06	; 6
    122c:	82 89       	ldd	r24, Z+18	; 0x12
    122e:	93 89       	ldd	r25, Z+19	; 0x13
    1230:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    1232:	9c 93       	st	X, r25
    1234:	8e 93       	st	-X, r24
    1236:	18 97       	sbiw	r26, 0x08	; 8
    1238:	84 85       	ldd	r24, Z+12	; 0x0c
    123a:	95 85       	ldd	r25, Z+13	; 0x0d
    123c:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    123e:	9c 93       	st	X, r25
    1240:	8e 93       	st	-X, r24
    1242:	1a 97       	sbiw	r26, 0x0a	; 10
    1244:	82 85       	ldd	r24, Z+10	; 0x0a
    1246:	93 85       	ldd	r25, Z+11	; 0x0b
    1248:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    124a:	9c 93       	st	X, r25
    124c:	8e 93       	st	-X, r24
    124e:	1c 97       	sbiw	r26, 0x0c	; 12
    1250:	80 85       	ldd	r24, Z+8	; 0x08
    1252:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    1254:	1f 96       	adiw	r26, 0x0f	; 15
    1256:	9c 93       	st	X, r25
    1258:	8e 93       	st	-X, r24
    125a:	1e 97       	sbiw	r26, 0x0e	; 14
    125c:	2f e0       	ldi	r18, 0x0F	; 15
    125e:	37 e2       	ldi	r19, 0x27	; 39
    1260:	40 e1       	ldi	r20, 0x10	; 16
    1262:	b3 01       	movw	r22, r6
			 vTaskDelay(100);
    1264:	8f eb       	ldi	r24, 0xBF	; 191
    1266:	91 e0       	ldi	r25, 0x01	; 1
    1268:	fd dd       	rcall	.-1030   	; 0xe64 <_Z27make_udp_reply_from_requestPhPchj>
    126a:	84 e6       	ldi	r24, 0x64	; 100
    126c:	90 e0       	ldi	r25, 0x00	; 0
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    126e:	0e 94 59 13 	call	0x26b2	; 0x26b2 <vTaskDelay>
    1272:	c1 ce       	rjmp	.-638    	; 0xff6 <_ZL5proc2Pv+0xbe>
    1274:	20 91 eb 01 	lds	r18, 0x01EB	; 0x8001eb <_ZZL5proc2PvE3buf+0x2c>
    1278:	29 83       	std	Y+1, r18	; 0x01
    127a:	41 e0       	ldi	r20, 0x01	; 1
    127c:	50 e0       	ldi	r21, 0x00	; 0
    127e:	90 cf       	rjmp	.-224    	; 0x11a0 <__stack+0xa1>

00001280 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	cd b7       	in	r28, 0x3d	; 61
    1286:	de b7       	in	r29, 0x3e	; 62
    1288:	2f 97       	sbiw	r28, 0x0f	; 15
    128a:	0f b6       	in	r0, 0x3f	; 63
    128c:	f8 94       	cli
    128e:	de bf       	out	0x3e, r29	; 62
    1290:	0f be       	out	0x3f, r0	; 63
    1292:	cd bf       	out	0x3d, r28	; 61
    1294:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	//SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
    1296:	fe 01       	movw	r30, r28
    1298:	31 96       	adiw	r30, 0x01	; 1
    129a:	8f e0       	ldi	r24, 0x0F	; 15
    129c:	df 01       	movw	r26, r30
    129e:	1d 92       	st	X+, r1
    12a0:	8a 95       	dec	r24
    12a2:	e9 f7       	brne	.-6      	; 0x129e <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    12a4:	08 ec       	ldi	r16, 0xC8	; 200
    12a6:	13 e0       	ldi	r17, 0x03	; 3
    12a8:	5e 01       	movw	r10, r28
    12aa:	b0 e1       	ldi	r27, 0x10	; 16
    12ac:	ab 0e       	add	r10, r27
    12ae:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    12b0:	0f 2e       	mov	r0, r31
    12b2:	fa e9       	ldi	r31, 0x9A	; 154
    12b4:	8f 2e       	mov	r8, r31
    12b6:	91 2c       	mov	r9, r1
    12b8:	f0 2d       	mov	r31, r0
				mem4[TEMP] = current_temp;
				mem4[COUNT] = count_number;
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    12ba:	0f 2e       	mov	r0, r31
    12bc:	f3 e0       	ldi	r31, 0x03	; 3
    12be:	6f 2e       	mov	r6, r31
    12c0:	71 2c       	mov	r7, r1
    12c2:	f0 2d       	mov	r31, r0
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	//SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    12c4:	f8 01       	movw	r30, r16
    12c6:	80 89       	ldd	r24, Z+16	; 0x10
    12c8:	91 89       	ldd	r25, Z+17	; 0x11
    12ca:	26 ad       	ldd	r18, Z+62	; 0x3e
    12cc:	37 ad       	ldd	r19, Z+63	; 0x3f
    12ce:	28 17       	cp	r18, r24
    12d0:	39 07       	cpc	r19, r25
    12d2:	41 f0       	breq	.+16     	; 0x12e4 <_ZL5proc1Pv+0x64>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    12d4:	95 af       	std	Z+61, r25	; 0x3d
    12d6:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    12d8:	91 af       	std	Z+57, r25	; 0x39
    12da:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    12dc:	97 ab       	std	Z+55, r25	; 0x37
    12de:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    12e0:	97 af       	std	Z+63, r25	; 0x3f
    12e2:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    12e4:	c6 01       	movw	r24, r12
    12e6:	5d d8       	rcall	.-3910   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    12e8:	8f 30       	cpi	r24, 0x0F	; 15
    12ea:	60 f3       	brcs	.-40     	; 0x12c4 <_ZL5proc1Pv+0x44>
    12ec:	ce 01       	movw	r24, r28
    12ee:	01 96       	adiw	r24, 0x01	; 1
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    12f0:	7c 01       	movw	r14, r24
    12f2:	c6 01       	movw	r24, r12
    12f4:	2a d8       	rcall	.-4012   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    12f6:	d7 01       	movw	r26, r14
    12f8:	8d 93       	st	X+, r24
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    12fa:	7d 01       	movw	r14, r26
    12fc:	aa 15       	cp	r26, r10
    12fe:	bb 05       	cpc	r27, r11
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    1300:	c1 f7       	brne	.-16     	; 0x12f2 <_ZL5proc1Pv+0x72>
    1302:	89 81       	ldd	r24, Y+1	; 0x01
    1304:	82 30       	cpi	r24, 0x02	; 2
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1306:	99 f5       	brne	.+102    	; 0x136e <_ZL5proc1Pv+0xee>
    1308:	88 85       	ldd	r24, Y+8	; 0x08
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	98 2f       	mov	r25, r24
    130e:	88 27       	eor	r24, r24
    1310:	29 85       	ldd	r18, Y+9	; 0x09
    1312:	82 2b       	or	r24, r18
    1314:	90 93 17 04 	sts	0x0417, r25	; 0x800417 <count_number+0x1>
    1318:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    131c:	4a 85       	ldd	r20, Y+10	; 0x0a
    131e:	50 e0       	ldi	r21, 0x00	; 0
    1320:	54 2f       	mov	r21, r20
    1322:	44 27       	eor	r20, r20
    1324:	2b 85       	ldd	r18, Y+11	; 0x0b
    1326:	42 2b       	or	r20, r18
    1328:	50 93 15 04 	sts	0x0415, r21	; 0x800415 <current_temp+0x1>
    132c:	40 93 14 04 	sts	0x0414, r20	; 0x800414 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    1330:	2c 85       	ldd	r18, Y+12	; 0x0c
    1332:	30 e0       	ldi	r19, 0x00	; 0
    1334:	32 2f       	mov	r19, r18
    1336:	22 27       	eor	r18, r18
    1338:	6d 85       	ldd	r22, Y+13	; 0x0d
    133a:	26 2b       	or	r18, r22
    133c:	30 93 13 04 	sts	0x0413, r19	; 0x800413 <current_pressure+0x1>
    1340:	20 93 12 04 	sts	0x0412, r18	; 0x800412 <current_pressure>
				mem4[TEMP] = current_temp;
    1344:	f8 01       	movw	r30, r16
    1346:	53 83       	std	Z+3, r21	; 0x03
				mem4[COUNT] = count_number;
    1348:	42 83       	std	Z+2, r20	; 0x02
    134a:	97 83       	std	Z+7, r25	; 0x07
				mem4[PRESSURE] = current_pressure;
    134c:	86 83       	std	Z+6, r24	; 0x06
    134e:	35 83       	std	Z+5, r19	; 0x05
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    1350:	24 83       	std	Z+4, r18	; 0x04
    1352:	20 89       	ldd	r18, Z+16	; 0x10
    1354:	31 89       	ldd	r19, Z+17	; 0x11
    1356:	82 17       	cp	r24, r18
    1358:	93 07       	cpc	r25, r19
    135a:	09 f0       	breq	.+2      	; 0x135e <_ZL5proc1Pv+0xde>
    135c:	b3 cf       	rjmp	.-154    	; 0x12c4 <_ZL5proc1Pv+0x44>
    135e:	82 89       	ldd	r24, Z+18	; 0x12
    1360:	93 89       	ldd	r25, Z+19	; 0x13
    1362:	89 2b       	or	r24, r25
    1364:	09 f0       	breq	.+2      	; 0x1368 <_ZL5proc1Pv+0xe8>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1366:	ae cf       	rjmp	.-164    	; 0x12c4 <_ZL5proc1Pv+0x44>
    1368:	73 8a       	std	Z+19, r7	; 0x13
    136a:	62 8a       	std	Z+18, r6	; 0x12
				}
			}
			else
			{
				cbi(PORTB,7);
    136c:	ab cf       	rjmp	.-170    	; 0x12c4 <_ZL5proc1Pv+0x44>
				GetExceptionCode(&exception,0x01,0x06);
    136e:	c7 98       	cbi	0x18, 7	; 24
    1370:	46 e0       	ldi	r20, 0x06	; 6
    1372:	61 e0       	ldi	r22, 0x01	; 1
    1374:	80 e2       	ldi	r24, 0x20	; 32
    1376:	94 e0       	ldi	r25, 0x04	; 4
    1378:	0e 94 0c 01 	call	0x218	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    137c:	45 e0       	ldi	r20, 0x05	; 5
    137e:	50 e0       	ldi	r21, 0x00	; 0
    1380:	60 e2       	ldi	r22, 0x20	; 32
    1382:	74 e0       	ldi	r23, 0x04	; 4
    1384:	c6 01       	movw	r24, r12
    1386:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    138a:	d4 01       	movw	r26, r8
    138c:	8c 91       	ld	r24, X
				sb->SerialFlush();
    138e:	8f 77       	andi	r24, 0x7F	; 127
    1390:	8c 93       	st	X, r24
    1392:	c6 01       	movw	r24, r12
				sbi(UCSR1B,RXCIE0);
    1394:	11 d8       	rcall	.-4062   	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
    1396:	f4 01       	movw	r30, r8
    1398:	80 81       	ld	r24, Z
    139a:	80 68       	ori	r24, 0x80	; 128
				sbi(PORTB,7);
    139c:	80 83       	st	Z, r24
    139e:	c7 9a       	sbi	0x18, 7	; 24
    13a0:	91 cf       	rjmp	.-222    	; 0x12c4 <_ZL5proc1Pv+0x44>

000013a2 <_ZL4procPv>:
	#if USE_SYSTEM_SEC
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	cd b7       	in	r28, 0x3d	; 61
    13a8:	de b7       	in	r29, 0x3e	; 62
    13aa:	2a 97       	sbiw	r28, 0x0a	; 10
    13ac:	0f b6       	in	r0, 0x3f	; 63
    13ae:	f8 94       	cli
    13b0:	de bf       	out	0x3e, r29	; 62
    13b2:	0f be       	out	0x3f, r0	; 63
    13b4:	cd bf       	out	0x3d, r28	; 61
    13b6:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    13b8:	d1 2c       	mov	r13, r1
	char buf1[10];
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	while(1)
	{
		if(mem4[SEC] >= 60)
    13ba:	08 ec       	ldi	r16, 0xC8	; 200
    13bc:	13 e0       	ldi	r17, 0x03	; 3
    13be:	4e 01       	movw	r8, r28
    13c0:	8c e0       	ldi	r24, 0x0C	; 12
    13c2:	88 0e       	add	r8, r24
    13c4:	91 1c       	adc	r9, r1
    13c6:	68 94       	set
    13c8:	33 24       	eor	r3, r3
    13ca:	34 f8       	bld	r3, 4
						buf1[i] = sb->SerialRead();
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					read_Flag = 0;
    13cc:	61 2c       	mov	r6, r1
    13ce:	77 24       	eor	r7, r7
    13d0:	73 94       	inc	r7
    13d2:	5e 01       	movw	r10, r28
    13d4:	e9 e0       	ldi	r30, 0x09	; 9
    13d6:	ae 0e       	add	r10, r30
    13d8:	b1 1c       	adc	r11, r1
    13da:	0f 2e       	mov	r0, r31
    13dc:	f5 e0       	ldi	r31, 0x05	; 5
    13de:	4f 2e       	mov	r4, r31
    13e0:	f0 2d       	mov	r31, r0
    13e2:	68 94       	set
    13e4:	55 24       	eor	r5, r5
    13e6:	52 f8       	bld	r5, 2
    13e8:	0e c0       	rjmp	.+28     	; 0x1406 <_ZL4procPv+0x64>
    13ea:	c7 2c       	mov	r12, r7
    13ec:	d7 2c       	mov	r13, r7
    13ee:	0b c0       	rjmp	.+22     	; 0x1406 <_ZL4procPv+0x64>
    13f0:	c7 2c       	mov	r12, r7
    13f2:	d7 2c       	mov	r13, r7
    13f4:	08 c0       	rjmp	.+16     	; 0x1406 <_ZL4procPv+0x64>
    13f6:	c5 2c       	mov	r12, r5
    13f8:	d7 2c       	mov	r13, r7
    13fa:	05 c0       	rjmp	.+10     	; 0x1406 <_ZL4procPv+0x64>
    13fc:	c4 2c       	mov	r12, r4
    13fe:	d7 2c       	mov	r13, r7
    1400:	02 c0       	rjmp	.+4      	; 0x1406 <_ZL4procPv+0x64>
    1402:	c3 2c       	mov	r12, r3
    1404:	d7 2c       	mov	r13, r7
	char buf1[10];
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	while(1)
	{
		if(mem4[SEC] >= 60)
    1406:	f8 01       	movw	r30, r16
    1408:	84 85       	ldd	r24, Z+12	; 0x0c
    140a:	95 85       	ldd	r25, Z+13	; 0x0d
    140c:	cc 97       	sbiw	r24, 0x3c	; 60
    140e:	9c f0       	brlt	.+38     	; 0x1436 <_ZL4procPv+0x94>
		{
			mem4[SEC] = 0;
    1410:	15 86       	std	Z+13, r1	; 0x0d
    1412:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    1414:	82 85       	ldd	r24, Z+10	; 0x0a
    1416:	93 85       	ldd	r25, Z+11	; 0x0b
    1418:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    141a:	8c 33       	cpi	r24, 0x3C	; 60
    141c:	91 05       	cpc	r25, r1
    141e:	1c f4       	brge	.+6      	; 0x1426 <_ZL4procPv+0x84>
	while(1)
	{
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    1420:	93 87       	std	Z+11, r25	; 0x0b
    1422:	82 87       	std	Z+10, r24	; 0x0a
    1424:	08 c0       	rjmp	.+16     	; 0x1436 <_ZL4procPv+0x94>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    1426:	f8 01       	movw	r30, r16
    1428:	13 86       	std	Z+11, r1	; 0x0b
    142a:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    142c:	80 85       	ldd	r24, Z+8	; 0x08
    142e:	91 85       	ldd	r25, Z+9	; 0x09
    1430:	01 96       	adiw	r24, 0x01	; 1
    1432:	91 87       	std	Z+9, r25	; 0x09
    1434:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    1436:	d1 10       	cpse	r13, r1
    1438:	2c c0       	rjmp	.+88     	; 0x1492 <_ZL4procPv+0xf0>
		{
			if(sb->SerialAvailable() >= 2)
    143a:	c7 01       	movw	r24, r14
    143c:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1440:	82 30       	cpi	r24, 0x02	; 2
    1442:	08 f3       	brcs	.-62     	; 0x1406 <_ZL4procPv+0x64>
			{
				for(int i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    1444:	c7 01       	movw	r24, r14
    1446:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    144a:	89 83       	std	Y+1, r24	; 0x01
    144c:	c7 01       	movw	r24, r14
    144e:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1452:	8a 83       	std	Y+2, r24	; 0x02
				}
				if(buf1[0] != 0x01)
				{
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    1454:	81 30       	cpi	r24, 0x01	; 1
    1456:	11 f1       	breq	.+68     	; 0x149c <_ZL4procPv+0xfa>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    1458:	84 30       	cpi	r24, 0x04	; 4
    145a:	b9 f1       	breq	.+110    	; 0x14ca <_ZL4procPv+0x128>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    145c:	85 30       	cpi	r24, 0x05	; 5
    145e:	09 f4       	brne	.+2      	; 0x1462 <_ZL4procPv+0xc0>
    1460:	5b c0       	rjmp	.+182    	; 0x1518 <_ZL4procPv+0x176>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1462:	80 31       	cpi	r24, 0x10	; 16
    1464:	09 f4       	brne	.+2      	; 0x1468 <_ZL4procPv+0xc6>
    1466:	7e c0       	rjmp	.+252    	; 0x1564 <_ZL4procPv+0x1c2>
				else
				{
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    1468:	47 2d       	mov	r20, r7
    146a:	67 2d       	mov	r22, r7
    146c:	80 e2       	ldi	r24, 0x20	; 32
    146e:	94 e0       	ldi	r25, 0x04	; 4
    1470:	0e 94 0c 01 	call	0x218	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
					//dev->Close_Handle(UART0);
					//PORTB = 0x00;
					cbi(PORTB,7);
    1474:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);                                                                                                                                                                                                                
    1476:	57 98       	cbi	0x0a, 7	; 10
					sb->SerialFlush();
    1478:	c7 01       	movw	r24, r14
    147a:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
					sbi(UCSR0B,RXCIE0);
    147e:	57 9a       	sbi	0x0a, 7	; 10
					//dev->Open_Handle(UART0,Uart_ISR);
					sb->SerialWrite((char*)&exception,sizeof(exception));
    1480:	45 e0       	ldi	r20, 0x05	; 5
    1482:	50 e0       	ldi	r21, 0x00	; 0
    1484:	60 e2       	ldi	r22, 0x20	; 32
    1486:	74 e0       	ldi	r23, 0x04	; 4
    1488:	c7 01       	movw	r24, r14
    148a:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    148e:	c7 9a       	sbi	0x18, 7	; 24
    1490:	ba cf       	rjmp	.-140    	; 0x1406 <_ZL4procPv+0x64>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1492:	f1 e0       	ldi	r31, 0x01	; 1
    1494:	df 12       	cpse	r13, r31
    1496:	b7 cf       	rjmp	.-146    	; 0x1406 <_ZL4procPv+0x64>
		{
			if(function_code == 0x01)  
    1498:	cf 12       	cpse	r12, r31
    149a:	14 c0       	rjmp	.+40     	; 0x14c4 <_ZL4procPv+0x122>
			{
				if(sb->SerialAvailable() >= 6)
    149c:	c7 01       	movw	r24, r14
    149e:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    14a2:	86 30       	cpi	r24, 0x06	; 6
    14a4:	08 f4       	brcc	.+2      	; 0x14a8 <_ZL4procPv+0x106>
    14a6:	a1 cf       	rjmp	.-190    	; 0x13ea <_ZL4procPv+0x48>
    14a8:	6e 01       	movw	r12, r28
    14aa:	83 e0       	ldi	r24, 0x03	; 3
    14ac:	c8 0e       	add	r12, r24
    14ae:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    14b0:	c7 01       	movw	r24, r14
    14b2:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    14b6:	f6 01       	movw	r30, r12
    14b8:	81 93       	st	Z+, r24
    14ba:	6f 01       	movw	r12, r30
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    14bc:	ae 16       	cp	r10, r30
    14be:	bf 06       	cpc	r11, r31
    14c0:	b9 f7       	brne	.-18     	; 0x14b0 <_ZL4procPv+0x10e>
    14c2:	96 cf       	rjmp	.-212    	; 0x13f0 <_ZL4procPv+0x4e>
						buf1[i] = sb->SerialRead();
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    14c4:	f4 e0       	ldi	r31, 0x04	; 4
    14c6:	cf 12       	cpse	r12, r31
    14c8:	24 c0       	rjmp	.+72     	; 0x1512 <_ZL4procPv+0x170>
			{
				if(sb->SerialAvailable() >= 6)
    14ca:	c7 01       	movw	r24, r14
    14cc:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    14d0:	86 30       	cpi	r24, 0x06	; 6
    14d2:	08 f4       	brcc	.+2      	; 0x14d6 <_ZL4procPv+0x134>
    14d4:	90 cf       	rjmp	.-224    	; 0x13f6 <_ZL4procPv+0x54>
    14d6:	6e 01       	movw	r12, r28
    14d8:	83 e0       	ldi	r24, 0x03	; 3
    14da:	c8 0e       	add	r12, r24
    14dc:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    14de:	c7 01       	movw	r24, r14
    14e0:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    14e4:	f6 01       	movw	r30, r12
    14e6:	81 93       	st	Z+, r24
    14e8:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    14ea:	ae 16       	cp	r10, r30
    14ec:	bf 06       	cpc	r11, r31
    14ee:	b9 f7       	brne	.-18     	; 0x14de <_ZL4procPv+0x13c>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc04Data(buf1,&func04,mem4);
    14f0:	a8 01       	movw	r20, r16
    14f2:	60 e3       	ldi	r22, 0x30	; 48
    14f4:	74 e0       	ldi	r23, 0x04	; 4
    14f6:	ce 01       	movw	r24, r28
    14f8:	01 96       	adiw	r24, 0x01	; 1
    14fa:	0e 94 8f 00 	call	0x11e	; 0x11e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
					sb->SerialWrite((char*)&func04,sizeof(func04));
    14fe:	47 e0       	ldi	r20, 0x07	; 7
    1500:	50 e0       	ldi	r21, 0x00	; 0
    1502:	60 e3       	ldi	r22, 0x30	; 48
    1504:	74 e0       	ldi	r23, 0x04	; 4
    1506:	c7 01       	movw	r24, r14
    1508:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    150c:	c5 2c       	mov	r12, r5
					read_Flag = 0;
    150e:	d6 2c       	mov	r13, r6
    1510:	7a cf       	rjmp	.-268    	; 0x1406 <_ZL4procPv+0x64>
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    1512:	f5 e0       	ldi	r31, 0x05	; 5
    1514:	cf 12       	cpse	r12, r31
    1516:	23 c0       	rjmp	.+70     	; 0x155e <_ZL4procPv+0x1bc>
			{
				if(sb->SerialAvailable() >= 6)
    1518:	c7 01       	movw	r24, r14
    151a:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    151e:	86 30       	cpi	r24, 0x06	; 6
    1520:	08 f4       	brcc	.+2      	; 0x1524 <_ZL4procPv+0x182>
    1522:	6c cf       	rjmp	.-296    	; 0x13fc <_ZL4procPv+0x5a>
    1524:	6e 01       	movw	r12, r28
    1526:	83 e0       	ldi	r24, 0x03	; 3
    1528:	c8 0e       	add	r12, r24
    152a:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    152c:	c7 01       	movw	r24, r14
    152e:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1532:	f6 01       	movw	r30, r12
    1534:	81 93       	st	Z+, r24
    1536:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1538:	ae 16       	cp	r10, r30
    153a:	bf 06       	cpc	r11, r31
    153c:	b9 f7       	brne	.-18     	; 0x152c <_ZL4procPv+0x18a>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc05Data(buf1,&func05);
    153e:	67 e3       	ldi	r22, 0x37	; 55
    1540:	74 e0       	ldi	r23, 0x04	; 4
    1542:	ce 01       	movw	r24, r28
    1544:	01 96       	adiw	r24, 0x01	; 1
    1546:	0e 94 b0 00 	call	0x160	; 0x160 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    154a:	48 e0       	ldi	r20, 0x08	; 8
    154c:	50 e0       	ldi	r21, 0x00	; 0
    154e:	67 e3       	ldi	r22, 0x37	; 55
    1550:	74 e0       	ldi	r23, 0x04	; 4
    1552:	c7 01       	movw	r24, r14
    1554:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    1558:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    155a:	d6 2c       	mov	r13, r6
    155c:	54 cf       	rjmp	.-344    	; 0x1406 <_ZL4procPv+0x64>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    155e:	f0 e1       	ldi	r31, 0x10	; 16
    1560:	cf 12       	cpse	r12, r31
    1562:	51 cf       	rjmp	.-350    	; 0x1406 <_ZL4procPv+0x64>
			{
				if(sb->SerialAvailable() >= 9)
    1564:	c7 01       	movw	r24, r14
    1566:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    156a:	89 30       	cpi	r24, 0x09	; 9
    156c:	08 f4       	brcc	.+2      	; 0x1570 <_ZL4procPv+0x1ce>
    156e:	49 cf       	rjmp	.-366    	; 0x1402 <_ZL4procPv+0x60>
    1570:	6e 01       	movw	r12, r28
    1572:	83 e0       	ldi	r24, 0x03	; 3
    1574:	c8 0e       	add	r12, r24
    1576:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    1578:	c7 01       	movw	r24, r14
    157a:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    157e:	f6 01       	movw	r30, r12
    1580:	81 93       	st	Z+, r24
    1582:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    1584:	8e 16       	cp	r8, r30
    1586:	9f 06       	cpc	r9, r31
    1588:	b9 f7       	brne	.-18     	; 0x1578 <_ZL4procPv+0x1d6>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    158a:	a8 01       	movw	r20, r16
    158c:	65 e2       	ldi	r22, 0x25	; 37
    158e:	74 e0       	ldi	r23, 0x04	; 4
    1590:	ce 01       	movw	r24, r28
    1592:	01 96       	adiw	r24, 0x01	; 1
    1594:	0e 94 c9 00 	call	0x192	; 0x192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1598:	68 e1       	ldi	r22, 0x18	; 24
    159a:	74 e0       	ldi	r23, 0x04	; 4
    159c:	ce 01       	movw	r24, r28
    159e:	01 96       	adiw	r24, 0x01	; 1
    15a0:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    15a4:	48 e0       	ldi	r20, 0x08	; 8
    15a6:	50 e0       	ldi	r21, 0x00	; 0
    15a8:	68 e1       	ldi	r22, 0x18	; 24
    15aa:	74 e0       	ldi	r23, 0x04	; 4
    15ac:	c7 01       	movw	r24, r14
    15ae:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    15b2:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    15b4:	d6 2c       	mov	r13, r6
    15b6:	27 cf       	rjmp	.-434    	; 0x1406 <_ZL4procPv+0x64>

000015b8 <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    15b8:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <DataStruct>
    15bc:	90 91 40 04 	lds	r25, 0x0440	; 0x800440 <DataStruct+0x1>
    15c0:	0e 94 44 01 	call	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    15c4:	c5 9a       	sbi	0x18, 5	; 24
    15c6:	08 95       	ret

000015c8 <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    15c8:	80 91 41 04 	lds	r24, 0x0441	; 0x800441 <DataStruct+0x2>
    15cc:	90 91 42 04 	lds	r25, 0x0442	; 0x800442 <DataStruct+0x3>
    15d0:	0e 94 44 01 	call	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    15d4:	c6 9a       	sbi	0x18, 6	; 24
    15d6:	08 95       	ret

000015d8 <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    15d8:	cf 93       	push	r28
    15da:	df 93       	push	r29
	dev = new Dev_Manager();
    15dc:	8c e0       	ldi	r24, 0x0C	; 12
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	0e 94 1f 02 	call	0x43e	; 0x43e <_ZN11Dev_ManagernwEj>
    15e4:	ec 01       	movw	r28, r24
    15e6:	0e 94 e7 01 	call	0x3ce	; 0x3ce <_ZN11Dev_ManagerC1Ev>
    15ea:	d0 93 46 04 	sts	0x0446, r29	; 0x800446 <dev+0x1>
    15ee:	c0 93 45 04 	sts	0x0445, r28	; 0x800445 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    15f2:	86 e0       	ldi	r24, 0x06	; 6
    15f4:	90 e0       	ldi	r25, 0x00	; 0
    15f6:	e3 d8       	rcall	.-3642   	; 0x7be <_ZN10UartDrivernwEj>
    15f8:	ec 01       	movw	r28, r24
    15fa:	d1 d8       	rcall	.-3678   	; 0x79e <_ZN10UartDriverC1Ev>
    15fc:	40 e0       	ldi	r20, 0x00	; 0
    15fe:	be 01       	movw	r22, r28
    1600:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1604:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1608:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    160c:	86 e0       	ldi	r24, 0x06	; 6
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	58 d8       	rcall	.-3920   	; 0x6c2 <_ZN11RS485DrivernwEj>
    1612:	ec 01       	movw	r28, r24
    1614:	46 d8       	rcall	.-3956   	; 0x6a2 <_ZN11RS485DriverC1Ev>
    1616:	41 e0       	ldi	r20, 0x01	; 1
    1618:	be 01       	movw	r22, r28
    161a:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    161e:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Register_Dev(new Timer,SEC_TIMER);
    1622:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    1626:	82 e0       	ldi	r24, 0x02	; 2
    1628:	90 e0       	ldi	r25, 0x00	; 0
    162a:	13 d8       	rcall	.-4058   	; 0x652 <_ZN5TimernwEj>
    162c:	ec 01       	movw	r28, r24
    162e:	0b d8       	rcall	.-4074   	; 0x646 <_ZN5TimerC1Ev>
    1630:	42 e0       	ldi	r20, 0x02	; 2
    1632:	be 01       	movw	r22, r28
    1634:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1638:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Device_Init(UART0);
    163c:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    1640:	60 e0       	ldi	r22, 0x00	; 0
    1642:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1646:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Device_Init(RS485);
    164a:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    164e:	61 e0       	ldi	r22, 0x01	; 1
    1650:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1654:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Device_Init(SEC_TIMER);
    1658:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    165c:	62 e0       	ldi	r22, 0x02	; 2
    165e:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1662:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    1666:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    166a:	4b e2       	ldi	r20, 0x2B	; 43
    166c:	51 e0       	ldi	r21, 0x01	; 1
    166e:	60 e0       	ldi	r22, 0x00	; 0
    1670:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1674:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1678:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePKc>
    167c:	41 e5       	ldi	r20, 0x51	; 81
    167e:	51 e0       	ldi	r21, 0x01	; 1
    1680:	61 e0       	ldi	r22, 0x01	; 1
    1682:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1686:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
}
    168a:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePKc>
    168e:	df 91       	pop	r29
    1690:	cf 91       	pop	r28
    1692:	08 95       	ret

00001694 <main>:
int current_pressure = 0;

int mem4[MAX_ENUM] = {0};
char cmp_mem[4] = {0};
int main( void )
{
    1694:	cf 92       	push	r12
    1696:	df 92       	push	r13
    1698:	ef 92       	push	r14
    169a:	ff 92       	push	r15
    169c:	0f 93       	push	r16
    169e:	cf 93       	push	r28
    16a0:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	PORTB = 0xff;
    16a2:	8f ef       	ldi	r24, 0xFF	; 255
    16a4:	88 bb       	out	0x18, r24	; 24
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	90 e0       	ldi	r25, 0x00	; 0
    16aa:	0e 94 83 15 	call	0x2b06	; 0x2b06 <eeprom_read_byte>
    16ae:	d8 2e       	mov	r13, r24
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	90 93 09 04 	sts	0x0409, r25	; 0x800409 <mem4+0x41>
    16b6:	80 93 08 04 	sts	0x0408, r24	; 0x800408 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    16ba:	81 e0       	ldi	r24, 0x01	; 1
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	0e 94 83 15 	call	0x2b06	; 0x2b06 <eeprom_read_byte>
    16c2:	d8 2f       	mov	r29, r24
    16c4:	90 e0       	ldi	r25, 0x00	; 0
    16c6:	90 93 0b 04 	sts	0x040B, r25	; 0x80040b <mem4+0x43>
    16ca:	80 93 0a 04 	sts	0x040A, r24	; 0x80040a <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    16ce:	82 e0       	ldi	r24, 0x02	; 2
    16d0:	90 e0       	ldi	r25, 0x00	; 0
    16d2:	0e 94 83 15 	call	0x2b06	; 0x2b06 <eeprom_read_byte>
    16d6:	c8 2f       	mov	r28, r24
    16d8:	90 e0       	ldi	r25, 0x00	; 0
    16da:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <mem4+0x45>
    16de:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    16e2:	83 e0       	ldi	r24, 0x03	; 3
    16e4:	90 e0       	ldi	r25, 0x00	; 0
    16e6:	0e 94 83 15 	call	0x2b06	; 0x2b06 <eeprom_read_byte>
    16ea:	28 2f       	mov	r18, r24
    16ec:	30 e0       	ldi	r19, 0x00	; 0
    16ee:	30 93 0f 04 	sts	0x040F, r19	; 0x80040f <mem4+0x47>
    16f2:	20 93 0e 04 	sts	0x040E, r18	; 0x80040e <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    16f6:	e4 ec       	ldi	r30, 0xC4	; 196
    16f8:	f3 e0       	ldi	r31, 0x03	; 3
    16fa:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    16fc:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    16fe:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    1700:	83 83       	std	Z+3, r24	; 0x03
char cmp_mem[4] = {0};
int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1702:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1704:	69 df       	rcall	.-302    	; 0x15d8 <_Z8Init_Devv>
    1706:	4c ed       	ldi	r20, 0xDC	; 220
    1708:	5a e0       	ldi	r21, 0x0A	; 10
    170a:	60 e0       	ldi	r22, 0x00	; 0
    170c:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1710:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1714:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1718:	44 ee       	ldi	r20, 0xE4	; 228
    171a:	5a e0       	ldi	r21, 0x0A	; 10
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1722:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1726:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    172a:	42 e9       	ldi	r20, 0x92	; 146
    172c:	57 e0       	ldi	r21, 0x07	; 7
    172e:	62 e0       	ldi	r22, 0x02	; 2
    1730:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    1734:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1738:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    173c:	88 e8       	ldi	r24, 0x88	; 136
    173e:	90 e0       	ldi	r25, 0x00	; 0
    1740:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    1744:	6c 01       	movw	r12, r24
    1746:	60 91 45 04 	lds	r22, 0x0445	; 0x800445 <dev>
    174a:	70 91 46 04 	lds	r23, 0x0446	; 0x800446 <dev+0x1>
    174e:	40 e0       	ldi	r20, 0x00	; 0
    1750:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1754:	c1 14       	cp	r12, r1
    1756:	d1 04       	cpc	r13, r1
	{
		#if DEBUG 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    1758:	21 f4       	brne	.+8      	; 0x1762 <main+0xce>
    175a:	81 e0       	ldi	r24, 0x01	; 1
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		#endif
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1762:	88 e8       	ldi	r24, 0x88	; 136
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    176a:	ec 01       	movw	r28, r24
    176c:	60 91 45 04 	lds	r22, 0x0445	; 0x800445 <dev>
    1770:	70 91 46 04 	lds	r23, 0x0446	; 0x800446 <dev+0x1>
    1774:	41 e0       	ldi	r20, 0x01	; 1
    1776:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    177a:	20 97       	sbiw	r28, 0x00	; 0
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    177c:	21 f4       	brne	.+8      	; 0x1786 <main+0xf2>
    177e:	81 e0       	ldi	r24, 0x01	; 1
    1780:	90 e0       	ldi	r25, 0x00	; 0
    1782:	0e 94 9c 15 	call	0x2b38	; 0x2b38 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		#endif
	}
	DataStruct[UART0] = sb;
    1786:	ef e3       	ldi	r30, 0x3F	; 63
    1788:	f4 e0       	ldi	r31, 0x04	; 4
    178a:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    178c:	c0 82       	st	Z, r12
    178e:	d3 83       	std	Z+3, r29	; 0x03
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			#endif
		}
	}

	sei(); //인터럽트 사용 
    1790:	c2 83       	std	Z+2, r28	; 0x02
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1792:	78 94       	sei
    1794:	e1 2c       	mov	r14, r1
    1796:	f1 2c       	mov	r15, r1
    1798:	02 e0       	ldi	r16, 0x02	; 2
    179a:	96 01       	movw	r18, r12
    179c:	4e e5       	ldi	r20, 0x5E	; 94
    179e:	51 e0       	ldi	r21, 0x01	; 1
    17a0:	68 e7       	ldi	r22, 0x78	; 120
    17a2:	71 e0       	ldi	r23, 0x01	; 1
    17a4:	81 ed       	ldi	r24, 0xD1	; 209
    17a6:	99 e0       	ldi	r25, 0x09	; 9
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    17a8:	28 d5       	rcall	.+2640   	; 0x21fa <xTaskCreate>
    17aa:	9e 01       	movw	r18, r28
    17ac:	4e e5       	ldi	r20, 0x5E	; 94
    17ae:	51 e0       	ldi	r21, 0x01	; 1
    17b0:	6e e7       	ldi	r22, 0x7E	; 126
    17b2:	71 e0       	ldi	r23, 0x01	; 1
    17b4:	80 e4       	ldi	r24, 0x40	; 64
    17b6:	99 e0       	ldi	r25, 0x09	; 9
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위
				NULL                   //태스크 핸들
				);
    17b8:	20 d5       	rcall	.+2624   	; 0x21fa <xTaskCreate>
    17ba:	20 e0       	ldi	r18, 0x00	; 0
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	40 ef       	ldi	r20, 0xF0	; 240
    17c0:	50 e0       	ldi	r21, 0x00	; 0
    17c2:	64 e8       	ldi	r22, 0x84	; 132
    17c4:	71 e0       	ldi	r23, 0x01	; 1
    17c6:	8c e9       	ldi	r24, 0x9C	; 156
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    17c8:	97 e0       	ldi	r25, 0x07	; 7
    17ca:	17 d5       	rcall	.+2606   	; 0x21fa <xTaskCreate>
	return 0;
}
    17cc:	14 d6       	rcall	.+3112   	; 0x23f6 <vTaskStartScheduler>
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	df 91       	pop	r29
    17d4:	cf 91       	pop	r28
    17d6:	0f 91       	pop	r16
    17d8:	ff 90       	pop	r15
    17da:	ef 90       	pop	r14
    17dc:	df 90       	pop	r13
    17de:	cf 90       	pop	r12
    17e0:	08 95       	ret

000017e2 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    17e2:	08 95       	ret

000017e4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    17e4:	cf 93       	push	r28
    17e6:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    17e8:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    17ea:	2d d6       	rcall	.+3162   	; 0x2446 <vTaskSuspendAll>
    17ec:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <pucAlignedHeap.2069>
    17f0:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <pucAlignedHeap.2069+0x1>
    17f4:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    17f6:	31 f4       	brne	.+12     	; 0x1804 <pvPortMalloc+0x20>
    17f8:	8c e4       	ldi	r24, 0x4C	; 76
    17fa:	94 e0       	ldi	r25, 0x04	; 4
    17fc:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <pucAlignedHeap.2069+0x1>
    1800:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1804:	20 91 49 04 	lds	r18, 0x0449	; 0x800449 <xNextFreeByte>
    1808:	30 91 4a 04 	lds	r19, 0x044A	; 0x80044a <xNextFreeByte+0x1>
    180c:	c9 01       	movw	r24, r18
    180e:	8c 0f       	add	r24, r28
    1810:	9d 1f       	adc	r25, r29
    1812:	8b 3f       	cpi	r24, 0xFB	; 251
    1814:	48 e0       	ldi	r20, 0x08	; 8
    1816:	94 07       	cpc	r25, r20
    1818:	70 f4       	brcc	.+28     	; 0x1836 <pvPortMalloc+0x52>
    181a:	28 17       	cp	r18, r24
    181c:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    181e:	70 f4       	brcc	.+28     	; 0x183c <pvPortMalloc+0x58>
    1820:	c0 91 47 04 	lds	r28, 0x0447	; 0x800447 <pucAlignedHeap.2069>
    1824:	d0 91 48 04 	lds	r29, 0x0448	; 0x800448 <pucAlignedHeap.2069+0x1>
    1828:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    182a:	d3 1f       	adc	r29, r19
    182c:	90 93 4a 04 	sts	0x044A, r25	; 0x80044a <xNextFreeByte+0x1>
    1830:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1834:	05 c0       	rjmp	.+10     	; 0x1840 <pvPortMalloc+0x5c>
    1836:	c0 e0       	ldi	r28, 0x00	; 0
    1838:	d0 e0       	ldi	r29, 0x00	; 0
    183a:	02 c0       	rjmp	.+4      	; 0x1840 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    183c:	c0 e0       	ldi	r28, 0x00	; 0
    183e:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1840:	bf d6       	rcall	.+3454   	; 0x25c0 <xTaskResumeAll>
    1842:	ce 01       	movw	r24, r28
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	08 95       	ret

0000184a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    184a:	08 95       	ret

0000184c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    184c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    184e:	03 96       	adiw	r24, 0x03	; 3
    1850:	92 83       	std	Z+2, r25	; 0x02
    1852:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1854:	2f ef       	ldi	r18, 0xFF	; 255
    1856:	3f ef       	ldi	r19, 0xFF	; 255
    1858:	34 83       	std	Z+4, r19	; 0x04
    185a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    185c:	96 83       	std	Z+6, r25	; 0x06
    185e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1860:	90 87       	std	Z+8, r25	; 0x08
    1862:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1864:	10 82       	st	Z, r1
    1866:	08 95       	ret

00001868 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1868:	fc 01       	movw	r30, r24
    186a:	11 86       	std	Z+9, r1	; 0x09
    186c:	10 86       	std	Z+8, r1	; 0x08
    186e:	08 95       	ret

00001870 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1870:	cf 93       	push	r28
    1872:	df 93       	push	r29
    1874:	9c 01       	movw	r18, r24
    1876:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1878:	dc 01       	movw	r26, r24
    187a:	11 96       	adiw	r26, 0x01	; 1
    187c:	cd 91       	ld	r28, X+
    187e:	dc 91       	ld	r29, X
    1880:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1882:	d3 83       	std	Z+3, r29	; 0x03
    1884:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1886:	8c 81       	ldd	r24, Y+4	; 0x04
    1888:	9d 81       	ldd	r25, Y+5	; 0x05
    188a:	95 83       	std	Z+5, r25	; 0x05
    188c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    188e:	8c 81       	ldd	r24, Y+4	; 0x04
    1890:	9d 81       	ldd	r25, Y+5	; 0x05
    1892:	dc 01       	movw	r26, r24
    1894:	13 96       	adiw	r26, 0x03	; 3
    1896:	7c 93       	st	X, r23
    1898:	6e 93       	st	-X, r22
    189a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    189c:	7d 83       	std	Y+5, r23	; 0x05
    189e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18a0:	31 87       	std	Z+9, r19	; 0x09
    18a2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18a4:	f9 01       	movw	r30, r18
    18a6:	80 81       	ld	r24, Z
    18a8:	8f 5f       	subi	r24, 0xFF	; 255
    18aa:	80 83       	st	Z, r24
}
    18ac:	df 91       	pop	r29
    18ae:	cf 91       	pop	r28
    18b0:	08 95       	ret

000018b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18b2:	cf 93       	push	r28
    18b4:	df 93       	push	r29
    18b6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18b8:	48 81       	ld	r20, Y
    18ba:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18bc:	4f 3f       	cpi	r20, 0xFF	; 255
    18be:	2f ef       	ldi	r18, 0xFF	; 255
    18c0:	52 07       	cpc	r21, r18
    18c2:	21 f4       	brne	.+8      	; 0x18cc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    18c4:	fc 01       	movw	r30, r24
    18c6:	a7 81       	ldd	r26, Z+7	; 0x07
    18c8:	b0 85       	ldd	r27, Z+8	; 0x08
    18ca:	0d c0       	rjmp	.+26     	; 0x18e6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18cc:	dc 01       	movw	r26, r24
    18ce:	13 96       	adiw	r26, 0x03	; 3
    18d0:	01 c0       	rjmp	.+2      	; 0x18d4 <vListInsert+0x22>
    18d2:	df 01       	movw	r26, r30
    18d4:	12 96       	adiw	r26, 0x02	; 2
    18d6:	ed 91       	ld	r30, X+
    18d8:	fc 91       	ld	r31, X
    18da:	13 97       	sbiw	r26, 0x03	; 3
    18dc:	20 81       	ld	r18, Z
    18de:	31 81       	ldd	r19, Z+1	; 0x01
    18e0:	42 17       	cp	r20, r18
    18e2:	53 07       	cpc	r21, r19
    18e4:	b0 f7       	brcc	.-20     	; 0x18d2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    18e6:	12 96       	adiw	r26, 0x02	; 2
    18e8:	ed 91       	ld	r30, X+
    18ea:	fc 91       	ld	r31, X
    18ec:	13 97       	sbiw	r26, 0x03	; 3
    18ee:	fb 83       	std	Y+3, r31	; 0x03
    18f0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    18f2:	d5 83       	std	Z+5, r29	; 0x05
    18f4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    18f6:	bd 83       	std	Y+5, r27	; 0x05
    18f8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    18fa:	13 96       	adiw	r26, 0x03	; 3
    18fc:	dc 93       	st	X, r29
    18fe:	ce 93       	st	-X, r28
    1900:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1902:	99 87       	std	Y+9, r25	; 0x09
    1904:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1906:	fc 01       	movw	r30, r24
    1908:	20 81       	ld	r18, Z
    190a:	2f 5f       	subi	r18, 0xFF	; 255
    190c:	20 83       	st	Z, r18
}
    190e:	df 91       	pop	r29
    1910:	cf 91       	pop	r28
    1912:	08 95       	ret

00001914 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1914:	cf 93       	push	r28
    1916:	df 93       	push	r29
    1918:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    191a:	a0 85       	ldd	r26, Z+8	; 0x08
    191c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    191e:	c2 81       	ldd	r28, Z+2	; 0x02
    1920:	d3 81       	ldd	r29, Z+3	; 0x03
    1922:	84 81       	ldd	r24, Z+4	; 0x04
    1924:	95 81       	ldd	r25, Z+5	; 0x05
    1926:	9d 83       	std	Y+5, r25	; 0x05
    1928:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    192a:	c4 81       	ldd	r28, Z+4	; 0x04
    192c:	d5 81       	ldd	r29, Z+5	; 0x05
    192e:	82 81       	ldd	r24, Z+2	; 0x02
    1930:	93 81       	ldd	r25, Z+3	; 0x03
    1932:	9b 83       	std	Y+3, r25	; 0x03
    1934:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1936:	11 96       	adiw	r26, 0x01	; 1
    1938:	8d 91       	ld	r24, X+
    193a:	9c 91       	ld	r25, X
    193c:	12 97       	sbiw	r26, 0x02	; 2
    193e:	e8 17       	cp	r30, r24
    1940:	f9 07       	cpc	r31, r25
    1942:	31 f4       	brne	.+12     	; 0x1950 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1944:	84 81       	ldd	r24, Z+4	; 0x04
    1946:	95 81       	ldd	r25, Z+5	; 0x05
    1948:	12 96       	adiw	r26, 0x02	; 2
    194a:	9c 93       	st	X, r25
    194c:	8e 93       	st	-X, r24
    194e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1950:	11 86       	std	Z+9, r1	; 0x09
    1952:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1954:	8c 91       	ld	r24, X
    1956:	81 50       	subi	r24, 0x01	; 1
    1958:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    195a:	df 91       	pop	r29
    195c:	cf 91       	pop	r28
    195e:	08 95       	ret

00001960 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1960:	31 e1       	ldi	r19, 0x11	; 17
    1962:	fc 01       	movw	r30, r24
    1964:	30 83       	st	Z, r19
    1966:	31 97       	sbiw	r30, 0x01	; 1
    1968:	22 e2       	ldi	r18, 0x22	; 34
    196a:	20 83       	st	Z, r18
    196c:	31 97       	sbiw	r30, 0x01	; 1
    196e:	a3 e3       	ldi	r26, 0x33	; 51
    1970:	a0 83       	st	Z, r26
    1972:	31 97       	sbiw	r30, 0x01	; 1
    1974:	60 83       	st	Z, r22
    1976:	31 97       	sbiw	r30, 0x01	; 1
    1978:	70 83       	st	Z, r23
    197a:	31 97       	sbiw	r30, 0x01	; 1
    197c:	10 82       	st	Z, r1
    197e:	31 97       	sbiw	r30, 0x01	; 1
    1980:	60 e8       	ldi	r22, 0x80	; 128
    1982:	60 83       	st	Z, r22
    1984:	31 97       	sbiw	r30, 0x01	; 1
    1986:	10 82       	st	Z, r1
    1988:	31 97       	sbiw	r30, 0x01	; 1
    198a:	62 e0       	ldi	r22, 0x02	; 2
    198c:	60 83       	st	Z, r22
    198e:	31 97       	sbiw	r30, 0x01	; 1
    1990:	63 e0       	ldi	r22, 0x03	; 3
    1992:	60 83       	st	Z, r22
    1994:	31 97       	sbiw	r30, 0x01	; 1
    1996:	64 e0       	ldi	r22, 0x04	; 4
    1998:	60 83       	st	Z, r22
    199a:	31 97       	sbiw	r30, 0x01	; 1
    199c:	65 e0       	ldi	r22, 0x05	; 5
    199e:	60 83       	st	Z, r22
    19a0:	31 97       	sbiw	r30, 0x01	; 1
    19a2:	66 e0       	ldi	r22, 0x06	; 6
    19a4:	60 83       	st	Z, r22
    19a6:	31 97       	sbiw	r30, 0x01	; 1
    19a8:	67 e0       	ldi	r22, 0x07	; 7
    19aa:	60 83       	st	Z, r22
    19ac:	31 97       	sbiw	r30, 0x01	; 1
    19ae:	68 e0       	ldi	r22, 0x08	; 8
    19b0:	60 83       	st	Z, r22
    19b2:	31 97       	sbiw	r30, 0x01	; 1
    19b4:	69 e0       	ldi	r22, 0x09	; 9
    19b6:	60 83       	st	Z, r22
    19b8:	31 97       	sbiw	r30, 0x01	; 1
    19ba:	60 e1       	ldi	r22, 0x10	; 16
    19bc:	60 83       	st	Z, r22
    19be:	31 97       	sbiw	r30, 0x01	; 1
    19c0:	30 83       	st	Z, r19
    19c2:	31 97       	sbiw	r30, 0x01	; 1
    19c4:	32 e1       	ldi	r19, 0x12	; 18
    19c6:	30 83       	st	Z, r19
    19c8:	31 97       	sbiw	r30, 0x01	; 1
    19ca:	33 e1       	ldi	r19, 0x13	; 19
    19cc:	30 83       	st	Z, r19
    19ce:	31 97       	sbiw	r30, 0x01	; 1
    19d0:	34 e1       	ldi	r19, 0x14	; 20
    19d2:	30 83       	st	Z, r19
    19d4:	31 97       	sbiw	r30, 0x01	; 1
    19d6:	35 e1       	ldi	r19, 0x15	; 21
    19d8:	30 83       	st	Z, r19
    19da:	31 97       	sbiw	r30, 0x01	; 1
    19dc:	36 e1       	ldi	r19, 0x16	; 22
    19de:	30 83       	st	Z, r19
    19e0:	31 97       	sbiw	r30, 0x01	; 1
    19e2:	37 e1       	ldi	r19, 0x17	; 23
    19e4:	30 83       	st	Z, r19
    19e6:	31 97       	sbiw	r30, 0x01	; 1
    19e8:	38 e1       	ldi	r19, 0x18	; 24
    19ea:	30 83       	st	Z, r19
    19ec:	31 97       	sbiw	r30, 0x01	; 1
    19ee:	39 e1       	ldi	r19, 0x19	; 25
    19f0:	30 83       	st	Z, r19
    19f2:	31 97       	sbiw	r30, 0x01	; 1
    19f4:	30 e2       	ldi	r19, 0x20	; 32
    19f6:	30 83       	st	Z, r19
    19f8:	31 97       	sbiw	r30, 0x01	; 1
    19fa:	31 e2       	ldi	r19, 0x21	; 33
    19fc:	30 83       	st	Z, r19
    19fe:	31 97       	sbiw	r30, 0x01	; 1
    1a00:	20 83       	st	Z, r18
    1a02:	31 97       	sbiw	r30, 0x01	; 1
    1a04:	23 e2       	ldi	r18, 0x23	; 35
    1a06:	20 83       	st	Z, r18
    1a08:	31 97       	sbiw	r30, 0x01	; 1
    1a0a:	40 83       	st	Z, r20
    1a0c:	31 97       	sbiw	r30, 0x01	; 1
    1a0e:	50 83       	st	Z, r21
    1a10:	31 97       	sbiw	r30, 0x01	; 1
    1a12:	26 e2       	ldi	r18, 0x26	; 38
    1a14:	20 83       	st	Z, r18
    1a16:	31 97       	sbiw	r30, 0x01	; 1
    1a18:	27 e2       	ldi	r18, 0x27	; 39
    1a1a:	20 83       	st	Z, r18
    1a1c:	31 97       	sbiw	r30, 0x01	; 1
    1a1e:	28 e2       	ldi	r18, 0x28	; 40
    1a20:	20 83       	st	Z, r18
    1a22:	31 97       	sbiw	r30, 0x01	; 1
    1a24:	29 e2       	ldi	r18, 0x29	; 41
    1a26:	20 83       	st	Z, r18
    1a28:	31 97       	sbiw	r30, 0x01	; 1
    1a2a:	20 e3       	ldi	r18, 0x30	; 48
    1a2c:	20 83       	st	Z, r18
    1a2e:	31 97       	sbiw	r30, 0x01	; 1
    1a30:	21 e3       	ldi	r18, 0x31	; 49
    1a32:	20 83       	st	Z, r18
    1a34:	86 97       	sbiw	r24, 0x26	; 38
    1a36:	08 95       	ret

00001a38 <xPortStartScheduler>:
    1a38:	1b bc       	out	0x2b, r1	; 43
    1a3a:	89 ef       	ldi	r24, 0xF9	; 249
    1a3c:	8a bd       	out	0x2a, r24	; 42
    1a3e:	8b e0       	ldi	r24, 0x0B	; 11
    1a40:	8e bd       	out	0x2e, r24	; 46
    1a42:	87 b7       	in	r24, 0x37	; 55
    1a44:	80 61       	ori	r24, 0x10	; 16
    1a46:	87 bf       	out	0x37, r24	; 55
    1a48:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1a4c:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1a50:	cd 91       	ld	r28, X+
    1a52:	cd bf       	out	0x3d, r28	; 61
    1a54:	dd 91       	ld	r29, X+
    1a56:	de bf       	out	0x3e, r29	; 62
    1a58:	ff 91       	pop	r31
    1a5a:	ef 91       	pop	r30
    1a5c:	df 91       	pop	r29
    1a5e:	cf 91       	pop	r28
    1a60:	bf 91       	pop	r27
    1a62:	af 91       	pop	r26
    1a64:	9f 91       	pop	r25
    1a66:	8f 91       	pop	r24
    1a68:	7f 91       	pop	r23
    1a6a:	6f 91       	pop	r22
    1a6c:	5f 91       	pop	r21
    1a6e:	4f 91       	pop	r20
    1a70:	3f 91       	pop	r19
    1a72:	2f 91       	pop	r18
    1a74:	1f 91       	pop	r17
    1a76:	0f 91       	pop	r16
    1a78:	ff 90       	pop	r15
    1a7a:	ef 90       	pop	r14
    1a7c:	df 90       	pop	r13
    1a7e:	cf 90       	pop	r12
    1a80:	bf 90       	pop	r11
    1a82:	af 90       	pop	r10
    1a84:	9f 90       	pop	r9
    1a86:	8f 90       	pop	r8
    1a88:	7f 90       	pop	r7
    1a8a:	6f 90       	pop	r6
    1a8c:	5f 90       	pop	r5
    1a8e:	4f 90       	pop	r4
    1a90:	3f 90       	pop	r3
    1a92:	2f 90       	pop	r2
    1a94:	1f 90       	pop	r1
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	0f 90       	pop	r0
    1a9c:	08 95       	ret
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	08 95       	ret

00001aa2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1aa2:	0f 92       	push	r0
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	f8 94       	cli
    1aa8:	0f 92       	push	r0
    1aaa:	1f 92       	push	r1
    1aac:	11 24       	eor	r1, r1
    1aae:	2f 92       	push	r2
    1ab0:	3f 92       	push	r3
    1ab2:	4f 92       	push	r4
    1ab4:	5f 92       	push	r5
    1ab6:	6f 92       	push	r6
    1ab8:	7f 92       	push	r7
    1aba:	8f 92       	push	r8
    1abc:	9f 92       	push	r9
    1abe:	af 92       	push	r10
    1ac0:	bf 92       	push	r11
    1ac2:	cf 92       	push	r12
    1ac4:	df 92       	push	r13
    1ac6:	ef 92       	push	r14
    1ac8:	ff 92       	push	r15
    1aca:	0f 93       	push	r16
    1acc:	1f 93       	push	r17
    1ace:	2f 93       	push	r18
    1ad0:	3f 93       	push	r19
    1ad2:	4f 93       	push	r20
    1ad4:	5f 93       	push	r21
    1ad6:	6f 93       	push	r22
    1ad8:	7f 93       	push	r23
    1ada:	8f 93       	push	r24
    1adc:	9f 93       	push	r25
    1ade:	af 93       	push	r26
    1ae0:	bf 93       	push	r27
    1ae2:	cf 93       	push	r28
    1ae4:	df 93       	push	r29
    1ae6:	ef 93       	push	r30
    1ae8:	ff 93       	push	r31
    1aea:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1aee:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1af2:	0d b6       	in	r0, 0x3d	; 61
    1af4:	0d 92       	st	X+, r0
    1af6:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1af8:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    1afa:	22 d6       	rcall	.+3140   	; 0x2740 <vTaskSwitchContext>
    1afc:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1b00:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1b04:	cd 91       	ld	r28, X+
    1b06:	cd bf       	out	0x3d, r28	; 61
    1b08:	dd 91       	ld	r29, X+
    1b0a:	de bf       	out	0x3e, r29	; 62
    1b0c:	ff 91       	pop	r31
    1b0e:	ef 91       	pop	r30
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	bf 91       	pop	r27
    1b16:	af 91       	pop	r26
    1b18:	9f 91       	pop	r25
    1b1a:	8f 91       	pop	r24
    1b1c:	7f 91       	pop	r23
    1b1e:	6f 91       	pop	r22
    1b20:	5f 91       	pop	r21
    1b22:	4f 91       	pop	r20
    1b24:	3f 91       	pop	r19
    1b26:	2f 91       	pop	r18
    1b28:	1f 91       	pop	r17
    1b2a:	0f 91       	pop	r16
    1b2c:	ff 90       	pop	r15
    1b2e:	ef 90       	pop	r14
    1b30:	df 90       	pop	r13
    1b32:	cf 90       	pop	r12
    1b34:	bf 90       	pop	r11
    1b36:	af 90       	pop	r10
    1b38:	9f 90       	pop	r9
    1b3a:	8f 90       	pop	r8
    1b3c:	7f 90       	pop	r7
    1b3e:	6f 90       	pop	r6
    1b40:	5f 90       	pop	r5
    1b42:	4f 90       	pop	r4
    1b44:	3f 90       	pop	r3
    1b46:	2f 90       	pop	r2
    1b48:	1f 90       	pop	r1
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1b4e:	0f 90       	pop	r0
    1b50:	08 95       	ret

00001b52 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b52:	0f 92       	push	r0
    1b54:	0f b6       	in	r0, 0x3f	; 63
    1b56:	f8 94       	cli
    1b58:	0f 92       	push	r0
    1b5a:	1f 92       	push	r1
    1b5c:	11 24       	eor	r1, r1
    1b5e:	2f 92       	push	r2
    1b60:	3f 92       	push	r3
    1b62:	4f 92       	push	r4
    1b64:	5f 92       	push	r5
    1b66:	6f 92       	push	r6
    1b68:	7f 92       	push	r7
    1b6a:	8f 92       	push	r8
    1b6c:	9f 92       	push	r9
    1b6e:	af 92       	push	r10
    1b70:	bf 92       	push	r11
    1b72:	cf 92       	push	r12
    1b74:	df 92       	push	r13
    1b76:	ef 92       	push	r14
    1b78:	ff 92       	push	r15
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	2f 93       	push	r18
    1b80:	3f 93       	push	r19
    1b82:	4f 93       	push	r20
    1b84:	5f 93       	push	r21
    1b86:	6f 93       	push	r22
    1b88:	7f 93       	push	r23
    1b8a:	8f 93       	push	r24
    1b8c:	9f 93       	push	r25
    1b8e:	af 93       	push	r26
    1b90:	bf 93       	push	r27
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	ef 93       	push	r30
    1b98:	ff 93       	push	r31
    1b9a:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1b9e:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1ba2:	0d b6       	in	r0, 0x3d	; 61
    1ba4:	0d 92       	st	X+, r0
    1ba6:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    1ba8:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    1baa:	53 d4       	rcall	.+2214   	; 0x2452 <xTaskIncrementTick>
    1bac:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    1bae:	c8 d5       	rcall	.+2960   	; 0x2740 <vTaskSwitchContext>
    1bb0:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1bb4:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1bb8:	cd 91       	ld	r28, X+
    1bba:	cd bf       	out	0x3d, r28	; 61
    1bbc:	dd 91       	ld	r29, X+
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	ff 91       	pop	r31
    1bc2:	ef 91       	pop	r30
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	bf 91       	pop	r27
    1bca:	af 91       	pop	r26
    1bcc:	9f 91       	pop	r25
    1bce:	8f 91       	pop	r24
    1bd0:	7f 91       	pop	r23
    1bd2:	6f 91       	pop	r22
    1bd4:	5f 91       	pop	r21
    1bd6:	4f 91       	pop	r20
    1bd8:	3f 91       	pop	r19
    1bda:	2f 91       	pop	r18
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	ff 90       	pop	r15
    1be2:	ef 90       	pop	r14
    1be4:	df 90       	pop	r13
    1be6:	cf 90       	pop	r12
    1be8:	bf 90       	pop	r11
    1bea:	af 90       	pop	r10
    1bec:	9f 90       	pop	r9
    1bee:	8f 90       	pop	r8
    1bf0:	7f 90       	pop	r7
    1bf2:	6f 90       	pop	r6
    1bf4:	5f 90       	pop	r5
    1bf6:	4f 90       	pop	r4
    1bf8:	3f 90       	pop	r3
    1bfa:	2f 90       	pop	r2
    1bfc:	1f 90       	pop	r1
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1c02:	0f 90       	pop	r0
    1c04:	08 95       	ret

00001c06 <__vector_12>:
    1c06:	a5 df       	rcall	.-182    	; 0x1b52 <vPortYieldFromTick>
    1c08:	18 95       	reti

00001c0a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1c0a:	0f 93       	push	r16
    1c0c:	1f 93       	push	r17
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
    1c12:	ec 01       	movw	r28, r24
    1c14:	04 2f       	mov	r16, r20
    1c16:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1c18:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c1a:	41 11       	cpse	r20, r1
    1c1c:	0b c0       	rjmp	.+22     	; 0x1c34 <prvCopyDataToQueue+0x2a>
    1c1e:	88 81       	ld	r24, Y
    1c20:	99 81       	ldd	r25, Y+1	; 0x01
    1c22:	89 2b       	or	r24, r25
    1c24:	09 f0       	breq	.+2      	; 0x1c28 <prvCopyDataToQueue+0x1e>
    1c26:	3f c0       	rjmp	.+126    	; 0x1ca6 <prvCopyDataToQueue+0x9c>
    1c28:	8a 81       	ldd	r24, Y+2	; 0x02
    1c2a:	9b 81       	ldd	r25, Y+3	; 0x03
    1c2c:	08 d7       	rcall	.+3600   	; 0x2a3e <xTaskPriorityDisinherit>
    1c2e:	1b 82       	std	Y+3, r1	; 0x03
    1c30:	1a 82       	std	Y+2, r1	; 0x02
    1c32:	40 c0       	rjmp	.+128    	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1c34:	01 11       	cpse	r16, r1
    1c36:	16 c0       	rjmp	.+44     	; 0x1c64 <prvCopyDataToQueue+0x5a>
    1c38:	50 e0       	ldi	r21, 0x00	; 0
    1c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3e:	5a d7       	rcall	.+3764   	; 0x2af4 <memcpy>
    1c40:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c42:	8c 81       	ldd	r24, Y+4	; 0x04
    1c44:	9d 81       	ldd	r25, Y+5	; 0x05
    1c46:	82 0f       	add	r24, r18
    1c48:	91 1d       	adc	r25, r1
    1c4a:	9d 83       	std	Y+5, r25	; 0x05
    1c4c:	8c 83       	std	Y+4, r24	; 0x04
    1c4e:	2a 81       	ldd	r18, Y+2	; 0x02
    1c50:	3b 81       	ldd	r19, Y+3	; 0x03
    1c52:	82 17       	cp	r24, r18
    1c54:	93 07       	cpc	r25, r19
    1c56:	48 f1       	brcs	.+82     	; 0x1caa <prvCopyDataToQueue+0xa0>
    1c58:	88 81       	ld	r24, Y
    1c5a:	99 81       	ldd	r25, Y+1	; 0x01
    1c5c:	9d 83       	std	Y+5, r25	; 0x05
    1c5e:	8c 83       	std	Y+4, r24	; 0x04
    1c60:	80 e0       	ldi	r24, 0x00	; 0
    1c62:	28 c0       	rjmp	.+80     	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1c64:	50 e0       	ldi	r21, 0x00	; 0
    1c66:	8e 81       	ldd	r24, Y+6	; 0x06
    1c68:	9f 81       	ldd	r25, Y+7	; 0x07
    1c6a:	44 d7       	rcall	.+3720   	; 0x2af4 <memcpy>
    1c6c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	91 95       	neg	r25
    1c72:	81 95       	neg	r24
    1c74:	91 09       	sbc	r25, r1
    1c76:	2e 81       	ldd	r18, Y+6	; 0x06
    1c78:	3f 81       	ldd	r19, Y+7	; 0x07
    1c7a:	28 0f       	add	r18, r24
    1c7c:	39 1f       	adc	r19, r25
    1c7e:	3f 83       	std	Y+7, r19	; 0x07
    1c80:	2e 83       	std	Y+6, r18	; 0x06
    1c82:	48 81       	ld	r20, Y
    1c84:	59 81       	ldd	r21, Y+1	; 0x01
    1c86:	24 17       	cp	r18, r20
    1c88:	35 07       	cpc	r19, r21
    1c8a:	30 f4       	brcc	.+12     	; 0x1c98 <prvCopyDataToQueue+0x8e>
    1c8c:	2a 81       	ldd	r18, Y+2	; 0x02
    1c8e:	3b 81       	ldd	r19, Y+3	; 0x03
    1c90:	82 0f       	add	r24, r18
    1c92:	93 1f       	adc	r25, r19
    1c94:	9f 83       	std	Y+7, r25	; 0x07
    1c96:	8e 83       	std	Y+6, r24	; 0x06
    1c98:	02 30       	cpi	r16, 0x02	; 2
    1c9a:	49 f4       	brne	.+18     	; 0x1cae <prvCopyDataToQueue+0xa4>
    1c9c:	11 23       	and	r17, r17
    1c9e:	49 f0       	breq	.+18     	; 0x1cb2 <prvCopyDataToQueue+0xa8>
    1ca0:	11 50       	subi	r17, 0x01	; 1
    1ca2:	80 e0       	ldi	r24, 0x00	; 0
    1ca4:	07 c0       	rjmp	.+14     	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1ca6:	80 e0       	ldi	r24, 0x00	; 0
    1ca8:	05 c0       	rjmp	.+10     	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1caa:	80 e0       	ldi	r24, 0x00	; 0
    1cac:	03 c0       	rjmp	.+6      	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1cae:	80 e0       	ldi	r24, 0x00	; 0
    1cb0:	01 c0       	rjmp	.+2      	; 0x1cb4 <prvCopyDataToQueue+0xaa>
    1cb2:	80 e0       	ldi	r24, 0x00	; 0
    1cb4:	1f 5f       	subi	r17, 0xFF	; 255
    1cb6:	1a 8f       	std	Y+26, r17	; 0x1a
    1cb8:	df 91       	pop	r29
    1cba:	cf 91       	pop	r28
    1cbc:	1f 91       	pop	r17
    1cbe:	0f 91       	pop	r16
    1cc0:	08 95       	ret

00001cc2 <prvCopyDataFromQueue>:
    1cc2:	fc 01       	movw	r30, r24
    1cc4:	44 8d       	ldd	r20, Z+28	; 0x1c
    1cc6:	44 23       	and	r20, r20
    1cc8:	a1 f0       	breq	.+40     	; 0x1cf2 <prvCopyDataFromQueue+0x30>
    1cca:	50 e0       	ldi	r21, 0x00	; 0
    1ccc:	26 81       	ldd	r18, Z+6	; 0x06
    1cce:	37 81       	ldd	r19, Z+7	; 0x07
    1cd0:	24 0f       	add	r18, r20
    1cd2:	35 1f       	adc	r19, r21
    1cd4:	37 83       	std	Z+7, r19	; 0x07
    1cd6:	26 83       	std	Z+6, r18	; 0x06
    1cd8:	82 81       	ldd	r24, Z+2	; 0x02
    1cda:	93 81       	ldd	r25, Z+3	; 0x03
    1cdc:	28 17       	cp	r18, r24
    1cde:	39 07       	cpc	r19, r25
    1ce0:	20 f0       	brcs	.+8      	; 0x1cea <prvCopyDataFromQueue+0x28>
    1ce2:	80 81       	ld	r24, Z
    1ce4:	91 81       	ldd	r25, Z+1	; 0x01
    1ce6:	97 83       	std	Z+7, r25	; 0x07
    1ce8:	86 83       	std	Z+6, r24	; 0x06
    1cea:	cb 01       	movw	r24, r22
    1cec:	66 81       	ldd	r22, Z+6	; 0x06
    1cee:	77 81       	ldd	r23, Z+7	; 0x07
    1cf0:	01 c7       	rjmp	.+3586   	; 0x2af4 <memcpy>
    1cf2:	08 95       	ret

00001cf4 <prvUnlockQueue>:
    1cf4:	ef 92       	push	r14
    1cf6:	ff 92       	push	r15
    1cf8:	0f 93       	push	r16
    1cfa:	1f 93       	push	r17
    1cfc:	cf 93       	push	r28
    1cfe:	8c 01       	movw	r16, r24
    1d00:	0f b6       	in	r0, 0x3f	; 63
    1d02:	f8 94       	cli
    1d04:	0f 92       	push	r0
    1d06:	fc 01       	movw	r30, r24
    1d08:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1d0a:	1c 16       	cp	r1, r28
    1d0c:	9c f4       	brge	.+38     	; 0x1d34 <prvUnlockQueue+0x40>
    1d0e:	81 89       	ldd	r24, Z+17	; 0x11
    1d10:	81 11       	cpse	r24, r1
    1d12:	06 c0       	rjmp	.+12     	; 0x1d20 <prvUnlockQueue+0x2c>
    1d14:	0f c0       	rjmp	.+30     	; 0x1d34 <prvUnlockQueue+0x40>
    1d16:	f8 01       	movw	r30, r16
    1d18:	81 89       	ldd	r24, Z+17	; 0x11
    1d1a:	81 11       	cpse	r24, r1
    1d1c:	05 c0       	rjmp	.+10     	; 0x1d28 <prvUnlockQueue+0x34>
    1d1e:	0a c0       	rjmp	.+20     	; 0x1d34 <prvUnlockQueue+0x40>
    1d20:	78 01       	movw	r14, r16
    1d22:	f1 e1       	ldi	r31, 0x11	; 17
    1d24:	ef 0e       	add	r14, r31
    1d26:	f1 1c       	adc	r15, r1
    1d28:	c7 01       	movw	r24, r14
    1d2a:	9a d5       	rcall	.+2868   	; 0x2860 <xTaskRemoveFromEventList>
    1d2c:	81 11       	cpse	r24, r1
    1d2e:	21 d6       	rcall	.+3138   	; 0x2972 <vTaskMissedYield>
    1d30:	c1 50       	subi	r28, 0x01	; 1
    1d32:	89 f7       	brne	.-30     	; 0x1d16 <prvUnlockQueue+0x22>
    1d34:	8f ef       	ldi	r24, 0xFF	; 255
    1d36:	f8 01       	movw	r30, r16
    1d38:	86 8f       	std	Z+30, r24	; 0x1e
    1d3a:	0f 90       	pop	r0
    1d3c:	0f be       	out	0x3f, r0	; 63
    1d3e:	0f b6       	in	r0, 0x3f	; 63
    1d40:	f8 94       	cli
    1d42:	0f 92       	push	r0
    1d44:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1d46:	1c 16       	cp	r1, r28
    1d48:	9c f4       	brge	.+38     	; 0x1d70 <prvUnlockQueue+0x7c>
    1d4a:	80 85       	ldd	r24, Z+8	; 0x08
    1d4c:	81 11       	cpse	r24, r1
    1d4e:	06 c0       	rjmp	.+12     	; 0x1d5c <prvUnlockQueue+0x68>
    1d50:	0f c0       	rjmp	.+30     	; 0x1d70 <prvUnlockQueue+0x7c>
    1d52:	f8 01       	movw	r30, r16
    1d54:	80 85       	ldd	r24, Z+8	; 0x08
    1d56:	81 11       	cpse	r24, r1
    1d58:	05 c0       	rjmp	.+10     	; 0x1d64 <prvUnlockQueue+0x70>
    1d5a:	0a c0       	rjmp	.+20     	; 0x1d70 <prvUnlockQueue+0x7c>
    1d5c:	78 01       	movw	r14, r16
    1d5e:	f8 e0       	ldi	r31, 0x08	; 8
    1d60:	ef 0e       	add	r14, r31
    1d62:	f1 1c       	adc	r15, r1
    1d64:	c7 01       	movw	r24, r14
    1d66:	7c d5       	rcall	.+2808   	; 0x2860 <xTaskRemoveFromEventList>
    1d68:	81 11       	cpse	r24, r1
    1d6a:	03 d6       	rcall	.+3078   	; 0x2972 <vTaskMissedYield>
    1d6c:	c1 50       	subi	r28, 0x01	; 1
    1d6e:	89 f7       	brne	.-30     	; 0x1d52 <prvUnlockQueue+0x5e>
    1d70:	8f ef       	ldi	r24, 0xFF	; 255
    1d72:	f8 01       	movw	r30, r16
    1d74:	85 8f       	std	Z+29, r24	; 0x1d
    1d76:	0f 90       	pop	r0
    1d78:	0f be       	out	0x3f, r0	; 63
    1d7a:	cf 91       	pop	r28
    1d7c:	1f 91       	pop	r17
    1d7e:	0f 91       	pop	r16
    1d80:	ff 90       	pop	r15
    1d82:	ef 90       	pop	r14
    1d84:	08 95       	ret

00001d86 <xQueueGenericReset>:
    1d86:	cf 93       	push	r28
    1d88:	df 93       	push	r29
    1d8a:	ec 01       	movw	r28, r24
    1d8c:	0f b6       	in	r0, 0x3f	; 63
    1d8e:	f8 94       	cli
    1d90:	0f 92       	push	r0
    1d92:	48 81       	ld	r20, Y
    1d94:	59 81       	ldd	r21, Y+1	; 0x01
    1d96:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1d98:	30 e0       	ldi	r19, 0x00	; 0
    1d9a:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1d9c:	72 9f       	mul	r23, r18
    1d9e:	c0 01       	movw	r24, r0
    1da0:	73 9f       	mul	r23, r19
    1da2:	90 0d       	add	r25, r0
    1da4:	11 24       	eor	r1, r1
    1da6:	fa 01       	movw	r30, r20
    1da8:	e8 0f       	add	r30, r24
    1daa:	f9 1f       	adc	r31, r25
    1dac:	fb 83       	std	Y+3, r31	; 0x03
    1dae:	ea 83       	std	Y+2, r30	; 0x02
    1db0:	1a 8e       	std	Y+26, r1	; 0x1a
    1db2:	5d 83       	std	Y+5, r21	; 0x05
    1db4:	4c 83       	std	Y+4, r20	; 0x04
    1db6:	82 1b       	sub	r24, r18
    1db8:	93 0b       	sbc	r25, r19
    1dba:	84 0f       	add	r24, r20
    1dbc:	95 1f       	adc	r25, r21
    1dbe:	9f 83       	std	Y+7, r25	; 0x07
    1dc0:	8e 83       	std	Y+6, r24	; 0x06
    1dc2:	8f ef       	ldi	r24, 0xFF	; 255
    1dc4:	8d 8f       	std	Y+29, r24	; 0x1d
    1dc6:	8e 8f       	std	Y+30, r24	; 0x1e
    1dc8:	61 11       	cpse	r22, r1
    1dca:	0a c0       	rjmp	.+20     	; 0x1de0 <xQueueGenericReset+0x5a>
    1dcc:	88 85       	ldd	r24, Y+8	; 0x08
    1dce:	88 23       	and	r24, r24
    1dd0:	69 f0       	breq	.+26     	; 0x1dec <xQueueGenericReset+0x66>
    1dd2:	ce 01       	movw	r24, r28
    1dd4:	08 96       	adiw	r24, 0x08	; 8
    1dd6:	44 d5       	rcall	.+2696   	; 0x2860 <xTaskRemoveFromEventList>
    1dd8:	88 23       	and	r24, r24
    1dda:	41 f0       	breq	.+16     	; 0x1dec <xQueueGenericReset+0x66>
    1ddc:	62 de       	rcall	.-828    	; 0x1aa2 <vPortYield>
    1dde:	06 c0       	rjmp	.+12     	; 0x1dec <xQueueGenericReset+0x66>
    1de0:	ce 01       	movw	r24, r28
    1de2:	08 96       	adiw	r24, 0x08	; 8
    1de4:	33 dd       	rcall	.-1434   	; 0x184c <vListInitialise>
    1de6:	ce 01       	movw	r24, r28
    1de8:	41 96       	adiw	r24, 0x11	; 17
    1dea:	30 dd       	rcall	.-1440   	; 0x184c <vListInitialise>
    1dec:	0f 90       	pop	r0
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	81 e0       	ldi	r24, 0x01	; 1
    1df2:	df 91       	pop	r29
    1df4:	cf 91       	pop	r28
    1df6:	08 95       	ret

00001df8 <xQueueGenericCreate>:
    1df8:	0f 93       	push	r16
    1dfa:	1f 93       	push	r17
    1dfc:	cf 93       	push	r28
    1dfe:	df 93       	push	r29
    1e00:	08 2f       	mov	r16, r24
    1e02:	16 2f       	mov	r17, r22
    1e04:	66 23       	and	r22, r22
    1e06:	b1 f0       	breq	.+44     	; 0x1e34 <xQueueGenericCreate+0x3c>
    1e08:	86 9f       	mul	r24, r22
    1e0a:	c0 01       	movw	r24, r0
    1e0c:	11 24       	eor	r1, r1
    1e0e:	4f 96       	adiw	r24, 0x1f	; 31
    1e10:	e9 dc       	rcall	.-1582   	; 0x17e4 <pvPortMalloc>
    1e12:	ec 01       	movw	r28, r24
    1e14:	00 97       	sbiw	r24, 0x00	; 0
    1e16:	39 f4       	brne	.+14     	; 0x1e26 <xQueueGenericCreate+0x2e>
    1e18:	13 c0       	rjmp	.+38     	; 0x1e40 <xQueueGenericCreate+0x48>
    1e1a:	0b 8f       	std	Y+27, r16	; 0x1b
    1e1c:	1c 8f       	std	Y+28, r17	; 0x1c
    1e1e:	61 e0       	ldi	r22, 0x01	; 1
    1e20:	ce 01       	movw	r24, r28
    1e22:	b1 df       	rcall	.-158    	; 0x1d86 <xQueueGenericReset>
    1e24:	0d c0       	rjmp	.+26     	; 0x1e40 <xQueueGenericCreate+0x48>
    1e26:	4f 96       	adiw	r24, 0x1f	; 31
    1e28:	99 83       	std	Y+1, r25	; 0x01
    1e2a:	88 83       	st	Y, r24
    1e2c:	f6 cf       	rjmp	.-20     	; 0x1e1a <xQueueGenericCreate+0x22>
    1e2e:	d9 83       	std	Y+1, r29	; 0x01
    1e30:	c8 83       	st	Y, r28
    1e32:	f3 cf       	rjmp	.-26     	; 0x1e1a <xQueueGenericCreate+0x22>
    1e34:	8f e1       	ldi	r24, 0x1F	; 31
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	d5 dc       	rcall	.-1622   	; 0x17e4 <pvPortMalloc>
    1e3a:	ec 01       	movw	r28, r24
    1e3c:	89 2b       	or	r24, r25
    1e3e:	b9 f7       	brne	.-18     	; 0x1e2e <xQueueGenericCreate+0x36>
    1e40:	ce 01       	movw	r24, r28
    1e42:	df 91       	pop	r29
    1e44:	cf 91       	pop	r28
    1e46:	1f 91       	pop	r17
    1e48:	0f 91       	pop	r16
    1e4a:	08 95       	ret

00001e4c <xQueueGenericSend>:
    1e4c:	9f 92       	push	r9
    1e4e:	af 92       	push	r10
    1e50:	bf 92       	push	r11
    1e52:	cf 92       	push	r12
    1e54:	df 92       	push	r13
    1e56:	ef 92       	push	r14
    1e58:	ff 92       	push	r15
    1e5a:	0f 93       	push	r16
    1e5c:	1f 93       	push	r17
    1e5e:	cf 93       	push	r28
    1e60:	df 93       	push	r29
    1e62:	00 d0       	rcall	.+0      	; 0x1e64 <xQueueGenericSend+0x18>
    1e64:	00 d0       	rcall	.+0      	; 0x1e66 <xQueueGenericSend+0x1a>
    1e66:	1f 92       	push	r1
    1e68:	cd b7       	in	r28, 0x3d	; 61
    1e6a:	de b7       	in	r29, 0x3e	; 62
    1e6c:	8c 01       	movw	r16, r24
    1e6e:	6b 01       	movw	r12, r22
    1e70:	5d 83       	std	Y+5, r21	; 0x05
    1e72:	4c 83       	std	Y+4, r20	; 0x04
    1e74:	a2 2e       	mov	r10, r18
    1e76:	b1 2c       	mov	r11, r1
    1e78:	99 24       	eor	r9, r9
    1e7a:	93 94       	inc	r9
    1e7c:	7c 01       	movw	r14, r24
    1e7e:	88 e0       	ldi	r24, 0x08	; 8
    1e80:	e8 0e       	add	r14, r24
    1e82:	f1 1c       	adc	r15, r1
    1e84:	0f b6       	in	r0, 0x3f	; 63
    1e86:	f8 94       	cli
    1e88:	0f 92       	push	r0
    1e8a:	f8 01       	movw	r30, r16
    1e8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e8e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e90:	98 17       	cp	r25, r24
    1e92:	18 f0       	brcs	.+6      	; 0x1e9a <xQueueGenericSend+0x4e>
    1e94:	f2 e0       	ldi	r31, 0x02	; 2
    1e96:	af 12       	cpse	r10, r31
    1e98:	15 c0       	rjmp	.+42     	; 0x1ec4 <xQueueGenericSend+0x78>
    1e9a:	4a 2d       	mov	r20, r10
    1e9c:	b6 01       	movw	r22, r12
    1e9e:	c8 01       	movw	r24, r16
    1ea0:	b4 de       	rcall	.-664    	; 0x1c0a <prvCopyDataToQueue>
    1ea2:	f8 01       	movw	r30, r16
    1ea4:	91 89       	ldd	r25, Z+17	; 0x11
    1ea6:	99 23       	and	r25, r25
    1ea8:	39 f0       	breq	.+14     	; 0x1eb8 <xQueueGenericSend+0x6c>
    1eaa:	c8 01       	movw	r24, r16
    1eac:	41 96       	adiw	r24, 0x11	; 17
    1eae:	d8 d4       	rcall	.+2480   	; 0x2860 <xTaskRemoveFromEventList>
    1eb0:	88 23       	and	r24, r24
    1eb2:	21 f0       	breq	.+8      	; 0x1ebc <xQueueGenericSend+0x70>
    1eb4:	f6 dd       	rcall	.-1044   	; 0x1aa2 <vPortYield>
    1eb6:	02 c0       	rjmp	.+4      	; 0x1ebc <xQueueGenericSend+0x70>
    1eb8:	81 11       	cpse	r24, r1
    1eba:	f3 dd       	rcall	.-1050   	; 0x1aa2 <vPortYield>
    1ebc:	0f 90       	pop	r0
    1ebe:	0f be       	out	0x3f, r0	; 63
    1ec0:	81 e0       	ldi	r24, 0x01	; 1
    1ec2:	45 c0       	rjmp	.+138    	; 0x1f4e <xQueueGenericSend+0x102>
    1ec4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ec6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ec8:	89 2b       	or	r24, r25
    1eca:	21 f4       	brne	.+8      	; 0x1ed4 <xQueueGenericSend+0x88>
    1ecc:	0f 90       	pop	r0
    1ece:	0f be       	out	0x3f, r0	; 63
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	3d c0       	rjmp	.+122    	; 0x1f4e <xQueueGenericSend+0x102>
    1ed4:	b1 10       	cpse	r11, r1
    1ed6:	04 c0       	rjmp	.+8      	; 0x1ee0 <xQueueGenericSend+0x94>
    1ed8:	ce 01       	movw	r24, r28
    1eda:	01 96       	adiw	r24, 0x01	; 1
    1edc:	07 d5       	rcall	.+2574   	; 0x28ec <vTaskSetTimeOutState>
    1ede:	b9 2c       	mov	r11, r9
    1ee0:	0f 90       	pop	r0
    1ee2:	0f be       	out	0x3f, r0	; 63
    1ee4:	b0 d2       	rcall	.+1376   	; 0x2446 <vTaskSuspendAll>
    1ee6:	0f b6       	in	r0, 0x3f	; 63
    1ee8:	f8 94       	cli
    1eea:	0f 92       	push	r0
    1eec:	f8 01       	movw	r30, r16
    1eee:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ef0:	8f 3f       	cpi	r24, 0xFF	; 255
    1ef2:	09 f4       	brne	.+2      	; 0x1ef6 <xQueueGenericSend+0xaa>
    1ef4:	15 8e       	std	Z+29, r1	; 0x1d
    1ef6:	f8 01       	movw	r30, r16
    1ef8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1efa:	8f 3f       	cpi	r24, 0xFF	; 255
    1efc:	09 f4       	brne	.+2      	; 0x1f00 <xQueueGenericSend+0xb4>
    1efe:	16 8e       	std	Z+30, r1	; 0x1e
    1f00:	0f 90       	pop	r0
    1f02:	0f be       	out	0x3f, r0	; 63
    1f04:	be 01       	movw	r22, r28
    1f06:	6c 5f       	subi	r22, 0xFC	; 252
    1f08:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0a:	ce 01       	movw	r24, r28
    1f0c:	01 96       	adiw	r24, 0x01	; 1
    1f0e:	f9 d4       	rcall	.+2546   	; 0x2902 <xTaskCheckForTimeOut>
    1f10:	81 11       	cpse	r24, r1
    1f12:	19 c0       	rjmp	.+50     	; 0x1f46 <xQueueGenericSend+0xfa>
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	0f 92       	push	r0
    1f1a:	f8 01       	movw	r30, r16
    1f1c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f1e:	0f 90       	pop	r0
    1f20:	0f be       	out	0x3f, r0	; 63
    1f22:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f24:	98 13       	cpse	r25, r24
    1f26:	0b c0       	rjmp	.+22     	; 0x1f3e <xQueueGenericSend+0xf2>
    1f28:	6c 81       	ldd	r22, Y+4	; 0x04
    1f2a:	7d 81       	ldd	r23, Y+5	; 0x05
    1f2c:	c7 01       	movw	r24, r14
    1f2e:	88 d4       	rcall	.+2320   	; 0x2840 <vTaskPlaceOnEventList>
    1f30:	c8 01       	movw	r24, r16
    1f32:	e0 de       	rcall	.-576    	; 0x1cf4 <prvUnlockQueue>
    1f34:	45 d3       	rcall	.+1674   	; 0x25c0 <xTaskResumeAll>
    1f36:	81 11       	cpse	r24, r1
    1f38:	a5 cf       	rjmp	.-182    	; 0x1e84 <xQueueGenericSend+0x38>
    1f3a:	b3 dd       	rcall	.-1178   	; 0x1aa2 <vPortYield>
    1f3c:	a3 cf       	rjmp	.-186    	; 0x1e84 <xQueueGenericSend+0x38>
    1f3e:	c8 01       	movw	r24, r16
    1f40:	d9 de       	rcall	.-590    	; 0x1cf4 <prvUnlockQueue>
    1f42:	3e d3       	rcall	.+1660   	; 0x25c0 <xTaskResumeAll>
    1f44:	9f cf       	rjmp	.-194    	; 0x1e84 <xQueueGenericSend+0x38>
    1f46:	c8 01       	movw	r24, r16
    1f48:	d5 de       	rcall	.-598    	; 0x1cf4 <prvUnlockQueue>
    1f4a:	3a d3       	rcall	.+1652   	; 0x25c0 <xTaskResumeAll>
    1f4c:	80 e0       	ldi	r24, 0x00	; 0
    1f4e:	0f 90       	pop	r0
    1f50:	0f 90       	pop	r0
    1f52:	0f 90       	pop	r0
    1f54:	0f 90       	pop	r0
    1f56:	0f 90       	pop	r0
    1f58:	df 91       	pop	r29
    1f5a:	cf 91       	pop	r28
    1f5c:	1f 91       	pop	r17
    1f5e:	0f 91       	pop	r16
    1f60:	ff 90       	pop	r15
    1f62:	ef 90       	pop	r14
    1f64:	df 90       	pop	r13
    1f66:	cf 90       	pop	r12
    1f68:	bf 90       	pop	r11
    1f6a:	af 90       	pop	r10
    1f6c:	9f 90       	pop	r9
    1f6e:	08 95       	ret

00001f70 <xQueueCreateMutex>:
    1f70:	cf 93       	push	r28
    1f72:	df 93       	push	r29
    1f74:	48 2f       	mov	r20, r24
    1f76:	60 e0       	ldi	r22, 0x00	; 0
    1f78:	81 e0       	ldi	r24, 0x01	; 1
    1f7a:	3e df       	rcall	.-388    	; 0x1df8 <xQueueGenericCreate>
    1f7c:	ec 01       	movw	r28, r24
    1f7e:	00 97       	sbiw	r24, 0x00	; 0
    1f80:	59 f0       	breq	.+22     	; 0x1f98 <xQueueCreateMutex+0x28>
    1f82:	1b 82       	std	Y+3, r1	; 0x03
    1f84:	1a 82       	std	Y+2, r1	; 0x02
    1f86:	19 82       	std	Y+1, r1	; 0x01
    1f88:	18 82       	st	Y, r1
    1f8a:	1e 82       	std	Y+6, r1	; 0x06
    1f8c:	20 e0       	ldi	r18, 0x00	; 0
    1f8e:	40 e0       	ldi	r20, 0x00	; 0
    1f90:	50 e0       	ldi	r21, 0x00	; 0
    1f92:	60 e0       	ldi	r22, 0x00	; 0
    1f94:	70 e0       	ldi	r23, 0x00	; 0
    1f96:	5a df       	rcall	.-332    	; 0x1e4c <xQueueGenericSend>
    1f98:	ce 01       	movw	r24, r28
    1f9a:	df 91       	pop	r29
    1f9c:	cf 91       	pop	r28
    1f9e:	08 95       	ret

00001fa0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1fa0:	8f 92       	push	r8
    1fa2:	9f 92       	push	r9
    1fa4:	af 92       	push	r10
    1fa6:	bf 92       	push	r11
    1fa8:	cf 92       	push	r12
    1faa:	df 92       	push	r13
    1fac:	ef 92       	push	r14
    1fae:	ff 92       	push	r15
    1fb0:	0f 93       	push	r16
    1fb2:	1f 93       	push	r17
    1fb4:	cf 93       	push	r28
    1fb6:	df 93       	push	r29
    1fb8:	00 d0       	rcall	.+0      	; 0x1fba <xQueueGenericReceive+0x1a>
    1fba:	00 d0       	rcall	.+0      	; 0x1fbc <xQueueGenericReceive+0x1c>
    1fbc:	1f 92       	push	r1
    1fbe:	cd b7       	in	r28, 0x3d	; 61
    1fc0:	de b7       	in	r29, 0x3e	; 62
    1fc2:	8c 01       	movw	r16, r24
    1fc4:	5b 01       	movw	r10, r22
    1fc6:	5d 83       	std	Y+5, r21	; 0x05
    1fc8:	4c 83       	std	Y+4, r20	; 0x04
    1fca:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1fcc:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1fce:	99 24       	eor	r9, r9
    1fd0:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fd2:	6c 01       	movw	r12, r24
    1fd4:	81 e1       	ldi	r24, 0x11	; 17
    1fd6:	c8 0e       	add	r12, r24
    1fd8:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1fda:	0f b6       	in	r0, 0x3f	; 63
    1fdc:	f8 94       	cli
    1fde:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1fe0:	f8 01       	movw	r30, r16
    1fe2:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1fe4:	ff 20       	and	r15, r15
    1fe6:	61 f1       	breq	.+88     	; 0x2040 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1fe8:	c6 80       	ldd	r12, Z+6	; 0x06
    1fea:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1fec:	b5 01       	movw	r22, r10
    1fee:	c8 01       	movw	r24, r16
    1ff0:	68 de       	rcall	.-816    	; 0x1cc2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1ff2:	81 10       	cpse	r8, r1
    1ff4:	16 c0       	rjmp	.+44     	; 0x2022 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1ff6:	fa 94       	dec	r15
    1ff8:	f8 01       	movw	r30, r16
    1ffa:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ffc:	80 81       	ld	r24, Z
    1ffe:	91 81       	ldd	r25, Z+1	; 0x01
    2000:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2002:	21 f4       	brne	.+8      	; 0x200c <xQueueGenericReceive+0x6c>
    2004:	5c d5       	rcall	.+2744   	; 0x2abe <pvTaskIncrementMutexHeldCount>
    2006:	f8 01       	movw	r30, r16
    2008:	93 83       	std	Z+3, r25	; 0x03
    200a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    200c:	f8 01       	movw	r30, r16
    200e:	80 85       	ldd	r24, Z+8	; 0x08
    2010:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2012:	91 f0       	breq	.+36     	; 0x2038 <xQueueGenericReceive+0x98>
    2014:	c8 01       	movw	r24, r16
    2016:	08 96       	adiw	r24, 0x08	; 8
    2018:	23 d4       	rcall	.+2118   	; 0x2860 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    201a:	88 23       	and	r24, r24
    201c:	69 f0       	breq	.+26     	; 0x2038 <xQueueGenericReceive+0x98>
    201e:	41 dd       	rcall	.-1406   	; 0x1aa2 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2020:	0b c0       	rjmp	.+22     	; 0x2038 <xQueueGenericReceive+0x98>
    2022:	f8 01       	movw	r30, r16
    2024:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2026:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2028:	81 89       	ldd	r24, Z+17	; 0x11
    202a:	88 23       	and	r24, r24
    202c:	29 f0       	breq	.+10     	; 0x2038 <xQueueGenericReceive+0x98>
    202e:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2030:	41 96       	adiw	r24, 0x11	; 17
    2032:	16 d4       	rcall	.+2092   	; 0x2860 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2034:	81 11       	cpse	r24, r1
    2036:	35 dd       	rcall	.-1430   	; 0x1aa2 <vPortYield>
				return pdPASS;
    2038:	0f 90       	pop	r0
    203a:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    203c:	81 e0       	ldi	r24, 0x01	; 1
    203e:	58 c0       	rjmp	.+176    	; 0x20f0 <xQueueGenericReceive+0x150>
    2040:	8c 81       	ldd	r24, Y+4	; 0x04
    2042:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2044:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2046:	21 f4       	brne	.+8      	; 0x2050 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    2048:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    204a:	0f be       	out	0x3f, r0	; 63
    204c:	80 e0       	ldi	r24, 0x00	; 0
    204e:	50 c0       	rjmp	.+160    	; 0x20f0 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    2050:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2052:	04 c0       	rjmp	.+8      	; 0x205c <xQueueGenericReceive+0xbc>
    2054:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2056:	01 96       	adiw	r24, 0x01	; 1
    2058:	49 d4       	rcall	.+2194   	; 0x28ec <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    205a:	e9 2c       	mov	r14, r9
    205c:	0f 90       	pop	r0
    205e:	0f be       	out	0x3f, r0	; 63
    2060:	f2 d1       	rcall	.+996    	; 0x2446 <vTaskSuspendAll>
    2062:	0f b6       	in	r0, 0x3f	; 63
    2064:	f8 94       	cli
    2066:	0f 92       	push	r0
    2068:	f8 01       	movw	r30, r16
    206a:	85 8d       	ldd	r24, Z+29	; 0x1d
    206c:	8f 3f       	cpi	r24, 0xFF	; 255
    206e:	09 f4       	brne	.+2      	; 0x2072 <xQueueGenericReceive+0xd2>
    2070:	15 8e       	std	Z+29, r1	; 0x1d
    2072:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2074:	86 8d       	ldd	r24, Z+30	; 0x1e
    2076:	8f 3f       	cpi	r24, 0xFF	; 255
    2078:	09 f4       	brne	.+2      	; 0x207c <xQueueGenericReceive+0xdc>
    207a:	16 8e       	std	Z+30, r1	; 0x1e
    207c:	0f 90       	pop	r0
    207e:	0f be       	out	0x3f, r0	; 63
    2080:	be 01       	movw	r22, r28
    2082:	6c 5f       	subi	r22, 0xFC	; 252
    2084:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2086:	ce 01       	movw	r24, r28
    2088:	01 96       	adiw	r24, 0x01	; 1
    208a:	3b d4       	rcall	.+2166   	; 0x2902 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    208c:	81 11       	cpse	r24, r1
    208e:	24 c0       	rjmp	.+72     	; 0x20d8 <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2090:	0f b6       	in	r0, 0x3f	; 63
    2092:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2094:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2096:	f8 01       	movw	r30, r16
    2098:	82 8d       	ldd	r24, Z+26	; 0x1a
    209a:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    209c:	0f be       	out	0x3f, r0	; 63
    209e:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    20a0:	17 c0       	rjmp	.+46     	; 0x20d0 <xQueueGenericReceive+0x130>
    20a2:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    20a4:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    20a6:	89 2b       	or	r24, r25
    20a8:	41 f4       	brne	.+16     	; 0x20ba <xQueueGenericReceive+0x11a>
    20aa:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    20ac:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    20ae:	0f 92       	push	r0
    20b0:	82 81       	ldd	r24, Z+2	; 0x02
    20b2:	93 81       	ldd	r25, Z+3	; 0x03
    20b4:	62 d4       	rcall	.+2244   	; 0x297a <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    20b6:	0f 90       	pop	r0
    20b8:	0f be       	out	0x3f, r0	; 63
    20ba:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    20bc:	7d 81       	ldd	r23, Y+5	; 0x05
    20be:	c6 01       	movw	r24, r12
    20c0:	bf d3       	rcall	.+1918   	; 0x2840 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    20c2:	c8 01       	movw	r24, r16
    20c4:	17 de       	rcall	.-978    	; 0x1cf4 <prvUnlockQueue>
    20c6:	7c d2       	rcall	.+1272   	; 0x25c0 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    20c8:	81 11       	cpse	r24, r1
    20ca:	87 cf       	rjmp	.-242    	; 0x1fda <xQueueGenericReceive+0x3a>
    20cc:	ea dc       	rcall	.-1580   	; 0x1aa2 <vPortYield>
			( void ) xTaskResumeAll();
    20ce:	85 cf       	rjmp	.-246    	; 0x1fda <xQueueGenericReceive+0x3a>
    20d0:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    20d2:	10 de       	rcall	.-992    	; 0x1cf4 <prvUnlockQueue>
    20d4:	75 d2       	rcall	.+1258   	; 0x25c0 <xTaskResumeAll>
    20d6:	81 cf       	rjmp	.-254    	; 0x1fda <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    20d8:	c8 01       	movw	r24, r16
    20da:	0c de       	rcall	.-1000   	; 0x1cf4 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    20dc:	71 d2       	rcall	.+1250   	; 0x25c0 <xTaskResumeAll>
    20de:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    20e0:	f8 94       	cli
    20e2:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    20e4:	f8 01       	movw	r30, r16
    20e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    20e8:	0f 90       	pop	r0
    20ea:	0f be       	out	0x3f, r0	; 63
    20ec:	81 11       	cpse	r24, r1
    20ee:	75 cf       	rjmp	.-278    	; 0x1fda <xQueueGenericReceive+0x3a>
    20f0:	0f 90       	pop	r0
    20f2:	0f 90       	pop	r0
    20f4:	0f 90       	pop	r0
    20f6:	0f 90       	pop	r0
    20f8:	0f 90       	pop	r0
    20fa:	df 91       	pop	r29
    20fc:	cf 91       	pop	r28
    20fe:	1f 91       	pop	r17
    2100:	0f 91       	pop	r16
    2102:	ff 90       	pop	r15
    2104:	ef 90       	pop	r14
    2106:	df 90       	pop	r13
    2108:	cf 90       	pop	r12
    210a:	bf 90       	pop	r11
    210c:	af 90       	pop	r10
    210e:	9f 90       	pop	r9
    2110:	8f 90       	pop	r8
    2112:	08 95       	ret

00002114 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    2114:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    2118:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    211c:	80 81       	ld	r24, Z
    211e:	81 11       	cpse	r24, r1
    2120:	07 c0       	rjmp	.+14     	; 0x2130 <prvResetNextTaskUnblockTime+0x1c>
    2122:	8f ef       	ldi	r24, 0xFF	; 255
    2124:	9f ef       	ldi	r25, 0xFF	; 255
    2126:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    212a:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    212e:	08 95       	ret
    2130:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    2134:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    2138:	05 80       	ldd	r0, Z+5	; 0x05
    213a:	f6 81       	ldd	r31, Z+6	; 0x06
    213c:	e0 2d       	mov	r30, r0
    213e:	06 80       	ldd	r0, Z+6	; 0x06
    2140:	f7 81       	ldd	r31, Z+7	; 0x07
    2142:	e0 2d       	mov	r30, r0
    2144:	82 81       	ldd	r24, Z+2	; 0x02
    2146:	93 81       	ldd	r25, Z+3	; 0x03
    2148:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    214c:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    2150:	08 95       	ret

00002152 <prvAddCurrentTaskToDelayedList>:
    2152:	ff 92       	push	r15
    2154:	0f 93       	push	r16
    2156:	1f 93       	push	r17
    2158:	cf 93       	push	r28
    215a:	df 93       	push	r29
    215c:	ec 01       	movw	r28, r24
    215e:	f6 2e       	mov	r15, r22
    2160:	00 91 52 0d 	lds	r16, 0x0D52	; 0x800d52 <xTickCount>
    2164:	10 91 53 0d 	lds	r17, 0x0D53	; 0x800d53 <xTickCount+0x1>
    2168:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    216c:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2170:	02 96       	adiw	r24, 0x02	; 2
    2172:	d0 db       	rcall	.-2144   	; 0x1914 <uxListRemove>
    2174:	cf 3f       	cpi	r28, 0xFF	; 255
    2176:	8f ef       	ldi	r24, 0xFF	; 255
    2178:	d8 07       	cpc	r29, r24
    217a:	61 f4       	brne	.+24     	; 0x2194 <prvAddCurrentTaskToDelayedList+0x42>
    217c:	ff 20       	and	r15, r15
    217e:	51 f0       	breq	.+20     	; 0x2194 <prvAddCurrentTaskToDelayedList+0x42>
    2180:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2184:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2188:	6e 5f       	subi	r22, 0xFE	; 254
    218a:	7f 4f       	sbci	r23, 0xFF	; 255
    218c:	85 e5       	ldi	r24, 0x55	; 85
    218e:	9d e0       	ldi	r25, 0x0D	; 13
    2190:	6f db       	rcall	.-2338   	; 0x1870 <vListInsertEnd>
    2192:	2d c0       	rjmp	.+90     	; 0x21ee <prvAddCurrentTaskToDelayedList+0x9c>
    2194:	c0 0f       	add	r28, r16
    2196:	d1 1f       	adc	r29, r17
    2198:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    219c:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    21a0:	d3 83       	std	Z+3, r29	; 0x03
    21a2:	c2 83       	std	Z+2, r28	; 0x02
    21a4:	c0 17       	cp	r28, r16
    21a6:	d1 07       	cpc	r29, r17
    21a8:	60 f4       	brcc	.+24     	; 0x21c2 <prvAddCurrentTaskToDelayedList+0x70>
    21aa:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    21ae:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    21b2:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <pxOverflowDelayedTaskList>
    21b6:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    21ba:	6e 5f       	subi	r22, 0xFE	; 254
    21bc:	7f 4f       	sbci	r23, 0xFF	; 255
    21be:	79 db       	rcall	.-2318   	; 0x18b2 <vListInsert>
    21c0:	16 c0       	rjmp	.+44     	; 0x21ee <prvAddCurrentTaskToDelayedList+0x9c>
    21c2:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    21c6:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    21ca:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    21ce:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    21d2:	6e 5f       	subi	r22, 0xFE	; 254
    21d4:	7f 4f       	sbci	r23, 0xFF	; 255
    21d6:	6d db       	rcall	.-2342   	; 0x18b2 <vListInsert>
    21d8:	80 91 4a 0d 	lds	r24, 0x0D4A	; 0x800d4a <xNextTaskUnblockTime>
    21dc:	90 91 4b 0d 	lds	r25, 0x0D4B	; 0x800d4b <xNextTaskUnblockTime+0x1>
    21e0:	c8 17       	cp	r28, r24
    21e2:	d9 07       	cpc	r29, r25
    21e4:	20 f4       	brcc	.+8      	; 0x21ee <prvAddCurrentTaskToDelayedList+0x9c>
    21e6:	d0 93 4b 0d 	sts	0x0D4B, r29	; 0x800d4b <xNextTaskUnblockTime+0x1>
    21ea:	c0 93 4a 0d 	sts	0x0D4A, r28	; 0x800d4a <xNextTaskUnblockTime>
    21ee:	df 91       	pop	r29
    21f0:	cf 91       	pop	r28
    21f2:	1f 91       	pop	r17
    21f4:	0f 91       	pop	r16
    21f6:	ff 90       	pop	r15
    21f8:	08 95       	ret

000021fa <xTaskCreate>:
    21fa:	4f 92       	push	r4
    21fc:	5f 92       	push	r5
    21fe:	6f 92       	push	r6
    2200:	7f 92       	push	r7
    2202:	8f 92       	push	r8
    2204:	9f 92       	push	r9
    2206:	af 92       	push	r10
    2208:	bf 92       	push	r11
    220a:	cf 92       	push	r12
    220c:	df 92       	push	r13
    220e:	ef 92       	push	r14
    2210:	ff 92       	push	r15
    2212:	0f 93       	push	r16
    2214:	cf 93       	push	r28
    2216:	df 93       	push	r29
    2218:	4c 01       	movw	r8, r24
    221a:	6b 01       	movw	r12, r22
    221c:	5a 01       	movw	r10, r20
    221e:	29 01       	movw	r4, r18
    2220:	ca 01       	movw	r24, r20
    2222:	e0 da       	rcall	.-2624   	; 0x17e4 <pvPortMalloc>
    2224:	3c 01       	movw	r6, r24
    2226:	89 2b       	or	r24, r25
    2228:	09 f4       	brne	.+2      	; 0x222c <xTaskCreate+0x32>
    222a:	d4 c0       	rjmp	.+424    	; 0x23d4 <xTaskCreate+0x1da>
    222c:	88 e2       	ldi	r24, 0x28	; 40
    222e:	90 e0       	ldi	r25, 0x00	; 0
    2230:	d9 da       	rcall	.-2638   	; 0x17e4 <pvPortMalloc>
    2232:	ec 01       	movw	r28, r24
    2234:	89 2b       	or	r24, r25
    2236:	71 f0       	breq	.+28     	; 0x2254 <xTaskCreate+0x5a>
    2238:	78 8e       	std	Y+24, r7	; 0x18
    223a:	6f 8a       	std	Y+23, r6	; 0x17
    223c:	81 e0       	ldi	r24, 0x01	; 1
    223e:	a8 1a       	sub	r10, r24
    2240:	b1 08       	sbc	r11, r1
    2242:	6a 0c       	add	r6, r10
    2244:	7b 1c       	adc	r7, r11
    2246:	d6 01       	movw	r26, r12
    2248:	8c 91       	ld	r24, X
    224a:	89 8f       	std	Y+25, r24	; 0x19
    224c:	8c 91       	ld	r24, X
    224e:	81 11       	cpse	r24, r1
    2250:	04 c0       	rjmp	.+8      	; 0x225a <xTaskCreate+0x60>
    2252:	17 c0       	rjmp	.+46     	; 0x2282 <xTaskCreate+0x88>
    2254:	c3 01       	movw	r24, r6
    2256:	f9 da       	rcall	.-2574   	; 0x184a <vPortFree>
    2258:	bd c0       	rjmp	.+378    	; 0x23d4 <xTaskCreate+0x1da>
    225a:	ae 01       	movw	r20, r28
    225c:	46 5e       	subi	r20, 0xE6	; 230
    225e:	5f 4f       	sbci	r21, 0xFF	; 255
    2260:	f6 01       	movw	r30, r12
    2262:	31 96       	adiw	r30, 0x01	; 1
    2264:	b8 e0       	ldi	r27, 0x08	; 8
    2266:	cb 0e       	add	r12, r27
    2268:	d1 1c       	adc	r13, r1
    226a:	cf 01       	movw	r24, r30
    226c:	21 91       	ld	r18, Z+
    226e:	da 01       	movw	r26, r20
    2270:	2d 93       	st	X+, r18
    2272:	ad 01       	movw	r20, r26
    2274:	dc 01       	movw	r26, r24
    2276:	8c 91       	ld	r24, X
    2278:	88 23       	and	r24, r24
    227a:	19 f0       	breq	.+6      	; 0x2282 <xTaskCreate+0x88>
    227c:	ec 15       	cp	r30, r12
    227e:	fd 05       	cpc	r31, r13
    2280:	a1 f7       	brne	.-24     	; 0x226a <xTaskCreate+0x70>
    2282:	18 a2       	std	Y+32, r1	; 0x20
    2284:	04 30       	cpi	r16, 0x04	; 4
    2286:	08 f0       	brcs	.+2      	; 0x228a <xTaskCreate+0x90>
    2288:	03 e0       	ldi	r16, 0x03	; 3
    228a:	0e 8b       	std	Y+22, r16	; 0x16
    228c:	09 a3       	std	Y+33, r16	; 0x21
    228e:	1a a2       	std	Y+34, r1	; 0x22
    2290:	6e 01       	movw	r12, r28
    2292:	b2 e0       	ldi	r27, 0x02	; 2
    2294:	cb 0e       	add	r12, r27
    2296:	d1 1c       	adc	r13, r1
    2298:	c6 01       	movw	r24, r12
    229a:	e6 da       	rcall	.-2612   	; 0x1868 <vListInitialiseItem>
    229c:	ce 01       	movw	r24, r28
    229e:	0c 96       	adiw	r24, 0x0c	; 12
    22a0:	e3 da       	rcall	.-2618   	; 0x1868 <vListInitialiseItem>
    22a2:	d9 87       	std	Y+9, r29	; 0x09
    22a4:	c8 87       	std	Y+8, r28	; 0x08
    22a6:	84 e0       	ldi	r24, 0x04	; 4
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	80 1b       	sub	r24, r16
    22ac:	91 09       	sbc	r25, r1
    22ae:	9d 87       	std	Y+13, r25	; 0x0d
    22b0:	8c 87       	std	Y+12, r24	; 0x0c
    22b2:	db 8b       	std	Y+19, r29	; 0x13
    22b4:	ca 8b       	std	Y+18, r28	; 0x12
    22b6:	1b a2       	std	Y+35, r1	; 0x23
    22b8:	1c a2       	std	Y+36, r1	; 0x24
    22ba:	1d a2       	std	Y+37, r1	; 0x25
    22bc:	1e a2       	std	Y+38, r1	; 0x26
    22be:	1f a2       	std	Y+39, r1	; 0x27
    22c0:	a2 01       	movw	r20, r4
    22c2:	b4 01       	movw	r22, r8
    22c4:	c3 01       	movw	r24, r6
    22c6:	4c db       	rcall	.-2408   	; 0x1960 <pxPortInitialiseStack>
    22c8:	99 83       	std	Y+1, r25	; 0x01
    22ca:	88 83       	st	Y, r24
    22cc:	e1 14       	cp	r14, r1
    22ce:	f1 04       	cpc	r15, r1
    22d0:	19 f0       	breq	.+6      	; 0x22d8 <xTaskCreate+0xde>
    22d2:	f7 01       	movw	r30, r14
    22d4:	d1 83       	std	Z+1, r29	; 0x01
    22d6:	c0 83       	st	Z, r28
    22d8:	0f b6       	in	r0, 0x3f	; 63
    22da:	f8 94       	cli
    22dc:	0f 92       	push	r0
    22de:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    22e2:	8f 5f       	subi	r24, 0xFF	; 255
    22e4:	80 93 54 0d 	sts	0x0D54, r24	; 0x800d54 <uxCurrentNumberOfTasks>
    22e8:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    22ec:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    22f0:	89 2b       	or	r24, r25
    22f2:	89 f5       	brne	.+98     	; 0x2356 <xTaskCreate+0x15c>
    22f4:	d0 93 ac 0d 	sts	0x0DAC, r29	; 0x800dac <pxCurrentTCB+0x1>
    22f8:	c0 93 ab 0d 	sts	0x0DAB, r28	; 0x800dab <pxCurrentTCB>
    22fc:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    2300:	81 30       	cpi	r24, 0x01	; 1
    2302:	09 f0       	breq	.+2      	; 0x2306 <xTaskCreate+0x10c>
    2304:	38 c0       	rjmp	.+112    	; 0x2376 <xTaskCreate+0x17c>
    2306:	87 e8       	ldi	r24, 0x87	; 135
    2308:	9d e0       	ldi	r25, 0x0D	; 13
    230a:	a0 da       	rcall	.-2752   	; 0x184c <vListInitialise>
    230c:	80 e9       	ldi	r24, 0x90	; 144
    230e:	9d e0       	ldi	r25, 0x0D	; 13
    2310:	9d da       	rcall	.-2758   	; 0x184c <vListInitialise>
    2312:	89 e9       	ldi	r24, 0x99	; 153
    2314:	9d e0       	ldi	r25, 0x0D	; 13
    2316:	9a da       	rcall	.-2764   	; 0x184c <vListInitialise>
    2318:	82 ea       	ldi	r24, 0xA2	; 162
    231a:	9d e0       	ldi	r25, 0x0D	; 13
    231c:	97 da       	rcall	.-2770   	; 0x184c <vListInitialise>
    231e:	8e e7       	ldi	r24, 0x7E	; 126
    2320:	9d e0       	ldi	r25, 0x0D	; 13
    2322:	94 da       	rcall	.-2776   	; 0x184c <vListInitialise>
    2324:	85 e7       	ldi	r24, 0x75	; 117
    2326:	9d e0       	ldi	r25, 0x0D	; 13
    2328:	91 da       	rcall	.-2782   	; 0x184c <vListInitialise>
    232a:	88 e6       	ldi	r24, 0x68	; 104
    232c:	9d e0       	ldi	r25, 0x0D	; 13
    232e:	8e da       	rcall	.-2788   	; 0x184c <vListInitialise>
    2330:	8f e5       	ldi	r24, 0x5F	; 95
    2332:	9d e0       	ldi	r25, 0x0D	; 13
    2334:	8b da       	rcall	.-2794   	; 0x184c <vListInitialise>
    2336:	85 e5       	ldi	r24, 0x55	; 85
    2338:	9d e0       	ldi	r25, 0x0D	; 13
    233a:	88 da       	rcall	.-2800   	; 0x184c <vListInitialise>
    233c:	8e e7       	ldi	r24, 0x7E	; 126
    233e:	9d e0       	ldi	r25, 0x0D	; 13
    2340:	90 93 74 0d 	sts	0x0D74, r25	; 0x800d74 <pxDelayedTaskList+0x1>
    2344:	80 93 73 0d 	sts	0x0D73, r24	; 0x800d73 <pxDelayedTaskList>
    2348:	85 e7       	ldi	r24, 0x75	; 117
    234a:	9d e0       	ldi	r25, 0x0D	; 13
    234c:	90 93 72 0d 	sts	0x0D72, r25	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    2350:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <pxOverflowDelayedTaskList>
    2354:	10 c0       	rjmp	.+32     	; 0x2376 <xTaskCreate+0x17c>
    2356:	80 91 50 0d 	lds	r24, 0x0D50	; 0x800d50 <xSchedulerRunning>
    235a:	81 11       	cpse	r24, r1
    235c:	0c c0       	rjmp	.+24     	; 0x2376 <xTaskCreate+0x17c>
    235e:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2362:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2366:	96 89       	ldd	r25, Z+22	; 0x16
    2368:	8e 89       	ldd	r24, Y+22	; 0x16
    236a:	89 17       	cp	r24, r25
    236c:	20 f0       	brcs	.+8      	; 0x2376 <xTaskCreate+0x17c>
    236e:	d0 93 ac 0d 	sts	0x0DAC, r29	; 0x800dac <pxCurrentTCB+0x1>
    2372:	c0 93 ab 0d 	sts	0x0DAB, r28	; 0x800dab <pxCurrentTCB>
    2376:	80 91 4c 0d 	lds	r24, 0x0D4C	; 0x800d4c <uxTaskNumber>
    237a:	8f 5f       	subi	r24, 0xFF	; 255
    237c:	80 93 4c 0d 	sts	0x0D4C, r24	; 0x800d4c <uxTaskNumber>
    2380:	8e 89       	ldd	r24, Y+22	; 0x16
    2382:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2386:	98 17       	cp	r25, r24
    2388:	10 f4       	brcc	.+4      	; 0x238e <xTaskCreate+0x194>
    238a:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    238e:	90 e0       	ldi	r25, 0x00	; 0
    2390:	9c 01       	movw	r18, r24
    2392:	22 0f       	add	r18, r18
    2394:	33 1f       	adc	r19, r19
    2396:	22 0f       	add	r18, r18
    2398:	33 1f       	adc	r19, r19
    239a:	22 0f       	add	r18, r18
    239c:	33 1f       	adc	r19, r19
    239e:	82 0f       	add	r24, r18
    23a0:	93 1f       	adc	r25, r19
    23a2:	b6 01       	movw	r22, r12
    23a4:	89 57       	subi	r24, 0x79	; 121
    23a6:	92 4f       	sbci	r25, 0xF2	; 242
    23a8:	63 da       	rcall	.-2874   	; 0x1870 <vListInsertEnd>
    23aa:	0f 90       	pop	r0
    23ac:	0f be       	out	0x3f, r0	; 63
    23ae:	80 91 50 0d 	lds	r24, 0x0D50	; 0x800d50 <xSchedulerRunning>
    23b2:	88 23       	and	r24, r24
    23b4:	59 f0       	breq	.+22     	; 0x23cc <xTaskCreate+0x1d2>
    23b6:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    23ba:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    23be:	96 89       	ldd	r25, Z+22	; 0x16
    23c0:	8e 89       	ldd	r24, Y+22	; 0x16
    23c2:	98 17       	cp	r25, r24
    23c4:	28 f4       	brcc	.+10     	; 0x23d0 <xTaskCreate+0x1d6>
    23c6:	6d db       	rcall	.-2342   	; 0x1aa2 <vPortYield>
    23c8:	81 e0       	ldi	r24, 0x01	; 1
    23ca:	05 c0       	rjmp	.+10     	; 0x23d6 <xTaskCreate+0x1dc>
    23cc:	81 e0       	ldi	r24, 0x01	; 1
    23ce:	03 c0       	rjmp	.+6      	; 0x23d6 <xTaskCreate+0x1dc>
    23d0:	81 e0       	ldi	r24, 0x01	; 1
    23d2:	01 c0       	rjmp	.+2      	; 0x23d6 <xTaskCreate+0x1dc>
    23d4:	8f ef       	ldi	r24, 0xFF	; 255
    23d6:	df 91       	pop	r29
    23d8:	cf 91       	pop	r28
    23da:	0f 91       	pop	r16
    23dc:	ff 90       	pop	r15
    23de:	ef 90       	pop	r14
    23e0:	df 90       	pop	r13
    23e2:	cf 90       	pop	r12
    23e4:	bf 90       	pop	r11
    23e6:	af 90       	pop	r10
    23e8:	9f 90       	pop	r9
    23ea:	8f 90       	pop	r8
    23ec:	7f 90       	pop	r7
    23ee:	6f 90       	pop	r6
    23f0:	5f 90       	pop	r5
    23f2:	4f 90       	pop	r4
    23f4:	08 95       	ret

000023f6 <vTaskStartScheduler>:
    23f6:	ef 92       	push	r14
    23f8:	ff 92       	push	r15
    23fa:	0f 93       	push	r16
    23fc:	0f 2e       	mov	r0, r31
    23fe:	f8 e4       	ldi	r31, 0x48	; 72
    2400:	ef 2e       	mov	r14, r31
    2402:	fd e0       	ldi	r31, 0x0D	; 13
    2404:	ff 2e       	mov	r15, r31
    2406:	f0 2d       	mov	r31, r0
    2408:	00 e0       	ldi	r16, 0x00	; 0
    240a:	20 e0       	ldi	r18, 0x00	; 0
    240c:	30 e0       	ldi	r19, 0x00	; 0
    240e:	45 e5       	ldi	r20, 0x55	; 85
    2410:	50 e0       	ldi	r21, 0x00	; 0
    2412:	6a e8       	ldi	r22, 0x8A	; 138
    2414:	71 e0       	ldi	r23, 0x01	; 1
    2416:	89 e6       	ldi	r24, 0x69	; 105
    2418:	93 e1       	ldi	r25, 0x13	; 19
    241a:	ef de       	rcall	.-546    	; 0x21fa <xTaskCreate>
    241c:	81 30       	cpi	r24, 0x01	; 1
    241e:	79 f4       	brne	.+30     	; 0x243e <vTaskStartScheduler+0x48>
    2420:	f8 94       	cli
    2422:	8f ef       	ldi	r24, 0xFF	; 255
    2424:	9f ef       	ldi	r25, 0xFF	; 255
    2426:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    242a:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    242e:	81 e0       	ldi	r24, 0x01	; 1
    2430:	80 93 50 0d 	sts	0x0D50, r24	; 0x800d50 <xSchedulerRunning>
    2434:	10 92 53 0d 	sts	0x0D53, r1	; 0x800d53 <xTickCount+0x1>
    2438:	10 92 52 0d 	sts	0x0D52, r1	; 0x800d52 <xTickCount>
    243c:	fd da       	rcall	.-2566   	; 0x1a38 <xPortStartScheduler>
    243e:	0f 91       	pop	r16
    2440:	ff 90       	pop	r15
    2442:	ef 90       	pop	r14
    2444:	08 95       	ret

00002446 <vTaskSuspendAll>:
    2446:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    244a:	8f 5f       	subi	r24, 0xFF	; 255
    244c:	80 93 47 0d 	sts	0x0D47, r24	; 0x800d47 <uxSchedulerSuspended>
    2450:	08 95       	ret

00002452 <xTaskIncrementTick>:
    2452:	cf 92       	push	r12
    2454:	df 92       	push	r13
    2456:	ef 92       	push	r14
    2458:	ff 92       	push	r15
    245a:	0f 93       	push	r16
    245c:	1f 93       	push	r17
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
    2462:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2466:	81 11       	cpse	r24, r1
    2468:	95 c0       	rjmp	.+298    	; 0x2594 <xTaskIncrementTick+0x142>
    246a:	e0 90 52 0d 	lds	r14, 0x0D52	; 0x800d52 <xTickCount>
    246e:	f0 90 53 0d 	lds	r15, 0x0D53	; 0x800d53 <xTickCount+0x1>
    2472:	8f ef       	ldi	r24, 0xFF	; 255
    2474:	e8 1a       	sub	r14, r24
    2476:	f8 0a       	sbc	r15, r24
    2478:	f0 92 53 0d 	sts	0x0D53, r15	; 0x800d53 <xTickCount+0x1>
    247c:	e0 92 52 0d 	sts	0x0D52, r14	; 0x800d52 <xTickCount>
    2480:	e1 14       	cp	r14, r1
    2482:	f1 04       	cpc	r15, r1
    2484:	b1 f4       	brne	.+44     	; 0x24b2 <xTaskIncrementTick+0x60>
    2486:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    248a:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    248e:	20 91 71 0d 	lds	r18, 0x0D71	; 0x800d71 <pxOverflowDelayedTaskList>
    2492:	30 91 72 0d 	lds	r19, 0x0D72	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    2496:	30 93 74 0d 	sts	0x0D74, r19	; 0x800d74 <pxDelayedTaskList+0x1>
    249a:	20 93 73 0d 	sts	0x0D73, r18	; 0x800d73 <pxDelayedTaskList>
    249e:	90 93 72 0d 	sts	0x0D72, r25	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    24a2:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <pxOverflowDelayedTaskList>
    24a6:	80 91 4d 0d 	lds	r24, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    24aa:	8f 5f       	subi	r24, 0xFF	; 255
    24ac:	80 93 4d 0d 	sts	0x0D4D, r24	; 0x800d4d <xNumOfOverflows>
    24b0:	31 de       	rcall	.-926    	; 0x2114 <prvResetNextTaskUnblockTime>
    24b2:	80 91 4a 0d 	lds	r24, 0x0D4A	; 0x800d4a <xNextTaskUnblockTime>
    24b6:	90 91 4b 0d 	lds	r25, 0x0D4B	; 0x800d4b <xNextTaskUnblockTime+0x1>
    24ba:	e8 16       	cp	r14, r24
    24bc:	f9 06       	cpc	r15, r25
    24be:	10 f4       	brcc	.+4      	; 0x24c4 <xTaskIncrementTick+0x72>
    24c0:	d1 2c       	mov	r13, r1
    24c2:	50 c0       	rjmp	.+160    	; 0x2564 <xTaskIncrementTick+0x112>
    24c4:	d1 2c       	mov	r13, r1
    24c6:	cc 24       	eor	r12, r12
    24c8:	c3 94       	inc	r12
    24ca:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    24ce:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    24d2:	80 81       	ld	r24, Z
    24d4:	81 11       	cpse	r24, r1
    24d6:	07 c0       	rjmp	.+14     	; 0x24e6 <xTaskIncrementTick+0x94>
    24d8:	8f ef       	ldi	r24, 0xFF	; 255
    24da:	9f ef       	ldi	r25, 0xFF	; 255
    24dc:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    24e0:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    24e4:	3f c0       	rjmp	.+126    	; 0x2564 <xTaskIncrementTick+0x112>
    24e6:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    24ea:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    24ee:	05 80       	ldd	r0, Z+5	; 0x05
    24f0:	f6 81       	ldd	r31, Z+6	; 0x06
    24f2:	e0 2d       	mov	r30, r0
    24f4:	c6 81       	ldd	r28, Z+6	; 0x06
    24f6:	d7 81       	ldd	r29, Z+7	; 0x07
    24f8:	8a 81       	ldd	r24, Y+2	; 0x02
    24fa:	9b 81       	ldd	r25, Y+3	; 0x03
    24fc:	e8 16       	cp	r14, r24
    24fe:	f9 06       	cpc	r15, r25
    2500:	28 f4       	brcc	.+10     	; 0x250c <xTaskIncrementTick+0xba>
    2502:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    2506:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    250a:	2c c0       	rjmp	.+88     	; 0x2564 <xTaskIncrementTick+0x112>
    250c:	8e 01       	movw	r16, r28
    250e:	0e 5f       	subi	r16, 0xFE	; 254
    2510:	1f 4f       	sbci	r17, 0xFF	; 255
    2512:	c8 01       	movw	r24, r16
    2514:	ff d9       	rcall	.-3074   	; 0x1914 <uxListRemove>
    2516:	8c 89       	ldd	r24, Y+20	; 0x14
    2518:	9d 89       	ldd	r25, Y+21	; 0x15
    251a:	89 2b       	or	r24, r25
    251c:	19 f0       	breq	.+6      	; 0x2524 <xTaskIncrementTick+0xd2>
    251e:	ce 01       	movw	r24, r28
    2520:	0c 96       	adiw	r24, 0x0c	; 12
    2522:	f8 d9       	rcall	.-3088   	; 0x1914 <uxListRemove>
    2524:	8e 89       	ldd	r24, Y+22	; 0x16
    2526:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    252a:	98 17       	cp	r25, r24
    252c:	10 f4       	brcc	.+4      	; 0x2532 <xTaskIncrementTick+0xe0>
    252e:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2532:	90 e0       	ldi	r25, 0x00	; 0
    2534:	9c 01       	movw	r18, r24
    2536:	22 0f       	add	r18, r18
    2538:	33 1f       	adc	r19, r19
    253a:	22 0f       	add	r18, r18
    253c:	33 1f       	adc	r19, r19
    253e:	22 0f       	add	r18, r18
    2540:	33 1f       	adc	r19, r19
    2542:	82 0f       	add	r24, r18
    2544:	93 1f       	adc	r25, r19
    2546:	b8 01       	movw	r22, r16
    2548:	89 57       	subi	r24, 0x79	; 121
    254a:	92 4f       	sbci	r25, 0xF2	; 242
    254c:	91 d9       	rcall	.-3294   	; 0x1870 <vListInsertEnd>
    254e:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2552:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2556:	9e 89       	ldd	r25, Y+22	; 0x16
    2558:	86 89       	ldd	r24, Z+22	; 0x16
    255a:	98 17       	cp	r25, r24
    255c:	08 f4       	brcc	.+2      	; 0x2560 <xTaskIncrementTick+0x10e>
    255e:	b5 cf       	rjmp	.-150    	; 0x24ca <xTaskIncrementTick+0x78>
    2560:	dc 2c       	mov	r13, r12
    2562:	b3 cf       	rjmp	.-154    	; 0x24ca <xTaskIncrementTick+0x78>
    2564:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2568:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    256c:	86 89       	ldd	r24, Z+22	; 0x16
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	fc 01       	movw	r30, r24
    2572:	ee 0f       	add	r30, r30
    2574:	ff 1f       	adc	r31, r31
    2576:	ee 0f       	add	r30, r30
    2578:	ff 1f       	adc	r31, r31
    257a:	ee 0f       	add	r30, r30
    257c:	ff 1f       	adc	r31, r31
    257e:	8e 0f       	add	r24, r30
    2580:	9f 1f       	adc	r25, r31
    2582:	fc 01       	movw	r30, r24
    2584:	e9 57       	subi	r30, 0x79	; 121
    2586:	f2 4f       	sbci	r31, 0xF2	; 242
    2588:	80 81       	ld	r24, Z
    258a:	82 30       	cpi	r24, 0x02	; 2
    258c:	48 f0       	brcs	.+18     	; 0x25a0 <xTaskIncrementTick+0x14e>
    258e:	dd 24       	eor	r13, r13
    2590:	d3 94       	inc	r13
    2592:	06 c0       	rjmp	.+12     	; 0x25a0 <xTaskIncrementTick+0x14e>
    2594:	80 91 4f 0d 	lds	r24, 0x0D4F	; 0x800d4f <uxPendedTicks>
    2598:	8f 5f       	subi	r24, 0xFF	; 255
    259a:	80 93 4f 0d 	sts	0x0D4F, r24	; 0x800d4f <uxPendedTicks>
    259e:	d1 2c       	mov	r13, r1
    25a0:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <xYieldPending>
    25a4:	88 23       	and	r24, r24
    25a6:	11 f0       	breq	.+4      	; 0x25ac <xTaskIncrementTick+0x15a>
    25a8:	dd 24       	eor	r13, r13
    25aa:	d3 94       	inc	r13
    25ac:	8d 2d       	mov	r24, r13
    25ae:	df 91       	pop	r29
    25b0:	cf 91       	pop	r28
    25b2:	1f 91       	pop	r17
    25b4:	0f 91       	pop	r16
    25b6:	ff 90       	pop	r15
    25b8:	ef 90       	pop	r14
    25ba:	df 90       	pop	r13
    25bc:	cf 90       	pop	r12
    25be:	08 95       	ret

000025c0 <xTaskResumeAll>:
    25c0:	df 92       	push	r13
    25c2:	ef 92       	push	r14
    25c4:	ff 92       	push	r15
    25c6:	0f 93       	push	r16
    25c8:	1f 93       	push	r17
    25ca:	cf 93       	push	r28
    25cc:	df 93       	push	r29
    25ce:	0f b6       	in	r0, 0x3f	; 63
    25d0:	f8 94       	cli
    25d2:	0f 92       	push	r0
    25d4:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    25d8:	81 50       	subi	r24, 0x01	; 1
    25da:	80 93 47 0d 	sts	0x0D47, r24	; 0x800d47 <uxSchedulerSuspended>
    25de:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    25e2:	81 11       	cpse	r24, r1
    25e4:	59 c0       	rjmp	.+178    	; 0x2698 <xTaskResumeAll+0xd8>
    25e6:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    25ea:	81 11       	cpse	r24, r1
    25ec:	30 c0       	rjmp	.+96     	; 0x264e <xTaskResumeAll+0x8e>
    25ee:	57 c0       	rjmp	.+174    	; 0x269e <xTaskResumeAll+0xde>
    25f0:	d7 01       	movw	r26, r14
    25f2:	15 96       	adiw	r26, 0x05	; 5
    25f4:	ed 91       	ld	r30, X+
    25f6:	fc 91       	ld	r31, X
    25f8:	16 97       	sbiw	r26, 0x06	; 6
    25fa:	c6 81       	ldd	r28, Z+6	; 0x06
    25fc:	d7 81       	ldd	r29, Z+7	; 0x07
    25fe:	ce 01       	movw	r24, r28
    2600:	0c 96       	adiw	r24, 0x0c	; 12
    2602:	88 d9       	rcall	.-3312   	; 0x1914 <uxListRemove>
    2604:	8e 01       	movw	r16, r28
    2606:	0e 5f       	subi	r16, 0xFE	; 254
    2608:	1f 4f       	sbci	r17, 0xFF	; 255
    260a:	c8 01       	movw	r24, r16
    260c:	83 d9       	rcall	.-3322   	; 0x1914 <uxListRemove>
    260e:	8e 89       	ldd	r24, Y+22	; 0x16
    2610:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2614:	98 17       	cp	r25, r24
    2616:	10 f4       	brcc	.+4      	; 0x261c <xTaskResumeAll+0x5c>
    2618:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	9c 01       	movw	r18, r24
    2620:	22 0f       	add	r18, r18
    2622:	33 1f       	adc	r19, r19
    2624:	22 0f       	add	r18, r18
    2626:	33 1f       	adc	r19, r19
    2628:	22 0f       	add	r18, r18
    262a:	33 1f       	adc	r19, r19
    262c:	82 0f       	add	r24, r18
    262e:	93 1f       	adc	r25, r19
    2630:	b8 01       	movw	r22, r16
    2632:	89 57       	subi	r24, 0x79	; 121
    2634:	92 4f       	sbci	r25, 0xF2	; 242
    2636:	1c d9       	rcall	.-3528   	; 0x1870 <vListInsertEnd>
    2638:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    263c:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2640:	9e 89       	ldd	r25, Y+22	; 0x16
    2642:	86 89       	ldd	r24, Z+22	; 0x16
    2644:	98 17       	cp	r25, r24
    2646:	68 f0       	brcs	.+26     	; 0x2662 <xTaskResumeAll+0xa2>
    2648:	d0 92 4e 0d 	sts	0x0D4E, r13	; 0x800d4e <xYieldPending>
    264c:	0a c0       	rjmp	.+20     	; 0x2662 <xTaskResumeAll+0xa2>
    264e:	c0 e0       	ldi	r28, 0x00	; 0
    2650:	d0 e0       	ldi	r29, 0x00	; 0
    2652:	0f 2e       	mov	r0, r31
    2654:	f8 e6       	ldi	r31, 0x68	; 104
    2656:	ef 2e       	mov	r14, r31
    2658:	fd e0       	ldi	r31, 0x0D	; 13
    265a:	ff 2e       	mov	r15, r31
    265c:	f0 2d       	mov	r31, r0
    265e:	dd 24       	eor	r13, r13
    2660:	d3 94       	inc	r13
    2662:	f7 01       	movw	r30, r14
    2664:	80 81       	ld	r24, Z
    2666:	81 11       	cpse	r24, r1
    2668:	c3 cf       	rjmp	.-122    	; 0x25f0 <xTaskResumeAll+0x30>
    266a:	cd 2b       	or	r28, r29
    266c:	09 f0       	breq	.+2      	; 0x2670 <xTaskResumeAll+0xb0>
    266e:	52 dd       	rcall	.-1372   	; 0x2114 <prvResetNextTaskUnblockTime>
    2670:	c0 91 4f 0d 	lds	r28, 0x0D4F	; 0x800d4f <uxPendedTicks>
    2674:	cc 23       	and	r28, r28
    2676:	49 f0       	breq	.+18     	; 0x268a <xTaskResumeAll+0xca>
    2678:	d1 e0       	ldi	r29, 0x01	; 1
    267a:	eb de       	rcall	.-554    	; 0x2452 <xTaskIncrementTick>
    267c:	81 11       	cpse	r24, r1
    267e:	d0 93 4e 0d 	sts	0x0D4E, r29	; 0x800d4e <xYieldPending>
    2682:	c1 50       	subi	r28, 0x01	; 1
    2684:	d1 f7       	brne	.-12     	; 0x267a <xTaskResumeAll+0xba>
    2686:	10 92 4f 0d 	sts	0x0D4F, r1	; 0x800d4f <uxPendedTicks>
    268a:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <xYieldPending>
    268e:	88 23       	and	r24, r24
    2690:	29 f0       	breq	.+10     	; 0x269c <xTaskResumeAll+0xdc>
    2692:	07 da       	rcall	.-3058   	; 0x1aa2 <vPortYield>
    2694:	81 e0       	ldi	r24, 0x01	; 1
    2696:	03 c0       	rjmp	.+6      	; 0x269e <xTaskResumeAll+0xde>
    2698:	80 e0       	ldi	r24, 0x00	; 0
    269a:	01 c0       	rjmp	.+2      	; 0x269e <xTaskResumeAll+0xde>
    269c:	80 e0       	ldi	r24, 0x00	; 0
    269e:	0f 90       	pop	r0
    26a0:	0f be       	out	0x3f, r0	; 63
    26a2:	df 91       	pop	r29
    26a4:	cf 91       	pop	r28
    26a6:	1f 91       	pop	r17
    26a8:	0f 91       	pop	r16
    26aa:	ff 90       	pop	r15
    26ac:	ef 90       	pop	r14
    26ae:	df 90       	pop	r13
    26b0:	08 95       	ret

000026b2 <vTaskDelay>:
    26b2:	cf 93       	push	r28
    26b4:	df 93       	push	r29
    26b6:	ec 01       	movw	r28, r24
    26b8:	89 2b       	or	r24, r25
    26ba:	39 f0       	breq	.+14     	; 0x26ca <vTaskDelay+0x18>
    26bc:	c4 de       	rcall	.-632    	; 0x2446 <vTaskSuspendAll>
    26be:	60 e0       	ldi	r22, 0x00	; 0
    26c0:	ce 01       	movw	r24, r28
    26c2:	47 dd       	rcall	.-1394   	; 0x2152 <prvAddCurrentTaskToDelayedList>
    26c4:	7d df       	rcall	.-262    	; 0x25c0 <xTaskResumeAll>
    26c6:	81 11       	cpse	r24, r1
    26c8:	01 c0       	rjmp	.+2      	; 0x26cc <vTaskDelay+0x1a>
    26ca:	eb d9       	rcall	.-3114   	; 0x1aa2 <vPortYield>
    26cc:	df 91       	pop	r29
    26ce:	cf 91       	pop	r28
    26d0:	08 95       	ret

000026d2 <prvIdleTask>:
    26d2:	0f e5       	ldi	r16, 0x5F	; 95
    26d4:	1d e0       	ldi	r17, 0x0D	; 13
    26d6:	0f 2e       	mov	r0, r31
    26d8:	f7 e8       	ldi	r31, 0x87	; 135
    26da:	ef 2e       	mov	r14, r31
    26dc:	fd e0       	ldi	r31, 0x0D	; 13
    26de:	ff 2e       	mov	r15, r31
    26e0:	f0 2d       	mov	r31, r0
    26e2:	24 c0       	rjmp	.+72     	; 0x272c <prvIdleTask+0x5a>
    26e4:	b0 de       	rcall	.-672    	; 0x2446 <vTaskSuspendAll>
    26e6:	d8 01       	movw	r26, r16
    26e8:	cc 91       	ld	r28, X
    26ea:	6a df       	rcall	.-300    	; 0x25c0 <xTaskResumeAll>
    26ec:	cc 23       	and	r28, r28
    26ee:	f1 f0       	breq	.+60     	; 0x272c <prvIdleTask+0x5a>
    26f0:	0f b6       	in	r0, 0x3f	; 63
    26f2:	f8 94       	cli
    26f4:	0f 92       	push	r0
    26f6:	d8 01       	movw	r26, r16
    26f8:	15 96       	adiw	r26, 0x05	; 5
    26fa:	ed 91       	ld	r30, X+
    26fc:	fc 91       	ld	r31, X
    26fe:	16 97       	sbiw	r26, 0x06	; 6
    2700:	c6 81       	ldd	r28, Z+6	; 0x06
    2702:	d7 81       	ldd	r29, Z+7	; 0x07
    2704:	ce 01       	movw	r24, r28
    2706:	02 96       	adiw	r24, 0x02	; 2
    2708:	05 d9       	rcall	.-3574   	; 0x1914 <uxListRemove>
    270a:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    270e:	81 50       	subi	r24, 0x01	; 1
    2710:	80 93 54 0d 	sts	0x0D54, r24	; 0x800d54 <uxCurrentNumberOfTasks>
    2714:	80 91 5e 0d 	lds	r24, 0x0D5E	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    2718:	81 50       	subi	r24, 0x01	; 1
    271a:	80 93 5e 0d 	sts	0x0D5E, r24	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    271e:	0f 90       	pop	r0
    2720:	0f be       	out	0x3f, r0	; 63
    2722:	8f 89       	ldd	r24, Y+23	; 0x17
    2724:	98 8d       	ldd	r25, Y+24	; 0x18
    2726:	91 d8       	rcall	.-3806   	; 0x184a <vPortFree>
    2728:	ce 01       	movw	r24, r28
    272a:	8f d8       	rcall	.-3810   	; 0x184a <vPortFree>
    272c:	80 91 5e 0d 	lds	r24, 0x0D5E	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    2730:	81 11       	cpse	r24, r1
    2732:	d8 cf       	rjmp	.-80     	; 0x26e4 <prvIdleTask+0x12>
    2734:	f7 01       	movw	r30, r14
    2736:	80 81       	ld	r24, Z
    2738:	82 30       	cpi	r24, 0x02	; 2
    273a:	c0 f3       	brcs	.-16     	; 0x272c <prvIdleTask+0x5a>
    273c:	b2 d9       	rcall	.-3228   	; 0x1aa2 <vPortYield>
    273e:	f6 cf       	rjmp	.-20     	; 0x272c <prvIdleTask+0x5a>

00002740 <vTaskSwitchContext>:
    2740:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2744:	88 23       	and	r24, r24
    2746:	21 f0       	breq	.+8      	; 0x2750 <vTaskSwitchContext+0x10>
    2748:	81 e0       	ldi	r24, 0x01	; 1
    274a:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    274e:	08 95       	ret
    2750:	10 92 4e 0d 	sts	0x0D4E, r1	; 0x800d4e <xYieldPending>
    2754:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2758:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    275c:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2760:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2764:	2d 91       	ld	r18, X+
    2766:	3c 91       	ld	r19, X
    2768:	87 89       	ldd	r24, Z+23	; 0x17
    276a:	90 8d       	ldd	r25, Z+24	; 0x18
    276c:	82 17       	cp	r24, r18
    276e:	93 07       	cpc	r25, r19
    2770:	58 f0       	brcs	.+22     	; 0x2788 <vTaskSwitchContext+0x48>
    2772:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2776:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    277a:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    277e:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2782:	67 5e       	subi	r22, 0xE7	; 231
    2784:	7f 4f       	sbci	r23, 0xFF	; 255
    2786:	2d d8       	rcall	.-4006   	; 0x17e2 <vApplicationStackOverflowHook>
    2788:	20 91 51 0d 	lds	r18, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    278c:	82 2f       	mov	r24, r18
    278e:	90 e0       	ldi	r25, 0x00	; 0
    2790:	fc 01       	movw	r30, r24
    2792:	ee 0f       	add	r30, r30
    2794:	ff 1f       	adc	r31, r31
    2796:	ee 0f       	add	r30, r30
    2798:	ff 1f       	adc	r31, r31
    279a:	ee 0f       	add	r30, r30
    279c:	ff 1f       	adc	r31, r31
    279e:	e8 0f       	add	r30, r24
    27a0:	f9 1f       	adc	r31, r25
    27a2:	e9 57       	subi	r30, 0x79	; 121
    27a4:	f2 4f       	sbci	r31, 0xF2	; 242
    27a6:	30 81       	ld	r19, Z
    27a8:	31 11       	cpse	r19, r1
    27aa:	11 c0       	rjmp	.+34     	; 0x27ce <vTaskSwitchContext+0x8e>
    27ac:	21 50       	subi	r18, 0x01	; 1
    27ae:	82 2f       	mov	r24, r18
    27b0:	90 e0       	ldi	r25, 0x00	; 0
    27b2:	fc 01       	movw	r30, r24
    27b4:	ee 0f       	add	r30, r30
    27b6:	ff 1f       	adc	r31, r31
    27b8:	ee 0f       	add	r30, r30
    27ba:	ff 1f       	adc	r31, r31
    27bc:	ee 0f       	add	r30, r30
    27be:	ff 1f       	adc	r31, r31
    27c0:	e8 0f       	add	r30, r24
    27c2:	f9 1f       	adc	r31, r25
    27c4:	e9 57       	subi	r30, 0x79	; 121
    27c6:	f2 4f       	sbci	r31, 0xF2	; 242
    27c8:	30 81       	ld	r19, Z
    27ca:	33 23       	and	r19, r19
    27cc:	79 f3       	breq	.-34     	; 0x27ac <vTaskSwitchContext+0x6c>
    27ce:	ac 01       	movw	r20, r24
    27d0:	44 0f       	add	r20, r20
    27d2:	55 1f       	adc	r21, r21
    27d4:	44 0f       	add	r20, r20
    27d6:	55 1f       	adc	r21, r21
    27d8:	44 0f       	add	r20, r20
    27da:	55 1f       	adc	r21, r21
    27dc:	48 0f       	add	r20, r24
    27de:	59 1f       	adc	r21, r25
    27e0:	da 01       	movw	r26, r20
    27e2:	a9 57       	subi	r26, 0x79	; 121
    27e4:	b2 4f       	sbci	r27, 0xF2	; 242
    27e6:	11 96       	adiw	r26, 0x01	; 1
    27e8:	ed 91       	ld	r30, X+
    27ea:	fc 91       	ld	r31, X
    27ec:	12 97       	sbiw	r26, 0x02	; 2
    27ee:	02 80       	ldd	r0, Z+2	; 0x02
    27f0:	f3 81       	ldd	r31, Z+3	; 0x03
    27f2:	e0 2d       	mov	r30, r0
    27f4:	12 96       	adiw	r26, 0x02	; 2
    27f6:	fc 93       	st	X, r31
    27f8:	ee 93       	st	-X, r30
    27fa:	11 97       	sbiw	r26, 0x01	; 1
    27fc:	46 57       	subi	r20, 0x76	; 118
    27fe:	52 4f       	sbci	r21, 0xF2	; 242
    2800:	e4 17       	cp	r30, r20
    2802:	f5 07       	cpc	r31, r21
    2804:	29 f4       	brne	.+10     	; 0x2810 <vTaskSwitchContext+0xd0>
    2806:	42 81       	ldd	r20, Z+2	; 0x02
    2808:	53 81       	ldd	r21, Z+3	; 0x03
    280a:	fd 01       	movw	r30, r26
    280c:	52 83       	std	Z+2, r21	; 0x02
    280e:	41 83       	std	Z+1, r20	; 0x01
    2810:	fc 01       	movw	r30, r24
    2812:	ee 0f       	add	r30, r30
    2814:	ff 1f       	adc	r31, r31
    2816:	ee 0f       	add	r30, r30
    2818:	ff 1f       	adc	r31, r31
    281a:	ee 0f       	add	r30, r30
    281c:	ff 1f       	adc	r31, r31
    281e:	8e 0f       	add	r24, r30
    2820:	9f 1f       	adc	r25, r31
    2822:	fc 01       	movw	r30, r24
    2824:	e9 57       	subi	r30, 0x79	; 121
    2826:	f2 4f       	sbci	r31, 0xF2	; 242
    2828:	01 80       	ldd	r0, Z+1	; 0x01
    282a:	f2 81       	ldd	r31, Z+2	; 0x02
    282c:	e0 2d       	mov	r30, r0
    282e:	86 81       	ldd	r24, Z+6	; 0x06
    2830:	97 81       	ldd	r25, Z+7	; 0x07
    2832:	90 93 ac 0d 	sts	0x0DAC, r25	; 0x800dac <pxCurrentTCB+0x1>
    2836:	80 93 ab 0d 	sts	0x0DAB, r24	; 0x800dab <pxCurrentTCB>
    283a:	20 93 51 0d 	sts	0x0D51, r18	; 0x800d51 <uxTopReadyPriority>
    283e:	08 95       	ret

00002840 <vTaskPlaceOnEventList>:
    2840:	cf 93       	push	r28
    2842:	df 93       	push	r29
    2844:	eb 01       	movw	r28, r22
    2846:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    284a:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    284e:	64 5f       	subi	r22, 0xF4	; 244
    2850:	7f 4f       	sbci	r23, 0xFF	; 255
    2852:	2f d8       	rcall	.-4002   	; 0x18b2 <vListInsert>
    2854:	61 e0       	ldi	r22, 0x01	; 1
    2856:	ce 01       	movw	r24, r28
    2858:	7c dc       	rcall	.-1800   	; 0x2152 <prvAddCurrentTaskToDelayedList>
    285a:	df 91       	pop	r29
    285c:	cf 91       	pop	r28
    285e:	08 95       	ret

00002860 <xTaskRemoveFromEventList>:
    2860:	0f 93       	push	r16
    2862:	1f 93       	push	r17
    2864:	cf 93       	push	r28
    2866:	df 93       	push	r29
    2868:	dc 01       	movw	r26, r24
    286a:	15 96       	adiw	r26, 0x05	; 5
    286c:	ed 91       	ld	r30, X+
    286e:	fc 91       	ld	r31, X
    2870:	16 97       	sbiw	r26, 0x06	; 6
    2872:	c6 81       	ldd	r28, Z+6	; 0x06
    2874:	d7 81       	ldd	r29, Z+7	; 0x07
    2876:	8e 01       	movw	r16, r28
    2878:	04 5f       	subi	r16, 0xF4	; 244
    287a:	1f 4f       	sbci	r17, 0xFF	; 255
    287c:	c8 01       	movw	r24, r16
    287e:	4a d8       	rcall	.-3948   	; 0x1914 <uxListRemove>
    2880:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2884:	81 11       	cpse	r24, r1
    2886:	1b c0       	rjmp	.+54     	; 0x28be <xTaskRemoveFromEventList+0x5e>
    2888:	0a 50       	subi	r16, 0x0A	; 10
    288a:	11 09       	sbc	r17, r1
    288c:	c8 01       	movw	r24, r16
    288e:	42 d8       	rcall	.-3964   	; 0x1914 <uxListRemove>
    2890:	8e 89       	ldd	r24, Y+22	; 0x16
    2892:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2896:	98 17       	cp	r25, r24
    2898:	10 f4       	brcc	.+4      	; 0x289e <xTaskRemoveFromEventList+0x3e>
    289a:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    289e:	90 e0       	ldi	r25, 0x00	; 0
    28a0:	9c 01       	movw	r18, r24
    28a2:	22 0f       	add	r18, r18
    28a4:	33 1f       	adc	r19, r19
    28a6:	22 0f       	add	r18, r18
    28a8:	33 1f       	adc	r19, r19
    28aa:	22 0f       	add	r18, r18
    28ac:	33 1f       	adc	r19, r19
    28ae:	82 0f       	add	r24, r18
    28b0:	93 1f       	adc	r25, r19
    28b2:	b8 01       	movw	r22, r16
    28b4:	89 57       	subi	r24, 0x79	; 121
    28b6:	92 4f       	sbci	r25, 0xF2	; 242
    28b8:	0e 94 38 0c 	call	0x1870	; 0x1870 <vListInsertEnd>
    28bc:	05 c0       	rjmp	.+10     	; 0x28c8 <xTaskRemoveFromEventList+0x68>
    28be:	b8 01       	movw	r22, r16
    28c0:	88 e6       	ldi	r24, 0x68	; 104
    28c2:	9d e0       	ldi	r25, 0x0D	; 13
    28c4:	0e 94 38 0c 	call	0x1870	; 0x1870 <vListInsertEnd>
    28c8:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    28cc:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    28d0:	9e 89       	ldd	r25, Y+22	; 0x16
    28d2:	86 89       	ldd	r24, Z+22	; 0x16
    28d4:	89 17       	cp	r24, r25
    28d6:	20 f4       	brcc	.+8      	; 0x28e0 <xTaskRemoveFromEventList+0x80>
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    28de:	01 c0       	rjmp	.+2      	; 0x28e2 <xTaskRemoveFromEventList+0x82>
    28e0:	80 e0       	ldi	r24, 0x00	; 0
    28e2:	df 91       	pop	r29
    28e4:	cf 91       	pop	r28
    28e6:	1f 91       	pop	r17
    28e8:	0f 91       	pop	r16
    28ea:	08 95       	ret

000028ec <vTaskSetTimeOutState>:
    28ec:	20 91 4d 0d 	lds	r18, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    28f0:	fc 01       	movw	r30, r24
    28f2:	20 83       	st	Z, r18
    28f4:	20 91 52 0d 	lds	r18, 0x0D52	; 0x800d52 <xTickCount>
    28f8:	30 91 53 0d 	lds	r19, 0x0D53	; 0x800d53 <xTickCount+0x1>
    28fc:	32 83       	std	Z+2, r19	; 0x02
    28fe:	21 83       	std	Z+1, r18	; 0x01
    2900:	08 95       	ret

00002902 <xTaskCheckForTimeOut>:
    2902:	0f b6       	in	r0, 0x3f	; 63
    2904:	f8 94       	cli
    2906:	0f 92       	push	r0
    2908:	40 91 52 0d 	lds	r20, 0x0D52	; 0x800d52 <xTickCount>
    290c:	50 91 53 0d 	lds	r21, 0x0D53	; 0x800d53 <xTickCount+0x1>
    2910:	db 01       	movw	r26, r22
    2912:	2d 91       	ld	r18, X+
    2914:	3c 91       	ld	r19, X
    2916:	2f 3f       	cpi	r18, 0xFF	; 255
    2918:	bf ef       	ldi	r27, 0xFF	; 255
    291a:	3b 07       	cpc	r19, r27
    291c:	11 f1       	breq	.+68     	; 0x2962 <xTaskCheckForTimeOut+0x60>
    291e:	e0 91 4d 0d 	lds	r30, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    2922:	dc 01       	movw	r26, r24
    2924:	fc 91       	ld	r31, X
    2926:	fe 17       	cp	r31, r30
    2928:	39 f0       	breq	.+14     	; 0x2938 <xTaskCheckForTimeOut+0x36>
    292a:	11 96       	adiw	r26, 0x01	; 1
    292c:	ed 91       	ld	r30, X+
    292e:	fc 91       	ld	r31, X
    2930:	12 97       	sbiw	r26, 0x02	; 2
    2932:	4e 17       	cp	r20, r30
    2934:	5f 07       	cpc	r21, r31
    2936:	b8 f4       	brcc	.+46     	; 0x2966 <xTaskCheckForTimeOut+0x64>
    2938:	dc 01       	movw	r26, r24
    293a:	11 96       	adiw	r26, 0x01	; 1
    293c:	ed 91       	ld	r30, X+
    293e:	fc 91       	ld	r31, X
    2940:	12 97       	sbiw	r26, 0x02	; 2
    2942:	da 01       	movw	r26, r20
    2944:	ae 1b       	sub	r26, r30
    2946:	bf 0b       	sbc	r27, r31
    2948:	a2 17       	cp	r26, r18
    294a:	b3 07       	cpc	r27, r19
    294c:	70 f4       	brcc	.+28     	; 0x296a <xTaskCheckForTimeOut+0x68>
    294e:	db 01       	movw	r26, r22
    2950:	e4 1b       	sub	r30, r20
    2952:	f5 0b       	sbc	r31, r21
    2954:	2e 0f       	add	r18, r30
    2956:	3f 1f       	adc	r19, r31
    2958:	2d 93       	st	X+, r18
    295a:	3c 93       	st	X, r19
    295c:	c7 df       	rcall	.-114    	; 0x28ec <vTaskSetTimeOutState>
    295e:	80 e0       	ldi	r24, 0x00	; 0
    2960:	05 c0       	rjmp	.+10     	; 0x296c <xTaskCheckForTimeOut+0x6a>
    2962:	80 e0       	ldi	r24, 0x00	; 0
    2964:	03 c0       	rjmp	.+6      	; 0x296c <xTaskCheckForTimeOut+0x6a>
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	01 c0       	rjmp	.+2      	; 0x296c <xTaskCheckForTimeOut+0x6a>
    296a:	81 e0       	ldi	r24, 0x01	; 1
    296c:	0f 90       	pop	r0
    296e:	0f be       	out	0x3f, r0	; 63
    2970:	08 95       	ret

00002972 <vTaskMissedYield>:
    2972:	81 e0       	ldi	r24, 0x01	; 1
    2974:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    2978:	08 95       	ret

0000297a <vTaskPriorityInherit>:
    297a:	0f 93       	push	r16
    297c:	1f 93       	push	r17
    297e:	cf 93       	push	r28
    2980:	df 93       	push	r29
    2982:	fc 01       	movw	r30, r24
    2984:	89 2b       	or	r24, r25
    2986:	09 f4       	brne	.+2      	; 0x298a <vTaskPriorityInherit+0x10>
    2988:	55 c0       	rjmp	.+170    	; 0x2a34 <vTaskPriorityInherit+0xba>
    298a:	26 89       	ldd	r18, Z+22	; 0x16
    298c:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2990:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2994:	56 96       	adiw	r26, 0x16	; 22
    2996:	8c 91       	ld	r24, X
    2998:	28 17       	cp	r18, r24
    299a:	08 f0       	brcs	.+2      	; 0x299e <vTaskPriorityInherit+0x24>
    299c:	4b c0       	rjmp	.+150    	; 0x2a34 <vTaskPriorityInherit+0xba>
    299e:	84 85       	ldd	r24, Z+12	; 0x0c
    29a0:	95 85       	ldd	r25, Z+13	; 0x0d
    29a2:	99 23       	and	r25, r25
    29a4:	64 f0       	brlt	.+24     	; 0x29be <vTaskPriorityInherit+0x44>
    29a6:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    29aa:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    29ae:	56 96       	adiw	r26, 0x16	; 22
    29b0:	3c 91       	ld	r19, X
    29b2:	84 e0       	ldi	r24, 0x04	; 4
    29b4:	90 e0       	ldi	r25, 0x00	; 0
    29b6:	83 1b       	sub	r24, r19
    29b8:	91 09       	sbc	r25, r1
    29ba:	95 87       	std	Z+13, r25	; 0x0d
    29bc:	84 87       	std	Z+12, r24	; 0x0c
    29be:	30 e0       	ldi	r19, 0x00	; 0
    29c0:	c9 01       	movw	r24, r18
    29c2:	88 0f       	add	r24, r24
    29c4:	99 1f       	adc	r25, r25
    29c6:	88 0f       	add	r24, r24
    29c8:	99 1f       	adc	r25, r25
    29ca:	88 0f       	add	r24, r24
    29cc:	99 1f       	adc	r25, r25
    29ce:	28 0f       	add	r18, r24
    29d0:	39 1f       	adc	r19, r25
    29d2:	29 57       	subi	r18, 0x79	; 121
    29d4:	32 4f       	sbci	r19, 0xF2	; 242
    29d6:	82 85       	ldd	r24, Z+10	; 0x0a
    29d8:	93 85       	ldd	r25, Z+11	; 0x0b
    29da:	82 17       	cp	r24, r18
    29dc:	93 07       	cpc	r25, r19
    29de:	19 f5       	brne	.+70     	; 0x2a26 <vTaskPriorityInherit+0xac>
    29e0:	8f 01       	movw	r16, r30
    29e2:	ef 01       	movw	r28, r30
    29e4:	22 96       	adiw	r28, 0x02	; 2
    29e6:	ce 01       	movw	r24, r28
    29e8:	0e 94 8a 0c 	call	0x1914	; 0x1914 <uxListRemove>
    29ec:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    29f0:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    29f4:	86 89       	ldd	r24, Z+22	; 0x16
    29f6:	f8 01       	movw	r30, r16
    29f8:	86 8b       	std	Z+22, r24	; 0x16
    29fa:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    29fe:	98 17       	cp	r25, r24
    2a00:	10 f4       	brcc	.+4      	; 0x2a06 <vTaskPriorityInherit+0x8c>
    2a02:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2a06:	90 e0       	ldi	r25, 0x00	; 0
    2a08:	9c 01       	movw	r18, r24
    2a0a:	22 0f       	add	r18, r18
    2a0c:	33 1f       	adc	r19, r19
    2a0e:	22 0f       	add	r18, r18
    2a10:	33 1f       	adc	r19, r19
    2a12:	22 0f       	add	r18, r18
    2a14:	33 1f       	adc	r19, r19
    2a16:	82 0f       	add	r24, r18
    2a18:	93 1f       	adc	r25, r19
    2a1a:	be 01       	movw	r22, r28
    2a1c:	89 57       	subi	r24, 0x79	; 121
    2a1e:	92 4f       	sbci	r25, 0xF2	; 242
    2a20:	0e 94 38 0c 	call	0x1870	; 0x1870 <vListInsertEnd>
    2a24:	07 c0       	rjmp	.+14     	; 0x2a34 <vTaskPriorityInherit+0xba>
    2a26:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2a2a:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2a2e:	56 96       	adiw	r26, 0x16	; 22
    2a30:	8c 91       	ld	r24, X
    2a32:	86 8b       	std	Z+22, r24	; 0x16
    2a34:	df 91       	pop	r29
    2a36:	cf 91       	pop	r28
    2a38:	1f 91       	pop	r17
    2a3a:	0f 91       	pop	r16
    2a3c:	08 95       	ret

00002a3e <xTaskPriorityDisinherit>:
    2a3e:	0f 93       	push	r16
    2a40:	1f 93       	push	r17
    2a42:	cf 93       	push	r28
    2a44:	df 93       	push	r29
    2a46:	fc 01       	movw	r30, r24
    2a48:	89 2b       	or	r24, r25
    2a4a:	79 f1       	breq	.+94     	; 0x2aaa <xTaskPriorityDisinherit+0x6c>
    2a4c:	82 a1       	ldd	r24, Z+34	; 0x22
    2a4e:	81 50       	subi	r24, 0x01	; 1
    2a50:	82 a3       	std	Z+34, r24	; 0x22
    2a52:	26 89       	ldd	r18, Z+22	; 0x16
    2a54:	91 a1       	ldd	r25, Z+33	; 0x21
    2a56:	29 17       	cp	r18, r25
    2a58:	51 f1       	breq	.+84     	; 0x2aae <xTaskPriorityDisinherit+0x70>
    2a5a:	81 11       	cpse	r24, r1
    2a5c:	2a c0       	rjmp	.+84     	; 0x2ab2 <xTaskPriorityDisinherit+0x74>
    2a5e:	ef 01       	movw	r28, r30
    2a60:	8f 01       	movw	r16, r30
    2a62:	0e 5f       	subi	r16, 0xFE	; 254
    2a64:	1f 4f       	sbci	r17, 0xFF	; 255
    2a66:	c8 01       	movw	r24, r16
    2a68:	0e 94 8a 0c 	call	0x1914	; 0x1914 <uxListRemove>
    2a6c:	89 a1       	ldd	r24, Y+33	; 0x21
    2a6e:	8e 8b       	std	Y+22, r24	; 0x16
    2a70:	24 e0       	ldi	r18, 0x04	; 4
    2a72:	30 e0       	ldi	r19, 0x00	; 0
    2a74:	28 1b       	sub	r18, r24
    2a76:	31 09       	sbc	r19, r1
    2a78:	3d 87       	std	Y+13, r19	; 0x0d
    2a7a:	2c 87       	std	Y+12, r18	; 0x0c
    2a7c:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2a80:	98 17       	cp	r25, r24
    2a82:	10 f4       	brcc	.+4      	; 0x2a88 <xTaskPriorityDisinherit+0x4a>
    2a84:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2a88:	90 e0       	ldi	r25, 0x00	; 0
    2a8a:	9c 01       	movw	r18, r24
    2a8c:	22 0f       	add	r18, r18
    2a8e:	33 1f       	adc	r19, r19
    2a90:	22 0f       	add	r18, r18
    2a92:	33 1f       	adc	r19, r19
    2a94:	22 0f       	add	r18, r18
    2a96:	33 1f       	adc	r19, r19
    2a98:	82 0f       	add	r24, r18
    2a9a:	93 1f       	adc	r25, r19
    2a9c:	b8 01       	movw	r22, r16
    2a9e:	89 57       	subi	r24, 0x79	; 121
    2aa0:	92 4f       	sbci	r25, 0xF2	; 242
    2aa2:	0e 94 38 0c 	call	0x1870	; 0x1870 <vListInsertEnd>
    2aa6:	81 e0       	ldi	r24, 0x01	; 1
    2aa8:	05 c0       	rjmp	.+10     	; 0x2ab4 <xTaskPriorityDisinherit+0x76>
    2aaa:	80 e0       	ldi	r24, 0x00	; 0
    2aac:	03 c0       	rjmp	.+6      	; 0x2ab4 <xTaskPriorityDisinherit+0x76>
    2aae:	80 e0       	ldi	r24, 0x00	; 0
    2ab0:	01 c0       	rjmp	.+2      	; 0x2ab4 <xTaskPriorityDisinherit+0x76>
    2ab2:	80 e0       	ldi	r24, 0x00	; 0
    2ab4:	df 91       	pop	r29
    2ab6:	cf 91       	pop	r28
    2ab8:	1f 91       	pop	r17
    2aba:	0f 91       	pop	r16
    2abc:	08 95       	ret

00002abe <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2abe:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2ac2:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2ac6:	89 2b       	or	r24, r25
    2ac8:	39 f0       	breq	.+14     	; 0x2ad8 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2aca:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2ace:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2ad2:	82 a1       	ldd	r24, Z+34	; 0x22
    2ad4:	8f 5f       	subi	r24, 0xFF	; 255
    2ad6:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2ad8:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2adc:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
	}
    2ae0:	08 95       	ret

00002ae2 <__tablejump2__>:
    2ae2:	ee 0f       	add	r30, r30
    2ae4:	ff 1f       	adc	r31, r31
    2ae6:	00 24       	eor	r0, r0
    2ae8:	00 1c       	adc	r0, r0
    2aea:	0b be       	out	0x3b, r0	; 59
    2aec:	07 90       	elpm	r0, Z+
    2aee:	f6 91       	elpm	r31, Z
    2af0:	e0 2d       	mov	r30, r0
    2af2:	09 94       	ijmp

00002af4 <memcpy>:
    2af4:	fb 01       	movw	r30, r22
    2af6:	dc 01       	movw	r26, r24
    2af8:	02 c0       	rjmp	.+4      	; 0x2afe <memcpy+0xa>
    2afa:	01 90       	ld	r0, Z+
    2afc:	0d 92       	st	X+, r0
    2afe:	41 50       	subi	r20, 0x01	; 1
    2b00:	50 40       	sbci	r21, 0x00	; 0
    2b02:	d8 f7       	brcc	.-10     	; 0x2afa <memcpy+0x6>
    2b04:	08 95       	ret

00002b06 <eeprom_read_byte>:
    2b06:	e1 99       	sbic	0x1c, 1	; 28
    2b08:	fe cf       	rjmp	.-4      	; 0x2b06 <eeprom_read_byte>
    2b0a:	9f bb       	out	0x1f, r25	; 31
    2b0c:	8e bb       	out	0x1e, r24	; 30
    2b0e:	e0 9a       	sbi	0x1c, 0	; 28
    2b10:	99 27       	eor	r25, r25
    2b12:	8d b3       	in	r24, 0x1d	; 29
    2b14:	08 95       	ret

00002b16 <eeprom_update_byte>:
    2b16:	26 2f       	mov	r18, r22

00002b18 <eeprom_update_r18>:
    2b18:	e1 99       	sbic	0x1c, 1	; 28
    2b1a:	fe cf       	rjmp	.-4      	; 0x2b18 <eeprom_update_r18>
    2b1c:	9f bb       	out	0x1f, r25	; 31
    2b1e:	8e bb       	out	0x1e, r24	; 30
    2b20:	e0 9a       	sbi	0x1c, 0	; 28
    2b22:	01 97       	sbiw	r24, 0x01	; 1
    2b24:	0d b2       	in	r0, 0x1d	; 29
    2b26:	02 16       	cp	r0, r18
    2b28:	31 f0       	breq	.+12     	; 0x2b36 <eeprom_update_r18+0x1e>
    2b2a:	2d bb       	out	0x1d, r18	; 29
    2b2c:	0f b6       	in	r0, 0x3f	; 63
    2b2e:	f8 94       	cli
    2b30:	e2 9a       	sbi	0x1c, 2	; 28
    2b32:	e1 9a       	sbi	0x1c, 1	; 28
    2b34:	0f be       	out	0x3f, r0	; 63
    2b36:	08 95       	ret

00002b38 <__do_global_dtors>:
    2b38:	10 e0       	ldi	r17, 0x00	; 0
    2b3a:	c7 e4       	ldi	r28, 0x47	; 71
    2b3c:	d0 e0       	ldi	r29, 0x00	; 0
    2b3e:	03 c0       	rjmp	.+6      	; 0x2b46 <__do_global_dtors+0xe>
    2b40:	fe 01       	movw	r30, r28
    2b42:	cf df       	rcall	.-98     	; 0x2ae2 <__tablejump2__>
    2b44:	21 96       	adiw	r28, 0x01	; 1
    2b46:	c8 34       	cpi	r28, 0x48	; 72
    2b48:	d1 07       	cpc	r29, r17
    2b4a:	d1 f7       	brne	.-12     	; 0x2b40 <__do_global_dtors+0x8>
    2b4c:	f8 94       	cli

00002b4e <__stop_program>:
    2b4e:	ff cf       	rjmp	.-2      	; 0x2b4e <__stop_program>
