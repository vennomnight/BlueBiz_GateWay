
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000094  00800100  0000294e  000029e2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000294e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c0d  00800194  00800194  00002a76  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002a76  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002aa8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000788  00000000  00000000  00002ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a3a6  00000000  00000000  00003270  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002b22  00000000  00000000  0000d616  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000494e  00000000  00000000  00010138  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001530  00000000  00000000  00014a88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002f74  00000000  00000000  00015fb8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000078eb  00000000  00000000  00018f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007f8  00000000  00000000  00020817  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__dtors_end>
       2:	00 00       	nop
       4:	6f c0       	rjmp	.+222    	; 0xe4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c0       	rjmp	.+218    	; 0xe4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c0       	rjmp	.+214    	; 0xe4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c0       	rjmp	.+210    	; 0xe4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c0       	rjmp	.+206    	; 0xe4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c0       	rjmp	.+202    	; 0xe4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c0       	rjmp	.+198    	; 0xe4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c0       	rjmp	.+194    	; 0xe4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c0       	rjmp	.+190    	; 0xe4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c0       	rjmp	.+186    	; 0xe4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c0       	rjmp	.+182    	; 0xe4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 1b 0d 	jmp	0x1a36	; 0x1a36 <__vector_12>
      34:	57 c0       	rjmp	.+174    	; 0xe4 <__bad_interrupt>
      36:	00 00       	nop
      38:	55 c0       	rjmp	.+170    	; 0xe4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	53 c0       	rjmp	.+166    	; 0xe4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c0       	rjmp	.+162    	; 0xe4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c0       	rjmp	.+158    	; 0xe4 <__bad_interrupt>
      46:	00 00       	nop
      48:	5a c2       	rjmp	.+1204   	; 0x4fe <__vector_18>
      4a:	00 00       	nop
      4c:	4b c0       	rjmp	.+150    	; 0xe4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c0       	rjmp	.+146    	; 0xe4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c0       	rjmp	.+142    	; 0xe4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c0       	rjmp	.+138    	; 0xe4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c0       	rjmp	.+134    	; 0xe4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c0       	rjmp	.+130    	; 0xe4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c0       	rjmp	.+126    	; 0xe4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c0       	rjmp	.+122    	; 0xe4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c0       	rjmp	.+118    	; 0xe4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a7 c2       	rjmp	.+1358   	; 0x5c0 <__vector_28>
      72:	00 00       	nop
      74:	37 c0       	rjmp	.+110    	; 0xe4 <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c2       	rjmp	.+1252   	; 0x55e <__vector_30>
      7a:	00 00       	nop
      7c:	33 c0       	rjmp	.+102    	; 0xe4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c0       	rjmp	.+98     	; 0xe4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c0       	rjmp	.+94     	; 0xe4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c0       	rjmp	.+90     	; 0xe4 <__bad_interrupt>
	...

0000008c <__ctors_start>:
      8c:	2b 03       	fmul	r18, r19

0000008e <__ctors_end>:
      8e:	2f 03       	fmul	r18, r23

00000090 <__dtors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d0 e1       	ldi	r29, 0x10	; 16
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	ee e4       	ldi	r30, 0x4E	; 78
      a4:	f9 e2       	ldi	r31, 0x29	; 41
      a6:	00 e0       	ldi	r16, 0x00	; 0
      a8:	0b bf       	out	0x3b, r16	; 59
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x14>
      ac:	07 90       	elpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a4 39       	cpi	r26, 0x94	; 148
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0x10>

000000b6 <__do_clear_bss>:
      b6:	2d e0       	ldi	r18, 0x0D	; 13
      b8:	a4 e9       	ldi	r26, 0x94	; 148
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a1 3a       	cpi	r26, 0xA1	; 161
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>

000000c6 <__do_global_ctors>:
      c6:	10 e0       	ldi	r17, 0x00	; 0
      c8:	c7 e4       	ldi	r28, 0x47	; 71
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      cc:	04 c0       	rjmp	.+8      	; 0xd6 <__do_global_ctors+0x10>
      ce:	21 97       	sbiw	r28, 0x01	; 1
      d0:	fe 01       	movw	r30, r28
      d2:	0e 94 89 14 	call	0x2912	; 0x2912 <__tablejump2__>
      d6:	c6 34       	cpi	r28, 0x46	; 70
      d8:	d1 07       	cpc	r29, r17
      da:	c9 f7       	brne	.-14     	; 0xce <__do_global_ctors+0x8>
      dc:	0e 94 92 0a 	call	0x1524	; 0x1524 <main>
      e0:	0c 94 9b 14 	jmp	0x2936	; 0x2936 <__do_global_dtors>

000000e4 <__bad_interrupt>:
      e4:	8d cf       	rjmp	.-230    	; 0x0 <__vectors>

000000e6 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      e6:	fc 01       	movw	r30, r24
      e8:	68 0f       	add	r22, r24
      ea:	79 1f       	adc	r23, r25
      ec:	8f ef       	ldi	r24, 0xFF	; 255
      ee:	9f ef       	ldi	r25, 0xFF	; 255
      f0:	e6 17       	cp	r30, r22
      f2:	f7 07       	cpc	r31, r23
      f4:	99 f0       	breq	.+38     	; 0x11c <_Z5CRC16Phi+0x36>
      f6:	21 91       	ld	r18, Z+
      f8:	82 27       	eor	r24, r18
      fa:	28 e0       	ldi	r18, 0x08	; 8
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	ac 01       	movw	r20, r24
     100:	41 70       	andi	r20, 0x01	; 1
     102:	55 27       	eor	r21, r21
     104:	96 95       	lsr	r25
     106:	87 95       	ror	r24
     108:	45 2b       	or	r20, r21
     10a:	21 f0       	breq	.+8      	; 0x114 <_Z5CRC16Phi+0x2e>
     10c:	41 e0       	ldi	r20, 0x01	; 1
     10e:	84 27       	eor	r24, r20
     110:	40 ea       	ldi	r20, 0xA0	; 160
     112:	94 27       	eor	r25, r20
     114:	21 50       	subi	r18, 0x01	; 1
     116:	31 09       	sbc	r19, r1
     118:	91 f7       	brne	.-28     	; 0xfe <_Z5CRC16Phi+0x18>
     11a:	ea cf       	rjmp	.-44     	; 0xf0 <_Z5CRC16Phi+0xa>
     11c:	08 95       	ret

0000011e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	dc 01       	movw	r26, r24
     124:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     126:	8c 91       	ld	r24, X
     128:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     12a:	11 96       	adiw	r26, 0x01	; 1
     12c:	8c 91       	ld	r24, X
     12e:	11 97       	sbiw	r26, 0x01	; 1
     130:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     132:	13 96       	adiw	r26, 0x03	; 3
     134:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     136:	92 e0       	ldi	r25, 0x02	; 2
     138:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     13a:	e8 2f       	mov	r30, r24
     13c:	f0 e0       	ldi	r31, 0x00	; 0
     13e:	ee 0f       	add	r30, r30
     140:	ff 1f       	adc	r31, r31
     142:	e4 0f       	add	r30, r20
     144:	f5 1f       	adc	r31, r21
     146:	81 81       	ldd	r24, Z+1	; 0x01
     148:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     14a:	80 81       	ld	r24, Z
     14c:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     14e:	65 e0       	ldi	r22, 0x05	; 5
     150:	70 e0       	ldi	r23, 0x00	; 0
     152:	ce 01       	movw	r24, r28
     154:	c8 df       	rcall	.-112    	; 0xe6 <_Z5CRC16Phi>
	function04->CRC = crc16;
     156:	9e 83       	std	Y+6, r25	; 0x06
     158:	8d 83       	std	Y+5, r24	; 0x05
}
     15a:	df 91       	pop	r29
     15c:	cf 91       	pop	r28
     15e:	08 95       	ret

00000160 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	fc 01       	movw	r30, r24
     166:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     168:	80 81       	ld	r24, Z
     16a:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     170:	82 81       	ldd	r24, Z+2	; 0x02
     172:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     174:	83 81       	ldd	r24, Z+3	; 0x03
     176:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     178:	84 81       	ldd	r24, Z+4	; 0x04
     17a:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     17c:	85 81       	ldd	r24, Z+5	; 0x05
     17e:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     180:	66 e0       	ldi	r22, 0x06	; 6
     182:	70 e0       	ldi	r23, 0x00	; 0
     184:	ce 01       	movw	r24, r28
     186:	af df       	rcall	.-162    	; 0xe6 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     188:	9f 83       	std	Y+7, r25	; 0x07
     18a:	8e 83       	std	Y+6, r24	; 0x06
}
     18c:	df 91       	pop	r29
     18e:	cf 91       	pop	r28
     190:	08 95       	ret

00000192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     192:	cf 93       	push	r28
     194:	df 93       	push	r29
     196:	fc 01       	movw	r30, r24
     198:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     19a:	80 81       	ld	r24, Z
     19c:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     19e:	81 81       	ldd	r24, Z+1	; 0x01
     1a0:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1a2:	82 81       	ldd	r24, Z+2	; 0x02
     1a4:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1a6:	83 81       	ldd	r24, Z+3	; 0x03
     1a8:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1aa:	94 81       	ldd	r25, Z+4	; 0x04
     1ac:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1ae:	95 81       	ldd	r25, Z+5	; 0x05
     1b0:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1b2:	96 81       	ldd	r25, Z+6	; 0x06
     1b4:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1b6:	27 81       	ldd	r18, Z+7	; 0x07
     1b8:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1ba:	90 85       	ldd	r25, Z+8	; 0x08
     1bc:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1be:	e8 2f       	mov	r30, r24
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	ee 0f       	add	r30, r30
     1c4:	ff 1f       	adc	r31, r31
     1c6:	e4 0f       	add	r30, r20
     1c8:	f5 1f       	adc	r31, r21
     1ca:	89 2f       	mov	r24, r25
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	92 2b       	or	r25, r18
     1d0:	91 83       	std	Z+1, r25	; 0x01
     1d2:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1d4:	69 e0       	ldi	r22, 0x09	; 9
     1d6:	70 e0       	ldi	r23, 0x00	; 0
     1d8:	ce 01       	movw	r24, r28
     1da:	85 df       	rcall	.-246    	; 0xe6 <_Z5CRC16Phi>
	function10->CRC = crc16;
     1dc:	9a 87       	std	Y+10, r25	; 0x0a
     1de:	89 87       	std	Y+9, r24	; 0x09
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1e6:	cf 93       	push	r28
     1e8:	df 93       	push	r29
     1ea:	fc 01       	movw	r30, r24
     1ec:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1ee:	80 81       	ld	r24, Z
     1f0:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1f2:	81 81       	ldd	r24, Z+1	; 0x01
     1f4:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1f6:	82 81       	ldd	r24, Z+2	; 0x02
     1f8:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1fa:	83 81       	ldd	r24, Z+3	; 0x03
     1fc:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1fe:	84 81       	ldd	r24, Z+4	; 0x04
     200:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     202:	85 81       	ldd	r24, Z+5	; 0x05
     204:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	70 e0       	ldi	r23, 0x00	; 0
     20a:	ce 01       	movw	r24, r28
     20c:	6c df       	rcall	.-296    	; 0xe6 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     20e:	9f 83       	std	Y+7, r25	; 0x07
     210:	8e 83       	std	Y+6, r24	; 0x06
}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     21e:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     220:	81 e8       	ldi	r24, 0x81	; 129
     222:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     224:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	70 e0       	ldi	r23, 0x00	; 0
     22a:	ce 01       	movw	r24, r28
     22c:	5c df       	rcall	.-328    	; 0xe6 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     22e:	9c 83       	std	Y+4, r25	; 0x04
     230:	8b 83       	std	Y+3, r24	; 0x03
}
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	ec 01       	movw	r28, r24
     240:	cb 01       	movw	r24, r22
     242:	14 2f       	mov	r17, r20
     244:	fe 01       	movw	r30, r28
     246:	ea 57       	subi	r30, 0x7A	; 122
     248:	ff 4f       	sbci	r31, 0xFF	; 255
     24a:	71 83       	std	Z+1, r23	; 0x01
     24c:	60 83       	st	Z, r22
     24e:	64 2f       	mov	r22, r20
     250:	40 d1       	rcall	.+640    	; 0x4d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     252:	88 23       	and	r24, r24
     254:	71 f0       	breq	.+28     	; 0x272 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     256:	fe 01       	movw	r30, r28
     258:	eb 57       	subi	r30, 0x7B	; 123
     25a:	ff 4f       	sbci	r31, 0xFF	; 255
     25c:	10 83       	st	Z, r17
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	34 97       	sbiw	r30, 0x04	; 4
     264:	11 82       	std	Z+1, r1	; 0x01
     266:	10 82       	st	Z, r1
     268:	ce 57       	subi	r28, 0x7E	; 126
     26a:	df 4f       	sbci	r29, 0xFF	; 255
     26c:	19 82       	std	Y+1, r1	; 0x01
     26e:	18 82       	st	Y, r1
     270:	04 c0       	rjmp	.+8      	; 0x27a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     272:	ca 57       	subi	r28, 0x7A	; 122
     274:	df 4f       	sbci	r29, 0xFF	; 255
     276:	19 82       	std	Y+1, r1	; 0x01
     278:	18 82       	st	Y, r1
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	1f 91       	pop	r17
     280:	08 95       	ret

00000282 <_ZN12SerialBuffernwEj>:
     282:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <pvPortMalloc>
     286:	08 95       	ret

00000288 <_ZN12SerialBuffer11SerialstoreEc>:
     288:	fc 01       	movw	r30, r24
     28a:	e0 58       	subi	r30, 0x80	; 128
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	20 81       	ld	r18, Z
     290:	2f 5f       	subi	r18, 0xFF	; 255
     292:	2f 77       	andi	r18, 0x7F	; 127
     294:	19 f4       	brne	.+6      	; 0x29c <_ZN12SerialBuffer11SerialstoreEc+0x14>
     296:	11 82       	std	Z+1, r1	; 0x01
     298:	10 82       	st	Z, r1
     29a:	21 e0       	ldi	r18, 0x01	; 1
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	fc 01       	movw	r30, r24
     2a0:	ee 57       	subi	r30, 0x7E	; 126
     2a2:	ff 4f       	sbci	r31, 0xFF	; 255
     2a4:	40 81       	ld	r20, Z
     2a6:	51 81       	ldd	r21, Z+1	; 0x01
     2a8:	24 17       	cp	r18, r20
     2aa:	35 07       	cpc	r19, r21
     2ac:	89 f0       	breq	.+34     	; 0x2d0 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     2ae:	dc 01       	movw	r26, r24
     2b0:	a0 58       	subi	r26, 0x80	; 128
     2b2:	bf 4f       	sbci	r27, 0xFF	; 255
     2b4:	ed 91       	ld	r30, X+
     2b6:	fc 91       	ld	r31, X
     2b8:	11 97       	sbiw	r26, 0x01	; 1
     2ba:	e8 0f       	add	r30, r24
     2bc:	f9 1f       	adc	r31, r25
     2be:	61 83       	std	Z+1, r22	; 0x01
     2c0:	2d 93       	st	X+, r18
     2c2:	3c 93       	st	X, r19
     2c4:	fc 01       	movw	r30, r24
     2c6:	ec 57       	subi	r30, 0x7C	; 124
     2c8:	ff 4f       	sbci	r31, 0xFF	; 255
     2ca:	80 81       	ld	r24, Z
     2cc:	8f 5f       	subi	r24, 0xFF	; 255
     2ce:	80 83       	st	Z, r24
     2d0:	08 95       	ret

000002d2 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2d2:	af 92       	push	r10
     2d4:	bf 92       	push	r11
     2d6:	cf 92       	push	r12
     2d8:	df 92       	push	r13
     2da:	ef 92       	push	r14
     2dc:	ff 92       	push	r15
     2de:	0f 93       	push	r16
     2e0:	1f 93       	push	r17
     2e2:	cf 93       	push	r28
     2e4:	8c 01       	movw	r16, r24
     2e6:	6b 01       	movw	r12, r22
     2e8:	7a 01       	movw	r14, r20
     2ea:	dc 01       	movw	r26, r24
     2ec:	ab 57       	subi	r26, 0x7B	; 123
     2ee:	bf 4f       	sbci	r27, 0xFF	; 255
     2f0:	fc 01       	movw	r30, r24
     2f2:	ea 57       	subi	r30, 0x7A	; 122
     2f4:	ff 4f       	sbci	r31, 0xFF	; 255
     2f6:	6c 91       	ld	r22, X
     2f8:	80 81       	ld	r24, Z
     2fa:	91 81       	ldd	r25, Z+1	; 0x01
     2fc:	f7 d0       	rcall	.+494    	; 0x4ec <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>
     2fe:	89 2b       	or	r24, r25
     300:	d1 f0       	breq	.+52     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     302:	1e 14       	cp	r1, r14
     304:	1f 04       	cpc	r1, r15
     306:	bc f4       	brge	.+46     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     308:	c0 e0       	ldi	r28, 0x00	; 0
     30a:	58 01       	movw	r10, r16
     30c:	85 e8       	ldi	r24, 0x85	; 133
     30e:	a8 0e       	add	r10, r24
     310:	b1 1c       	adc	r11, r1
     312:	0a 57       	subi	r16, 0x7A	; 122
     314:	1f 4f       	sbci	r17, 0xFF	; 255
     316:	f6 01       	movw	r30, r12
     318:	ec 0f       	add	r30, r28
     31a:	f1 1d       	adc	r31, r1
     31c:	40 81       	ld	r20, Z
     31e:	f5 01       	movw	r30, r10
     320:	60 81       	ld	r22, Z
     322:	f8 01       	movw	r30, r16
     324:	80 81       	ld	r24, Z
     326:	91 81       	ldd	r25, Z+1	; 0x01
     328:	8d d0       	rcall	.+282    	; 0x444 <_ZN11Dev_Manager5WriteE8Dev_typec>
     32a:	cf 5f       	subi	r28, 0xFF	; 255
     32c:	2c 2f       	mov	r18, r28
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	2e 15       	cp	r18, r14
     332:	3f 05       	cpc	r19, r15
     334:	84 f3       	brlt	.-32     	; 0x316 <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	df 90       	pop	r13
     342:	cf 90       	pop	r12
     344:	bf 90       	pop	r11
     346:	af 90       	pop	r10
     348:	08 95       	ret

0000034a <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     34a:	fc 01       	movw	r30, r24
     34c:	ee 57       	subi	r30, 0x7E	; 126
     34e:	ff 4f       	sbci	r31, 0xFF	; 255
     350:	20 81       	ld	r18, Z
     352:	31 81       	ldd	r19, Z+1	; 0x01
     354:	32 97       	sbiw	r30, 0x02	; 2
     356:	40 81       	ld	r20, Z
     358:	51 81       	ldd	r21, Z+1	; 0x01
     35a:	42 17       	cp	r20, r18
     35c:	53 07       	cpc	r21, r19
     35e:	e9 f0       	breq	.+58     	; 0x39a <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     360:	2f 5f       	subi	r18, 0xFF	; 255
     362:	3f 4f       	sbci	r19, 0xFF	; 255
     364:	fc 01       	movw	r30, r24
     366:	e2 0f       	add	r30, r18
     368:	f3 1f       	adc	r31, r19
     36a:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     36c:	2f 77       	andi	r18, 0x7F	; 127
     36e:	33 27       	eor	r19, r19
     370:	fc 01       	movw	r30, r24
     372:	ee 57       	subi	r30, 0x7E	; 126
     374:	ff 4f       	sbci	r31, 0xFF	; 255
     376:	31 83       	std	Z+1, r19	; 0x01
     378:	20 83       	st	Z, r18
		if (ib.tail == num)
     37a:	32 96       	adiw	r30, 0x02	; 2
     37c:	60 81       	ld	r22, Z
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	26 17       	cp	r18, r22
     382:	37 07       	cpc	r19, r23
     384:	61 f4       	brne	.+24     	; 0x39e <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     386:	32 97       	sbiw	r30, 0x02	; 2
     388:	11 82       	std	Z+1, r1	; 0x01
     38a:	10 82       	st	Z, r1
			ib.head = 0;
     38c:	32 97       	sbiw	r30, 0x02	; 2
     38e:	11 82       	std	Z+1, r1	; 0x01
     390:	10 82       	st	Z, r1
			num = 0;
     392:	34 96       	adiw	r30, 0x04	; 4
     394:	10 82       	st	Z, r1
		}
		return data;
     396:	84 2f       	mov	r24, r20
     398:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     39a:	8f ef       	ldi	r24, 0xFF	; 255
     39c:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     39e:	84 2f       	mov	r24, r20
	}
}
     3a0:	08 95       	ret

000003a2 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     3a2:	dc 01       	movw	r26, r24
     3a4:	a0 58       	subi	r26, 0x80	; 128
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ee 57       	subi	r30, 0x7E	; 126
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	8c 91       	ld	r24, X
     3b0:	90 81       	ld	r25, Z
     3b2:	89 1b       	sub	r24, r25
}
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	08 95       	ret

000003b8 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     3b8:	fc 01       	movw	r30, r24
     3ba:	ee 57       	subi	r30, 0x7E	; 126
     3bc:	ff 4f       	sbci	r31, 0xFF	; 255
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	ib.head = 0;
     3c2:	32 97       	sbiw	r30, 0x02	; 2
     3c4:	11 82       	std	Z+1, r1	; 0x01
     3c6:	10 82       	st	Z, r1
	num = 0;
     3c8:	34 96       	adiw	r30, 0x04	; 4
     3ca:	10 82       	st	Z, r1
     3cc:	08 95       	ret

000003ce <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     3ce:	26 e0       	ldi	r18, 0x06	; 6
     3d0:	dc 01       	movw	r26, r24
     3d2:	e2 2f       	mov	r30, r18
     3d4:	1d 92       	st	X+, r1
     3d6:	ea 95       	dec	r30
     3d8:	e9 f7       	brne	.-6      	; 0x3d4 <_ZN11Dev_ManagerC1Ev+0x6>
     3da:	fc 01       	movw	r30, r24
     3dc:	36 96       	adiw	r30, 0x06	; 6
     3de:	df 01       	movw	r26, r30
     3e0:	1d 92       	st	X+, r1
     3e2:	2a 95       	dec	r18
     3e4:	e9 f7       	brne	.-6      	; 0x3e0 <_ZN11Dev_ManagerC1Ev+0x12>
     3e6:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <__data_end+0x1>
     3ea:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <__data_end>
     3ee:	08 95       	ret

000003f0 <_ZN11Dev_ManagerD1Ev>:
     3f0:	10 92 95 01 	sts	0x0195, r1	; 0x800195 <__data_end+0x1>
     3f4:	10 92 94 01 	sts	0x0194, r1	; 0x800194 <__data_end>
     3f8:	08 95       	ret

000003fa <_ZN11Dev_Manager11getInstanceEv>:
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <__data_end>
     402:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <__data_end+0x1>
     406:	89 2b       	or	r24, r25
     408:	51 f4       	brne	.+20     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 0a 0b 	call	0x1614	; 0x1614 <pvPortMalloc>
     412:	ec 01       	movw	r28, r24
     414:	dc df       	rcall	.-72     	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     416:	d0 93 95 01 	sts	0x0195, r29	; 0x800195 <__data_end+0x1>
     41a:	c0 93 94 01 	sts	0x0194, r28	; 0x800194 <__data_end>
     41e:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <__data_end>
     422:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <__data_end+0x1>
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	08 95       	ret

0000042c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     42c:	50 e0       	ldi	r21, 0x00	; 0
     42e:	44 0f       	add	r20, r20
     430:	55 1f       	adc	r21, r21
     432:	84 0f       	add	r24, r20
     434:	95 1f       	adc	r25, r21
     436:	fc 01       	movw	r30, r24
     438:	71 83       	std	Z+1, r23	; 0x01
     43a:	60 83       	st	Z, r22
     43c:	08 95       	ret

0000043e <_ZN11Dev_ManagernwEj>:
     43e:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <pvPortMalloc>
     442:	08 95       	ret

00000444 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     444:	26 2f       	mov	r18, r22
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	22 0f       	add	r18, r18
     44a:	33 1f       	adc	r19, r19
     44c:	82 0f       	add	r24, r18
     44e:	93 1f       	adc	r25, r19
     450:	dc 01       	movw	r26, r24
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	00 97       	sbiw	r24, 0x00	; 0
     458:	41 f0       	breq	.+16     	; 0x46a <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     45a:	64 2f       	mov	r22, r20
     45c:	dc 01       	movw	r26, r24
     45e:	ed 91       	ld	r30, X+
     460:	fc 91       	ld	r31, X
     462:	06 80       	ldd	r0, Z+6	; 0x06
     464:	f7 81       	ldd	r31, Z+7	; 0x07
     466:	e0 2d       	mov	r30, r0
     468:	09 95       	icall
     46a:	08 95       	ret

0000046c <_ZN11Dev_Manager6WritesE8Dev_typePc>:
     46c:	26 2f       	mov	r18, r22
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	22 0f       	add	r18, r18
     472:	33 1f       	adc	r19, r19
     474:	82 0f       	add	r24, r18
     476:	93 1f       	adc	r25, r19
     478:	dc 01       	movw	r26, r24
     47a:	8d 91       	ld	r24, X+
     47c:	9c 91       	ld	r25, X
     47e:	00 97       	sbiw	r24, 0x00	; 0
     480:	41 f0       	breq	.+16     	; 0x492 <_ZN11Dev_Manager6WritesE8Dev_typePc+0x26>
     482:	ba 01       	movw	r22, r20
     484:	dc 01       	movw	r26, r24
     486:	ed 91       	ld	r30, X+
     488:	fc 91       	ld	r31, X
     48a:	04 80       	ldd	r0, Z+4	; 0x04
     48c:	f5 81       	ldd	r31, Z+5	; 0x05
     48e:	e0 2d       	mov	r30, r0
     490:	09 95       	icall
     492:	08 95       	ret

00000494 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     494:	70 e0       	ldi	r23, 0x00	; 0
     496:	66 0f       	add	r22, r22
     498:	77 1f       	adc	r23, r23
     49a:	86 0f       	add	r24, r22
     49c:	97 1f       	adc	r25, r23
     49e:	dc 01       	movw	r26, r24
     4a0:	8d 91       	ld	r24, X+
     4a2:	9c 91       	ld	r25, X
     4a4:	00 97       	sbiw	r24, 0x00	; 0
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     4a8:	dc 01       	movw	r26, r24
     4aa:	ed 91       	ld	r30, X+
     4ac:	fc 91       	ld	r31, X
     4ae:	01 90       	ld	r0, Z+
     4b0:	f0 81       	ld	r31, Z
     4b2:	e0 2d       	mov	r30, r0
     4b4:	09 95       	icall
     4b6:	08 95       	ret

000004b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     4b8:	e6 2f       	mov	r30, r22
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 0f       	add	r30, r24
     4c2:	f9 1f       	adc	r31, r25
     4c4:	80 81       	ld	r24, Z
     4c6:	91 81       	ldd	r25, Z+1	; 0x01
     4c8:	89 2b       	or	r24, r25
     4ca:	11 f0       	breq	.+4      	; 0x4d0 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     4cc:	57 83       	std	Z+7, r21	; 0x07
     4ce:	46 83       	std	Z+6, r20	; 0x06
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	66 0f       	add	r22, r22
     4d6:	77 1f       	adc	r23, r23
     4d8:	fc 01       	movw	r30, r24
     4da:	e6 0f       	add	r30, r22
     4dc:	f7 1f       	adc	r31, r23
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	20 81       	ld	r18, Z
     4e2:	31 81       	ldd	r19, Z+1	; 0x01
     4e4:	23 2b       	or	r18, r19
     4e6:	09 f4       	brne	.+2      	; 0x4ea <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	08 95       	ret

000004ec <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device)
{
	if(interface[Device])
     4ec:	70 e0       	ldi	r23, 0x00	; 0
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	86 0f       	add	r24, r22
     4f4:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     4f6:	fc 01       	movw	r30, r24
     4f8:	80 81       	ld	r24, Z
     4fa:	91 81       	ldd	r25, Z+1	; 0x01
     4fc:	08 95       	ret

000004fe <__vector_18>:
ISR(USART0_RX_vect)
{
     4fe:	1f 92       	push	r1
     500:	0f 92       	push	r0
     502:	0f b6       	in	r0, 0x3f	; 63
     504:	0f 92       	push	r0
     506:	11 24       	eor	r1, r1
     508:	0b b6       	in	r0, 0x3b	; 59
     50a:	0f 92       	push	r0
     50c:	2f 93       	push	r18
     50e:	3f 93       	push	r19
     510:	4f 93       	push	r20
     512:	5f 93       	push	r21
     514:	6f 93       	push	r22
     516:	7f 93       	push	r23
     518:	8f 93       	push	r24
     51a:	9f 93       	push	r25
     51c:	af 93       	push	r26
     51e:	bf 93       	push	r27
     520:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     522:	ff 93       	push	r31
     524:	6a df       	rcall	.-300    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     526:	6c b1       	in	r22, 0x0c	; 12
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	dc 01       	movw	r26, r24
     52c:	16 96       	adiw	r26, 0x06	; 6
     52e:	ed 91       	ld	r30, X+
     530:	fc 91       	ld	r31, X
     532:	17 97       	sbiw	r26, 0x07	; 7
     534:	80 e0       	ldi	r24, 0x00	; 0
}
     536:	09 95       	icall
     538:	ff 91       	pop	r31
     53a:	ef 91       	pop	r30
     53c:	bf 91       	pop	r27
     53e:	af 91       	pop	r26
     540:	9f 91       	pop	r25
     542:	8f 91       	pop	r24
     544:	7f 91       	pop	r23
     546:	6f 91       	pop	r22
     548:	5f 91       	pop	r21
     54a:	4f 91       	pop	r20
     54c:	3f 91       	pop	r19
     54e:	2f 91       	pop	r18
     550:	0f 90       	pop	r0
     552:	0b be       	out	0x3b, r0	; 59
     554:	0f 90       	pop	r0
     556:	0f be       	out	0x3f, r0	; 63
     558:	0f 90       	pop	r0
     55a:	1f 90       	pop	r1
     55c:	18 95       	reti

0000055e <__vector_30>:
ISR(USART1_RX_vect)
{
     55e:	1f 92       	push	r1
     560:	0f 92       	push	r0
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	0f 92       	push	r0
     566:	11 24       	eor	r1, r1
     568:	0b b6       	in	r0, 0x3b	; 59
     56a:	0f 92       	push	r0
     56c:	2f 93       	push	r18
     56e:	3f 93       	push	r19
     570:	4f 93       	push	r20
     572:	5f 93       	push	r21
     574:	6f 93       	push	r22
     576:	7f 93       	push	r23
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
     57c:	af 93       	push	r26
     57e:	bf 93       	push	r27
     580:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     582:	ff 93       	push	r31
     584:	3a df       	rcall	.-396    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     586:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	dc 01       	movw	r26, r24
     58e:	18 96       	adiw	r26, 0x08	; 8
     590:	ed 91       	ld	r30, X+
     592:	fc 91       	ld	r31, X
     594:	19 97       	sbiw	r26, 0x09	; 9
     596:	81 e0       	ldi	r24, 0x01	; 1
}
     598:	09 95       	icall
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	bf 91       	pop	r27
     5a0:	af 91       	pop	r26
     5a2:	9f 91       	pop	r25
     5a4:	8f 91       	pop	r24
     5a6:	7f 91       	pop	r23
     5a8:	6f 91       	pop	r22
     5aa:	5f 91       	pop	r21
     5ac:	4f 91       	pop	r20
     5ae:	3f 91       	pop	r19
     5b0:	2f 91       	pop	r18
     5b2:	0f 90       	pop	r0
     5b4:	0b be       	out	0x3b, r0	; 59
     5b6:	0f 90       	pop	r0
     5b8:	0f be       	out	0x3f, r0	; 63
     5ba:	0f 90       	pop	r0
     5bc:	1f 90       	pop	r1
     5be:	18 95       	reti

000005c0 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     5c0:	1f 92       	push	r1
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	0f 92       	push	r0
     5c8:	11 24       	eor	r1, r1
     5ca:	0b b6       	in	r0, 0x3b	; 59
     5cc:	0f 92       	push	r0
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,0);
     5e4:	ff 93       	push	r31
     5e6:	09 df       	rcall	.-494    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     5e8:	dc 01       	movw	r26, r24
     5ea:	1a 96       	adiw	r26, 0x0a	; 10
     5ec:	ed 91       	ld	r30, X+
     5ee:	fc 91       	ld	r31, X
     5f0:	1b 97       	sbiw	r26, 0x0b	; 11
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	82 e0       	ldi	r24, 0x02	; 2
     5f8:	09 95       	icall
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	bf 91       	pop	r27
     600:	af 91       	pop	r26
     602:	9f 91       	pop	r25
     604:	8f 91       	pop	r24
     606:	7f 91       	pop	r23
     608:	6f 91       	pop	r22
     60a:	5f 91       	pop	r21
     60c:	4f 91       	pop	r20
     60e:	3f 91       	pop	r19
     610:	2f 91       	pop	r18
     612:	0f 90       	pop	r0
     614:	0b be       	out	0x3b, r0	; 59
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0
     61c:	1f 90       	pop	r1
     61e:	18 95       	reti

00000620 <_ZN20DeviceDriveInterFace11Device_ReadEv>:
{
	return malloc(size);
}
void Timer::operator delete(void* ptr)
{
	free(ptr);
     620:	08 95       	ret

00000622 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
     622:	08 95       	ret

00000624 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
     624:	08 95       	ret

00000626 <_ZN5Timer11Device_InitEv>:
     626:	80 e4       	ldi	r24, 0x40	; 64
     628:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
     632:	88 e0       	ldi	r24, 0x08	; 8
     634:	9d e3       	ldi	r25, 0x3D	; 61
     636:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     63a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     63e:	82 e0       	ldi	r24, 0x02	; 2
     640:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     644:	08 95       	ret

00000646 <_ZN5TimerC1Ev>:
     646:	2f e0       	ldi	r18, 0x0F	; 15
     648:	31 e0       	ldi	r19, 0x01	; 1
     64a:	fc 01       	movw	r30, r24
     64c:	31 83       	std	Z+1, r19	; 0x01
     64e:	20 83       	st	Z, r18
     650:	08 95       	ret

00000652 <_ZN5TimernwEj>:
     652:	e0 c7       	rjmp	.+4032   	; 0x1614 <pvPortMalloc>
     654:	08 95       	ret

00000656 <_GLOBAL__sub_I_dev1>:
 *
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"
Dev_Manager dev1;
     656:	86 e9       	ldi	r24, 0x96	; 150
     658:	91 e0       	ldi	r25, 0x01	; 1
     65a:	b9 ce       	rjmp	.-654    	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     65c:	08 95       	ret

0000065e <_GLOBAL__sub_D_dev1>:
	TCCR3B = 0x04;
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
     65e:	86 e9       	ldi	r24, 0x96	; 150
     660:	91 e0       	ldi	r25, 0x01	; 1
     662:	c6 ce       	rjmp	.-628    	; 0x3f0 <_ZN11Dev_ManagerD1Ev>
     664:	08 95       	ret

00000666 <_ZN11RS485Driver11Device_InitEv>:
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	ec 01       	movw	r28, r24
     66c:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     670:	88 e9       	ldi	r24, 0x98	; 152
     672:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     676:	86 e0       	ldi	r24, 0x06	; 6
     678:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     67c:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     680:	87 e6       	ldi	r24, 0x67	; 103
     682:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     686:	81 e0       	ldi	r24, 0x01	; 1
     688:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xQueueCreateMutex>
     68c:	9d 83       	std	Y+5, r25	; 0x05
     68e:	8c 83       	std	Y+4, r24	; 0x04
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xQueueCreateMutex>
     696:	9b 83       	std	Y+3, r25	; 0x03
     698:	8a 83       	std	Y+2, r24	; 0x02
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	08 95       	ret

000006a0 <_ZN11RS485DriverC1Ev>:
     6a0:	2b e1       	ldi	r18, 0x1B	; 27
     6a2:	31 e0       	ldi	r19, 0x01	; 1
     6a4:	fc 01       	movw	r30, r24
     6a6:	31 83       	std	Z+1, r19	; 0x01
     6a8:	20 83       	st	Z, r18
     6aa:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <_ZN11RS485Driver4instE>
     6ae:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <_ZN11RS485Driver4instE+0x1>
     6b2:	23 2b       	or	r18, r19
     6b4:	21 f4       	brne	.+8      	; 0x6be <_ZN11RS485DriverC1Ev+0x1e>
     6b6:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <_ZN11RS485Driver4instE+0x1>
     6ba:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <_ZN11RS485Driver4instE>
     6be:	08 95       	ret

000006c0 <_ZN11RS485DrivernwEj>:
     6c0:	a9 c7       	rjmp	.+3922   	; 0x1614 <pvPortMalloc>
     6c2:	08 95       	ret

000006c4 <_ZN11RS485Driver12UART_PutcharEc>:
     6c4:	1f 93       	push	r17
     6c6:	cf 93       	push	r28
     6c8:	df 93       	push	r29
     6ca:	ec 01       	movw	r28, r24
     6cc:	16 2f       	mov	r17, r22
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	44 e6       	ldi	r20, 0x64	; 100
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	60 e0       	ldi	r22, 0x00	; 0
     6d6:	70 e0       	ldi	r23, 0x00	; 0
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <xQueueGenericReceive>
     6e0:	81 30       	cpi	r24, 0x01	; 1
     6e2:	81 f4       	brne	.+32     	; 0x704 <_ZN11RS485Driver12UART_PutcharEc+0x40>
     6e4:	eb e9       	ldi	r30, 0x9B	; 155
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	80 81       	ld	r24, Z
     6ea:	85 ff       	sbrs	r24, 5
     6ec:	fd cf       	rjmp	.-6      	; 0x6e8 <_ZN11RS485Driver12UART_PutcharEc+0x24>
     6ee:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     6f2:	20 e0       	ldi	r18, 0x00	; 0
     6f4:	40 e0       	ldi	r20, 0x00	; 0
     6f6:	50 e0       	ldi	r21, 0x00	; 0
     6f8:	60 e0       	ldi	r22, 0x00	; 0
     6fa:	70 e0       	ldi	r23, 0x00	; 0
     6fc:	8a 81       	ldd	r24, Y+2	; 0x02
     6fe:	9b 81       	ldd	r25, Y+3	; 0x03
     700:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xQueueGenericSend>
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	1f 91       	pop	r17
     70a:	08 95       	ret

0000070c <_ZN11RS485Driver12Device_WriteEc>:
     70c:	db cf       	rjmp	.-74     	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc>
     70e:	08 95       	ret

00000710 <_ZN11RS485Driver14UART_PutStringEPKc>:
     710:	0f 93       	push	r16
     712:	1f 93       	push	r17
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	8c 01       	movw	r16, r24
     71a:	eb 01       	movw	r28, r22
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	44 e6       	ldi	r20, 0x64	; 100
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	fc 01       	movw	r30, r24
     728:	84 81       	ldd	r24, Z+4	; 0x04
     72a:	95 81       	ldd	r25, Z+5	; 0x05
     72c:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <xQueueGenericReceive>
     730:	81 30       	cpi	r24, 0x01	; 1
     732:	99 f4       	brne	.+38     	; 0x75a <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     734:	68 81       	ld	r22, Y
     736:	66 23       	and	r22, r22
     738:	31 f0       	breq	.+12     	; 0x746 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     73a:	21 96       	adiw	r28, 0x01	; 1
     73c:	c8 01       	movw	r24, r16
     73e:	c2 df       	rcall	.-124    	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc>
     740:	69 91       	ld	r22, Y+
     742:	61 11       	cpse	r22, r1
     744:	fb cf       	rjmp	.-10     	; 0x73c <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	40 e0       	ldi	r20, 0x00	; 0
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	f8 01       	movw	r30, r16
     752:	84 81       	ldd	r24, Z+4	; 0x04
     754:	95 81       	ldd	r25, Z+5	; 0x05
     756:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xQueueGenericSend>
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	1f 91       	pop	r17
     760:	0f 91       	pop	r16
     762:	08 95       	ret

00000764 <_ZN11RS485Driver13Device_WritesEPKc>:
     764:	d5 cf       	rjmp	.-86     	; 0x710 <_ZN11RS485Driver14UART_PutStringEPKc>
     766:	08 95       	ret

00000768 <_ZN10UartDriver11Device_InitEv>:
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	ec 01       	movw	r28, r24
     76e:	88 e9       	ldi	r24, 0x98	; 152
     770:	8a b9       	out	0x0a, r24	; 10
     772:	86 e0       	ldi	r24, 0x06	; 6
     774:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     778:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     77c:	8f ec       	ldi	r24, 0xCF	; 207
     77e:	89 b9       	out	0x09, r24	; 9
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xQueueCreateMutex>
     786:	9d 83       	std	Y+5, r25	; 0x05
     788:	8c 83       	std	Y+4, r24	; 0x04
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	0e 94 d0 0e 	call	0x1da0	; 0x1da0 <xQueueCreateMutex>
     790:	9b 83       	std	Y+3, r25	; 0x03
     792:	8a 83       	std	Y+2, r24	; 0x02
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	08 95       	ret

0000079a <_ZN10UartDriverC1Ev>:
     79a:	27 e2       	ldi	r18, 0x27	; 39
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	fc 01       	movw	r30, r24
     7a0:	31 83       	std	Z+1, r19	; 0x01
     7a2:	20 83       	st	Z, r18
     7a4:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <_ZN10UartDriver4instE>
     7a8:	30 91 a5 01 	lds	r19, 0x01A5	; 0x8001a5 <_ZN10UartDriver4instE+0x1>
     7ac:	23 2b       	or	r18, r19
     7ae:	21 f4       	brne	.+8      	; 0x7b8 <_ZN10UartDriverC1Ev+0x1e>
     7b0:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <_ZN10UartDriver4instE+0x1>
     7b4:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <_ZN10UartDriver4instE>
     7b8:	08 95       	ret

000007ba <_ZN10UartDrivernwEj>:
     7ba:	2c c7       	rjmp	.+3672   	; 0x1614 <pvPortMalloc>
     7bc:	08 95       	ret

000007be <_ZN10UartDriver12UART_PutcharEc>:
     7be:	1f 93       	push	r17
     7c0:	cf 93       	push	r28
     7c2:	df 93       	push	r29
     7c4:	ec 01       	movw	r28, r24
     7c6:	16 2f       	mov	r17, r22
     7c8:	20 e0       	ldi	r18, 0x00	; 0
     7ca:	44 e6       	ldi	r20, 0x64	; 100
     7cc:	50 e0       	ldi	r21, 0x00	; 0
     7ce:	60 e0       	ldi	r22, 0x00	; 0
     7d0:	70 e0       	ldi	r23, 0x00	; 0
     7d2:	8a 81       	ldd	r24, Y+2	; 0x02
     7d4:	9b 81       	ldd	r25, Y+3	; 0x03
     7d6:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <xQueueGenericReceive>
     7da:	81 30       	cpi	r24, 0x01	; 1
     7dc:	61 f4       	brne	.+24     	; 0x7f6 <_ZN10UartDriver12UART_PutcharEc+0x38>
     7de:	5d 9b       	sbis	0x0b, 5	; 11
     7e0:	fe cf       	rjmp	.-4      	; 0x7de <_ZN10UartDriver12UART_PutcharEc+0x20>
     7e2:	1c b9       	out	0x0c, r17	; 12
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e0       	ldi	r21, 0x00	; 0
     7ea:	60 e0       	ldi	r22, 0x00	; 0
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	8a 81       	ldd	r24, Y+2	; 0x02
     7f0:	9b 81       	ldd	r25, Y+3	; 0x03
     7f2:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xQueueGenericSend>
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	1f 91       	pop	r17
     7fc:	08 95       	ret

000007fe <_ZN10UartDriver12Device_WriteEc>:
     7fe:	df cf       	rjmp	.-66     	; 0x7be <_ZN10UartDriver12UART_PutcharEc>
     800:	08 95       	ret

00000802 <_ZN10UartDriver14UART_PutStringEPKc>:
     802:	0f 93       	push	r16
     804:	1f 93       	push	r17
     806:	cf 93       	push	r28
     808:	df 93       	push	r29
     80a:	8c 01       	movw	r16, r24
     80c:	eb 01       	movw	r28, r22
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	44 e6       	ldi	r20, 0x64	; 100
     812:	50 e0       	ldi	r21, 0x00	; 0
     814:	60 e0       	ldi	r22, 0x00	; 0
     816:	70 e0       	ldi	r23, 0x00	; 0
     818:	fc 01       	movw	r30, r24
     81a:	84 81       	ldd	r24, Z+4	; 0x04
     81c:	95 81       	ldd	r25, Z+5	; 0x05
     81e:	0e 94 e8 0e 	call	0x1dd0	; 0x1dd0 <xQueueGenericReceive>
     822:	81 30       	cpi	r24, 0x01	; 1
     824:	99 f4       	brne	.+38     	; 0x84c <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     826:	68 81       	ld	r22, Y
     828:	66 23       	and	r22, r22
     82a:	31 f0       	breq	.+12     	; 0x838 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     82c:	21 96       	adiw	r28, 0x01	; 1
     82e:	c8 01       	movw	r24, r16
     830:	c6 df       	rcall	.-116    	; 0x7be <_ZN10UartDriver12UART_PutcharEc>
     832:	69 91       	ld	r22, Y+
     834:	61 11       	cpse	r22, r1
     836:	fb cf       	rjmp	.-10     	; 0x82e <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     838:	20 e0       	ldi	r18, 0x00	; 0
     83a:	40 e0       	ldi	r20, 0x00	; 0
     83c:	50 e0       	ldi	r21, 0x00	; 0
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	70 e0       	ldi	r23, 0x00	; 0
     842:	f8 01       	movw	r30, r16
     844:	84 81       	ldd	r24, Z+4	; 0x04
     846:	95 81       	ldd	r25, Z+5	; 0x05
     848:	0e 94 3e 0e 	call	0x1c7c	; 0x1c7c <xQueueGenericSend>
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN10UartDriver13Device_WritesEPKc>:
     856:	d5 cf       	rjmp	.-86     	; 0x802 <_ZN10UartDriver14UART_PutStringEPKc>
     858:	08 95       	ret

0000085a <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     85a:	c0 98       	cbi	0x18, 0	; 24
     85c:	96 2f       	mov	r25, r22
     85e:	6f 71       	andi	r22, 0x1F	; 31
     860:	86 2b       	or	r24, r22
     862:	8f b9       	out	0x0f, r24	; 15
     864:	77 9b       	sbis	0x0e, 7	; 14
     866:	fe cf       	rjmp	.-4      	; 0x864 <_Z14enc28j60ReadOphh+0xa>
     868:	1f b8       	out	0x0f, r1	; 15
     86a:	77 9b       	sbis	0x0e, 7	; 14
     86c:	fe cf       	rjmp	.-4      	; 0x86a <_Z14enc28j60ReadOphh+0x10>
     86e:	99 23       	and	r25, r25
     870:	1c f4       	brge	.+6      	; 0x878 <_Z14enc28j60ReadOphh+0x1e>
     872:	1f b8       	out	0x0f, r1	; 15
     874:	77 9b       	sbis	0x0e, 7	; 14
     876:	fe cf       	rjmp	.-4      	; 0x874 <_Z14enc28j60ReadOphh+0x1a>
     878:	c0 9a       	sbi	0x18, 0	; 24
     87a:	8f b1       	in	r24, 0x0f	; 15
     87c:	08 95       	ret

0000087e <_Z15enc28j60WriteOphhh>:
     87e:	c0 98       	cbi	0x18, 0	; 24
     880:	6f 71       	andi	r22, 0x1F	; 31
     882:	86 2b       	or	r24, r22
     884:	8f b9       	out	0x0f, r24	; 15
     886:	77 9b       	sbis	0x0e, 7	; 14
     888:	fe cf       	rjmp	.-4      	; 0x886 <_Z15enc28j60WriteOphhh+0x8>
     88a:	4f b9       	out	0x0f, r20	; 15
     88c:	77 9b       	sbis	0x0e, 7	; 14
     88e:	fe cf       	rjmp	.-4      	; 0x88c <_Z15enc28j60WriteOphhh+0xe>
     890:	c0 9a       	sbi	0x18, 0	; 24
     892:	08 95       	ret

00000894 <_Z18enc28j60ReadBufferjPh>:
     894:	fb 01       	movw	r30, r22
     896:	c0 98       	cbi	0x18, 0	; 24
     898:	2a e3       	ldi	r18, 0x3A	; 58
     89a:	2f b9       	out	0x0f, r18	; 15
     89c:	77 9b       	sbis	0x0e, 7	; 14
     89e:	fe cf       	rjmp	.-4      	; 0x89c <_Z18enc28j60ReadBufferjPh+0x8>
     8a0:	00 97       	sbiw	r24, 0x00	; 0
     8a2:	61 f0       	breq	.+24     	; 0x8bc <_Z18enc28j60ReadBufferjPh+0x28>
     8a4:	df 01       	movw	r26, r30
     8a6:	a8 0f       	add	r26, r24
     8a8:	b9 1f       	adc	r27, r25
     8aa:	1f b8       	out	0x0f, r1	; 15
     8ac:	77 9b       	sbis	0x0e, 7	; 14
     8ae:	fe cf       	rjmp	.-4      	; 0x8ac <_Z18enc28j60ReadBufferjPh+0x18>
     8b0:	9f b1       	in	r25, 0x0f	; 15
     8b2:	91 93       	st	Z+, r25
     8b4:	ae 17       	cp	r26, r30
     8b6:	bf 07       	cpc	r27, r31
     8b8:	c1 f7       	brne	.-16     	; 0x8aa <_Z18enc28j60ReadBufferjPh+0x16>
     8ba:	01 c0       	rjmp	.+2      	; 0x8be <_Z18enc28j60ReadBufferjPh+0x2a>
     8bc:	df 01       	movw	r26, r30
     8be:	1c 92       	st	X, r1
     8c0:	c0 9a       	sbi	0x18, 0	; 24
     8c2:	08 95       	ret

000008c4 <_Z19enc28j60WriteBufferjPh>:
     8c4:	fb 01       	movw	r30, r22
     8c6:	c0 98       	cbi	0x18, 0	; 24
     8c8:	2a e7       	ldi	r18, 0x7A	; 122
     8ca:	2f b9       	out	0x0f, r18	; 15
     8cc:	77 9b       	sbis	0x0e, 7	; 14
     8ce:	fe cf       	rjmp	.-4      	; 0x8cc <_Z19enc28j60WriteBufferjPh+0x8>
     8d0:	00 97       	sbiw	r24, 0x00	; 0
     8d2:	61 f0       	breq	.+24     	; 0x8ec <_Z19enc28j60WriteBufferjPh+0x28>
     8d4:	9f 01       	movw	r18, r30
     8d6:	28 0f       	add	r18, r24
     8d8:	39 1f       	adc	r19, r25
     8da:	03 c0       	rjmp	.+6      	; 0x8e2 <_Z19enc28j60WriteBufferjPh+0x1e>
     8dc:	2e 17       	cp	r18, r30
     8de:	3f 07       	cpc	r19, r31
     8e0:	29 f0       	breq	.+10     	; 0x8ec <_Z19enc28j60WriteBufferjPh+0x28>
     8e2:	91 91       	ld	r25, Z+
     8e4:	9f b9       	out	0x0f, r25	; 15
     8e6:	77 9b       	sbis	0x0e, 7	; 14
     8e8:	fe cf       	rjmp	.-4      	; 0x8e6 <_Z19enc28j60WriteBufferjPh+0x22>
     8ea:	f8 cf       	rjmp	.-16     	; 0x8dc <_Z19enc28j60WriteBufferjPh+0x18>
     8ec:	c0 9a       	sbi	0x18, 0	; 24
     8ee:	08 95       	ret

000008f0 <_Z15enc28j60SetBankh>:
     8f0:	1f 93       	push	r17
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	18 2f       	mov	r17, r24
     8f8:	10 76       	andi	r17, 0x60	; 96
     8fa:	c1 2f       	mov	r28, r17
     8fc:	d0 e0       	ldi	r29, 0x00	; 0
     8fe:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <_ZL12Enc28j60Bank>
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	c8 17       	cp	r28, r24
     906:	d9 07       	cpc	r29, r25
     908:	a1 f0       	breq	.+40     	; 0x932 <_Z15enc28j60SetBankh+0x42>
     90a:	43 e0       	ldi	r20, 0x03	; 3
     90c:	6f e1       	ldi	r22, 0x1F	; 31
     90e:	80 ea       	ldi	r24, 0xA0	; 160
     910:	b6 df       	rcall	.-148    	; 0x87e <_Z15enc28j60WriteOphhh>
     912:	ae 01       	movw	r20, r28
     914:	55 95       	asr	r21
     916:	47 95       	ror	r20
     918:	55 95       	asr	r21
     91a:	47 95       	ror	r20
     91c:	55 95       	asr	r21
     91e:	47 95       	ror	r20
     920:	55 95       	asr	r21
     922:	47 95       	ror	r20
     924:	55 95       	asr	r21
     926:	47 95       	ror	r20
     928:	6f e1       	ldi	r22, 0x1F	; 31
     92a:	80 e8       	ldi	r24, 0x80	; 128
     92c:	a8 df       	rcall	.-176    	; 0x87e <_Z15enc28j60WriteOphhh>
     92e:	10 93 a8 01 	sts	0x01A8, r17	; 0x8001a8 <_ZL12Enc28j60Bank>
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	08 95       	ret

0000093a <_Z12enc28j60Readh>:
     93a:	cf 93       	push	r28
     93c:	c8 2f       	mov	r28, r24
     93e:	d8 df       	rcall	.-80     	; 0x8f0 <_Z15enc28j60SetBankh>
     940:	6c 2f       	mov	r22, r28
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	8a df       	rcall	.-236    	; 0x85a <_Z14enc28j60ReadOphh>
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_Z13enc28j60Writehh>:
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	c8 2f       	mov	r28, r24
     950:	d6 2f       	mov	r29, r22
     952:	ce df       	rcall	.-100    	; 0x8f0 <_Z15enc28j60SetBankh>
     954:	4d 2f       	mov	r20, r29
     956:	6c 2f       	mov	r22, r28
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	91 df       	rcall	.-222    	; 0x87e <_Z15enc28j60WriteOphhh>
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	08 95       	ret

00000962 <_Z16enc28j60PhyWritehj>:
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	d6 2f       	mov	r29, r22
     968:	c7 2f       	mov	r28, r23
     96a:	68 2f       	mov	r22, r24
     96c:	84 ed       	ldi	r24, 0xD4	; 212
     96e:	ed df       	rcall	.-38     	; 0x94a <_Z13enc28j60Writehh>
     970:	6d 2f       	mov	r22, r29
     972:	86 ed       	ldi	r24, 0xD6	; 214
     974:	ea df       	rcall	.-44     	; 0x94a <_Z13enc28j60Writehh>
     976:	6c 2f       	mov	r22, r28
     978:	87 ed       	ldi	r24, 0xD7	; 215
     97a:	e7 df       	rcall	.-50     	; 0x94a <_Z13enc28j60Writehh>
     97c:	8a ee       	ldi	r24, 0xEA	; 234
     97e:	dd df       	rcall	.-70     	; 0x93a <_Z12enc28j60Readh>
     980:	80 ff       	sbrs	r24, 0
     982:	04 c0       	rjmp	.+8      	; 0x98c <_Z16enc28j60PhyWritehj+0x2a>
     984:	85 e0       	ldi	r24, 0x05	; 5
     986:	8a 95       	dec	r24
     988:	f1 f7       	brne	.-4      	; 0x986 <_Z16enc28j60PhyWritehj+0x24>
     98a:	f8 cf       	rjmp	.-16     	; 0x97c <_Z16enc28j60PhyWritehj+0x1a>
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	08 95       	ret

00000992 <_Z14enc28j60clkouth>:
     992:	68 2f       	mov	r22, r24
     994:	67 70       	andi	r22, 0x07	; 7
     996:	85 e7       	ldi	r24, 0x75	; 117
     998:	d8 cf       	rjmp	.-80     	; 0x94a <_Z13enc28j60Writehh>
     99a:	08 95       	ret

0000099c <_Z12enc28j60InitPh>:
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
     9a0:	ec 01       	movw	r28, r24
     9a2:	b8 9a       	sbi	0x17, 0	; 23
     9a4:	c0 9a       	sbi	0x18, 0	; 24
     9a6:	a6 d2       	rcall	.+1356   	; 0xef4 <_Z8spi_initv>
     9a8:	4f ef       	ldi	r20, 0xFF	; 255
     9aa:	60 e0       	ldi	r22, 0x00	; 0
     9ac:	8f ef       	ldi	r24, 0xFF	; 255
     9ae:	67 df       	rcall	.-306    	; 0x87e <_Z15enc28j60WriteOphhh>
     9b0:	82 e3       	ldi	r24, 0x32	; 50
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	a9 d2       	rcall	.+1362   	; 0xf08 <_Z8delay_msj>
     9b6:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
     9ba:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <_ZL13NextPacketPtr>
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	88 e0       	ldi	r24, 0x08	; 8
     9c2:	c3 df       	rcall	.-122    	; 0x94a <_Z13enc28j60Writehh>
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	89 e0       	ldi	r24, 0x09	; 9
     9c8:	c0 df       	rcall	.-128    	; 0x94a <_Z13enc28j60Writehh>
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	8c e0       	ldi	r24, 0x0C	; 12
     9ce:	bd df       	rcall	.-134    	; 0x94a <_Z13enc28j60Writehh>
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	8d e0       	ldi	r24, 0x0D	; 13
     9d4:	ba df       	rcall	.-140    	; 0x94a <_Z13enc28j60Writehh>
     9d6:	6e ef       	ldi	r22, 0xFE	; 254
     9d8:	8a e0       	ldi	r24, 0x0A	; 10
     9da:	b7 df       	rcall	.-146    	; 0x94a <_Z13enc28j60Writehh>
     9dc:	69 e1       	ldi	r22, 0x19	; 25
     9de:	8b e0       	ldi	r24, 0x0B	; 11
     9e0:	b4 df       	rcall	.-152    	; 0x94a <_Z13enc28j60Writehh>
     9e2:	6f ef       	ldi	r22, 0xFF	; 255
     9e4:	84 e0       	ldi	r24, 0x04	; 4
     9e6:	b1 df       	rcall	.-158    	; 0x94a <_Z13enc28j60Writehh>
     9e8:	69 e1       	ldi	r22, 0x19	; 25
     9ea:	85 e0       	ldi	r24, 0x05	; 5
     9ec:	ae df       	rcall	.-164    	; 0x94a <_Z13enc28j60Writehh>
     9ee:	6f ef       	ldi	r22, 0xFF	; 255
     9f0:	86 e0       	ldi	r24, 0x06	; 6
     9f2:	ab df       	rcall	.-170    	; 0x94a <_Z13enc28j60Writehh>
     9f4:	6f e1       	ldi	r22, 0x1F	; 31
     9f6:	87 e0       	ldi	r24, 0x07	; 7
     9f8:	a8 df       	rcall	.-176    	; 0x94a <_Z13enc28j60Writehh>
     9fa:	60 eb       	ldi	r22, 0xB0	; 176
     9fc:	88 e3       	ldi	r24, 0x38	; 56
     9fe:	a5 df       	rcall	.-182    	; 0x94a <_Z13enc28j60Writehh>
     a00:	6f e3       	ldi	r22, 0x3F	; 63
     a02:	88 e2       	ldi	r24, 0x28	; 40
     a04:	a2 df       	rcall	.-188    	; 0x94a <_Z13enc28j60Writehh>
     a06:	60 e3       	ldi	r22, 0x30	; 48
     a08:	89 e2       	ldi	r24, 0x29	; 41
     a0a:	9f df       	rcall	.-194    	; 0x94a <_Z13enc28j60Writehh>
     a0c:	69 ef       	ldi	r22, 0xF9	; 249
     a0e:	80 e3       	ldi	r24, 0x30	; 48
     a10:	9c df       	rcall	.-200    	; 0x94a <_Z13enc28j60Writehh>
     a12:	67 ef       	ldi	r22, 0xF7	; 247
     a14:	81 e3       	ldi	r24, 0x31	; 49
     a16:	99 df       	rcall	.-206    	; 0x94a <_Z13enc28j60Writehh>
     a18:	6d e0       	ldi	r22, 0x0D	; 13
     a1a:	80 ec       	ldi	r24, 0xC0	; 192
     a1c:	96 df       	rcall	.-212    	; 0x94a <_Z13enc28j60Writehh>
     a1e:	60 e0       	ldi	r22, 0x00	; 0
     a20:	81 ec       	ldi	r24, 0xC1	; 193
     a22:	93 df       	rcall	.-218    	; 0x94a <_Z13enc28j60Writehh>
     a24:	42 e3       	ldi	r20, 0x32	; 50
     a26:	62 ec       	ldi	r22, 0xC2	; 194
     a28:	80 e8       	ldi	r24, 0x80	; 128
     a2a:	29 df       	rcall	.-430    	; 0x87e <_Z15enc28j60WriteOphhh>
     a2c:	62 e1       	ldi	r22, 0x12	; 18
     a2e:	86 ec       	ldi	r24, 0xC6	; 198
     a30:	8c df       	rcall	.-232    	; 0x94a <_Z13enc28j60Writehh>
     a32:	6c e0       	ldi	r22, 0x0C	; 12
     a34:	87 ec       	ldi	r24, 0xC7	; 199
     a36:	89 df       	rcall	.-238    	; 0x94a <_Z13enc28j60Writehh>
     a38:	62 e1       	ldi	r22, 0x12	; 18
     a3a:	84 ec       	ldi	r24, 0xC4	; 196
     a3c:	86 df       	rcall	.-244    	; 0x94a <_Z13enc28j60Writehh>
     a3e:	6c ed       	ldi	r22, 0xDC	; 220
     a40:	8a ec       	ldi	r24, 0xCA	; 202
     a42:	83 df       	rcall	.-250    	; 0x94a <_Z13enc28j60Writehh>
     a44:	65 e0       	ldi	r22, 0x05	; 5
     a46:	8b ec       	ldi	r24, 0xCB	; 203
     a48:	80 df       	rcall	.-256    	; 0x94a <_Z13enc28j60Writehh>
     a4a:	68 81       	ld	r22, Y
     a4c:	84 ee       	ldi	r24, 0xE4	; 228
     a4e:	7d df       	rcall	.-262    	; 0x94a <_Z13enc28j60Writehh>
     a50:	69 81       	ldd	r22, Y+1	; 0x01
     a52:	85 ee       	ldi	r24, 0xE5	; 229
     a54:	7a df       	rcall	.-268    	; 0x94a <_Z13enc28j60Writehh>
     a56:	6a 81       	ldd	r22, Y+2	; 0x02
     a58:	82 ee       	ldi	r24, 0xE2	; 226
     a5a:	77 df       	rcall	.-274    	; 0x94a <_Z13enc28j60Writehh>
     a5c:	6b 81       	ldd	r22, Y+3	; 0x03
     a5e:	83 ee       	ldi	r24, 0xE3	; 227
     a60:	74 df       	rcall	.-280    	; 0x94a <_Z13enc28j60Writehh>
     a62:	6c 81       	ldd	r22, Y+4	; 0x04
     a64:	80 ee       	ldi	r24, 0xE0	; 224
     a66:	71 df       	rcall	.-286    	; 0x94a <_Z13enc28j60Writehh>
     a68:	6d 81       	ldd	r22, Y+5	; 0x05
     a6a:	81 ee       	ldi	r24, 0xE1	; 225
     a6c:	6e df       	rcall	.-292    	; 0x94a <_Z13enc28j60Writehh>
     a6e:	60 e0       	ldi	r22, 0x00	; 0
     a70:	71 e0       	ldi	r23, 0x01	; 1
     a72:	80 e1       	ldi	r24, 0x10	; 16
     a74:	76 df       	rcall	.-276    	; 0x962 <_Z16enc28j60PhyWritehj>
     a76:	8f e1       	ldi	r24, 0x1F	; 31
     a78:	3b df       	rcall	.-394    	; 0x8f0 <_Z15enc28j60SetBankh>
     a7a:	40 ec       	ldi	r20, 0xC0	; 192
     a7c:	6b e1       	ldi	r22, 0x1B	; 27
     a7e:	80 e8       	ldi	r24, 0x80	; 128
     a80:	fe de       	rcall	.-516    	; 0x87e <_Z15enc28j60WriteOphhh>
     a82:	44 e0       	ldi	r20, 0x04	; 4
     a84:	6f e1       	ldi	r22, 0x1F	; 31
     a86:	80 e8       	ldi	r24, 0x80	; 128
     a88:	fa de       	rcall	.-524    	; 0x87e <_Z15enc28j60WriteOphhh>
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	08 95       	ret

00000a90 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	ec 01       	movw	r28, r24
     a9a:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     a9c:	6f ef       	ldi	r22, 0xFF	; 255
     a9e:	82 e0       	ldi	r24, 0x02	; 2
     aa0:	54 df       	rcall	.-344    	; 0x94a <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     aa2:	69 e1       	ldi	r22, 0x19	; 25
     aa4:	83 e0       	ldi	r24, 0x03	; 3
     aa6:	51 df       	rcall	.-350    	; 0x94a <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     aa8:	6c 2f       	mov	r22, r28
     aaa:	61 50       	subi	r22, 0x01	; 1
     aac:	86 e0       	ldi	r24, 0x06	; 6
     aae:	4d df       	rcall	.-358    	; 0x94a <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     ab0:	ce 01       	movw	r24, r28
     ab2:	81 50       	subi	r24, 0x01	; 1
     ab4:	96 4e       	sbci	r25, 0xE6	; 230
     ab6:	69 2f       	mov	r22, r25
     ab8:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     aba:	47 df       	rcall	.-370    	; 0x94a <_Z13enc28j60Writehh>
     abc:	40 e0       	ldi	r20, 0x00	; 0
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     ac2:	dd de       	rcall	.-582    	; 0x87e <_Z15enc28j60WriteOphhh>
     ac4:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     ac6:	ce 01       	movw	r24, r28
     ac8:	fd de       	rcall	.-518    	; 0x8c4 <_Z19enc28j60WriteBufferjPh>
     aca:	48 e0       	ldi	r20, 0x08	; 8
     acc:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     ace:	80 e8       	ldi	r24, 0x80	; 128
     ad0:	d6 de       	rcall	.-596    	; 0x87e <_Z15enc28j60WriteOphhh>
     ad2:	8c e1       	ldi	r24, 0x1C	; 28
     ad4:	32 df       	rcall	.-412    	; 0x93a <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     ad6:	81 ff       	sbrs	r24, 1
     ad8:	04 c0       	rjmp	.+8      	; 0xae2 <_Z18enc28j60PacketSendjPh+0x52>
     ada:	48 e0       	ldi	r20, 0x08	; 8
     adc:	6f e1       	ldi	r22, 0x1F	; 31
     ade:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     ae0:	ce de       	rcall	.-612    	; 0x87e <_Z15enc28j60WriteOphhh>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	1f 91       	pop	r17
     ae8:	0f 91       	pop	r16
     aea:	08 95       	ret

00000aec <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     aec:	9f 92       	push	r9
     aee:	af 92       	push	r10
     af0:	bf 92       	push	r11
     af2:	cf 92       	push	r12
     af4:	df 92       	push	r13
     af6:	ef 92       	push	r14
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	5c 01       	movw	r10, r24
     b04:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     b06:	89 e3       	ldi	r24, 0x39	; 57
     b08:	18 df       	rcall	.-464    	; 0x93a <_Z12enc28j60Readh>
     b0a:	88 23       	and	r24, r24
     b0c:	09 f4       	brne	.+2      	; 0xb10 <_Z21enc28j60PacketReceivejPh+0x24>
     b0e:	45 c0       	rjmp	.+138    	; 0xb9a <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     b10:	60 91 a6 01 	lds	r22, 0x01A6	; 0x8001a6 <_ZL13NextPacketPtr>
     b14:	c0 91 a7 01 	lds	r28, 0x01A7	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
     b18:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     b1a:	17 df       	rcall	.-466    	; 0x94a <_Z13enc28j60Writehh>
     b1c:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	14 df       	rcall	.-472    	; 0x94a <_Z13enc28j60Writehh>
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b26:	99 de       	rcall	.-718    	; 0x85a <_Z14enc28j60ReadOphh>
     b28:	c8 2f       	mov	r28, r24
     b2a:	60 e0       	ldi	r22, 0x00	; 0
     b2c:	8a e3       	ldi	r24, 0x3A	; 58
     b2e:	95 de       	rcall	.-726    	; 0x85a <_Z14enc28j60ReadOphh>
     b30:	d0 e0       	ldi	r29, 0x00	; 0
     b32:	d8 2b       	or	r29, r24
     b34:	d0 93 a7 01 	sts	0x01A7, r29	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b38:	c0 93 a6 01 	sts	0x01A6, r28	; 0x8001a6 <_ZL13NextPacketPtr>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b3e:	8a e3       	ldi	r24, 0x3A	; 58
     b40:	8c de       	rcall	.-744    	; 0x85a <_Z14enc28j60ReadOphh>
     b42:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b44:	60 e0       	ldi	r22, 0x00	; 0
     b46:	8a e3       	ldi	r24, 0x3A	; 58
     b48:	88 de       	rcall	.-752    	; 0x85a <_Z14enc28j60ReadOphh>
     b4a:	98 2e       	mov	r9, r24
     b4c:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     b4e:	8a e3       	ldi	r24, 0x3A	; 58
     b50:	84 de       	rcall	.-760    	; 0x85a <_Z14enc28j60ReadOphh>
     b52:	c8 2e       	mov	r12, r24
     b54:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     b56:	8a e3       	ldi	r24, 0x3A	; 58
     b58:	80 de       	rcall	.-768    	; 0x85a <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     b5a:	c7 fe       	sbrs	r12, 7
     b5c:	0f c0       	rjmp	.+30     	; 0xb7c <_Z21enc28j60PacketReceivejPh+0x90>
     b5e:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b60:	a8 1a       	sub	r10, r24
     b62:	b1 08       	sbc	r11, r1
     b64:	10 e0       	ldi	r17, 0x00	; 0
     b66:	19 29       	or	r17, r9
     b68:	04 50       	subi	r16, 0x04	; 4
     b6a:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     b6c:	a0 16       	cp	r10, r16
     b6e:	b1 06       	cpc	r11, r17
     b70:	08 f4       	brcc	.+2      	; 0xb74 <_Z21enc28j60PacketReceivejPh+0x88>
     b72:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     b74:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     b76:	c8 01       	movw	r24, r16
     b78:	8d de       	rcall	.-742    	; 0x894 <_Z18enc28j60ReadBufferjPh>
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <_Z21enc28j60PacketReceivejPh+0x94>
     b7c:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     b7e:	10 e0       	ldi	r17, 0x00	; 0
     b80:	6c 2f       	mov	r22, r28
     b82:	8c e0       	ldi	r24, 0x0C	; 12
     b84:	e2 de       	rcall	.-572    	; 0x94a <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     b86:	6d 2f       	mov	r22, r29
     b88:	8d e0       	ldi	r24, 0x0D	; 13
     b8a:	df de       	rcall	.-578    	; 0x94a <_Z13enc28j60Writehh>
     b8c:	40 e4       	ldi	r20, 0x40	; 64
     b8e:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	75 de       	rcall	.-790    	; 0x87e <_Z15enc28j60WriteOphhh>
     b94:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     b96:	91 2f       	mov	r25, r17
     b98:	02 c0       	rjmp	.+4      	; 0xb9e <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     b9a:	80 e0       	ldi	r24, 0x00	; 0
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	df 91       	pop	r29
     ba0:	cf 91       	pop	r28
     ba2:	1f 91       	pop	r17
     ba4:	0f 91       	pop	r16
     ba6:	ff 90       	pop	r15
     ba8:	ef 90       	pop	r14
     baa:	df 90       	pop	r13
     bac:	cf 90       	pop	r12
     bae:	bf 90       	pop	r11
     bb0:	af 90       	pop	r10
     bb2:	9f 90       	pop	r9
     bb4:	08 95       	ret

00000bb6 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     bb6:	cf 92       	push	r12
     bb8:	df 92       	push	r13
     bba:	ef 92       	push	r14
     bbc:	ff 92       	push	r15
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	ec 01       	movw	r28, r24
     bc4:	db 01       	movw	r26, r22
     bc6:	41 30       	cpi	r20, 0x01	; 1
     bc8:	61 f4       	brne	.+24     	; 0xbe2 <_Z8checksumPhjh+0x2c>
     bca:	6b 01       	movw	r12, r22
     bcc:	88 e0       	ldi	r24, 0x08	; 8
     bce:	c8 1a       	sub	r12, r24
     bd0:	d1 08       	sbc	r13, r1
     bd2:	e1 2c       	mov	r14, r1
     bd4:	f1 2c       	mov	r15, r1
     bd6:	81 e1       	ldi	r24, 0x11	; 17
     bd8:	c8 0e       	add	r12, r24
     bda:	d1 1c       	adc	r13, r1
     bdc:	e1 1c       	adc	r14, r1
     bde:	f1 1c       	adc	r15, r1
     be0:	11 c0       	rjmp	.+34     	; 0xc04 <_Z8checksumPhjh+0x4e>
     be2:	42 30       	cpi	r20, 0x02	; 2
     be4:	61 f4       	brne	.+24     	; 0xbfe <_Z8checksumPhjh+0x48>
     be6:	6b 01       	movw	r12, r22
     be8:	88 e0       	ldi	r24, 0x08	; 8
     bea:	c8 1a       	sub	r12, r24
     bec:	d1 08       	sbc	r13, r1
     bee:	e1 2c       	mov	r14, r1
     bf0:	f1 2c       	mov	r15, r1
     bf2:	86 e0       	ldi	r24, 0x06	; 6
     bf4:	c8 0e       	add	r12, r24
     bf6:	d1 1c       	adc	r13, r1
     bf8:	e1 1c       	adc	r14, r1
     bfa:	f1 1c       	adc	r15, r1
     bfc:	03 c0       	rjmp	.+6      	; 0xc04 <_Z8checksumPhjh+0x4e>
     bfe:	c1 2c       	mov	r12, r1
     c00:	d1 2c       	mov	r13, r1
     c02:	76 01       	movw	r14, r12
     c04:	a2 30       	cpi	r26, 0x02	; 2
     c06:	b1 05       	cpc	r27, r1
     c08:	f0 f0       	brcs	.+60     	; 0xc46 <_Z8checksumPhjh+0x90>
     c0a:	9d 01       	movw	r18, r26
     c0c:	fe 01       	movw	r30, r28
     c0e:	40 81       	ld	r20, Z
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	60 e0       	ldi	r22, 0x00	; 0
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	76 2f       	mov	r23, r22
     c18:	65 2f       	mov	r22, r21
     c1a:	54 2f       	mov	r21, r20
     c1c:	44 27       	eor	r20, r20
     c1e:	81 81       	ldd	r24, Z+1	; 0x01
     c20:	48 2b       	or	r20, r24
     c22:	c4 0e       	add	r12, r20
     c24:	d5 1e       	adc	r13, r21
     c26:	e6 1e       	adc	r14, r22
     c28:	f7 1e       	adc	r15, r23
     c2a:	32 96       	adiw	r30, 0x02	; 2
     c2c:	22 50       	subi	r18, 0x02	; 2
     c2e:	31 09       	sbc	r19, r1
     c30:	22 30       	cpi	r18, 0x02	; 2
     c32:	31 05       	cpc	r19, r1
     c34:	60 f7       	brcc	.-40     	; 0xc0e <_Z8checksumPhjh+0x58>
     c36:	cd 01       	movw	r24, r26
     c38:	02 97       	sbiw	r24, 0x02	; 2
     c3a:	8e 7f       	andi	r24, 0xFE	; 254
     c3c:	02 96       	adiw	r24, 0x02	; 2
     c3e:	c8 0f       	add	r28, r24
     c40:	d9 1f       	adc	r29, r25
     c42:	a1 70       	andi	r26, 0x01	; 1
     c44:	bb 27       	eor	r27, r27
     c46:	ab 2b       	or	r26, r27
     c48:	61 f0       	breq	.+24     	; 0xc62 <_Z8checksumPhjh+0xac>
     c4a:	88 81       	ld	r24, Y
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	a0 e0       	ldi	r26, 0x00	; 0
     c50:	b0 e0       	ldi	r27, 0x00	; 0
     c52:	ba 2f       	mov	r27, r26
     c54:	a9 2f       	mov	r26, r25
     c56:	98 2f       	mov	r25, r24
     c58:	88 27       	eor	r24, r24
     c5a:	c8 0e       	add	r12, r24
     c5c:	d9 1e       	adc	r13, r25
     c5e:	ea 1e       	adc	r14, r26
     c60:	fb 1e       	adc	r15, r27
     c62:	a7 01       	movw	r20, r14
     c64:	66 27       	eor	r22, r22
     c66:	77 27       	eor	r23, r23
     c68:	41 15       	cp	r20, r1
     c6a:	51 05       	cpc	r21, r1
     c6c:	61 05       	cpc	r22, r1
     c6e:	71 05       	cpc	r23, r1
     c70:	71 f0       	breq	.+28     	; 0xc8e <_Z8checksumPhjh+0xd8>
     c72:	ee 24       	eor	r14, r14
     c74:	ff 24       	eor	r15, r15
     c76:	c4 0e       	add	r12, r20
     c78:	d5 1e       	adc	r13, r21
     c7a:	e6 1e       	adc	r14, r22
     c7c:	f7 1e       	adc	r15, r23
     c7e:	a7 01       	movw	r20, r14
     c80:	66 27       	eor	r22, r22
     c82:	77 27       	eor	r23, r23
     c84:	41 15       	cp	r20, r1
     c86:	51 05       	cpc	r21, r1
     c88:	61 05       	cpc	r22, r1
     c8a:	71 05       	cpc	r23, r1
     c8c:	91 f7       	brne	.-28     	; 0xc72 <_Z8checksumPhjh+0xbc>
     c8e:	c6 01       	movw	r24, r12
     c90:	80 95       	com	r24
     c92:	90 95       	com	r25
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	ff 90       	pop	r15
     c9a:	ef 90       	pop	r14
     c9c:	df 90       	pop	r13
     c9e:	cf 90       	pop	r12
     ca0:	08 95       	ret

00000ca2 <_Z19init_ip_arp_udp_tcpPhS_h>:
     ca2:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     ca6:	a6 2f       	mov	r26, r22
     ca8:	b7 2f       	mov	r27, r23
     caa:	e9 ea       	ldi	r30, 0xA9	; 169
     cac:	f1 e0       	ldi	r31, 0x01	; 1
     cae:	4d ea       	ldi	r20, 0xAD	; 173
     cb0:	51 e0       	ldi	r21, 0x01	; 1
     cb2:	2d 91       	ld	r18, X+
     cb4:	21 93       	st	Z+, r18
     cb6:	e4 17       	cp	r30, r20
     cb8:	f5 07       	cpc	r31, r21
     cba:	d9 f7       	brne	.-10     	; 0xcb2 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     cbc:	a8 2f       	mov	r26, r24
     cbe:	b9 2f       	mov	r27, r25
     cc0:	ed ea       	ldi	r30, 0xAD	; 173
     cc2:	f1 e0       	ldi	r31, 0x01	; 1
     cc4:	23 eb       	ldi	r18, 0xB3	; 179
     cc6:	31 e0       	ldi	r19, 0x01	; 1
     cc8:	8d 91       	ld	r24, X+
     cca:	81 93       	st	Z+, r24
     ccc:	e2 17       	cp	r30, r18
     cce:	f3 07       	cpc	r31, r19
     cd0:	d9 f7       	brne	.-10     	; 0xcc8 <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     cd2:	08 95       	ret

00000cd4 <_Z25eth_type_is_arp_and_my_ipPhj>:
     cd4:	69 32       	cpi	r22, 0x29	; 41
     cd6:	71 05       	cpc	r23, r1
     cd8:	c8 f0       	brcs	.+50     	; 0xd0c <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     cda:	fc 01       	movw	r30, r24
     cdc:	24 85       	ldd	r18, Z+12	; 0x0c
     cde:	28 30       	cpi	r18, 0x08	; 8
     ce0:	b9 f4       	brne	.+46     	; 0xd10 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     ce2:	25 85       	ldd	r18, Z+13	; 0x0d
     ce4:	26 30       	cpi	r18, 0x06	; 6
     ce6:	b1 f4       	brne	.+44     	; 0xd14 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     ce8:	36 a1       	ldd	r19, Z+38	; 0x26
     cea:	20 91 a9 01 	lds	r18, 0x01A9	; 0x8001a9 <_ZL6ipaddr>
     cee:	32 13       	cpse	r19, r18
     cf0:	13 c0       	rjmp	.+38     	; 0xd18 <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     cf2:	b7 96       	adiw	r30, 0x27	; 39
     cf4:	aa ea       	ldi	r26, 0xAA	; 170
     cf6:	b1 e0       	ldi	r27, 0x01	; 1
     cf8:	8a 96       	adiw	r24, 0x2a	; 42
     cfa:	31 91       	ld	r19, Z+
     cfc:	2d 91       	ld	r18, X+
     cfe:	32 13       	cpse	r19, r18
     d00:	0d c0       	rjmp	.+26     	; 0xd1c <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     d02:	e8 17       	cp	r30, r24
     d04:	f9 07       	cpc	r31, r25
     d06:	c9 f7       	brne	.-14     	; 0xcfa <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	08 95       	ret
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	08 95       	ret
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	08 95       	ret
     d14:	80 e0       	ldi	r24, 0x00	; 0
     d16:	08 95       	ret
     d18:	80 e0       	ldi	r24, 0x00	; 0
     d1a:	08 95       	ret
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	08 95       	ret

00000d20 <_Z24eth_type_is_ip_and_my_ipPhj>:
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	fc 01       	movw	r30, r24
     d26:	6a 32       	cpi	r22, 0x2A	; 42
     d28:	71 05       	cpc	r23, r1
     d2a:	e0 f0       	brcs	.+56     	; 0xd64 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     d2c:	84 85       	ldd	r24, Z+12	; 0x0c
     d2e:	88 30       	cpi	r24, 0x08	; 8
     d30:	d9 f4       	brne	.+54     	; 0xd68 <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     d32:	85 85       	ldd	r24, Z+13	; 0x0d
     d34:	81 11       	cpse	r24, r1
     d36:	1a c0       	rjmp	.+52     	; 0xd6c <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     d38:	96 85       	ldd	r25, Z+14	; 0x0e
     d3a:	95 34       	cpi	r25, 0x45	; 69
     d3c:	c1 f4       	brne	.+48     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d3e:	26 8d       	ldd	r18, Z+30	; 0x1e
     d40:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <_ZL6ipaddr>
     d44:	29 13       	cpse	r18, r25
     d46:	13 c0       	rjmp	.+38     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d48:	df 01       	movw	r26, r30
     d4a:	5f 96       	adiw	r26, 0x1f	; 31
     d4c:	ca ea       	ldi	r28, 0xAA	; 170
     d4e:	d1 e0       	ldi	r29, 0x01	; 1
     d50:	b2 96       	adiw	r30, 0x22	; 34
     d52:	2d 91       	ld	r18, X+
     d54:	99 91       	ld	r25, Y+
     d56:	29 13       	cpse	r18, r25
     d58:	0a c0       	rjmp	.+20     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d5a:	ae 17       	cp	r26, r30
     d5c:	bf 07       	cpc	r27, r31
     d5e:	c9 f7       	brne	.-14     	; 0xd52 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	05 c0       	rjmp	.+10     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	03 c0       	rjmp	.+6      	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d68:	80 e0       	ldi	r24, 0x00	; 0
     d6a:	01 c0       	rjmp	.+2      	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d6c:	80 e0       	ldi	r24, 0x00	; 0
     d6e:	df 91       	pop	r29
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <_Z8make_ethPh>:
     d74:	fc 01       	movw	r30, r24
     d76:	ad ea       	ldi	r26, 0xAD	; 173
     d78:	b1 e0       	ldi	r27, 0x01	; 1
     d7a:	9c 01       	movw	r18, r24
     d7c:	2a 5f       	subi	r18, 0xFA	; 250
     d7e:	3f 4f       	sbci	r19, 0xFF	; 255
     d80:	86 81       	ldd	r24, Z+6	; 0x06
     d82:	81 93       	st	Z+, r24
     d84:	8d 91       	ld	r24, X+
     d86:	85 83       	std	Z+5, r24	; 0x05
     d88:	e2 17       	cp	r30, r18
     d8a:	f3 07       	cpc	r31, r19
     d8c:	c9 f7       	brne	.-14     	; 0xd80 <_Z8make_ethPh+0xc>
     d8e:	08 95       	ret

00000d90 <_Z20fill_ip_hdr_checksumPh>:
     d90:	cf 93       	push	r28
     d92:	df 93       	push	r29
     d94:	ec 01       	movw	r28, r24
     d96:	18 8e       	std	Y+24, r1	; 0x18
     d98:	19 8e       	std	Y+25, r1	; 0x19
     d9a:	80 e4       	ldi	r24, 0x40	; 64
     d9c:	8c 8b       	std	Y+20, r24	; 0x14
     d9e:	1d 8a       	std	Y+21, r1	; 0x15
     da0:	8e 8b       	std	Y+22, r24	; 0x16
     da2:	40 e0       	ldi	r20, 0x00	; 0
     da4:	64 e1       	ldi	r22, 0x14	; 20
     da6:	70 e0       	ldi	r23, 0x00	; 0
     da8:	ce 01       	movw	r24, r28
     daa:	0e 96       	adiw	r24, 0x0e	; 14
     dac:	04 df       	rcall	.-504    	; 0xbb6 <_Z8checksumPhjh>
     dae:	98 8f       	std	Y+24, r25	; 0x18
     db0:	89 8f       	std	Y+25, r24	; 0x19
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	08 95       	ret

00000db8 <_Z7make_ipPh>:
     db8:	ac 01       	movw	r20, r24
     dba:	a9 ea       	ldi	r26, 0xA9	; 169
     dbc:	b1 e0       	ldi	r27, 0x01	; 1
     dbe:	fc 01       	movw	r30, r24
     dc0:	7a 96       	adiw	r30, 0x1a	; 26
     dc2:	2d ea       	ldi	r18, 0xAD	; 173
     dc4:	31 e0       	ldi	r19, 0x01	; 1
     dc6:	90 81       	ld	r25, Z
     dc8:	94 83       	std	Z+4, r25	; 0x04
     dca:	9d 91       	ld	r25, X+
     dcc:	91 93       	st	Z+, r25
     dce:	a2 17       	cp	r26, r18
     dd0:	b3 07       	cpc	r27, r19
     dd2:	c9 f7       	brne	.-14     	; 0xdc6 <_Z7make_ipPh+0xe>
     dd4:	ca 01       	movw	r24, r20
     dd6:	dc cf       	rjmp	.-72     	; 0xd90 <_Z20fill_ip_hdr_checksumPh>
     dd8:	08 95       	ret

00000dda <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
     dde:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
     de0:	c9 df       	rcall	.-110    	; 0xd74 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
     de2:	1c 8a       	std	Y+20, r1	; 0x14
     de4:	82 e0       	ldi	r24, 0x02	; 2
     de6:	8d 8b       	std	Y+21, r24	; 0x15
     de8:	ad ea       	ldi	r26, 0xAD	; 173
     dea:	b1 e0       	ldi	r27, 0x01	; 1
     dec:	fe 01       	movw	r30, r28
     dee:	76 96       	adiw	r30, 0x16	; 22
     df0:	23 eb       	ldi	r18, 0xB3	; 179
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
     df2:	31 e0       	ldi	r19, 0x01	; 1
     df4:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
     df6:	82 87       	std	Z+10, r24	; 0x0a
     df8:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
     dfa:	81 93       	st	Z+, r24
     dfc:	a2 17       	cp	r26, r18
     dfe:	b3 07       	cpc	r27, r19
     e00:	c9 f7       	brne	.-14     	; 0xdf4 <_Z28make_arp_answer_from_requestPh+0x1a>
     e02:	a9 ea       	ldi	r26, 0xA9	; 169
     e04:	b1 e0       	ldi	r27, 0x01	; 1
     e06:	fe 01       	movw	r30, r28
     e08:	7c 96       	adiw	r30, 0x1c	; 28
     e0a:	2d ea       	ldi	r18, 0xAD	; 173
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
     e0c:	31 e0       	ldi	r19, 0x01	; 1
     e0e:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
     e10:	82 87       	std	Z+10, r24	; 0x0a
     e12:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
     e14:	81 93       	st	Z+, r24
     e16:	a2 17       	cp	r26, r18
     e18:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
     e1a:	c9 f7       	brne	.-14     	; 0xe0e <_Z28make_arp_answer_from_requestPh+0x34>
     e1c:	be 01       	movw	r22, r28
     e1e:	8a e2       	ldi	r24, 0x2A	; 42
     e20:	90 e0       	ldi	r25, 0x00	; 0
}
     e22:	36 de       	rcall	.-916    	; 0xa90 <_Z18enc28j60PacketSendjPh>
     e24:	df 91       	pop	r29
     e26:	cf 91       	pop	r28
     e28:	08 95       	ret

00000e2a <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
     e30:	df 93       	push	r29
     e32:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
     e34:	8b 01       	movw	r16, r22
     e36:	9e df       	rcall	.-196    	; 0xd74 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
     e38:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
     e3a:	be df       	rcall	.-132    	; 0xdb8 <_Z7make_ipPh>
     e3c:	1a a2       	std	Y+34, r1	; 0x22
     e3e:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
     e40:	88 3f       	cpi	r24, 0xF8	; 248
     e42:	18 f0       	brcs	.+6      	; 0xe4a <_Z28make_echo_reply_from_requestPhj+0x20>
     e44:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
     e46:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
     e48:	9d a3       	std	Y+37, r25	; 0x25
     e4a:	88 5f       	subi	r24, 0xF8	; 248
     e4c:	8c a3       	std	Y+36, r24	; 0x24
}
     e4e:	be 01       	movw	r22, r28
     e50:	c8 01       	movw	r24, r16
     e52:	1e de       	rcall	.-964    	; 0xa90 <_Z18enc28j60PacketSendjPh>
     e54:	df 91       	pop	r29
     e56:	cf 91       	pop	r28
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	08 95       	ret

00000e5e <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
     e5e:	df 92       	push	r13
     e60:	ef 92       	push	r14
     e62:	ff 92       	push	r15
     e64:	0f 93       	push	r16
     e66:	1f 93       	push	r17
     e68:	cf 93       	push	r28
     e6a:	df 93       	push	r29
     e6c:	ec 01       	movw	r28, r24
     e6e:	d6 2e       	mov	r13, r22
     e70:	e7 2e       	mov	r14, r23
     e72:	04 2f       	mov	r16, r20
     e74:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
     e76:	f3 2e       	mov	r15, r19
     e78:	7d df       	rcall	.-262    	; 0xd74 <_Z8make_ethPh>
     e7a:	0d 3d       	cpi	r16, 0xDD	; 221
     e7c:	08 f0       	brcs	.+2      	; 0xe80 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
     e7e:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
     e80:	18 8a       	std	Y+16, r1	; 0x10
     e82:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
     e84:	80 0f       	add	r24, r16
     e86:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
     e88:	ce 01       	movw	r24, r28
     e8a:	96 df       	rcall	.-212    	; 0xdb8 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
     e8c:	8a a1       	ldd	r24, Y+34	; 0x22
     e8e:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
     e90:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
     e92:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
     e94:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
     e96:	1b a3       	std	Y+35, r17	; 0x23
     e98:	1e a2       	std	Y+38, r1	; 0x26
     e9a:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
     e9c:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
     e9e:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
     ea0:	18 a6       	std	Y+40, r1	; 0x28
     ea2:	19 a6       	std	Y+41, r1	; 0x29
     ea4:	00 23       	and	r16, r16
     ea6:	81 f0       	breq	.+32     	; 0xec8 <_Z27make_udp_reply_from_requestPhPchj+0x6a>
     ea8:	ad 2d       	mov	r26, r13
     eaa:	be 2d       	mov	r27, r14
     eac:	fe 01       	movw	r30, r28
     eae:	ba 96       	adiw	r30, 0x2a	; 42
     eb0:	2f ef       	ldi	r18, 0xFF	; 255
     eb2:	20 0f       	add	r18, r16
     eb4:	30 e0       	ldi	r19, 0x00	; 0
     eb6:	25 5d       	subi	r18, 0xD5	; 213
     eb8:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
     eba:	2c 0f       	add	r18, r28
     ebc:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
     ebe:	9d 91       	ld	r25, X+
     ec0:	91 93       	st	Z+, r25
     ec2:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
     ec4:	f3 07       	cpc	r31, r19
     ec6:	d9 f7       	brne	.-10     	; 0xebe <_Z27make_udp_reply_from_requestPhPchj+0x60>
     ec8:	10 e0       	ldi	r17, 0x00	; 0
     eca:	b8 01       	movw	r22, r16
     ecc:	60 5f       	subi	r22, 0xF0	; 240
     ece:	7f 4f       	sbci	r23, 0xFF	; 255
     ed0:	41 e0       	ldi	r20, 0x01	; 1
     ed2:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
     ed4:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
     ed6:	6f de       	rcall	.-802    	; 0xbb6 <_Z8checksumPhjh>
     ed8:	98 a7       	std	Y+40, r25	; 0x28
     eda:	89 a7       	std	Y+41, r24	; 0x29
     edc:	be 01       	movw	r22, r28
}
     ede:	c8 01       	movw	r24, r16
     ee0:	8a 96       	adiw	r24, 0x2a	; 42
     ee2:	d6 dd       	rcall	.-1108   	; 0xa90 <_Z18enc28j60PacketSendjPh>
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	1f 91       	pop	r17
     eea:	0f 91       	pop	r16
     eec:	ff 90       	pop	r15
     eee:	ef 90       	pop	r14
     ef0:	df 90       	pop	r13
     ef2:	08 95       	ret

00000ef4 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
     ef4:	87 b3       	in	r24, 0x17	; 23
     ef6:	86 60       	ori	r24, 0x06	; 6
     ef8:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
     efa:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
     efc:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
     efe:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
     f00:	80 e5       	ldi	r24, 0x50	; 80
     f02:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
     f04:	70 9a       	sbi	0x0e, 0	; 14
     f06:	08 95       	ret

00000f08 <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f08:	00 97       	sbiw	r24, 0x00	; 0
     f0a:	41 f0       	breq	.+16     	; 0xf1c <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f0c:	ef eb       	ldi	r30, 0xBF	; 191
     f0e:	f0 e0       	ldi	r31, 0x00	; 0
     f10:	31 97       	sbiw	r30, 0x01	; 1
     f12:	f1 f7       	brne	.-4      	; 0xf10 <_Z8delay_msj+0x8>
     f14:	00 c0       	rjmp	.+0      	; 0xf16 <_Z8delay_msj+0xe>
     f16:	00 00       	nop
                _delay_ms(0.96);
                ms--;
     f18:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f1a:	c1 f7       	brne	.-16     	; 0xf0c <_Z8delay_msj+0x4>
     f1c:	08 95       	ret

00000f1e <_Z9Timer_ISR8Dev_typej>:
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
     f1e:	e4 ec       	ldi	r30, 0xC4	; 196
     f20:	f3 e0       	ldi	r31, 0x03	; 3
     f22:	84 85       	ldd	r24, Z+12	; 0x0c
     f24:	95 85       	ldd	r25, Z+13	; 0x0d
     f26:	01 96       	adiw	r24, 0x01	; 1
     f28:	95 87       	std	Z+13, r25	; 0x0d
     f2a:	84 87       	std	Z+12, r24	; 0x0c
     f2c:	08 95       	ret

00000f2e <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
     f2e:	cf 93       	push	r28
     f30:	df 93       	push	r29
     f32:	cd b7       	in	r28, 0x3d	; 61
     f34:	de b7       	in	r29, 0x3e	; 62
     f36:	6d 97       	sbiw	r28, 0x1d	; 29
     f38:	0f b6       	in	r0, 0x3f	; 63
     f3a:	f8 94       	cli
     f3c:	de bf       	out	0x3e, r29	; 62
     f3e:	0f be       	out	0x3f, r0	; 63
     f40:	cd bf       	out	0x3d, r28	; 61
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {192,168,0,108};
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
     f42:	8f ef       	ldi	r24, 0xFF	; 255
     f44:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
     f46:	88 bb       	out	0x18, r24	; 24
    char str[30];
	 enc28j60Init(mymac);
     f48:	85 e0       	ldi	r24, 0x05	; 5
     f4a:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
     f4c:	27 dd       	rcall	.-1458   	; 0x99c <_Z12enc28j60InitPh>
     f4e:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
     f50:	20 dd       	rcall	.-1472   	; 0x992 <_Z14enc28j60clkouth>
     f52:	8a e0       	ldi	r24, 0x0A	; 10
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
     f5a:	66 e7       	ldi	r22, 0x76	; 118
     f5c:	74 e0       	ldi	r23, 0x04	; 4
     f5e:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
     f60:	00 dd       	rcall	.-1536   	; 0x962 <_Z16enc28j60PhyWritehj>
     f62:	84 e1       	ldi	r24, 0x14	; 20
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	0e 94 71 12 	call	0x24e2	; 0x24e2 <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
     f6a:	40 e5       	ldi	r20, 0x50	; 80
     f6c:	61 e0       	ldi	r22, 0x01	; 1
     f6e:	71 e0       	ldi	r23, 0x01	; 1
     f70:	85 e0       	ldi	r24, 0x05	; 5
     f72:	91 e0       	ldi	r25, 0x01	; 1
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 PORTB = ~PORTB;
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
     f74:	96 de       	rcall	.-724    	; 0xca2 <_Z19init_ip_arp_udp_tcpPhS_h>
     f76:	03 eb       	ldi	r16, 0xB3	; 179
     f78:	11 e0       	ldi	r17, 0x01	; 1
     f7a:	0f 2e       	mov	r0, r31
     f7c:	f4 ec       	ldi	r31, 0xC4	; 196
     f7e:	ef 2e       	mov	r14, r31
     f80:	f3 e0       	ldi	r31, 0x03	; 3
     f82:	ff 2e       	mov	r15, r31
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
     f84:	f0 2d       	mov	r31, r0
     f86:	0f 2e       	mov	r0, r31
     f88:	fd e1       	ldi	r31, 0x1D	; 29
     f8a:	9f 2e       	mov	r9, r31
     f8c:	f0 2d       	mov	r31, r0
     f8e:	ce 01       	movw	r24, r28
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
     f90:	01 96       	adiw	r24, 0x01	; 1
     f92:	5c 01       	movw	r10, r24
     f94:	63 ec       	ldi	r22, 0xC3	; 195
     f96:	71 e0       	ldi	r23, 0x01	; 1
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	92 e0       	ldi	r25, 0x02	; 2
		 if(plen==0)
     f9c:	a7 dd       	rcall	.-1202   	; 0xaec <_Z21enc28j60PacketReceivejPh>
     f9e:	6c 01       	movw	r12, r24
		 {
				goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
     fa0:	00 97       	sbiw	r24, 0x00	; 0
     fa2:	09 f4       	brne	.+2      	; 0xfa6 <_ZL5proc2Pv+0x78>
     fa4:	5e c0       	rjmp	.+188    	; 0x1062 <_ZL5proc2Pv+0x134>
     fa6:	bc 01       	movw	r22, r24
     fa8:	83 ec       	ldi	r24, 0xC3	; 195
     faa:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
     fac:	93 de       	rcall	.-730    	; 0xcd4 <_Z25eth_type_is_arp_and_my_ipPhj>
     fae:	88 23       	and	r24, r24
     fb0:	21 f0       	breq	.+8      	; 0xfba <_ZL5proc2Pv+0x8c>
			 continue;
     fb2:	83 ec       	ldi	r24, 0xC3	; 195
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
     fb4:	91 e0       	ldi	r25, 0x01	; 1
     fb6:	11 df       	rcall	.-478    	; 0xdda <_Z28make_arp_answer_from_requestPh>
     fb8:	ed cf       	rjmp	.-38     	; 0xf94 <_ZL5proc2Pv+0x66>
     fba:	b6 01       	movw	r22, r12
     fbc:	83 ec       	ldi	r24, 0xC3	; 195
     fbe:	91 e0       	ldi	r25, 0x01	; 1
     fc0:	af de       	rcall	.-674    	; 0xd20 <_Z24eth_type_is_ip_and_my_ipPhj>
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
     fc2:	88 23       	and	r24, r24
     fc4:	39 f3       	breq	.-50     	; 0xf94 <_ZL5proc2Pv+0x66>
     fc6:	80 91 da 01 	lds	r24, 0x01DA	; 0x8001da <_ZZL5proc2PvE3buf+0x17>
     fca:	81 30       	cpi	r24, 0x01	; 1
     fcc:	49 f4       	brne	.+18     	; 0xfe0 <_ZL5proc2Pv+0xb2>
     fce:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <_ZZL5proc2PvE3buf+0x22>
		 {
			make_echo_reply_from_request(buf,plen);
     fd2:	88 30       	cpi	r24, 0x08	; 8
     fd4:	29 f4       	brne	.+10     	; 0xfe0 <_ZL5proc2Pv+0xb2>
     fd6:	b6 01       	movw	r22, r12
     fd8:	83 ec       	ldi	r24, 0xC3	; 195
			continue;
     fda:	91 e0       	ldi	r25, 0x01	; 1
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
     fdc:	26 df       	rcall	.-436    	; 0xe2a <_Z28make_echo_reply_from_requestPhj>
     fde:	da cf       	rjmp	.-76     	; 0xf94 <_ZL5proc2Pv+0x66>
     fe0:	80 91 ed 01 	lds	r24, 0x01ED	; 0x8001ed <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
     fe4:	81 33       	cpi	r24, 0x31	; 49
     fe6:	e9 f5       	brne	.+122    	; 0x1062 <_ZL5proc2Pv+0x134>
     fe8:	f5 01       	movw	r30, r10
     fea:	89 2d       	mov	r24, r9
     fec:	11 92       	st	Z+, r1
			 char loop = buf[UDP_DATA_P + 1];
     fee:	8a 95       	dec	r24
     ff0:	e9 f7       	brne	.-6      	; 0xfec <_ZL5proc2Pv+0xbe>
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
     ff2:	40 91 ee 01 	lds	r20, 0x01EE	; 0x8001ee <_ZZL5proc2PvE3buf+0x2b>
     ff6:	40 53       	subi	r20, 0x30	; 48
     ff8:	50 e0       	ldi	r21, 0x00	; 0
     ffa:	4f 5f       	subi	r20, 0xFF	; 255
     ffc:	5f 4f       	sbci	r21, 0xFF	; 255
     ffe:	42 30       	cpi	r20, 0x02	; 2
    1000:	51 05       	cpc	r21, r1
    1002:	0c f0       	brlt	.+2      	; 0x1006 <_ZL5proc2Pv+0xd8>
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    1004:	69 c0       	rjmp	.+210    	; 0x10d8 <_ZL5proc2Pv+0x1aa>
    1006:	22 c0       	rjmp	.+68     	; 0x104c <_ZL5proc2Pv+0x11e>
    1008:	fc 01       	movw	r30, r24
    100a:	ed 53       	subi	r30, 0x3D	; 61
    100c:	fe 4f       	sbci	r31, 0xFE	; 254
    100e:	33 a5       	ldd	r19, Z+43	; 0x2b
    1010:	fe 01       	movw	r30, r28
    1012:	e8 0f       	add	r30, r24
				 if(i % 2 == 0)
    1014:	f9 1f       	adc	r31, r25
    1016:	30 83       	st	Z, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    1018:	20 fd       	sbrc	r18, 0
    101a:	12 c0       	rjmp	.+36     	; 0x1040 <_ZL5proc2Pv+0x112>
    101c:	e6 2f       	mov	r30, r22
    101e:	f0 e0       	ldi	r31, 0x00	; 0
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	e8 52       	subi	r30, 0x28	; 40
    1026:	fc 4f       	sbci	r31, 0xFC	; 252
    1028:	af ef       	ldi	r26, 0xFF	; 255
    102a:	bf ef       	ldi	r27, 0xFF	; 255
    102c:	ac 0f       	add	r26, r28
    102e:	bd 1f       	adc	r27, r29
    1030:	a8 0f       	add	r26, r24
    1032:	b9 1f       	adc	r27, r25
    1034:	8c 91       	ld	r24, X
    1036:	90 e0       	ldi	r25, 0x00	; 0
    1038:	93 2b       	or	r25, r19
					num++;
    103a:	91 83       	std	Z+1, r25	; 0x01
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    103c:	80 83       	st	Z, r24
    103e:	6f 5f       	subi	r22, 0xFF	; 255
    1040:	2f 5f       	subi	r18, 0xFF	; 255
    1042:	82 2f       	mov	r24, r18
    1044:	90 e0       	ldi	r25, 0x00	; 0
    1046:	84 17       	cp	r24, r20
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    1048:	95 07       	cpc	r25, r21
    104a:	f4 f2       	brlt	.-68     	; 0x1008 <_ZL5proc2Pv+0xda>
    104c:	f7 01       	movw	r30, r14
    104e:	80 a9       	ldd	r24, Z+48	; 0x30
    1050:	91 a9       	ldd	r25, Z+49	; 0x31
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1052:	91 8b       	std	Z+17, r25	; 0x11
    1054:	80 8b       	std	Z+16, r24	; 0x10
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    1056:	95 af       	std	Z+61, r25	; 0x3d
    1058:	84 af       	std	Z+60, r24	; 0x3c
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    105a:	91 af       	std	Z+57, r25	; 0x39
    105c:	80 af       	std	Z+56, r24	; 0x38
			//mem4[TEST] =  mem4[UDP_DATA14];//(( 0xffff & temp[UDP_DATA14] << 8)) | (0xffff & temp[UDP_DATA15]);
			//mem4[TEST] = mem4[TEST] - '0';
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 PORTB = ~PORTB;
    105e:	97 ab       	std	Z+55, r25	; 0x37
    1060:	86 ab       	std	Z+54, r24	; 0x36
    1062:	88 b3       	in	r24, 0x18	; 24
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    1064:	80 95       	com	r24
    1066:	88 bb       	out	0x18, r24	; 24
    1068:	f7 01       	movw	r30, r14
    106a:	82 81       	ldd	r24, Z+2	; 0x02
    106c:	93 81       	ldd	r25, Z+3	; 0x03
    106e:	f8 01       	movw	r30, r16
			 data[1] = mem4[COUNT];
    1070:	91 83       	std	Z+1, r25	; 0x01
    1072:	80 83       	st	Z, r24
    1074:	f7 01       	movw	r30, r14
    1076:	86 81       	ldd	r24, Z+6	; 0x06
    1078:	97 81       	ldd	r25, Z+7	; 0x07
    107a:	f8 01       	movw	r30, r16
			 data[2] = mem4[PRESSURE];
    107c:	93 83       	std	Z+3, r25	; 0x03
    107e:	82 83       	std	Z+2, r24	; 0x02
    1080:	f7 01       	movw	r30, r14
    1082:	84 81       	ldd	r24, Z+4	; 0x04
    1084:	95 81       	ldd	r25, Z+5	; 0x05
    1086:	f8 01       	movw	r30, r16
			 data[3] = mem4[GOAL_CNT];
    1088:	95 83       	std	Z+5, r25	; 0x05
    108a:	84 83       	std	Z+4, r24	; 0x04
    108c:	f7 01       	movw	r30, r14
    108e:	80 89       	ldd	r24, Z+16	; 0x10
    1090:	91 89       	ldd	r25, Z+17	; 0x11
    1092:	f8 01       	movw	r30, r16
			 data[4] = mem4[MACHINE_STATES];
    1094:	97 83       	std	Z+7, r25	; 0x07
    1096:	86 83       	std	Z+6, r24	; 0x06
    1098:	f7 01       	movw	r30, r14
    109a:	82 89       	ldd	r24, Z+18	; 0x12
    109c:	93 89       	ldd	r25, Z+19	; 0x13
    109e:	f8 01       	movw	r30, r16
			 data[5] = mem4[SEC];
    10a0:	91 87       	std	Z+9, r25	; 0x09
    10a2:	80 87       	std	Z+8, r24	; 0x08
    10a4:	f7 01       	movw	r30, r14
    10a6:	84 85       	ldd	r24, Z+12	; 0x0c
    10a8:	95 85       	ldd	r25, Z+13	; 0x0d
    10aa:	f8 01       	movw	r30, r16
			 data[6] = mem4[MIN];
    10ac:	93 87       	std	Z+11, r25	; 0x0b
    10ae:	82 87       	std	Z+10, r24	; 0x0a
    10b0:	f7 01       	movw	r30, r14
    10b2:	82 85       	ldd	r24, Z+10	; 0x0a
    10b4:	93 85       	ldd	r25, Z+11	; 0x0b
    10b6:	f8 01       	movw	r30, r16
			 data[7] = mem4[HOUR];
    10b8:	95 87       	std	Z+13, r25	; 0x0d
    10ba:	84 87       	std	Z+12, r24	; 0x0c
    10bc:	f7 01       	movw	r30, r14
    10be:	80 85       	ldd	r24, Z+8	; 0x08
    10c0:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    10c2:	f8 01       	movw	r30, r16
    10c4:	97 87       	std	Z+15, r25	; 0x0f
    10c6:	86 87       	std	Z+14, r24	; 0x0e
    10c8:	2f e0       	ldi	r18, 0x0F	; 15
    10ca:	37 e2       	ldi	r19, 0x27	; 39
    10cc:	40 e1       	ldi	r20, 0x10	; 16
    10ce:	b8 01       	movw	r22, r16
    10d0:	83 ec       	ldi	r24, 0xC3	; 195
    10d2:	91 e0       	ldi	r25, 0x01	; 1
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    10d4:	c4 de       	rcall	.-632    	; 0xe5e <_Z27make_udp_reply_from_requestPhPchj>
    10d6:	5e cf       	rjmp	.-324    	; 0xf94 <_ZL5proc2Pv+0x66>
    10d8:	80 91 ef 01 	lds	r24, 0x01EF	; 0x8001ef <_ZZL5proc2PvE3buf+0x2c>
    10dc:	89 83       	std	Y+1, r24	; 0x01
    10de:	21 e0       	ldi	r18, 0x01	; 1
    10e0:	60 e0       	ldi	r22, 0x00	; 0
    10e2:	ae cf       	rjmp	.-164    	; 0x1040 <_ZL5proc2Pv+0x112>

000010e4 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    10e4:	cf 93       	push	r28
    10e6:	df 93       	push	r29
    10e8:	cd b7       	in	r28, 0x3d	; 61
    10ea:	de b7       	in	r29, 0x3e	; 62
    10ec:	2f 97       	sbiw	r28, 0x0f	; 15
    10ee:	0f b6       	in	r0, 0x3f	; 63
    10f0:	f8 94       	cli
    10f2:	de bf       	out	0x3e, r29	; 62
    10f4:	0f be       	out	0x3f, r0	; 63
    10f6:	cd bf       	out	0x3d, r28	; 61
    10f8:	7c 01       	movw	r14, r24
	//UART1 
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
    10fa:	fe 01       	movw	r30, r28
    10fc:	31 96       	adiw	r30, 0x01	; 1
    10fe:	8f e0       	ldi	r24, 0x0F	; 15
    1100:	df 01       	movw	r26, r30
    1102:	1d 92       	st	X+, r1
    1104:	8a 95       	dec	r24
    1106:	e9 f7       	brne	.-6      	; 0x1102 <__stack+0x3>
    1108:	6e 01       	movw	r12, r28
    110a:	b0 e1       	ldi	r27, 0x10	; 16
    110c:	cb 0e       	add	r12, r27
    110e:	d1 1c       	adc	r13, r1
			}
			else
			{
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    1110:	0f 2e       	mov	r0, r31
    1112:	fa e9       	ldi	r31, 0x9A	; 154
    1114:	8f 2e       	mov	r8, r31
    1116:	91 2c       	mov	r9, r1
    1118:	f0 2d       	mov	r31, r0
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
    111a:	0f 2e       	mov	r0, r31
    111c:	f4 ec       	ldi	r31, 0xC4	; 196
    111e:	af 2e       	mov	r10, r31
    1120:	f3 e0       	ldi	r31, 0x03	; 3
    1122:	bf 2e       	mov	r11, r31
    1124:	f0 2d       	mov	r31, r0
				mem4[COUNT] = count_number;
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1126:	0f 2e       	mov	r0, r31
    1128:	f3 e0       	ldi	r31, 0x03	; 3
    112a:	6f 2e       	mov	r6, r31
    112c:	71 2c       	mov	r7, r1
    112e:	f0 2d       	mov	r31, r0
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
		if(sb->SerialAvailable() >= 15)
    1130:	c7 01       	movw	r24, r14
    1132:	37 d9       	rcall	.-3474   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1134:	8f 30       	cpi	r24, 0x0F	; 15
    1136:	e0 f3       	brcs	.-8      	; 0x1130 <__stack+0x31>
    1138:	8e 01       	movw	r16, r28
    113a:	0f 5f       	subi	r16, 0xFF	; 255
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    113c:	1f 4f       	sbci	r17, 0xFF	; 255
    113e:	c7 01       	movw	r24, r14
    1140:	04 d9       	rcall	.-3576   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1142:	f8 01       	movw	r30, r16
    1144:	81 93       	st	Z+, r24
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1146:	8f 01       	movw	r16, r30
    1148:	ec 15       	cp	r30, r12
    114a:	fd 05       	cpc	r31, r13
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    114c:	c1 f7       	brne	.-16     	; 0x113e <__stack+0x3f>
    114e:	89 81       	ldd	r24, Y+1	; 0x01
    1150:	82 30       	cpi	r24, 0x02	; 2
    1152:	09 f0       	breq	.+2      	; 0x1156 <__stack+0x57>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1154:	3f c0       	rjmp	.+126    	; 0x11d4 <__stack+0xd5>
    1156:	88 85       	ldd	r24, Y+8	; 0x08
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	98 2f       	mov	r25, r24
    115c:	88 27       	eor	r24, r24
    115e:	29 85       	ldd	r18, Y+9	; 0x09
    1160:	82 2b       	or	r24, r18
    1162:	90 93 0b 04 	sts	0x040B, r25	; 0x80040b <count_number+0x1>
    1166:	80 93 0a 04 	sts	0x040A, r24	; 0x80040a <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    116a:	4a 85       	ldd	r20, Y+10	; 0x0a
    116c:	50 e0       	ldi	r21, 0x00	; 0
    116e:	54 2f       	mov	r21, r20
    1170:	44 27       	eor	r20, r20
    1172:	2b 85       	ldd	r18, Y+11	; 0x0b
    1174:	42 2b       	or	r20, r18
    1176:	50 93 09 04 	sts	0x0409, r21	; 0x800409 <current_temp+0x1>
    117a:	40 93 08 04 	sts	0x0408, r20	; 0x800408 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    117e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1180:	30 e0       	ldi	r19, 0x00	; 0
    1182:	32 2f       	mov	r19, r18
    1184:	22 27       	eor	r18, r18
    1186:	6d 85       	ldd	r22, Y+13	; 0x0d
    1188:	26 2b       	or	r18, r22
    118a:	30 93 07 04 	sts	0x0407, r19	; 0x800407 <current_pressure+0x1>
    118e:	20 93 06 04 	sts	0x0406, r18	; 0x800406 <current_pressure>
				mem4[TEMP] = current_temp;
    1192:	d5 01       	movw	r26, r10
    1194:	13 96       	adiw	r26, 0x03	; 3
    1196:	5c 93       	st	X, r21
    1198:	4e 93       	st	-X, r20
				mem4[COUNT] = count_number;
    119a:	12 97       	sbiw	r26, 0x02	; 2
    119c:	17 96       	adiw	r26, 0x07	; 7
    119e:	9c 93       	st	X, r25
    11a0:	8e 93       	st	-X, r24
				mem4[PRESSURE] = current_pressure;
    11a2:	16 97       	sbiw	r26, 0x06	; 6
    11a4:	15 96       	adiw	r26, 0x05	; 5
    11a6:	3c 93       	st	X, r19
    11a8:	2e 93       	st	-X, r18
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    11aa:	14 97       	sbiw	r26, 0x04	; 4
    11ac:	50 96       	adiw	r26, 0x10	; 16
    11ae:	2d 91       	ld	r18, X+
    11b0:	3c 91       	ld	r19, X
    11b2:	51 97       	sbiw	r26, 0x11	; 17
    11b4:	82 17       	cp	r24, r18
    11b6:	93 07       	cpc	r25, r19
    11b8:	09 f0       	breq	.+2      	; 0x11bc <__stack+0xbd>
    11ba:	ba cf       	rjmp	.-140    	; 0x1130 <__stack+0x31>
    11bc:	52 96       	adiw	r26, 0x12	; 18
    11be:	8d 91       	ld	r24, X+
    11c0:	9c 91       	ld	r25, X
    11c2:	53 97       	sbiw	r26, 0x13	; 19
    11c4:	89 2b       	or	r24, r25
    11c6:	09 f0       	breq	.+2      	; 0x11ca <__stack+0xcb>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    11c8:	b3 cf       	rjmp	.-154    	; 0x1130 <__stack+0x31>
    11ca:	53 96       	adiw	r26, 0x13	; 19
    11cc:	7c 92       	st	X, r7
    11ce:	6e 92       	st	-X, r6
    11d0:	52 97       	sbiw	r26, 0x12	; 18
				}
			}
			else
			{
				GetExceptionCode(&exception,0x01,0x06);
    11d2:	ae cf       	rjmp	.-164    	; 0x1130 <__stack+0x31>
    11d4:	46 e0       	ldi	r20, 0x06	; 6
    11d6:	61 e0       	ldi	r22, 0x01	; 1
    11d8:	84 e1       	ldi	r24, 0x14	; 20
    11da:	94 e0       	ldi	r25, 0x04	; 4
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    11dc:	1d d8       	rcall	.-4038   	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
    11de:	45 e0       	ldi	r20, 0x05	; 5
    11e0:	50 e0       	ldi	r21, 0x00	; 0
    11e2:	64 e1       	ldi	r22, 0x14	; 20
    11e4:	74 e0       	ldi	r23, 0x04	; 4
    11e6:	c7 01       	movw	r24, r14
				cbi(UCSR1B,RXCIE0);
    11e8:	74 d8       	rcall	.-3864   	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    11ea:	f4 01       	movw	r30, r8
    11ec:	80 81       	ld	r24, Z
				sb->SerialFlush();
    11ee:	8f 77       	andi	r24, 0x7F	; 127
    11f0:	80 83       	st	Z, r24
    11f2:	c7 01       	movw	r24, r14
				sbi(UCSR1B,RXCIE0);
    11f4:	e1 d8       	rcall	.-3646   	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
    11f6:	d4 01       	movw	r26, r8
    11f8:	8c 91       	ld	r24, X
    11fa:	80 68       	ori	r24, 0x80	; 128
    11fc:	8c 93       	st	X, r24
    11fe:	98 cf       	rjmp	.-208    	; 0x1130 <__stack+0x31>

00001200 <_ZL4procPv>:
	#if USE_SYSTEM_SEC
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	cd b7       	in	r28, 0x3d	; 61
    1206:	de b7       	in	r29, 0x3e	; 62
    1208:	2a 97       	sbiw	r28, 0x0a	; 10
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	cd bf       	out	0x3d, r28	; 61
    1214:	6c 01       	movw	r12, r24
	char read_Flag = 0;
	char function_code;
	char buf1[10];
	DDRG = 0xff;
    1216:	8f ef       	ldi	r24, 0xFF	; 255
    1218:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
	char read_Flag = 0;
    121c:	b1 2c       	mov	r11, r1
	DDRG = 0xff;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
		
	while(1)
	{
		if(mem4[SEC] >= 60)
    121e:	04 ec       	ldi	r16, 0xC4	; 196
    1220:	13 e0       	ldi	r17, 0x03	; 3
    1222:	2e 01       	movw	r4, r28
    1224:	8c e0       	ldi	r24, 0x0C	; 12
    1226:	48 0e       	add	r4, r24
    1228:	51 1c       	adc	r5, r1
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    122a:	0f 2e       	mov	r0, r31
    122c:	f5 e6       	ldi	r31, 0x65	; 101
    122e:	ef 2e       	mov	r14, r31
    1230:	f1 2c       	mov	r15, r1
    1232:	f0 2d       	mov	r31, r0
    1234:	77 24       	eor	r7, r7
    1236:	7a 94       	dec	r7
    1238:	67 2c       	mov	r6, r7
						mem4[WARNING_HIGH] = mem4[GOAL_CNT];
					}*/
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    123a:	21 2c       	mov	r2, r1
    123c:	33 24       	eor	r3, r3
    123e:	33 94       	inc	r3
    1240:	4e 01       	movw	r8, r28
    1242:	e9 e0       	ldi	r30, 0x09	; 9
    1244:	8e 0e       	add	r8, r30
    1246:	91 1c       	adc	r9, r1
    1248:	15 c0       	rjmp	.+42     	; 0x1274 <_ZL4procPv+0x74>
    124a:	a3 2c       	mov	r10, r3
    124c:	b3 2c       	mov	r11, r3
    124e:	12 c0       	rjmp	.+36     	; 0x1274 <_ZL4procPv+0x74>
    1250:	a3 2c       	mov	r10, r3
    1252:	b3 2c       	mov	r11, r3
    1254:	0f c0       	rjmp	.+30     	; 0x1274 <_ZL4procPv+0x74>
    1256:	68 94       	set
    1258:	aa 24       	eor	r10, r10
    125a:	a2 f8       	bld	r10, 2
    125c:	b3 2c       	mov	r11, r3
    125e:	0a c0       	rjmp	.+20     	; 0x1274 <_ZL4procPv+0x74>
    1260:	0f 2e       	mov	r0, r31
    1262:	f5 e0       	ldi	r31, 0x05	; 5
    1264:	af 2e       	mov	r10, r31
    1266:	f0 2d       	mov	r31, r0
    1268:	b3 2c       	mov	r11, r3
    126a:	04 c0       	rjmp	.+8      	; 0x1274 <_ZL4procPv+0x74>
    126c:	68 94       	set
    126e:	aa 24       	eor	r10, r10
    1270:	a4 f8       	bld	r10, 4
    1272:	b3 2c       	mov	r11, r3
	DDRG = 0xff;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
		
	while(1)
	{
		if(mem4[SEC] >= 60)
    1274:	f8 01       	movw	r30, r16
    1276:	84 85       	ldd	r24, Z+12	; 0x0c
    1278:	95 85       	ldd	r25, Z+13	; 0x0d
    127a:	cc 97       	sbiw	r24, 0x3c	; 60
    127c:	9c f0       	brlt	.+38     	; 0x12a4 <_ZL4procPv+0xa4>
		{
			mem4[SEC] = 0;
    127e:	15 86       	std	Z+13, r1	; 0x0d
    1280:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    1282:	82 85       	ldd	r24, Z+10	; 0x0a
    1284:	93 85       	ldd	r25, Z+11	; 0x0b
    1286:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    1288:	8c 33       	cpi	r24, 0x3C	; 60
    128a:	91 05       	cpc	r25, r1
    128c:	1c f4       	brge	.+6      	; 0x1294 <_ZL4procPv+0x94>
	while(1)
	{
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    128e:	93 87       	std	Z+11, r25	; 0x0b
    1290:	82 87       	std	Z+10, r24	; 0x0a
    1292:	08 c0       	rjmp	.+16     	; 0x12a4 <_ZL4procPv+0xa4>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    1294:	f8 01       	movw	r30, r16
    1296:	13 86       	std	Z+11, r1	; 0x0b
    1298:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    129a:	80 85       	ldd	r24, Z+8	; 0x08
    129c:	91 85       	ldd	r25, Z+9	; 0x09
    129e:	01 96       	adiw	r24, 0x01	; 1
    12a0:	91 87       	std	Z+9, r25	; 0x09
    12a2:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    12a4:	b1 10       	cpse	r11, r1
    12a6:	2c c0       	rjmp	.+88     	; 0x1300 <_ZL4procPv+0x100>
		{
			if(sb->SerialAvailable() >= 2)
    12a8:	c6 01       	movw	r24, r12
    12aa:	7b d8       	rcall	.-3850   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    12ac:	82 30       	cpi	r24, 0x02	; 2
    12ae:	10 f3       	brcs	.-60     	; 0x1274 <_ZL4procPv+0x74>
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    12b0:	f7 01       	movw	r30, r14
					buf1[i] = sb->SerialRead();
    12b2:	70 82       	st	Z, r7
    12b4:	c6 01       	movw	r24, r12
    12b6:	49 d8       	rcall	.-3950   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
				    PORTG = 0x00;
    12b8:	89 83       	std	Y+1, r24	; 0x01
			if(sb->SerialAvailable() >= 2)
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
					buf1[i] = sb->SerialRead();
    12ba:	f7 01       	movw	r30, r14
    12bc:	10 82       	st	Z, r1
    12be:	70 82       	st	Z, r7
    12c0:	c6 01       	movw	r24, r12
				    PORTG = 0x00;
    12c2:	43 d8       	rcall	.-3962   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    12c4:	8a 83       	std	Y+2, r24	; 0x02
				}
				if(buf1[0] != 0x01)
				{
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    12c6:	f7 01       	movw	r30, r14
    12c8:	10 82       	st	Z, r1
    12ca:	8a 81       	ldd	r24, Y+2	; 0x02
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    12cc:	81 30       	cpi	r24, 0x01	; 1
    12ce:	e9 f0       	breq	.+58     	; 0x130a <_ZL4procPv+0x10a>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    12d0:	84 30       	cpi	r24, 0x04	; 4
    12d2:	a1 f1       	breq	.+104    	; 0x133c <_ZL4procPv+0x13c>
    12d4:	85 30       	cpi	r24, 0x05	; 5
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    12d6:	09 f4       	brne	.+2      	; 0x12da <_ZL4procPv+0xda>
    12d8:	5d c0       	rjmp	.+186    	; 0x1394 <_ZL4procPv+0x194>
    12da:	80 31       	cpi	r24, 0x10	; 16
				else
				{
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);                                                                                                                                                                                                                  
    12dc:	09 f4       	brne	.+2      	; 0x12e0 <_ZL4procPv+0xe0>
    12de:	86 c0       	rjmp	.+268    	; 0x13ec <_ZL4procPv+0x1ec>
    12e0:	43 2d       	mov	r20, r3
    12e2:	63 2d       	mov	r22, r3
    12e4:	84 e1       	ldi	r24, 0x14	; 20
					sb->SerialFlush();
    12e6:	94 e0       	ldi	r25, 0x04	; 4
    12e8:	0e 94 0c 01 	call	0x218	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
					sb->SerialWrite((char*)&exception,sizeof(exception));
    12ec:	c6 01       	movw	r24, r12
    12ee:	64 d8       	rcall	.-3896   	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
    12f0:	45 e0       	ldi	r20, 0x05	; 5
    12f2:	50 e0       	ldi	r21, 0x00	; 0
    12f4:	64 e1       	ldi	r22, 0x14	; 20
    12f6:	74 e0       	ldi	r23, 0x04	; 4
    12f8:	c6 01       	movw	r24, r12
    12fa:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    12fe:	ba cf       	rjmp	.-140    	; 0x1274 <_ZL4procPv+0x74>
		{
			if(function_code == 0x01)  
    1300:	f1 e0       	ldi	r31, 0x01	; 1
    1302:	bf 12       	cpse	r11, r31
			{
				if(sb->SerialAvailable() >= 6)
    1304:	b7 cf       	rjmp	.-146    	; 0x1274 <_ZL4procPv+0x74>
    1306:	af 12       	cpse	r10, r31
    1308:	16 c0       	rjmp	.+44     	; 0x1336 <_ZL4procPv+0x136>
    130a:	c6 01       	movw	r24, r12
    130c:	4a d8       	rcall	.-3948   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    130e:	86 30       	cpi	r24, 0x06	; 6
    1310:	08 f4       	brcc	.+2      	; 0x1314 <_ZL4procPv+0x114>
    1312:	9b cf       	rjmp	.-202    	; 0x124a <_ZL4procPv+0x4a>
    1314:	5e 01       	movw	r10, r28
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    1316:	83 e0       	ldi	r24, 0x03	; 3
    1318:	a8 0e       	add	r10, r24
						buf1[i] = sb->SerialRead();
    131a:	b1 1c       	adc	r11, r1
    131c:	f7 01       	movw	r30, r14
    131e:	60 82       	st	Z, r6
    1320:	c6 01       	movw	r24, r12
    1322:	13 d8       	rcall	.-4058   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1324:	f5 01       	movw	r30, r10
						PORTG = 0x00;
    1326:	81 93       	st	Z+, r24
    1328:	5f 01       	movw	r10, r30
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    132a:	f7 01       	movw	r30, r14
    132c:	10 82       	st	Z, r1
    132e:	8a 14       	cp	r8, r10
						PORTG = 0x00;
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1330:	9b 04       	cpc	r9, r11
    1332:	a1 f7       	brne	.-24     	; 0x131c <_ZL4procPv+0x11c>
    1334:	8d cf       	rjmp	.-230    	; 0x1250 <_ZL4procPv+0x50>
			{
				if(sb->SerialAvailable() >= 6)
    1336:	f4 e0       	ldi	r31, 0x04	; 4
    1338:	af 12       	cpse	r10, r31
    133a:	29 c0       	rjmp	.+82     	; 0x138e <_ZL4procPv+0x18e>
    133c:	c6 01       	movw	r24, r12
    133e:	31 d8       	rcall	.-3998   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1340:	86 30       	cpi	r24, 0x06	; 6
    1342:	08 f4       	brcc	.+2      	; 0x1346 <_ZL4procPv+0x146>
    1344:	88 cf       	rjmp	.-240    	; 0x1256 <_ZL4procPv+0x56>
    1346:	5e 01       	movw	r10, r28
    1348:	83 e0       	ldi	r24, 0x03	; 3
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    134a:	a8 0e       	add	r10, r24
    134c:	b1 1c       	adc	r11, r1
						buf1[i] = sb->SerialRead();
    134e:	f7 01       	movw	r30, r14
    1350:	60 82       	st	Z, r6
    1352:	c6 01       	movw	r24, r12
    1354:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1358:	f5 01       	movw	r30, r10
						PORTG = 0x00;
    135a:	81 93       	st	Z+, r24
    135c:	5f 01       	movw	r10, r30
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    135e:	f7 01       	movw	r30, r14
    1360:	10 82       	st	Z, r1
    1362:	a8 14       	cp	r10, r8
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc04Data(buf1,&func04,mem4);
    1364:	b9 04       	cpc	r11, r9
    1366:	99 f7       	brne	.-26     	; 0x134e <_ZL4procPv+0x14e>
    1368:	a8 01       	movw	r20, r16
    136a:	64 e2       	ldi	r22, 0x24	; 36
    136c:	74 e0       	ldi	r23, 0x04	; 4
    136e:	ce 01       	movw	r24, r28
    1370:	01 96       	adiw	r24, 0x01	; 1
					sb->SerialWrite((char*)&func04,sizeof(func04));
    1372:	0e 94 8f 00 	call	0x11e	; 0x11e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
    1376:	47 e0       	ldi	r20, 0x07	; 7
    1378:	50 e0       	ldi	r21, 0x00	; 0
    137a:	64 e2       	ldi	r22, 0x24	; 36
    137c:	74 e0       	ldi	r23, 0x04	; 4
    137e:	c6 01       	movw	r24, r12
    1380:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					read_Flag = 0;
    1384:	68 94       	set
    1386:	aa 24       	eor	r10, r10
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    1388:	a2 f8       	bld	r10, 2
    138a:	b2 2c       	mov	r11, r2
    138c:	73 cf       	rjmp	.-282    	; 0x1274 <_ZL4procPv+0x74>
			{
				if(sb->SerialAvailable() >= 6)
    138e:	f5 e0       	ldi	r31, 0x05	; 5
    1390:	af 12       	cpse	r10, r31
    1392:	29 c0       	rjmp	.+82     	; 0x13e6 <_ZL4procPv+0x1e6>
    1394:	c6 01       	movw	r24, r12
    1396:	05 d8       	rcall	.-4086   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1398:	86 30       	cpi	r24, 0x06	; 6
    139a:	08 f4       	brcc	.+2      	; 0x139e <_ZL4procPv+0x19e>
    139c:	61 cf       	rjmp	.-318    	; 0x1260 <_ZL4procPv+0x60>
    139e:	5e 01       	movw	r10, r28
    13a0:	83 e0       	ldi	r24, 0x03	; 3
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    13a2:	a8 0e       	add	r10, r24
    13a4:	b1 1c       	adc	r11, r1
						buf1[i] = sb->SerialRead();
    13a6:	f7 01       	movw	r30, r14
    13a8:	60 82       	st	Z, r6
    13aa:	c6 01       	movw	r24, r12
    13ac:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    13b0:	f5 01       	movw	r30, r10
						PORTG = 0x00;
    13b2:	81 93       	st	Z+, r24
    13b4:	5f 01       	movw	r10, r30
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    13b6:	f7 01       	movw	r30, r14
    13b8:	10 82       	st	Z, r1
    13ba:	8a 14       	cp	r8, r10
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc05Data(buf1,&func05);
    13bc:	9b 04       	cpc	r9, r11
    13be:	99 f7       	brne	.-26     	; 0x13a6 <_ZL4procPv+0x1a6>
    13c0:	6b e2       	ldi	r22, 0x2B	; 43
    13c2:	74 e0       	ldi	r23, 0x04	; 4
    13c4:	ce 01       	movw	r24, r28
    13c6:	01 96       	adiw	r24, 0x01	; 1
					sb->SerialWrite((char*)&func05,sizeof(func05));
    13c8:	0e 94 b0 00 	call	0x160	; 0x160 <_Z13GetFunc05DataPcP17GetFunctionCode05>
    13cc:	48 e0       	ldi	r20, 0x08	; 8
    13ce:	50 e0       	ldi	r21, 0x00	; 0
    13d0:	6b e2       	ldi	r22, 0x2B	; 43
    13d2:	74 e0       	ldi	r23, 0x04	; 4
    13d4:	c6 01       	movw	r24, r12
    13d6:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    13da:	0f 2e       	mov	r0, r31
    13dc:	f5 e0       	ldi	r31, 0x05	; 5
					read_Flag = 0;
    13de:	af 2e       	mov	r10, r31
    13e0:	f0 2d       	mov	r31, r0
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    13e2:	b2 2c       	mov	r11, r2
    13e4:	47 cf       	rjmp	.-370    	; 0x1274 <_ZL4procPv+0x74>
    13e6:	f0 e1       	ldi	r31, 0x10	; 16
			{
				if(sb->SerialAvailable() >= 9)
    13e8:	af 12       	cpse	r10, r31
    13ea:	44 cf       	rjmp	.-376    	; 0x1274 <_ZL4procPv+0x74>
    13ec:	c6 01       	movw	r24, r12
    13ee:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    13f2:	89 30       	cpi	r24, 0x09	; 9
    13f4:	08 f4       	brcc	.+2      	; 0x13f8 <_ZL4procPv+0x1f8>
    13f6:	3a cf       	rjmp	.-396    	; 0x126c <_ZL4procPv+0x6c>
    13f8:	5e 01       	movw	r10, r28
    13fa:	83 e0       	ldi	r24, 0x03	; 3
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    13fc:	a8 0e       	add	r10, r24
    13fe:	b1 1c       	adc	r11, r1
						buf1[i] = sb->SerialRead();
    1400:	f7 01       	movw	r30, r14
    1402:	60 82       	st	Z, r6
    1404:	c6 01       	movw	r24, r12
    1406:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    140a:	f5 01       	movw	r30, r10
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    140c:	81 93       	st	Z+, r24
    140e:	5f 01       	movw	r10, r30
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    1410:	f7 01       	movw	r30, r14
    1412:	10 82       	st	Z, r1
    1414:	4a 14       	cp	r4, r10
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1416:	5b 04       	cpc	r5, r11
    1418:	99 f7       	brne	.-26     	; 0x1400 <_ZL4procPv+0x200>
    141a:	a8 01       	movw	r20, r16
    141c:	69 e1       	ldi	r22, 0x19	; 25
    141e:	74 e0       	ldi	r23, 0x04	; 4
    1420:	ce 01       	movw	r24, r28
    1422:	01 96       	adiw	r24, 0x01	; 1
					{
						mem4[TARGET_MAX] = mem4[GOAL_CNT];
						mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
						mem4[WARNING_HIGH] = mem4[GOAL_CNT];
					}*/
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1424:	0e 94 c9 00 	call	0x192	; 0x192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
    1428:	6c e0       	ldi	r22, 0x0C	; 12
    142a:	74 e0       	ldi	r23, 0x04	; 4
    142c:	ce 01       	movw	r24, r28
    142e:	01 96       	adiw	r24, 0x01	; 1
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    1430:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
    1434:	48 e0       	ldi	r20, 0x08	; 8
    1436:	50 e0       	ldi	r21, 0x00	; 0
    1438:	6c e0       	ldi	r22, 0x0C	; 12
    143a:	74 e0       	ldi	r23, 0x04	; 4
    143c:	c6 01       	movw	r24, r12
    143e:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    1442:	68 94       	set
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    1444:	aa 24       	eor	r10, r10
    1446:	a4 f8       	bld	r10, 4
    1448:	b2 2c       	mov	r11, r2
    144a:	14 cf       	rjmp	.-472    	; 0x1274 <_ZL4procPv+0x74>

0000144c <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    144c:	80 91 33 04 	lds	r24, 0x0433	; 0x800433 <DataStruct>
    1450:	90 91 34 04 	lds	r25, 0x0434	; 0x800434 <DataStruct+0x1>
    1454:	0c 94 44 01 	jmp	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
    1458:	08 95       	ret

0000145a <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    145a:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <DataStruct+0x2>
    145e:	90 91 36 04 	lds	r25, 0x0436	; 0x800436 <DataStruct+0x3>
    1462:	0c 94 44 01 	jmp	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
    1466:	08 95       	ret

00001468 <_Z8Init_Devv>:
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}

void Init_Dev()
{
    1468:	cf 93       	push	r28
    146a:	df 93       	push	r29
	dev = new Dev_Manager();
    146c:	8c e0       	ldi	r24, 0x0C	; 12
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	0e 94 1f 02 	call	0x43e	; 0x43e <_ZN11Dev_ManagernwEj>
    1474:	ec 01       	movw	r28, r24
    1476:	0e 94 e7 01 	call	0x3ce	; 0x3ce <_ZN11Dev_ManagerC1Ev>
    147a:	d0 93 3a 04 	sts	0x043A, r29	; 0x80043a <dev+0x1>
    147e:	c0 93 39 04 	sts	0x0439, r28	; 0x800439 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    1482:	86 e0       	ldi	r24, 0x06	; 6
    1484:	90 e0       	ldi	r25, 0x00	; 0
    1486:	99 d9       	rcall	.-3278   	; 0x7ba <_ZN10UartDrivernwEj>
    1488:	ec 01       	movw	r28, r24
    148a:	87 d9       	rcall	.-3314   	; 0x79a <_ZN10UartDriverC1Ev>
    148c:	40 e0       	ldi	r20, 0x00	; 0
    148e:	be 01       	movw	r22, r28
    1490:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1494:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
    1498:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    149c:	86 e0       	ldi	r24, 0x06	; 6
    149e:	90 e0       	ldi	r25, 0x00	; 0
    14a0:	0f d9       	rcall	.-3554   	; 0x6c0 <_ZN11RS485DrivernwEj>
    14a2:	ec 01       	movw	r28, r24
    14a4:	fd d8       	rcall	.-3590   	; 0x6a0 <_ZN11RS485DriverC1Ev>
    14a6:	41 e0       	ldi	r20, 0x01	; 1
    14a8:	be 01       	movw	r22, r28
    14aa:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    14ae:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Register_Dev(new Timer,SEC_TIMER);
    14b2:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    14b6:	82 e0       	ldi	r24, 0x02	; 2
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	cb d8       	rcall	.-3690   	; 0x652 <_ZN5TimernwEj>
    14bc:	ec 01       	movw	r28, r24
    14be:	c3 d8       	rcall	.-3706   	; 0x646 <_ZN5TimerC1Ev>
    14c0:	42 e0       	ldi	r20, 0x02	; 2
    14c2:	be 01       	movw	r22, r28
    14c4:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    14c8:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Device_Init(UART0);
    14cc:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    14d0:	60 e0       	ldi	r22, 0x00	; 0
    14d2:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    14d6:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Device_Init(RS485);
    14da:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    14de:	61 e0       	ldi	r22, 0x01	; 1
    14e0:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    14e4:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Device_Init(SEC_TIMER);
    14e8:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    14ec:	62 e0       	ldi	r22, 0x02	; 2
    14ee:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    14f2:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    14f6:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    14fa:	4f e2       	ldi	r20, 0x2F	; 47
    14fc:	51 e0       	ldi	r21, 0x01	; 1
    14fe:	60 e0       	ldi	r22, 0x00	; 0
    1500:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1504:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1508:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePc>
    150c:	45 e5       	ldi	r20, 0x55	; 85
    150e:	51 e0       	ldi	r21, 0x01	; 1
    1510:	61 e0       	ldi	r22, 0x01	; 1
    1512:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1516:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
}
    151a:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePc>
    151e:	df 91       	pop	r29
    1520:	cf 91       	pop	r28
    1522:	08 95       	ret

00001524 <main>:
int current_pressure = 0;

int mem4[MAX_ENUM] = {0};

int main( void )
{
    1524:	cf 92       	push	r12
    1526:	df 92       	push	r13
    1528:	ef 92       	push	r14
    152a:	ff 92       	push	r15
    152c:	0f 93       	push	r16
    152e:	cf 93       	push	r28
    1530:	df 93       	push	r29
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    1532:	f8 94       	cli
	
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    1534:	99 df       	rcall	.-206    	; 0x1468 <_Z8Init_Devv>
    1536:	46 e2       	ldi	r20, 0x26	; 38
    1538:	5a e0       	ldi	r21, 0x0A	; 10
    153a:	60 e0       	ldi	r22, 0x00	; 0
    153c:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1540:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
    1544:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    1548:	4d e2       	ldi	r20, 0x2D	; 45
    154a:	5a e0       	ldi	r21, 0x0A	; 10
    154c:	61 e0       	ldi	r22, 0x01	; 1
    154e:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1552:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
    1556:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    155a:	4f e8       	ldi	r20, 0x8F	; 143
    155c:	57 e0       	ldi	r21, 0x07	; 7
    155e:	62 e0       	ldi	r22, 0x02	; 2
    1560:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <dev>
    1564:	90 91 3a 04 	lds	r25, 0x043A	; 0x80043a <dev+0x1>
    1568:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    156c:	88 e8       	ldi	r24, 0x88	; 136
    156e:	90 e0       	ldi	r25, 0x00	; 0
    1570:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    1574:	6c 01       	movw	r12, r24
    1576:	60 91 39 04 	lds	r22, 0x0439	; 0x800439 <dev>
    157a:	70 91 3a 04 	lds	r23, 0x043A	; 0x80043a <dev+0x1>
    157e:	40 e0       	ldi	r20, 0x00	; 0
    1580:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1584:	c1 14       	cp	r12, r1
    1586:	d1 04       	cpc	r13, r1
	{
		#if DEBUG 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    1588:	21 f4       	brne	.+8      	; 0x1592 <main+0x6e>
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	0e 94 9b 14 	call	0x2936	; 0x2936 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		#endif
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1592:	88 e8       	ldi	r24, 0x88	; 136
    1594:	90 e0       	ldi	r25, 0x00	; 0
    1596:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    159a:	ec 01       	movw	r28, r24
    159c:	60 91 39 04 	lds	r22, 0x0439	; 0x800439 <dev>
    15a0:	70 91 3a 04 	lds	r23, 0x043A	; 0x80043a <dev+0x1>
    15a4:	41 e0       	ldi	r20, 0x01	; 1
    15a6:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    15aa:	20 97       	sbiw	r28, 0x00	; 0
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    15ac:	21 f4       	brne	.+8      	; 0x15b6 <main+0x92>
    15ae:	81 e0       	ldi	r24, 0x01	; 1
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	0e 94 9b 14 	call	0x2936	; 0x2936 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		#endif
	}
	DataStruct[UART0] = sb;
    15b6:	e3 e3       	ldi	r30, 0x33	; 51
    15b8:	f4 e0       	ldi	r31, 0x04	; 4
    15ba:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    15bc:	c0 82       	st	Z, r12
    15be:	d3 83       	std	Z+3, r29	; 0x03
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			#endif
		}
	}

	sei(); //인터럽트 사용 
    15c0:	c2 83       	std	Z+2, r28	; 0x02
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    15c2:	78 94       	sei
    15c4:	e1 2c       	mov	r14, r1
    15c6:	f1 2c       	mov	r15, r1
    15c8:	02 e0       	ldi	r16, 0x02	; 2
    15ca:	96 01       	movw	r18, r12
    15cc:	4e e5       	ldi	r20, 0x5E	; 94
    15ce:	51 e0       	ldi	r21, 0x01	; 1
    15d0:	6c e7       	ldi	r22, 0x7C	; 124
    15d2:	71 e0       	ldi	r23, 0x01	; 1
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	99 e0       	ldi	r25, 0x09	; 9
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    15d8:	28 d5       	rcall	.+2640   	; 0x202a <xTaskCreate>
    15da:	9e 01       	movw	r18, r28
    15dc:	4e e5       	ldi	r20, 0x5E	; 94
    15de:	51 e0       	ldi	r21, 0x01	; 1
    15e0:	62 e8       	ldi	r22, 0x82	; 130
    15e2:	71 e0       	ldi	r23, 0x01	; 1
    15e4:	82 e7       	ldi	r24, 0x72	; 114
    15e6:	98 e0       	ldi	r25, 0x08	; 8
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위
				NULL                   //태스크 핸들
				);
    15e8:	20 d5       	rcall	.+2624   	; 0x202a <xTaskCreate>
    15ea:	20 e0       	ldi	r18, 0x00	; 0
    15ec:	30 e0       	ldi	r19, 0x00	; 0
    15ee:	40 ef       	ldi	r20, 0xF0	; 240
    15f0:	50 e0       	ldi	r21, 0x00	; 0
    15f2:	68 e8       	ldi	r22, 0x88	; 136
    15f4:	71 e0       	ldi	r23, 0x01	; 1
    15f6:	87 e9       	ldi	r24, 0x97	; 151
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    15f8:	97 e0       	ldi	r25, 0x07	; 7
    15fa:	17 d5       	rcall	.+2606   	; 0x202a <xTaskCreate>
	return 0;
}
    15fc:	14 d6       	rcall	.+3112   	; 0x2226 <vTaskStartScheduler>
    15fe:	80 e0       	ldi	r24, 0x00	; 0
    1600:	90 e0       	ldi	r25, 0x00	; 0
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	0f 91       	pop	r16
    1608:	ff 90       	pop	r15
    160a:	ef 90       	pop	r14
    160c:	df 90       	pop	r13
    160e:	cf 90       	pop	r12
    1610:	08 95       	ret

00001612 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1612:	08 95       	ret

00001614 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    1618:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    161a:	2d d6       	rcall	.+3162   	; 0x2276 <vTaskSuspendAll>
    161c:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <pucAlignedHeap.2069>
    1620:	90 91 3c 04 	lds	r25, 0x043C	; 0x80043c <pucAlignedHeap.2069+0x1>
    1624:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1626:	31 f4       	brne	.+12     	; 0x1634 <pvPortMalloc+0x20>
    1628:	80 e4       	ldi	r24, 0x40	; 64
    162a:	94 e0       	ldi	r25, 0x04	; 4
    162c:	90 93 3c 04 	sts	0x043C, r25	; 0x80043c <pucAlignedHeap.2069+0x1>
    1630:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1634:	20 91 3d 04 	lds	r18, 0x043D	; 0x80043d <xNextFreeByte>
    1638:	30 91 3e 04 	lds	r19, 0x043E	; 0x80043e <xNextFreeByte+0x1>
    163c:	c9 01       	movw	r24, r18
    163e:	8c 0f       	add	r24, r28
    1640:	9d 1f       	adc	r25, r29
    1642:	8b 3f       	cpi	r24, 0xFB	; 251
    1644:	48 e0       	ldi	r20, 0x08	; 8
    1646:	94 07       	cpc	r25, r20
    1648:	70 f4       	brcc	.+28     	; 0x1666 <pvPortMalloc+0x52>
    164a:	28 17       	cp	r18, r24
    164c:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    164e:	70 f4       	brcc	.+28     	; 0x166c <pvPortMalloc+0x58>
    1650:	c0 91 3b 04 	lds	r28, 0x043B	; 0x80043b <pucAlignedHeap.2069>
    1654:	d0 91 3c 04 	lds	r29, 0x043C	; 0x80043c <pucAlignedHeap.2069+0x1>
    1658:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    165a:	d3 1f       	adc	r29, r19
    165c:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <xNextFreeByte+0x1>
    1660:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1664:	05 c0       	rjmp	.+10     	; 0x1670 <pvPortMalloc+0x5c>
    1666:	c0 e0       	ldi	r28, 0x00	; 0
    1668:	d0 e0       	ldi	r29, 0x00	; 0
    166a:	02 c0       	rjmp	.+4      	; 0x1670 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    166c:	c0 e0       	ldi	r28, 0x00	; 0
    166e:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1670:	bf d6       	rcall	.+3454   	; 0x23f0 <xTaskResumeAll>
    1672:	ce 01       	movw	r24, r28
    1674:	df 91       	pop	r29
    1676:	cf 91       	pop	r28
    1678:	08 95       	ret

0000167a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    167a:	08 95       	ret

0000167c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    167c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    167e:	03 96       	adiw	r24, 0x03	; 3
    1680:	92 83       	std	Z+2, r25	; 0x02
    1682:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1684:	2f ef       	ldi	r18, 0xFF	; 255
    1686:	3f ef       	ldi	r19, 0xFF	; 255
    1688:	34 83       	std	Z+4, r19	; 0x04
    168a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    168c:	96 83       	std	Z+6, r25	; 0x06
    168e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1690:	90 87       	std	Z+8, r25	; 0x08
    1692:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1694:	10 82       	st	Z, r1
    1696:	08 95       	ret

00001698 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1698:	fc 01       	movw	r30, r24
    169a:	11 86       	std	Z+9, r1	; 0x09
    169c:	10 86       	std	Z+8, r1	; 0x08
    169e:	08 95       	ret

000016a0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16a0:	cf 93       	push	r28
    16a2:	df 93       	push	r29
    16a4:	9c 01       	movw	r18, r24
    16a6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    16a8:	dc 01       	movw	r26, r24
    16aa:	11 96       	adiw	r26, 0x01	; 1
    16ac:	cd 91       	ld	r28, X+
    16ae:	dc 91       	ld	r29, X
    16b0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    16b2:	d3 83       	std	Z+3, r29	; 0x03
    16b4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    16b6:	8c 81       	ldd	r24, Y+4	; 0x04
    16b8:	9d 81       	ldd	r25, Y+5	; 0x05
    16ba:	95 83       	std	Z+5, r25	; 0x05
    16bc:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    16be:	8c 81       	ldd	r24, Y+4	; 0x04
    16c0:	9d 81       	ldd	r25, Y+5	; 0x05
    16c2:	dc 01       	movw	r26, r24
    16c4:	13 96       	adiw	r26, 0x03	; 3
    16c6:	7c 93       	st	X, r23
    16c8:	6e 93       	st	-X, r22
    16ca:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    16cc:	7d 83       	std	Y+5, r23	; 0x05
    16ce:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16d0:	31 87       	std	Z+9, r19	; 0x09
    16d2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    16d4:	f9 01       	movw	r30, r18
    16d6:	80 81       	ld	r24, Z
    16d8:	8f 5f       	subi	r24, 0xFF	; 255
    16da:	80 83       	st	Z, r24
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	08 95       	ret

000016e2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    16e8:	48 81       	ld	r20, Y
    16ea:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16ec:	4f 3f       	cpi	r20, 0xFF	; 255
    16ee:	2f ef       	ldi	r18, 0xFF	; 255
    16f0:	52 07       	cpc	r21, r18
    16f2:	21 f4       	brne	.+8      	; 0x16fc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16f4:	fc 01       	movw	r30, r24
    16f6:	a7 81       	ldd	r26, Z+7	; 0x07
    16f8:	b0 85       	ldd	r27, Z+8	; 0x08
    16fa:	0d c0       	rjmp	.+26     	; 0x1716 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16fc:	dc 01       	movw	r26, r24
    16fe:	13 96       	adiw	r26, 0x03	; 3
    1700:	01 c0       	rjmp	.+2      	; 0x1704 <vListInsert+0x22>
    1702:	df 01       	movw	r26, r30
    1704:	12 96       	adiw	r26, 0x02	; 2
    1706:	ed 91       	ld	r30, X+
    1708:	fc 91       	ld	r31, X
    170a:	13 97       	sbiw	r26, 0x03	; 3
    170c:	20 81       	ld	r18, Z
    170e:	31 81       	ldd	r19, Z+1	; 0x01
    1710:	42 17       	cp	r20, r18
    1712:	53 07       	cpc	r21, r19
    1714:	b0 f7       	brcc	.-20     	; 0x1702 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1716:	12 96       	adiw	r26, 0x02	; 2
    1718:	ed 91       	ld	r30, X+
    171a:	fc 91       	ld	r31, X
    171c:	13 97       	sbiw	r26, 0x03	; 3
    171e:	fb 83       	std	Y+3, r31	; 0x03
    1720:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1722:	d5 83       	std	Z+5, r29	; 0x05
    1724:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1726:	bd 83       	std	Y+5, r27	; 0x05
    1728:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    172a:	13 96       	adiw	r26, 0x03	; 3
    172c:	dc 93       	st	X, r29
    172e:	ce 93       	st	-X, r28
    1730:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1732:	99 87       	std	Y+9, r25	; 0x09
    1734:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1736:	fc 01       	movw	r30, r24
    1738:	20 81       	ld	r18, Z
    173a:	2f 5f       	subi	r18, 0xFF	; 255
    173c:	20 83       	st	Z, r18
}
    173e:	df 91       	pop	r29
    1740:	cf 91       	pop	r28
    1742:	08 95       	ret

00001744 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1744:	cf 93       	push	r28
    1746:	df 93       	push	r29
    1748:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    174a:	a0 85       	ldd	r26, Z+8	; 0x08
    174c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    174e:	c2 81       	ldd	r28, Z+2	; 0x02
    1750:	d3 81       	ldd	r29, Z+3	; 0x03
    1752:	84 81       	ldd	r24, Z+4	; 0x04
    1754:	95 81       	ldd	r25, Z+5	; 0x05
    1756:	9d 83       	std	Y+5, r25	; 0x05
    1758:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    175a:	c4 81       	ldd	r28, Z+4	; 0x04
    175c:	d5 81       	ldd	r29, Z+5	; 0x05
    175e:	82 81       	ldd	r24, Z+2	; 0x02
    1760:	93 81       	ldd	r25, Z+3	; 0x03
    1762:	9b 83       	std	Y+3, r25	; 0x03
    1764:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1766:	11 96       	adiw	r26, 0x01	; 1
    1768:	8d 91       	ld	r24, X+
    176a:	9c 91       	ld	r25, X
    176c:	12 97       	sbiw	r26, 0x02	; 2
    176e:	e8 17       	cp	r30, r24
    1770:	f9 07       	cpc	r31, r25
    1772:	31 f4       	brne	.+12     	; 0x1780 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1774:	84 81       	ldd	r24, Z+4	; 0x04
    1776:	95 81       	ldd	r25, Z+5	; 0x05
    1778:	12 96       	adiw	r26, 0x02	; 2
    177a:	9c 93       	st	X, r25
    177c:	8e 93       	st	-X, r24
    177e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1780:	11 86       	std	Z+9, r1	; 0x09
    1782:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1784:	8c 91       	ld	r24, X
    1786:	81 50       	subi	r24, 0x01	; 1
    1788:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    178a:	df 91       	pop	r29
    178c:	cf 91       	pop	r28
    178e:	08 95       	ret

00001790 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1790:	31 e1       	ldi	r19, 0x11	; 17
    1792:	fc 01       	movw	r30, r24
    1794:	30 83       	st	Z, r19
    1796:	31 97       	sbiw	r30, 0x01	; 1
    1798:	22 e2       	ldi	r18, 0x22	; 34
    179a:	20 83       	st	Z, r18
    179c:	31 97       	sbiw	r30, 0x01	; 1
    179e:	a3 e3       	ldi	r26, 0x33	; 51
    17a0:	a0 83       	st	Z, r26
    17a2:	31 97       	sbiw	r30, 0x01	; 1
    17a4:	60 83       	st	Z, r22
    17a6:	31 97       	sbiw	r30, 0x01	; 1
    17a8:	70 83       	st	Z, r23
    17aa:	31 97       	sbiw	r30, 0x01	; 1
    17ac:	10 82       	st	Z, r1
    17ae:	31 97       	sbiw	r30, 0x01	; 1
    17b0:	60 e8       	ldi	r22, 0x80	; 128
    17b2:	60 83       	st	Z, r22
    17b4:	31 97       	sbiw	r30, 0x01	; 1
    17b6:	10 82       	st	Z, r1
    17b8:	31 97       	sbiw	r30, 0x01	; 1
    17ba:	62 e0       	ldi	r22, 0x02	; 2
    17bc:	60 83       	st	Z, r22
    17be:	31 97       	sbiw	r30, 0x01	; 1
    17c0:	63 e0       	ldi	r22, 0x03	; 3
    17c2:	60 83       	st	Z, r22
    17c4:	31 97       	sbiw	r30, 0x01	; 1
    17c6:	64 e0       	ldi	r22, 0x04	; 4
    17c8:	60 83       	st	Z, r22
    17ca:	31 97       	sbiw	r30, 0x01	; 1
    17cc:	65 e0       	ldi	r22, 0x05	; 5
    17ce:	60 83       	st	Z, r22
    17d0:	31 97       	sbiw	r30, 0x01	; 1
    17d2:	66 e0       	ldi	r22, 0x06	; 6
    17d4:	60 83       	st	Z, r22
    17d6:	31 97       	sbiw	r30, 0x01	; 1
    17d8:	67 e0       	ldi	r22, 0x07	; 7
    17da:	60 83       	st	Z, r22
    17dc:	31 97       	sbiw	r30, 0x01	; 1
    17de:	68 e0       	ldi	r22, 0x08	; 8
    17e0:	60 83       	st	Z, r22
    17e2:	31 97       	sbiw	r30, 0x01	; 1
    17e4:	69 e0       	ldi	r22, 0x09	; 9
    17e6:	60 83       	st	Z, r22
    17e8:	31 97       	sbiw	r30, 0x01	; 1
    17ea:	60 e1       	ldi	r22, 0x10	; 16
    17ec:	60 83       	st	Z, r22
    17ee:	31 97       	sbiw	r30, 0x01	; 1
    17f0:	30 83       	st	Z, r19
    17f2:	31 97       	sbiw	r30, 0x01	; 1
    17f4:	32 e1       	ldi	r19, 0x12	; 18
    17f6:	30 83       	st	Z, r19
    17f8:	31 97       	sbiw	r30, 0x01	; 1
    17fa:	33 e1       	ldi	r19, 0x13	; 19
    17fc:	30 83       	st	Z, r19
    17fe:	31 97       	sbiw	r30, 0x01	; 1
    1800:	34 e1       	ldi	r19, 0x14	; 20
    1802:	30 83       	st	Z, r19
    1804:	31 97       	sbiw	r30, 0x01	; 1
    1806:	35 e1       	ldi	r19, 0x15	; 21
    1808:	30 83       	st	Z, r19
    180a:	31 97       	sbiw	r30, 0x01	; 1
    180c:	36 e1       	ldi	r19, 0x16	; 22
    180e:	30 83       	st	Z, r19
    1810:	31 97       	sbiw	r30, 0x01	; 1
    1812:	37 e1       	ldi	r19, 0x17	; 23
    1814:	30 83       	st	Z, r19
    1816:	31 97       	sbiw	r30, 0x01	; 1
    1818:	38 e1       	ldi	r19, 0x18	; 24
    181a:	30 83       	st	Z, r19
    181c:	31 97       	sbiw	r30, 0x01	; 1
    181e:	39 e1       	ldi	r19, 0x19	; 25
    1820:	30 83       	st	Z, r19
    1822:	31 97       	sbiw	r30, 0x01	; 1
    1824:	30 e2       	ldi	r19, 0x20	; 32
    1826:	30 83       	st	Z, r19
    1828:	31 97       	sbiw	r30, 0x01	; 1
    182a:	31 e2       	ldi	r19, 0x21	; 33
    182c:	30 83       	st	Z, r19
    182e:	31 97       	sbiw	r30, 0x01	; 1
    1830:	20 83       	st	Z, r18
    1832:	31 97       	sbiw	r30, 0x01	; 1
    1834:	23 e2       	ldi	r18, 0x23	; 35
    1836:	20 83       	st	Z, r18
    1838:	31 97       	sbiw	r30, 0x01	; 1
    183a:	40 83       	st	Z, r20
    183c:	31 97       	sbiw	r30, 0x01	; 1
    183e:	50 83       	st	Z, r21
    1840:	31 97       	sbiw	r30, 0x01	; 1
    1842:	26 e2       	ldi	r18, 0x26	; 38
    1844:	20 83       	st	Z, r18
    1846:	31 97       	sbiw	r30, 0x01	; 1
    1848:	27 e2       	ldi	r18, 0x27	; 39
    184a:	20 83       	st	Z, r18
    184c:	31 97       	sbiw	r30, 0x01	; 1
    184e:	28 e2       	ldi	r18, 0x28	; 40
    1850:	20 83       	st	Z, r18
    1852:	31 97       	sbiw	r30, 0x01	; 1
    1854:	29 e2       	ldi	r18, 0x29	; 41
    1856:	20 83       	st	Z, r18
    1858:	31 97       	sbiw	r30, 0x01	; 1
    185a:	20 e3       	ldi	r18, 0x30	; 48
    185c:	20 83       	st	Z, r18
    185e:	31 97       	sbiw	r30, 0x01	; 1
    1860:	21 e3       	ldi	r18, 0x31	; 49
    1862:	20 83       	st	Z, r18
    1864:	86 97       	sbiw	r24, 0x26	; 38
    1866:	08 95       	ret

00001868 <xPortStartScheduler>:
    1868:	1b bc       	out	0x2b, r1	; 43
    186a:	89 ef       	ldi	r24, 0xF9	; 249
    186c:	8a bd       	out	0x2a, r24	; 42
    186e:	8b e0       	ldi	r24, 0x0B	; 11
    1870:	8e bd       	out	0x2e, r24	; 46
    1872:	87 b7       	in	r24, 0x37	; 55
    1874:	80 61       	ori	r24, 0x10	; 16
    1876:	87 bf       	out	0x37, r24	; 55
    1878:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    187c:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1880:	cd 91       	ld	r28, X+
    1882:	cd bf       	out	0x3d, r28	; 61
    1884:	dd 91       	ld	r29, X+
    1886:	de bf       	out	0x3e, r29	; 62
    1888:	ff 91       	pop	r31
    188a:	ef 91       	pop	r30
    188c:	df 91       	pop	r29
    188e:	cf 91       	pop	r28
    1890:	bf 91       	pop	r27
    1892:	af 91       	pop	r26
    1894:	9f 91       	pop	r25
    1896:	8f 91       	pop	r24
    1898:	7f 91       	pop	r23
    189a:	6f 91       	pop	r22
    189c:	5f 91       	pop	r21
    189e:	4f 91       	pop	r20
    18a0:	3f 91       	pop	r19
    18a2:	2f 91       	pop	r18
    18a4:	1f 91       	pop	r17
    18a6:	0f 91       	pop	r16
    18a8:	ff 90       	pop	r15
    18aa:	ef 90       	pop	r14
    18ac:	df 90       	pop	r13
    18ae:	cf 90       	pop	r12
    18b0:	bf 90       	pop	r11
    18b2:	af 90       	pop	r10
    18b4:	9f 90       	pop	r9
    18b6:	8f 90       	pop	r8
    18b8:	7f 90       	pop	r7
    18ba:	6f 90       	pop	r6
    18bc:	5f 90       	pop	r5
    18be:	4f 90       	pop	r4
    18c0:	3f 90       	pop	r3
    18c2:	2f 90       	pop	r2
    18c4:	1f 90       	pop	r1
    18c6:	0f 90       	pop	r0
    18c8:	0f be       	out	0x3f, r0	; 63
    18ca:	0f 90       	pop	r0
    18cc:	08 95       	ret
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	08 95       	ret

000018d2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    18d2:	0f 92       	push	r0
    18d4:	0f b6       	in	r0, 0x3f	; 63
    18d6:	f8 94       	cli
    18d8:	0f 92       	push	r0
    18da:	1f 92       	push	r1
    18dc:	11 24       	eor	r1, r1
    18de:	2f 92       	push	r2
    18e0:	3f 92       	push	r3
    18e2:	4f 92       	push	r4
    18e4:	5f 92       	push	r5
    18e6:	6f 92       	push	r6
    18e8:	7f 92       	push	r7
    18ea:	8f 92       	push	r8
    18ec:	9f 92       	push	r9
    18ee:	af 92       	push	r10
    18f0:	bf 92       	push	r11
    18f2:	cf 92       	push	r12
    18f4:	df 92       	push	r13
    18f6:	ef 92       	push	r14
    18f8:	ff 92       	push	r15
    18fa:	0f 93       	push	r16
    18fc:	1f 93       	push	r17
    18fe:	2f 93       	push	r18
    1900:	3f 93       	push	r19
    1902:	4f 93       	push	r20
    1904:	5f 93       	push	r21
    1906:	6f 93       	push	r22
    1908:	7f 93       	push	r23
    190a:	8f 93       	push	r24
    190c:	9f 93       	push	r25
    190e:	af 93       	push	r26
    1910:	bf 93       	push	r27
    1912:	cf 93       	push	r28
    1914:	df 93       	push	r29
    1916:	ef 93       	push	r30
    1918:	ff 93       	push	r31
    191a:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    191e:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1922:	0d b6       	in	r0, 0x3d	; 61
    1924:	0d 92       	st	X+, r0
    1926:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1928:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    192a:	22 d6       	rcall	.+3140   	; 0x2570 <vTaskSwitchContext>
    192c:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1930:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1934:	cd 91       	ld	r28, X+
    1936:	cd bf       	out	0x3d, r28	; 61
    1938:	dd 91       	ld	r29, X+
    193a:	de bf       	out	0x3e, r29	; 62
    193c:	ff 91       	pop	r31
    193e:	ef 91       	pop	r30
    1940:	df 91       	pop	r29
    1942:	cf 91       	pop	r28
    1944:	bf 91       	pop	r27
    1946:	af 91       	pop	r26
    1948:	9f 91       	pop	r25
    194a:	8f 91       	pop	r24
    194c:	7f 91       	pop	r23
    194e:	6f 91       	pop	r22
    1950:	5f 91       	pop	r21
    1952:	4f 91       	pop	r20
    1954:	3f 91       	pop	r19
    1956:	2f 91       	pop	r18
    1958:	1f 91       	pop	r17
    195a:	0f 91       	pop	r16
    195c:	ff 90       	pop	r15
    195e:	ef 90       	pop	r14
    1960:	df 90       	pop	r13
    1962:	cf 90       	pop	r12
    1964:	bf 90       	pop	r11
    1966:	af 90       	pop	r10
    1968:	9f 90       	pop	r9
    196a:	8f 90       	pop	r8
    196c:	7f 90       	pop	r7
    196e:	6f 90       	pop	r6
    1970:	5f 90       	pop	r5
    1972:	4f 90       	pop	r4
    1974:	3f 90       	pop	r3
    1976:	2f 90       	pop	r2
    1978:	1f 90       	pop	r1
    197a:	0f 90       	pop	r0
    197c:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    197e:	0f 90       	pop	r0
    1980:	08 95       	ret

00001982 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1982:	0f 92       	push	r0
    1984:	0f b6       	in	r0, 0x3f	; 63
    1986:	f8 94       	cli
    1988:	0f 92       	push	r0
    198a:	1f 92       	push	r1
    198c:	11 24       	eor	r1, r1
    198e:	2f 92       	push	r2
    1990:	3f 92       	push	r3
    1992:	4f 92       	push	r4
    1994:	5f 92       	push	r5
    1996:	6f 92       	push	r6
    1998:	7f 92       	push	r7
    199a:	8f 92       	push	r8
    199c:	9f 92       	push	r9
    199e:	af 92       	push	r10
    19a0:	bf 92       	push	r11
    19a2:	cf 92       	push	r12
    19a4:	df 92       	push	r13
    19a6:	ef 92       	push	r14
    19a8:	ff 92       	push	r15
    19aa:	0f 93       	push	r16
    19ac:	1f 93       	push	r17
    19ae:	2f 93       	push	r18
    19b0:	3f 93       	push	r19
    19b2:	4f 93       	push	r20
    19b4:	5f 93       	push	r21
    19b6:	6f 93       	push	r22
    19b8:	7f 93       	push	r23
    19ba:	8f 93       	push	r24
    19bc:	9f 93       	push	r25
    19be:	af 93       	push	r26
    19c0:	bf 93       	push	r27
    19c2:	cf 93       	push	r28
    19c4:	df 93       	push	r29
    19c6:	ef 93       	push	r30
    19c8:	ff 93       	push	r31
    19ca:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    19ce:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    19d2:	0d b6       	in	r0, 0x3d	; 61
    19d4:	0d 92       	st	X+, r0
    19d6:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    19d8:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    19da:	53 d4       	rcall	.+2214   	; 0x2282 <xTaskIncrementTick>
    19dc:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    19de:	c8 d5       	rcall	.+2960   	; 0x2570 <vTaskSwitchContext>
    19e0:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    19e4:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    19e8:	cd 91       	ld	r28, X+
    19ea:	cd bf       	out	0x3d, r28	; 61
    19ec:	dd 91       	ld	r29, X+
    19ee:	de bf       	out	0x3e, r29	; 62
    19f0:	ff 91       	pop	r31
    19f2:	ef 91       	pop	r30
    19f4:	df 91       	pop	r29
    19f6:	cf 91       	pop	r28
    19f8:	bf 91       	pop	r27
    19fa:	af 91       	pop	r26
    19fc:	9f 91       	pop	r25
    19fe:	8f 91       	pop	r24
    1a00:	7f 91       	pop	r23
    1a02:	6f 91       	pop	r22
    1a04:	5f 91       	pop	r21
    1a06:	4f 91       	pop	r20
    1a08:	3f 91       	pop	r19
    1a0a:	2f 91       	pop	r18
    1a0c:	1f 91       	pop	r17
    1a0e:	0f 91       	pop	r16
    1a10:	ff 90       	pop	r15
    1a12:	ef 90       	pop	r14
    1a14:	df 90       	pop	r13
    1a16:	cf 90       	pop	r12
    1a18:	bf 90       	pop	r11
    1a1a:	af 90       	pop	r10
    1a1c:	9f 90       	pop	r9
    1a1e:	8f 90       	pop	r8
    1a20:	7f 90       	pop	r7
    1a22:	6f 90       	pop	r6
    1a24:	5f 90       	pop	r5
    1a26:	4f 90       	pop	r4
    1a28:	3f 90       	pop	r3
    1a2a:	2f 90       	pop	r2
    1a2c:	1f 90       	pop	r1
    1a2e:	0f 90       	pop	r0
    1a30:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1a32:	0f 90       	pop	r0
    1a34:	08 95       	ret

00001a36 <__vector_12>:
    1a36:	a5 df       	rcall	.-182    	; 0x1982 <vPortYieldFromTick>
    1a38:	18 95       	reti

00001a3a <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1a3a:	0f 93       	push	r16
    1a3c:	1f 93       	push	r17
    1a3e:	cf 93       	push	r28
    1a40:	df 93       	push	r29
    1a42:	ec 01       	movw	r28, r24
    1a44:	04 2f       	mov	r16, r20
    1a46:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1a48:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1a4a:	41 11       	cpse	r20, r1
    1a4c:	0b c0       	rjmp	.+22     	; 0x1a64 <prvCopyDataToQueue+0x2a>
    1a4e:	88 81       	ld	r24, Y
    1a50:	99 81       	ldd	r25, Y+1	; 0x01
    1a52:	89 2b       	or	r24, r25
    1a54:	09 f0       	breq	.+2      	; 0x1a58 <prvCopyDataToQueue+0x1e>
    1a56:	3f c0       	rjmp	.+126    	; 0x1ad6 <prvCopyDataToQueue+0x9c>
    1a58:	8a 81       	ldd	r24, Y+2	; 0x02
    1a5a:	9b 81       	ldd	r25, Y+3	; 0x03
    1a5c:	08 d7       	rcall	.+3600   	; 0x286e <xTaskPriorityDisinherit>
    1a5e:	1b 82       	std	Y+3, r1	; 0x03
    1a60:	1a 82       	std	Y+2, r1	; 0x02
    1a62:	40 c0       	rjmp	.+128    	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1a64:	01 11       	cpse	r16, r1
    1a66:	16 c0       	rjmp	.+44     	; 0x1a94 <prvCopyDataToQueue+0x5a>
    1a68:	50 e0       	ldi	r21, 0x00	; 0
    1a6a:	8c 81       	ldd	r24, Y+4	; 0x04
    1a6c:	9d 81       	ldd	r25, Y+5	; 0x05
    1a6e:	5a d7       	rcall	.+3764   	; 0x2924 <memcpy>
    1a70:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1a72:	8c 81       	ldd	r24, Y+4	; 0x04
    1a74:	9d 81       	ldd	r25, Y+5	; 0x05
    1a76:	82 0f       	add	r24, r18
    1a78:	91 1d       	adc	r25, r1
    1a7a:	9d 83       	std	Y+5, r25	; 0x05
    1a7c:	8c 83       	std	Y+4, r24	; 0x04
    1a7e:	2a 81       	ldd	r18, Y+2	; 0x02
    1a80:	3b 81       	ldd	r19, Y+3	; 0x03
    1a82:	82 17       	cp	r24, r18
    1a84:	93 07       	cpc	r25, r19
    1a86:	48 f1       	brcs	.+82     	; 0x1ada <prvCopyDataToQueue+0xa0>
    1a88:	88 81       	ld	r24, Y
    1a8a:	99 81       	ldd	r25, Y+1	; 0x01
    1a8c:	9d 83       	std	Y+5, r25	; 0x05
    1a8e:	8c 83       	std	Y+4, r24	; 0x04
    1a90:	80 e0       	ldi	r24, 0x00	; 0
    1a92:	28 c0       	rjmp	.+80     	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1a94:	50 e0       	ldi	r21, 0x00	; 0
    1a96:	8e 81       	ldd	r24, Y+6	; 0x06
    1a98:	9f 81       	ldd	r25, Y+7	; 0x07
    1a9a:	44 d7       	rcall	.+3720   	; 0x2924 <memcpy>
    1a9c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1a9e:	90 e0       	ldi	r25, 0x00	; 0
    1aa0:	91 95       	neg	r25
    1aa2:	81 95       	neg	r24
    1aa4:	91 09       	sbc	r25, r1
    1aa6:	2e 81       	ldd	r18, Y+6	; 0x06
    1aa8:	3f 81       	ldd	r19, Y+7	; 0x07
    1aaa:	28 0f       	add	r18, r24
    1aac:	39 1f       	adc	r19, r25
    1aae:	3f 83       	std	Y+7, r19	; 0x07
    1ab0:	2e 83       	std	Y+6, r18	; 0x06
    1ab2:	48 81       	ld	r20, Y
    1ab4:	59 81       	ldd	r21, Y+1	; 0x01
    1ab6:	24 17       	cp	r18, r20
    1ab8:	35 07       	cpc	r19, r21
    1aba:	30 f4       	brcc	.+12     	; 0x1ac8 <prvCopyDataToQueue+0x8e>
    1abc:	2a 81       	ldd	r18, Y+2	; 0x02
    1abe:	3b 81       	ldd	r19, Y+3	; 0x03
    1ac0:	82 0f       	add	r24, r18
    1ac2:	93 1f       	adc	r25, r19
    1ac4:	9f 83       	std	Y+7, r25	; 0x07
    1ac6:	8e 83       	std	Y+6, r24	; 0x06
    1ac8:	02 30       	cpi	r16, 0x02	; 2
    1aca:	49 f4       	brne	.+18     	; 0x1ade <prvCopyDataToQueue+0xa4>
    1acc:	11 23       	and	r17, r17
    1ace:	49 f0       	breq	.+18     	; 0x1ae2 <prvCopyDataToQueue+0xa8>
    1ad0:	11 50       	subi	r17, 0x01	; 1
    1ad2:	80 e0       	ldi	r24, 0x00	; 0
    1ad4:	07 c0       	rjmp	.+14     	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1ad6:	80 e0       	ldi	r24, 0x00	; 0
    1ad8:	05 c0       	rjmp	.+10     	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1ada:	80 e0       	ldi	r24, 0x00	; 0
    1adc:	03 c0       	rjmp	.+6      	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	01 c0       	rjmp	.+2      	; 0x1ae4 <prvCopyDataToQueue+0xaa>
    1ae2:	80 e0       	ldi	r24, 0x00	; 0
    1ae4:	1f 5f       	subi	r17, 0xFF	; 255
    1ae6:	1a 8f       	std	Y+26, r17	; 0x1a
    1ae8:	df 91       	pop	r29
    1aea:	cf 91       	pop	r28
    1aec:	1f 91       	pop	r17
    1aee:	0f 91       	pop	r16
    1af0:	08 95       	ret

00001af2 <prvCopyDataFromQueue>:
    1af2:	fc 01       	movw	r30, r24
    1af4:	44 8d       	ldd	r20, Z+28	; 0x1c
    1af6:	44 23       	and	r20, r20
    1af8:	a1 f0       	breq	.+40     	; 0x1b22 <prvCopyDataFromQueue+0x30>
    1afa:	50 e0       	ldi	r21, 0x00	; 0
    1afc:	26 81       	ldd	r18, Z+6	; 0x06
    1afe:	37 81       	ldd	r19, Z+7	; 0x07
    1b00:	24 0f       	add	r18, r20
    1b02:	35 1f       	adc	r19, r21
    1b04:	37 83       	std	Z+7, r19	; 0x07
    1b06:	26 83       	std	Z+6, r18	; 0x06
    1b08:	82 81       	ldd	r24, Z+2	; 0x02
    1b0a:	93 81       	ldd	r25, Z+3	; 0x03
    1b0c:	28 17       	cp	r18, r24
    1b0e:	39 07       	cpc	r19, r25
    1b10:	20 f0       	brcs	.+8      	; 0x1b1a <prvCopyDataFromQueue+0x28>
    1b12:	80 81       	ld	r24, Z
    1b14:	91 81       	ldd	r25, Z+1	; 0x01
    1b16:	97 83       	std	Z+7, r25	; 0x07
    1b18:	86 83       	std	Z+6, r24	; 0x06
    1b1a:	cb 01       	movw	r24, r22
    1b1c:	66 81       	ldd	r22, Z+6	; 0x06
    1b1e:	77 81       	ldd	r23, Z+7	; 0x07
    1b20:	01 c7       	rjmp	.+3586   	; 0x2924 <memcpy>
    1b22:	08 95       	ret

00001b24 <prvUnlockQueue>:
    1b24:	ef 92       	push	r14
    1b26:	ff 92       	push	r15
    1b28:	0f 93       	push	r16
    1b2a:	1f 93       	push	r17
    1b2c:	cf 93       	push	r28
    1b2e:	8c 01       	movw	r16, r24
    1b30:	0f b6       	in	r0, 0x3f	; 63
    1b32:	f8 94       	cli
    1b34:	0f 92       	push	r0
    1b36:	fc 01       	movw	r30, r24
    1b38:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1b3a:	1c 16       	cp	r1, r28
    1b3c:	9c f4       	brge	.+38     	; 0x1b64 <prvUnlockQueue+0x40>
    1b3e:	81 89       	ldd	r24, Z+17	; 0x11
    1b40:	81 11       	cpse	r24, r1
    1b42:	06 c0       	rjmp	.+12     	; 0x1b50 <prvUnlockQueue+0x2c>
    1b44:	0f c0       	rjmp	.+30     	; 0x1b64 <prvUnlockQueue+0x40>
    1b46:	f8 01       	movw	r30, r16
    1b48:	81 89       	ldd	r24, Z+17	; 0x11
    1b4a:	81 11       	cpse	r24, r1
    1b4c:	05 c0       	rjmp	.+10     	; 0x1b58 <prvUnlockQueue+0x34>
    1b4e:	0a c0       	rjmp	.+20     	; 0x1b64 <prvUnlockQueue+0x40>
    1b50:	78 01       	movw	r14, r16
    1b52:	f1 e1       	ldi	r31, 0x11	; 17
    1b54:	ef 0e       	add	r14, r31
    1b56:	f1 1c       	adc	r15, r1
    1b58:	c7 01       	movw	r24, r14
    1b5a:	9a d5       	rcall	.+2868   	; 0x2690 <xTaskRemoveFromEventList>
    1b5c:	81 11       	cpse	r24, r1
    1b5e:	21 d6       	rcall	.+3138   	; 0x27a2 <vTaskMissedYield>
    1b60:	c1 50       	subi	r28, 0x01	; 1
    1b62:	89 f7       	brne	.-30     	; 0x1b46 <prvUnlockQueue+0x22>
    1b64:	8f ef       	ldi	r24, 0xFF	; 255
    1b66:	f8 01       	movw	r30, r16
    1b68:	86 8f       	std	Z+30, r24	; 0x1e
    1b6a:	0f 90       	pop	r0
    1b6c:	0f be       	out	0x3f, r0	; 63
    1b6e:	0f b6       	in	r0, 0x3f	; 63
    1b70:	f8 94       	cli
    1b72:	0f 92       	push	r0
    1b74:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1b76:	1c 16       	cp	r1, r28
    1b78:	9c f4       	brge	.+38     	; 0x1ba0 <prvUnlockQueue+0x7c>
    1b7a:	80 85       	ldd	r24, Z+8	; 0x08
    1b7c:	81 11       	cpse	r24, r1
    1b7e:	06 c0       	rjmp	.+12     	; 0x1b8c <prvUnlockQueue+0x68>
    1b80:	0f c0       	rjmp	.+30     	; 0x1ba0 <prvUnlockQueue+0x7c>
    1b82:	f8 01       	movw	r30, r16
    1b84:	80 85       	ldd	r24, Z+8	; 0x08
    1b86:	81 11       	cpse	r24, r1
    1b88:	05 c0       	rjmp	.+10     	; 0x1b94 <prvUnlockQueue+0x70>
    1b8a:	0a c0       	rjmp	.+20     	; 0x1ba0 <prvUnlockQueue+0x7c>
    1b8c:	78 01       	movw	r14, r16
    1b8e:	f8 e0       	ldi	r31, 0x08	; 8
    1b90:	ef 0e       	add	r14, r31
    1b92:	f1 1c       	adc	r15, r1
    1b94:	c7 01       	movw	r24, r14
    1b96:	7c d5       	rcall	.+2808   	; 0x2690 <xTaskRemoveFromEventList>
    1b98:	81 11       	cpse	r24, r1
    1b9a:	03 d6       	rcall	.+3078   	; 0x27a2 <vTaskMissedYield>
    1b9c:	c1 50       	subi	r28, 0x01	; 1
    1b9e:	89 f7       	brne	.-30     	; 0x1b82 <prvUnlockQueue+0x5e>
    1ba0:	8f ef       	ldi	r24, 0xFF	; 255
    1ba2:	f8 01       	movw	r30, r16
    1ba4:	85 8f       	std	Z+29, r24	; 0x1d
    1ba6:	0f 90       	pop	r0
    1ba8:	0f be       	out	0x3f, r0	; 63
    1baa:	cf 91       	pop	r28
    1bac:	1f 91       	pop	r17
    1bae:	0f 91       	pop	r16
    1bb0:	ff 90       	pop	r15
    1bb2:	ef 90       	pop	r14
    1bb4:	08 95       	ret

00001bb6 <xQueueGenericReset>:
    1bb6:	cf 93       	push	r28
    1bb8:	df 93       	push	r29
    1bba:	ec 01       	movw	r28, r24
    1bbc:	0f b6       	in	r0, 0x3f	; 63
    1bbe:	f8 94       	cli
    1bc0:	0f 92       	push	r0
    1bc2:	48 81       	ld	r20, Y
    1bc4:	59 81       	ldd	r21, Y+1	; 0x01
    1bc6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1bc8:	30 e0       	ldi	r19, 0x00	; 0
    1bca:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1bcc:	72 9f       	mul	r23, r18
    1bce:	c0 01       	movw	r24, r0
    1bd0:	73 9f       	mul	r23, r19
    1bd2:	90 0d       	add	r25, r0
    1bd4:	11 24       	eor	r1, r1
    1bd6:	fa 01       	movw	r30, r20
    1bd8:	e8 0f       	add	r30, r24
    1bda:	f9 1f       	adc	r31, r25
    1bdc:	fb 83       	std	Y+3, r31	; 0x03
    1bde:	ea 83       	std	Y+2, r30	; 0x02
    1be0:	1a 8e       	std	Y+26, r1	; 0x1a
    1be2:	5d 83       	std	Y+5, r21	; 0x05
    1be4:	4c 83       	std	Y+4, r20	; 0x04
    1be6:	82 1b       	sub	r24, r18
    1be8:	93 0b       	sbc	r25, r19
    1bea:	84 0f       	add	r24, r20
    1bec:	95 1f       	adc	r25, r21
    1bee:	9f 83       	std	Y+7, r25	; 0x07
    1bf0:	8e 83       	std	Y+6, r24	; 0x06
    1bf2:	8f ef       	ldi	r24, 0xFF	; 255
    1bf4:	8d 8f       	std	Y+29, r24	; 0x1d
    1bf6:	8e 8f       	std	Y+30, r24	; 0x1e
    1bf8:	61 11       	cpse	r22, r1
    1bfa:	0a c0       	rjmp	.+20     	; 0x1c10 <xQueueGenericReset+0x5a>
    1bfc:	88 85       	ldd	r24, Y+8	; 0x08
    1bfe:	88 23       	and	r24, r24
    1c00:	69 f0       	breq	.+26     	; 0x1c1c <xQueueGenericReset+0x66>
    1c02:	ce 01       	movw	r24, r28
    1c04:	08 96       	adiw	r24, 0x08	; 8
    1c06:	44 d5       	rcall	.+2696   	; 0x2690 <xTaskRemoveFromEventList>
    1c08:	88 23       	and	r24, r24
    1c0a:	41 f0       	breq	.+16     	; 0x1c1c <xQueueGenericReset+0x66>
    1c0c:	62 de       	rcall	.-828    	; 0x18d2 <vPortYield>
    1c0e:	06 c0       	rjmp	.+12     	; 0x1c1c <xQueueGenericReset+0x66>
    1c10:	ce 01       	movw	r24, r28
    1c12:	08 96       	adiw	r24, 0x08	; 8
    1c14:	33 dd       	rcall	.-1434   	; 0x167c <vListInitialise>
    1c16:	ce 01       	movw	r24, r28
    1c18:	41 96       	adiw	r24, 0x11	; 17
    1c1a:	30 dd       	rcall	.-1440   	; 0x167c <vListInitialise>
    1c1c:	0f 90       	pop	r0
    1c1e:	0f be       	out	0x3f, r0	; 63
    1c20:	81 e0       	ldi	r24, 0x01	; 1
    1c22:	df 91       	pop	r29
    1c24:	cf 91       	pop	r28
    1c26:	08 95       	ret

00001c28 <xQueueGenericCreate>:
    1c28:	0f 93       	push	r16
    1c2a:	1f 93       	push	r17
    1c2c:	cf 93       	push	r28
    1c2e:	df 93       	push	r29
    1c30:	08 2f       	mov	r16, r24
    1c32:	16 2f       	mov	r17, r22
    1c34:	66 23       	and	r22, r22
    1c36:	b1 f0       	breq	.+44     	; 0x1c64 <xQueueGenericCreate+0x3c>
    1c38:	86 9f       	mul	r24, r22
    1c3a:	c0 01       	movw	r24, r0
    1c3c:	11 24       	eor	r1, r1
    1c3e:	4f 96       	adiw	r24, 0x1f	; 31
    1c40:	e9 dc       	rcall	.-1582   	; 0x1614 <pvPortMalloc>
    1c42:	ec 01       	movw	r28, r24
    1c44:	00 97       	sbiw	r24, 0x00	; 0
    1c46:	39 f4       	brne	.+14     	; 0x1c56 <xQueueGenericCreate+0x2e>
    1c48:	13 c0       	rjmp	.+38     	; 0x1c70 <xQueueGenericCreate+0x48>
    1c4a:	0b 8f       	std	Y+27, r16	; 0x1b
    1c4c:	1c 8f       	std	Y+28, r17	; 0x1c
    1c4e:	61 e0       	ldi	r22, 0x01	; 1
    1c50:	ce 01       	movw	r24, r28
    1c52:	b1 df       	rcall	.-158    	; 0x1bb6 <xQueueGenericReset>
    1c54:	0d c0       	rjmp	.+26     	; 0x1c70 <xQueueGenericCreate+0x48>
    1c56:	4f 96       	adiw	r24, 0x1f	; 31
    1c58:	99 83       	std	Y+1, r25	; 0x01
    1c5a:	88 83       	st	Y, r24
    1c5c:	f6 cf       	rjmp	.-20     	; 0x1c4a <xQueueGenericCreate+0x22>
    1c5e:	d9 83       	std	Y+1, r29	; 0x01
    1c60:	c8 83       	st	Y, r28
    1c62:	f3 cf       	rjmp	.-26     	; 0x1c4a <xQueueGenericCreate+0x22>
    1c64:	8f e1       	ldi	r24, 0x1F	; 31
    1c66:	90 e0       	ldi	r25, 0x00	; 0
    1c68:	d5 dc       	rcall	.-1622   	; 0x1614 <pvPortMalloc>
    1c6a:	ec 01       	movw	r28, r24
    1c6c:	89 2b       	or	r24, r25
    1c6e:	b9 f7       	brne	.-18     	; 0x1c5e <xQueueGenericCreate+0x36>
    1c70:	ce 01       	movw	r24, r28
    1c72:	df 91       	pop	r29
    1c74:	cf 91       	pop	r28
    1c76:	1f 91       	pop	r17
    1c78:	0f 91       	pop	r16
    1c7a:	08 95       	ret

00001c7c <xQueueGenericSend>:
    1c7c:	9f 92       	push	r9
    1c7e:	af 92       	push	r10
    1c80:	bf 92       	push	r11
    1c82:	cf 92       	push	r12
    1c84:	df 92       	push	r13
    1c86:	ef 92       	push	r14
    1c88:	ff 92       	push	r15
    1c8a:	0f 93       	push	r16
    1c8c:	1f 93       	push	r17
    1c8e:	cf 93       	push	r28
    1c90:	df 93       	push	r29
    1c92:	00 d0       	rcall	.+0      	; 0x1c94 <xQueueGenericSend+0x18>
    1c94:	00 d0       	rcall	.+0      	; 0x1c96 <xQueueGenericSend+0x1a>
    1c96:	1f 92       	push	r1
    1c98:	cd b7       	in	r28, 0x3d	; 61
    1c9a:	de b7       	in	r29, 0x3e	; 62
    1c9c:	8c 01       	movw	r16, r24
    1c9e:	6b 01       	movw	r12, r22
    1ca0:	5d 83       	std	Y+5, r21	; 0x05
    1ca2:	4c 83       	std	Y+4, r20	; 0x04
    1ca4:	a2 2e       	mov	r10, r18
    1ca6:	b1 2c       	mov	r11, r1
    1ca8:	99 24       	eor	r9, r9
    1caa:	93 94       	inc	r9
    1cac:	7c 01       	movw	r14, r24
    1cae:	88 e0       	ldi	r24, 0x08	; 8
    1cb0:	e8 0e       	add	r14, r24
    1cb2:	f1 1c       	adc	r15, r1
    1cb4:	0f b6       	in	r0, 0x3f	; 63
    1cb6:	f8 94       	cli
    1cb8:	0f 92       	push	r0
    1cba:	f8 01       	movw	r30, r16
    1cbc:	92 8d       	ldd	r25, Z+26	; 0x1a
    1cbe:	83 8d       	ldd	r24, Z+27	; 0x1b
    1cc0:	98 17       	cp	r25, r24
    1cc2:	18 f0       	brcs	.+6      	; 0x1cca <xQueueGenericSend+0x4e>
    1cc4:	f2 e0       	ldi	r31, 0x02	; 2
    1cc6:	af 12       	cpse	r10, r31
    1cc8:	15 c0       	rjmp	.+42     	; 0x1cf4 <xQueueGenericSend+0x78>
    1cca:	4a 2d       	mov	r20, r10
    1ccc:	b6 01       	movw	r22, r12
    1cce:	c8 01       	movw	r24, r16
    1cd0:	b4 de       	rcall	.-664    	; 0x1a3a <prvCopyDataToQueue>
    1cd2:	f8 01       	movw	r30, r16
    1cd4:	91 89       	ldd	r25, Z+17	; 0x11
    1cd6:	99 23       	and	r25, r25
    1cd8:	39 f0       	breq	.+14     	; 0x1ce8 <xQueueGenericSend+0x6c>
    1cda:	c8 01       	movw	r24, r16
    1cdc:	41 96       	adiw	r24, 0x11	; 17
    1cde:	d8 d4       	rcall	.+2480   	; 0x2690 <xTaskRemoveFromEventList>
    1ce0:	88 23       	and	r24, r24
    1ce2:	21 f0       	breq	.+8      	; 0x1cec <xQueueGenericSend+0x70>
    1ce4:	f6 dd       	rcall	.-1044   	; 0x18d2 <vPortYield>
    1ce6:	02 c0       	rjmp	.+4      	; 0x1cec <xQueueGenericSend+0x70>
    1ce8:	81 11       	cpse	r24, r1
    1cea:	f3 dd       	rcall	.-1050   	; 0x18d2 <vPortYield>
    1cec:	0f 90       	pop	r0
    1cee:	0f be       	out	0x3f, r0	; 63
    1cf0:	81 e0       	ldi	r24, 0x01	; 1
    1cf2:	45 c0       	rjmp	.+138    	; 0x1d7e <xQueueGenericSend+0x102>
    1cf4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf8:	89 2b       	or	r24, r25
    1cfa:	21 f4       	brne	.+8      	; 0x1d04 <xQueueGenericSend+0x88>
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63
    1d00:	80 e0       	ldi	r24, 0x00	; 0
    1d02:	3d c0       	rjmp	.+122    	; 0x1d7e <xQueueGenericSend+0x102>
    1d04:	b1 10       	cpse	r11, r1
    1d06:	04 c0       	rjmp	.+8      	; 0x1d10 <xQueueGenericSend+0x94>
    1d08:	ce 01       	movw	r24, r28
    1d0a:	01 96       	adiw	r24, 0x01	; 1
    1d0c:	07 d5       	rcall	.+2574   	; 0x271c <vTaskSetTimeOutState>
    1d0e:	b9 2c       	mov	r11, r9
    1d10:	0f 90       	pop	r0
    1d12:	0f be       	out	0x3f, r0	; 63
    1d14:	b0 d2       	rcall	.+1376   	; 0x2276 <vTaskSuspendAll>
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	f8 94       	cli
    1d1a:	0f 92       	push	r0
    1d1c:	f8 01       	movw	r30, r16
    1d1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d20:	8f 3f       	cpi	r24, 0xFF	; 255
    1d22:	09 f4       	brne	.+2      	; 0x1d26 <xQueueGenericSend+0xaa>
    1d24:	15 8e       	std	Z+29, r1	; 0x1d
    1d26:	f8 01       	movw	r30, r16
    1d28:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d2a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d2c:	09 f4       	brne	.+2      	; 0x1d30 <xQueueGenericSend+0xb4>
    1d2e:	16 8e       	std	Z+30, r1	; 0x1e
    1d30:	0f 90       	pop	r0
    1d32:	0f be       	out	0x3f, r0	; 63
    1d34:	be 01       	movw	r22, r28
    1d36:	6c 5f       	subi	r22, 0xFC	; 252
    1d38:	7f 4f       	sbci	r23, 0xFF	; 255
    1d3a:	ce 01       	movw	r24, r28
    1d3c:	01 96       	adiw	r24, 0x01	; 1
    1d3e:	f9 d4       	rcall	.+2546   	; 0x2732 <xTaskCheckForTimeOut>
    1d40:	81 11       	cpse	r24, r1
    1d42:	19 c0       	rjmp	.+50     	; 0x1d76 <xQueueGenericSend+0xfa>
    1d44:	0f b6       	in	r0, 0x3f	; 63
    1d46:	f8 94       	cli
    1d48:	0f 92       	push	r0
    1d4a:	f8 01       	movw	r30, r16
    1d4c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d4e:	0f 90       	pop	r0
    1d50:	0f be       	out	0x3f, r0	; 63
    1d52:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d54:	98 13       	cpse	r25, r24
    1d56:	0b c0       	rjmp	.+22     	; 0x1d6e <xQueueGenericSend+0xf2>
    1d58:	6c 81       	ldd	r22, Y+4	; 0x04
    1d5a:	7d 81       	ldd	r23, Y+5	; 0x05
    1d5c:	c7 01       	movw	r24, r14
    1d5e:	88 d4       	rcall	.+2320   	; 0x2670 <vTaskPlaceOnEventList>
    1d60:	c8 01       	movw	r24, r16
    1d62:	e0 de       	rcall	.-576    	; 0x1b24 <prvUnlockQueue>
    1d64:	45 d3       	rcall	.+1674   	; 0x23f0 <xTaskResumeAll>
    1d66:	81 11       	cpse	r24, r1
    1d68:	a5 cf       	rjmp	.-182    	; 0x1cb4 <xQueueGenericSend+0x38>
    1d6a:	b3 dd       	rcall	.-1178   	; 0x18d2 <vPortYield>
    1d6c:	a3 cf       	rjmp	.-186    	; 0x1cb4 <xQueueGenericSend+0x38>
    1d6e:	c8 01       	movw	r24, r16
    1d70:	d9 de       	rcall	.-590    	; 0x1b24 <prvUnlockQueue>
    1d72:	3e d3       	rcall	.+1660   	; 0x23f0 <xTaskResumeAll>
    1d74:	9f cf       	rjmp	.-194    	; 0x1cb4 <xQueueGenericSend+0x38>
    1d76:	c8 01       	movw	r24, r16
    1d78:	d5 de       	rcall	.-598    	; 0x1b24 <prvUnlockQueue>
    1d7a:	3a d3       	rcall	.+1652   	; 0x23f0 <xTaskResumeAll>
    1d7c:	80 e0       	ldi	r24, 0x00	; 0
    1d7e:	0f 90       	pop	r0
    1d80:	0f 90       	pop	r0
    1d82:	0f 90       	pop	r0
    1d84:	0f 90       	pop	r0
    1d86:	0f 90       	pop	r0
    1d88:	df 91       	pop	r29
    1d8a:	cf 91       	pop	r28
    1d8c:	1f 91       	pop	r17
    1d8e:	0f 91       	pop	r16
    1d90:	ff 90       	pop	r15
    1d92:	ef 90       	pop	r14
    1d94:	df 90       	pop	r13
    1d96:	cf 90       	pop	r12
    1d98:	bf 90       	pop	r11
    1d9a:	af 90       	pop	r10
    1d9c:	9f 90       	pop	r9
    1d9e:	08 95       	ret

00001da0 <xQueueCreateMutex>:
    1da0:	cf 93       	push	r28
    1da2:	df 93       	push	r29
    1da4:	48 2f       	mov	r20, r24
    1da6:	60 e0       	ldi	r22, 0x00	; 0
    1da8:	81 e0       	ldi	r24, 0x01	; 1
    1daa:	3e df       	rcall	.-388    	; 0x1c28 <xQueueGenericCreate>
    1dac:	ec 01       	movw	r28, r24
    1dae:	00 97       	sbiw	r24, 0x00	; 0
    1db0:	59 f0       	breq	.+22     	; 0x1dc8 <xQueueCreateMutex+0x28>
    1db2:	1b 82       	std	Y+3, r1	; 0x03
    1db4:	1a 82       	std	Y+2, r1	; 0x02
    1db6:	19 82       	std	Y+1, r1	; 0x01
    1db8:	18 82       	st	Y, r1
    1dba:	1e 82       	std	Y+6, r1	; 0x06
    1dbc:	20 e0       	ldi	r18, 0x00	; 0
    1dbe:	40 e0       	ldi	r20, 0x00	; 0
    1dc0:	50 e0       	ldi	r21, 0x00	; 0
    1dc2:	60 e0       	ldi	r22, 0x00	; 0
    1dc4:	70 e0       	ldi	r23, 0x00	; 0
    1dc6:	5a df       	rcall	.-332    	; 0x1c7c <xQueueGenericSend>
    1dc8:	ce 01       	movw	r24, r28
    1dca:	df 91       	pop	r29
    1dcc:	cf 91       	pop	r28
    1dce:	08 95       	ret

00001dd0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1dd0:	8f 92       	push	r8
    1dd2:	9f 92       	push	r9
    1dd4:	af 92       	push	r10
    1dd6:	bf 92       	push	r11
    1dd8:	cf 92       	push	r12
    1dda:	df 92       	push	r13
    1ddc:	ef 92       	push	r14
    1dde:	ff 92       	push	r15
    1de0:	0f 93       	push	r16
    1de2:	1f 93       	push	r17
    1de4:	cf 93       	push	r28
    1de6:	df 93       	push	r29
    1de8:	00 d0       	rcall	.+0      	; 0x1dea <xQueueGenericReceive+0x1a>
    1dea:	00 d0       	rcall	.+0      	; 0x1dec <xQueueGenericReceive+0x1c>
    1dec:	1f 92       	push	r1
    1dee:	cd b7       	in	r28, 0x3d	; 61
    1df0:	de b7       	in	r29, 0x3e	; 62
    1df2:	8c 01       	movw	r16, r24
    1df4:	5b 01       	movw	r10, r22
    1df6:	5d 83       	std	Y+5, r21	; 0x05
    1df8:	4c 83       	std	Y+4, r20	; 0x04
    1dfa:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1dfc:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1dfe:	99 24       	eor	r9, r9
    1e00:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1e02:	6c 01       	movw	r12, r24
    1e04:	81 e1       	ldi	r24, 0x11	; 17
    1e06:	c8 0e       	add	r12, r24
    1e08:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1e0a:	0f b6       	in	r0, 0x3f	; 63
    1e0c:	f8 94       	cli
    1e0e:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1e10:	f8 01       	movw	r30, r16
    1e12:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1e14:	ff 20       	and	r15, r15
    1e16:	61 f1       	breq	.+88     	; 0x1e70 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1e18:	c6 80       	ldd	r12, Z+6	; 0x06
    1e1a:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1e1c:	b5 01       	movw	r22, r10
    1e1e:	c8 01       	movw	r24, r16
    1e20:	68 de       	rcall	.-816    	; 0x1af2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1e22:	81 10       	cpse	r8, r1
    1e24:	16 c0       	rjmp	.+44     	; 0x1e52 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1e26:	fa 94       	dec	r15
    1e28:	f8 01       	movw	r30, r16
    1e2a:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1e2c:	80 81       	ld	r24, Z
    1e2e:	91 81       	ldd	r25, Z+1	; 0x01
    1e30:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1e32:	21 f4       	brne	.+8      	; 0x1e3c <xQueueGenericReceive+0x6c>
    1e34:	5c d5       	rcall	.+2744   	; 0x28ee <pvTaskIncrementMutexHeldCount>
    1e36:	f8 01       	movw	r30, r16
    1e38:	93 83       	std	Z+3, r25	; 0x03
    1e3a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e3c:	f8 01       	movw	r30, r16
    1e3e:	80 85       	ldd	r24, Z+8	; 0x08
    1e40:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e42:	91 f0       	breq	.+36     	; 0x1e68 <xQueueGenericReceive+0x98>
    1e44:	c8 01       	movw	r24, r16
    1e46:	08 96       	adiw	r24, 0x08	; 8
    1e48:	23 d4       	rcall	.+2118   	; 0x2690 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1e4a:	88 23       	and	r24, r24
    1e4c:	69 f0       	breq	.+26     	; 0x1e68 <xQueueGenericReceive+0x98>
    1e4e:	41 dd       	rcall	.-1406   	; 0x18d2 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1e50:	0b c0       	rjmp	.+22     	; 0x1e68 <xQueueGenericReceive+0x98>
    1e52:	f8 01       	movw	r30, r16
    1e54:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e56:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e58:	81 89       	ldd	r24, Z+17	; 0x11
    1e5a:	88 23       	and	r24, r24
    1e5c:	29 f0       	breq	.+10     	; 0x1e68 <xQueueGenericReceive+0x98>
    1e5e:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1e60:	41 96       	adiw	r24, 0x11	; 17
    1e62:	16 d4       	rcall	.+2092   	; 0x2690 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1e64:	81 11       	cpse	r24, r1
    1e66:	35 dd       	rcall	.-1430   	; 0x18d2 <vPortYield>
				return pdPASS;
    1e68:	0f 90       	pop	r0
    1e6a:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
    1e6e:	58 c0       	rjmp	.+176    	; 0x1f20 <xQueueGenericReceive+0x150>
    1e70:	8c 81       	ldd	r24, Y+4	; 0x04
    1e72:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1e74:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1e76:	21 f4       	brne	.+8      	; 0x1e80 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    1e78:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1e7a:	0f be       	out	0x3f, r0	; 63
    1e7c:	80 e0       	ldi	r24, 0x00	; 0
    1e7e:	50 c0       	rjmp	.+160    	; 0x1f20 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    1e80:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1e82:	04 c0       	rjmp	.+8      	; 0x1e8c <xQueueGenericReceive+0xbc>
    1e84:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1e86:	01 96       	adiw	r24, 0x01	; 1
    1e88:	49 d4       	rcall	.+2194   	; 0x271c <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    1e8a:	e9 2c       	mov	r14, r9
    1e8c:	0f 90       	pop	r0
    1e8e:	0f be       	out	0x3f, r0	; 63
    1e90:	f2 d1       	rcall	.+996    	; 0x2276 <vTaskSuspendAll>
    1e92:	0f b6       	in	r0, 0x3f	; 63
    1e94:	f8 94       	cli
    1e96:	0f 92       	push	r0
    1e98:	f8 01       	movw	r30, r16
    1e9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e9c:	8f 3f       	cpi	r24, 0xFF	; 255
    1e9e:	09 f4       	brne	.+2      	; 0x1ea2 <xQueueGenericReceive+0xd2>
    1ea0:	15 8e       	std	Z+29, r1	; 0x1d
    1ea2:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1ea4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ea6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ea8:	09 f4       	brne	.+2      	; 0x1eac <xQueueGenericReceive+0xdc>
    1eaa:	16 8e       	std	Z+30, r1	; 0x1e
    1eac:	0f 90       	pop	r0
    1eae:	0f be       	out	0x3f, r0	; 63
    1eb0:	be 01       	movw	r22, r28
    1eb2:	6c 5f       	subi	r22, 0xFC	; 252
    1eb4:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1eb6:	ce 01       	movw	r24, r28
    1eb8:	01 96       	adiw	r24, 0x01	; 1
    1eba:	3b d4       	rcall	.+2166   	; 0x2732 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1ebc:	81 11       	cpse	r24, r1
    1ebe:	24 c0       	rjmp	.+72     	; 0x1f08 <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ec0:	0f b6       	in	r0, 0x3f	; 63
    1ec2:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ec4:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ec6:	f8 01       	movw	r30, r16
    1ec8:	82 8d       	ldd	r24, Z+26	; 0x1a
    1eca:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    1ecc:	0f be       	out	0x3f, r0	; 63
    1ece:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1ed0:	17 c0       	rjmp	.+46     	; 0x1f00 <xQueueGenericReceive+0x130>
    1ed2:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    1ed4:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ed6:	89 2b       	or	r24, r25
    1ed8:	41 f4       	brne	.+16     	; 0x1eea <xQueueGenericReceive+0x11a>
    1eda:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    1edc:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    1ede:	0f 92       	push	r0
    1ee0:	82 81       	ldd	r24, Z+2	; 0x02
    1ee2:	93 81       	ldd	r25, Z+3	; 0x03
    1ee4:	62 d4       	rcall	.+2244   	; 0x27aa <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    1ee6:	0f 90       	pop	r0
    1ee8:	0f be       	out	0x3f, r0	; 63
    1eea:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1eec:	7d 81       	ldd	r23, Y+5	; 0x05
    1eee:	c6 01       	movw	r24, r12
    1ef0:	bf d3       	rcall	.+1918   	; 0x2670 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    1ef2:	c8 01       	movw	r24, r16
    1ef4:	17 de       	rcall	.-978    	; 0x1b24 <prvUnlockQueue>
    1ef6:	7c d2       	rcall	.+1272   	; 0x23f0 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ef8:	81 11       	cpse	r24, r1
    1efa:	87 cf       	rjmp	.-242    	; 0x1e0a <xQueueGenericReceive+0x3a>
    1efc:	ea dc       	rcall	.-1580   	; 0x18d2 <vPortYield>
			( void ) xTaskResumeAll();
    1efe:	85 cf       	rjmp	.-246    	; 0x1e0a <xQueueGenericReceive+0x3a>
    1f00:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f02:	10 de       	rcall	.-992    	; 0x1b24 <prvUnlockQueue>
    1f04:	75 d2       	rcall	.+1258   	; 0x23f0 <xTaskResumeAll>
    1f06:	81 cf       	rjmp	.-254    	; 0x1e0a <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1f08:	c8 01       	movw	r24, r16
    1f0a:	0c de       	rcall	.-1000   	; 0x1b24 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1f0c:	71 d2       	rcall	.+1250   	; 0x23f0 <xTaskResumeAll>
    1f0e:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1f10:	f8 94       	cli
    1f12:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1f14:	f8 01       	movw	r30, r16
    1f16:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f18:	0f 90       	pop	r0
    1f1a:	0f be       	out	0x3f, r0	; 63
    1f1c:	81 11       	cpse	r24, r1
    1f1e:	75 cf       	rjmp	.-278    	; 0x1e0a <xQueueGenericReceive+0x3a>
    1f20:	0f 90       	pop	r0
    1f22:	0f 90       	pop	r0
    1f24:	0f 90       	pop	r0
    1f26:	0f 90       	pop	r0
    1f28:	0f 90       	pop	r0
    1f2a:	df 91       	pop	r29
    1f2c:	cf 91       	pop	r28
    1f2e:	1f 91       	pop	r17
    1f30:	0f 91       	pop	r16
    1f32:	ff 90       	pop	r15
    1f34:	ef 90       	pop	r14
    1f36:	df 90       	pop	r13
    1f38:	cf 90       	pop	r12
    1f3a:	bf 90       	pop	r11
    1f3c:	af 90       	pop	r10
    1f3e:	9f 90       	pop	r9
    1f40:	8f 90       	pop	r8
    1f42:	08 95       	ret

00001f44 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1f44:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    1f48:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    1f4c:	80 81       	ld	r24, Z
    1f4e:	81 11       	cpse	r24, r1
    1f50:	07 c0       	rjmp	.+14     	; 0x1f60 <prvResetNextTaskUnblockTime+0x1c>
    1f52:	8f ef       	ldi	r24, 0xFF	; 255
    1f54:	9f ef       	ldi	r25, 0xFF	; 255
    1f56:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <xNextTaskUnblockTime+0x1>
    1f5a:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <xNextTaskUnblockTime>
    1f5e:	08 95       	ret
    1f60:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    1f64:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    1f68:	05 80       	ldd	r0, Z+5	; 0x05
    1f6a:	f6 81       	ldd	r31, Z+6	; 0x06
    1f6c:	e0 2d       	mov	r30, r0
    1f6e:	06 80       	ldd	r0, Z+6	; 0x06
    1f70:	f7 81       	ldd	r31, Z+7	; 0x07
    1f72:	e0 2d       	mov	r30, r0
    1f74:	82 81       	ldd	r24, Z+2	; 0x02
    1f76:	93 81       	ldd	r25, Z+3	; 0x03
    1f78:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <xNextTaskUnblockTime+0x1>
    1f7c:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <xNextTaskUnblockTime>
    1f80:	08 95       	ret

00001f82 <prvAddCurrentTaskToDelayedList>:
    1f82:	ff 92       	push	r15
    1f84:	0f 93       	push	r16
    1f86:	1f 93       	push	r17
    1f88:	cf 93       	push	r28
    1f8a:	df 93       	push	r29
    1f8c:	ec 01       	movw	r28, r24
    1f8e:	f6 2e       	mov	r15, r22
    1f90:	00 91 46 0d 	lds	r16, 0x0D46	; 0x800d46 <xTickCount>
    1f94:	10 91 47 0d 	lds	r17, 0x0D47	; 0x800d47 <xTickCount+0x1>
    1f98:	80 91 9f 0d 	lds	r24, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1f9c:	90 91 a0 0d 	lds	r25, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1fa0:	02 96       	adiw	r24, 0x02	; 2
    1fa2:	d0 db       	rcall	.-2144   	; 0x1744 <uxListRemove>
    1fa4:	cf 3f       	cpi	r28, 0xFF	; 255
    1fa6:	8f ef       	ldi	r24, 0xFF	; 255
    1fa8:	d8 07       	cpc	r29, r24
    1faa:	61 f4       	brne	.+24     	; 0x1fc4 <prvAddCurrentTaskToDelayedList+0x42>
    1fac:	ff 20       	and	r15, r15
    1fae:	51 f0       	breq	.+20     	; 0x1fc4 <prvAddCurrentTaskToDelayedList+0x42>
    1fb0:	60 91 9f 0d 	lds	r22, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1fb4:	70 91 a0 0d 	lds	r23, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1fb8:	6e 5f       	subi	r22, 0xFE	; 254
    1fba:	7f 4f       	sbci	r23, 0xFF	; 255
    1fbc:	89 e4       	ldi	r24, 0x49	; 73
    1fbe:	9d e0       	ldi	r25, 0x0D	; 13
    1fc0:	6f db       	rcall	.-2338   	; 0x16a0 <vListInsertEnd>
    1fc2:	2d c0       	rjmp	.+90     	; 0x201e <prvAddCurrentTaskToDelayedList+0x9c>
    1fc4:	c0 0f       	add	r28, r16
    1fc6:	d1 1f       	adc	r29, r17
    1fc8:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1fcc:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1fd0:	d3 83       	std	Z+3, r29	; 0x03
    1fd2:	c2 83       	std	Z+2, r28	; 0x02
    1fd4:	c0 17       	cp	r28, r16
    1fd6:	d1 07       	cpc	r29, r17
    1fd8:	60 f4       	brcc	.+24     	; 0x1ff2 <prvAddCurrentTaskToDelayedList+0x70>
    1fda:	60 91 9f 0d 	lds	r22, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1fde:	70 91 a0 0d 	lds	r23, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1fe2:	80 91 65 0d 	lds	r24, 0x0D65	; 0x800d65 <pxOverflowDelayedTaskList>
    1fe6:	90 91 66 0d 	lds	r25, 0x0D66	; 0x800d66 <pxOverflowDelayedTaskList+0x1>
    1fea:	6e 5f       	subi	r22, 0xFE	; 254
    1fec:	7f 4f       	sbci	r23, 0xFF	; 255
    1fee:	79 db       	rcall	.-2318   	; 0x16e2 <vListInsert>
    1ff0:	16 c0       	rjmp	.+44     	; 0x201e <prvAddCurrentTaskToDelayedList+0x9c>
    1ff2:	60 91 9f 0d 	lds	r22, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    1ff6:	70 91 a0 0d 	lds	r23, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    1ffa:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    1ffe:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    2002:	6e 5f       	subi	r22, 0xFE	; 254
    2004:	7f 4f       	sbci	r23, 0xFF	; 255
    2006:	6d db       	rcall	.-2342   	; 0x16e2 <vListInsert>
    2008:	80 91 3e 0d 	lds	r24, 0x0D3E	; 0x800d3e <xNextTaskUnblockTime>
    200c:	90 91 3f 0d 	lds	r25, 0x0D3F	; 0x800d3f <xNextTaskUnblockTime+0x1>
    2010:	c8 17       	cp	r28, r24
    2012:	d9 07       	cpc	r29, r25
    2014:	20 f4       	brcc	.+8      	; 0x201e <prvAddCurrentTaskToDelayedList+0x9c>
    2016:	d0 93 3f 0d 	sts	0x0D3F, r29	; 0x800d3f <xNextTaskUnblockTime+0x1>
    201a:	c0 93 3e 0d 	sts	0x0D3E, r28	; 0x800d3e <xNextTaskUnblockTime>
    201e:	df 91       	pop	r29
    2020:	cf 91       	pop	r28
    2022:	1f 91       	pop	r17
    2024:	0f 91       	pop	r16
    2026:	ff 90       	pop	r15
    2028:	08 95       	ret

0000202a <xTaskCreate>:
    202a:	4f 92       	push	r4
    202c:	5f 92       	push	r5
    202e:	6f 92       	push	r6
    2030:	7f 92       	push	r7
    2032:	8f 92       	push	r8
    2034:	9f 92       	push	r9
    2036:	af 92       	push	r10
    2038:	bf 92       	push	r11
    203a:	cf 92       	push	r12
    203c:	df 92       	push	r13
    203e:	ef 92       	push	r14
    2040:	ff 92       	push	r15
    2042:	0f 93       	push	r16
    2044:	cf 93       	push	r28
    2046:	df 93       	push	r29
    2048:	4c 01       	movw	r8, r24
    204a:	6b 01       	movw	r12, r22
    204c:	5a 01       	movw	r10, r20
    204e:	29 01       	movw	r4, r18
    2050:	ca 01       	movw	r24, r20
    2052:	e0 da       	rcall	.-2624   	; 0x1614 <pvPortMalloc>
    2054:	3c 01       	movw	r6, r24
    2056:	89 2b       	or	r24, r25
    2058:	09 f4       	brne	.+2      	; 0x205c <xTaskCreate+0x32>
    205a:	d4 c0       	rjmp	.+424    	; 0x2204 <xTaskCreate+0x1da>
    205c:	88 e2       	ldi	r24, 0x28	; 40
    205e:	90 e0       	ldi	r25, 0x00	; 0
    2060:	d9 da       	rcall	.-2638   	; 0x1614 <pvPortMalloc>
    2062:	ec 01       	movw	r28, r24
    2064:	89 2b       	or	r24, r25
    2066:	71 f0       	breq	.+28     	; 0x2084 <xTaskCreate+0x5a>
    2068:	78 8e       	std	Y+24, r7	; 0x18
    206a:	6f 8a       	std	Y+23, r6	; 0x17
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	a8 1a       	sub	r10, r24
    2070:	b1 08       	sbc	r11, r1
    2072:	6a 0c       	add	r6, r10
    2074:	7b 1c       	adc	r7, r11
    2076:	d6 01       	movw	r26, r12
    2078:	8c 91       	ld	r24, X
    207a:	89 8f       	std	Y+25, r24	; 0x19
    207c:	8c 91       	ld	r24, X
    207e:	81 11       	cpse	r24, r1
    2080:	04 c0       	rjmp	.+8      	; 0x208a <xTaskCreate+0x60>
    2082:	17 c0       	rjmp	.+46     	; 0x20b2 <xTaskCreate+0x88>
    2084:	c3 01       	movw	r24, r6
    2086:	f9 da       	rcall	.-2574   	; 0x167a <vPortFree>
    2088:	bd c0       	rjmp	.+378    	; 0x2204 <xTaskCreate+0x1da>
    208a:	ae 01       	movw	r20, r28
    208c:	46 5e       	subi	r20, 0xE6	; 230
    208e:	5f 4f       	sbci	r21, 0xFF	; 255
    2090:	f6 01       	movw	r30, r12
    2092:	31 96       	adiw	r30, 0x01	; 1
    2094:	b8 e0       	ldi	r27, 0x08	; 8
    2096:	cb 0e       	add	r12, r27
    2098:	d1 1c       	adc	r13, r1
    209a:	cf 01       	movw	r24, r30
    209c:	21 91       	ld	r18, Z+
    209e:	da 01       	movw	r26, r20
    20a0:	2d 93       	st	X+, r18
    20a2:	ad 01       	movw	r20, r26
    20a4:	dc 01       	movw	r26, r24
    20a6:	8c 91       	ld	r24, X
    20a8:	88 23       	and	r24, r24
    20aa:	19 f0       	breq	.+6      	; 0x20b2 <xTaskCreate+0x88>
    20ac:	ec 15       	cp	r30, r12
    20ae:	fd 05       	cpc	r31, r13
    20b0:	a1 f7       	brne	.-24     	; 0x209a <xTaskCreate+0x70>
    20b2:	18 a2       	std	Y+32, r1	; 0x20
    20b4:	04 30       	cpi	r16, 0x04	; 4
    20b6:	08 f0       	brcs	.+2      	; 0x20ba <xTaskCreate+0x90>
    20b8:	03 e0       	ldi	r16, 0x03	; 3
    20ba:	0e 8b       	std	Y+22, r16	; 0x16
    20bc:	09 a3       	std	Y+33, r16	; 0x21
    20be:	1a a2       	std	Y+34, r1	; 0x22
    20c0:	6e 01       	movw	r12, r28
    20c2:	b2 e0       	ldi	r27, 0x02	; 2
    20c4:	cb 0e       	add	r12, r27
    20c6:	d1 1c       	adc	r13, r1
    20c8:	c6 01       	movw	r24, r12
    20ca:	e6 da       	rcall	.-2612   	; 0x1698 <vListInitialiseItem>
    20cc:	ce 01       	movw	r24, r28
    20ce:	0c 96       	adiw	r24, 0x0c	; 12
    20d0:	e3 da       	rcall	.-2618   	; 0x1698 <vListInitialiseItem>
    20d2:	d9 87       	std	Y+9, r29	; 0x09
    20d4:	c8 87       	std	Y+8, r28	; 0x08
    20d6:	84 e0       	ldi	r24, 0x04	; 4
    20d8:	90 e0       	ldi	r25, 0x00	; 0
    20da:	80 1b       	sub	r24, r16
    20dc:	91 09       	sbc	r25, r1
    20de:	9d 87       	std	Y+13, r25	; 0x0d
    20e0:	8c 87       	std	Y+12, r24	; 0x0c
    20e2:	db 8b       	std	Y+19, r29	; 0x13
    20e4:	ca 8b       	std	Y+18, r28	; 0x12
    20e6:	1b a2       	std	Y+35, r1	; 0x23
    20e8:	1c a2       	std	Y+36, r1	; 0x24
    20ea:	1d a2       	std	Y+37, r1	; 0x25
    20ec:	1e a2       	std	Y+38, r1	; 0x26
    20ee:	1f a2       	std	Y+39, r1	; 0x27
    20f0:	a2 01       	movw	r20, r4
    20f2:	b4 01       	movw	r22, r8
    20f4:	c3 01       	movw	r24, r6
    20f6:	4c db       	rcall	.-2408   	; 0x1790 <pxPortInitialiseStack>
    20f8:	99 83       	std	Y+1, r25	; 0x01
    20fa:	88 83       	st	Y, r24
    20fc:	e1 14       	cp	r14, r1
    20fe:	f1 04       	cpc	r15, r1
    2100:	19 f0       	breq	.+6      	; 0x2108 <xTaskCreate+0xde>
    2102:	f7 01       	movw	r30, r14
    2104:	d1 83       	std	Z+1, r29	; 0x01
    2106:	c0 83       	st	Z, r28
    2108:	0f b6       	in	r0, 0x3f	; 63
    210a:	f8 94       	cli
    210c:	0f 92       	push	r0
    210e:	80 91 48 0d 	lds	r24, 0x0D48	; 0x800d48 <uxCurrentNumberOfTasks>
    2112:	8f 5f       	subi	r24, 0xFF	; 255
    2114:	80 93 48 0d 	sts	0x0D48, r24	; 0x800d48 <uxCurrentNumberOfTasks>
    2118:	80 91 9f 0d 	lds	r24, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    211c:	90 91 a0 0d 	lds	r25, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2120:	89 2b       	or	r24, r25
    2122:	89 f5       	brne	.+98     	; 0x2186 <xTaskCreate+0x15c>
    2124:	d0 93 a0 0d 	sts	0x0DA0, r29	; 0x800da0 <pxCurrentTCB+0x1>
    2128:	c0 93 9f 0d 	sts	0x0D9F, r28	; 0x800d9f <pxCurrentTCB>
    212c:	80 91 48 0d 	lds	r24, 0x0D48	; 0x800d48 <uxCurrentNumberOfTasks>
    2130:	81 30       	cpi	r24, 0x01	; 1
    2132:	09 f0       	breq	.+2      	; 0x2136 <xTaskCreate+0x10c>
    2134:	38 c0       	rjmp	.+112    	; 0x21a6 <xTaskCreate+0x17c>
    2136:	8b e7       	ldi	r24, 0x7B	; 123
    2138:	9d e0       	ldi	r25, 0x0D	; 13
    213a:	a0 da       	rcall	.-2752   	; 0x167c <vListInitialise>
    213c:	84 e8       	ldi	r24, 0x84	; 132
    213e:	9d e0       	ldi	r25, 0x0D	; 13
    2140:	9d da       	rcall	.-2758   	; 0x167c <vListInitialise>
    2142:	8d e8       	ldi	r24, 0x8D	; 141
    2144:	9d e0       	ldi	r25, 0x0D	; 13
    2146:	9a da       	rcall	.-2764   	; 0x167c <vListInitialise>
    2148:	86 e9       	ldi	r24, 0x96	; 150
    214a:	9d e0       	ldi	r25, 0x0D	; 13
    214c:	97 da       	rcall	.-2770   	; 0x167c <vListInitialise>
    214e:	82 e7       	ldi	r24, 0x72	; 114
    2150:	9d e0       	ldi	r25, 0x0D	; 13
    2152:	94 da       	rcall	.-2776   	; 0x167c <vListInitialise>
    2154:	89 e6       	ldi	r24, 0x69	; 105
    2156:	9d e0       	ldi	r25, 0x0D	; 13
    2158:	91 da       	rcall	.-2782   	; 0x167c <vListInitialise>
    215a:	8c e5       	ldi	r24, 0x5C	; 92
    215c:	9d e0       	ldi	r25, 0x0D	; 13
    215e:	8e da       	rcall	.-2788   	; 0x167c <vListInitialise>
    2160:	83 e5       	ldi	r24, 0x53	; 83
    2162:	9d e0       	ldi	r25, 0x0D	; 13
    2164:	8b da       	rcall	.-2794   	; 0x167c <vListInitialise>
    2166:	89 e4       	ldi	r24, 0x49	; 73
    2168:	9d e0       	ldi	r25, 0x0D	; 13
    216a:	88 da       	rcall	.-2800   	; 0x167c <vListInitialise>
    216c:	82 e7       	ldi	r24, 0x72	; 114
    216e:	9d e0       	ldi	r25, 0x0D	; 13
    2170:	90 93 68 0d 	sts	0x0D68, r25	; 0x800d68 <pxDelayedTaskList+0x1>
    2174:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <pxDelayedTaskList>
    2178:	89 e6       	ldi	r24, 0x69	; 105
    217a:	9d e0       	ldi	r25, 0x0D	; 13
    217c:	90 93 66 0d 	sts	0x0D66, r25	; 0x800d66 <pxOverflowDelayedTaskList+0x1>
    2180:	80 93 65 0d 	sts	0x0D65, r24	; 0x800d65 <pxOverflowDelayedTaskList>
    2184:	10 c0       	rjmp	.+32     	; 0x21a6 <xTaskCreate+0x17c>
    2186:	80 91 44 0d 	lds	r24, 0x0D44	; 0x800d44 <xSchedulerRunning>
    218a:	81 11       	cpse	r24, r1
    218c:	0c c0       	rjmp	.+24     	; 0x21a6 <xTaskCreate+0x17c>
    218e:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2192:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2196:	96 89       	ldd	r25, Z+22	; 0x16
    2198:	8e 89       	ldd	r24, Y+22	; 0x16
    219a:	89 17       	cp	r24, r25
    219c:	20 f0       	brcs	.+8      	; 0x21a6 <xTaskCreate+0x17c>
    219e:	d0 93 a0 0d 	sts	0x0DA0, r29	; 0x800da0 <pxCurrentTCB+0x1>
    21a2:	c0 93 9f 0d 	sts	0x0D9F, r28	; 0x800d9f <pxCurrentTCB>
    21a6:	80 91 40 0d 	lds	r24, 0x0D40	; 0x800d40 <uxTaskNumber>
    21aa:	8f 5f       	subi	r24, 0xFF	; 255
    21ac:	80 93 40 0d 	sts	0x0D40, r24	; 0x800d40 <uxTaskNumber>
    21b0:	8e 89       	ldd	r24, Y+22	; 0x16
    21b2:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    21b6:	98 17       	cp	r25, r24
    21b8:	10 f4       	brcc	.+4      	; 0x21be <xTaskCreate+0x194>
    21ba:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    21be:	90 e0       	ldi	r25, 0x00	; 0
    21c0:	9c 01       	movw	r18, r24
    21c2:	22 0f       	add	r18, r18
    21c4:	33 1f       	adc	r19, r19
    21c6:	22 0f       	add	r18, r18
    21c8:	33 1f       	adc	r19, r19
    21ca:	22 0f       	add	r18, r18
    21cc:	33 1f       	adc	r19, r19
    21ce:	82 0f       	add	r24, r18
    21d0:	93 1f       	adc	r25, r19
    21d2:	b6 01       	movw	r22, r12
    21d4:	85 58       	subi	r24, 0x85	; 133
    21d6:	92 4f       	sbci	r25, 0xF2	; 242
    21d8:	63 da       	rcall	.-2874   	; 0x16a0 <vListInsertEnd>
    21da:	0f 90       	pop	r0
    21dc:	0f be       	out	0x3f, r0	; 63
    21de:	80 91 44 0d 	lds	r24, 0x0D44	; 0x800d44 <xSchedulerRunning>
    21e2:	88 23       	and	r24, r24
    21e4:	59 f0       	breq	.+22     	; 0x21fc <xTaskCreate+0x1d2>
    21e6:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    21ea:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    21ee:	96 89       	ldd	r25, Z+22	; 0x16
    21f0:	8e 89       	ldd	r24, Y+22	; 0x16
    21f2:	98 17       	cp	r25, r24
    21f4:	28 f4       	brcc	.+10     	; 0x2200 <xTaskCreate+0x1d6>
    21f6:	6d db       	rcall	.-2342   	; 0x18d2 <vPortYield>
    21f8:	81 e0       	ldi	r24, 0x01	; 1
    21fa:	05 c0       	rjmp	.+10     	; 0x2206 <xTaskCreate+0x1dc>
    21fc:	81 e0       	ldi	r24, 0x01	; 1
    21fe:	03 c0       	rjmp	.+6      	; 0x2206 <xTaskCreate+0x1dc>
    2200:	81 e0       	ldi	r24, 0x01	; 1
    2202:	01 c0       	rjmp	.+2      	; 0x2206 <xTaskCreate+0x1dc>
    2204:	8f ef       	ldi	r24, 0xFF	; 255
    2206:	df 91       	pop	r29
    2208:	cf 91       	pop	r28
    220a:	0f 91       	pop	r16
    220c:	ff 90       	pop	r15
    220e:	ef 90       	pop	r14
    2210:	df 90       	pop	r13
    2212:	cf 90       	pop	r12
    2214:	bf 90       	pop	r11
    2216:	af 90       	pop	r10
    2218:	9f 90       	pop	r9
    221a:	8f 90       	pop	r8
    221c:	7f 90       	pop	r7
    221e:	6f 90       	pop	r6
    2220:	5f 90       	pop	r5
    2222:	4f 90       	pop	r4
    2224:	08 95       	ret

00002226 <vTaskStartScheduler>:
    2226:	ef 92       	push	r14
    2228:	ff 92       	push	r15
    222a:	0f 93       	push	r16
    222c:	0f 2e       	mov	r0, r31
    222e:	fc e3       	ldi	r31, 0x3C	; 60
    2230:	ef 2e       	mov	r14, r31
    2232:	fd e0       	ldi	r31, 0x0D	; 13
    2234:	ff 2e       	mov	r15, r31
    2236:	f0 2d       	mov	r31, r0
    2238:	00 e0       	ldi	r16, 0x00	; 0
    223a:	20 e0       	ldi	r18, 0x00	; 0
    223c:	30 e0       	ldi	r19, 0x00	; 0
    223e:	45 e5       	ldi	r20, 0x55	; 85
    2240:	50 e0       	ldi	r21, 0x00	; 0
    2242:	6e e8       	ldi	r22, 0x8E	; 142
    2244:	71 e0       	ldi	r23, 0x01	; 1
    2246:	81 e8       	ldi	r24, 0x81	; 129
    2248:	92 e1       	ldi	r25, 0x12	; 18
    224a:	ef de       	rcall	.-546    	; 0x202a <xTaskCreate>
    224c:	81 30       	cpi	r24, 0x01	; 1
    224e:	79 f4       	brne	.+30     	; 0x226e <vTaskStartScheduler+0x48>
    2250:	f8 94       	cli
    2252:	8f ef       	ldi	r24, 0xFF	; 255
    2254:	9f ef       	ldi	r25, 0xFF	; 255
    2256:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <xNextTaskUnblockTime+0x1>
    225a:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <xNextTaskUnblockTime>
    225e:	81 e0       	ldi	r24, 0x01	; 1
    2260:	80 93 44 0d 	sts	0x0D44, r24	; 0x800d44 <xSchedulerRunning>
    2264:	10 92 47 0d 	sts	0x0D47, r1	; 0x800d47 <xTickCount+0x1>
    2268:	10 92 46 0d 	sts	0x0D46, r1	; 0x800d46 <xTickCount>
    226c:	fd da       	rcall	.-2566   	; 0x1868 <xPortStartScheduler>
    226e:	0f 91       	pop	r16
    2270:	ff 90       	pop	r15
    2272:	ef 90       	pop	r14
    2274:	08 95       	ret

00002276 <vTaskSuspendAll>:
    2276:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    227a:	8f 5f       	subi	r24, 0xFF	; 255
    227c:	80 93 3b 0d 	sts	0x0D3B, r24	; 0x800d3b <uxSchedulerSuspended>
    2280:	08 95       	ret

00002282 <xTaskIncrementTick>:
    2282:	cf 92       	push	r12
    2284:	df 92       	push	r13
    2286:	ef 92       	push	r14
    2288:	ff 92       	push	r15
    228a:	0f 93       	push	r16
    228c:	1f 93       	push	r17
    228e:	cf 93       	push	r28
    2290:	df 93       	push	r29
    2292:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    2296:	81 11       	cpse	r24, r1
    2298:	95 c0       	rjmp	.+298    	; 0x23c4 <xTaskIncrementTick+0x142>
    229a:	e0 90 46 0d 	lds	r14, 0x0D46	; 0x800d46 <xTickCount>
    229e:	f0 90 47 0d 	lds	r15, 0x0D47	; 0x800d47 <xTickCount+0x1>
    22a2:	8f ef       	ldi	r24, 0xFF	; 255
    22a4:	e8 1a       	sub	r14, r24
    22a6:	f8 0a       	sbc	r15, r24
    22a8:	f0 92 47 0d 	sts	0x0D47, r15	; 0x800d47 <xTickCount+0x1>
    22ac:	e0 92 46 0d 	sts	0x0D46, r14	; 0x800d46 <xTickCount>
    22b0:	e1 14       	cp	r14, r1
    22b2:	f1 04       	cpc	r15, r1
    22b4:	b1 f4       	brne	.+44     	; 0x22e2 <xTaskIncrementTick+0x60>
    22b6:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    22ba:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    22be:	20 91 65 0d 	lds	r18, 0x0D65	; 0x800d65 <pxOverflowDelayedTaskList>
    22c2:	30 91 66 0d 	lds	r19, 0x0D66	; 0x800d66 <pxOverflowDelayedTaskList+0x1>
    22c6:	30 93 68 0d 	sts	0x0D68, r19	; 0x800d68 <pxDelayedTaskList+0x1>
    22ca:	20 93 67 0d 	sts	0x0D67, r18	; 0x800d67 <pxDelayedTaskList>
    22ce:	90 93 66 0d 	sts	0x0D66, r25	; 0x800d66 <pxOverflowDelayedTaskList+0x1>
    22d2:	80 93 65 0d 	sts	0x0D65, r24	; 0x800d65 <pxOverflowDelayedTaskList>
    22d6:	80 91 41 0d 	lds	r24, 0x0D41	; 0x800d41 <xNumOfOverflows>
    22da:	8f 5f       	subi	r24, 0xFF	; 255
    22dc:	80 93 41 0d 	sts	0x0D41, r24	; 0x800d41 <xNumOfOverflows>
    22e0:	31 de       	rcall	.-926    	; 0x1f44 <prvResetNextTaskUnblockTime>
    22e2:	80 91 3e 0d 	lds	r24, 0x0D3E	; 0x800d3e <xNextTaskUnblockTime>
    22e6:	90 91 3f 0d 	lds	r25, 0x0D3F	; 0x800d3f <xNextTaskUnblockTime+0x1>
    22ea:	e8 16       	cp	r14, r24
    22ec:	f9 06       	cpc	r15, r25
    22ee:	10 f4       	brcc	.+4      	; 0x22f4 <xTaskIncrementTick+0x72>
    22f0:	d1 2c       	mov	r13, r1
    22f2:	50 c0       	rjmp	.+160    	; 0x2394 <xTaskIncrementTick+0x112>
    22f4:	d1 2c       	mov	r13, r1
    22f6:	cc 24       	eor	r12, r12
    22f8:	c3 94       	inc	r12
    22fa:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    22fe:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    2302:	80 81       	ld	r24, Z
    2304:	81 11       	cpse	r24, r1
    2306:	07 c0       	rjmp	.+14     	; 0x2316 <xTaskIncrementTick+0x94>
    2308:	8f ef       	ldi	r24, 0xFF	; 255
    230a:	9f ef       	ldi	r25, 0xFF	; 255
    230c:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <xNextTaskUnblockTime+0x1>
    2310:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <xNextTaskUnblockTime>
    2314:	3f c0       	rjmp	.+126    	; 0x2394 <xTaskIncrementTick+0x112>
    2316:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxDelayedTaskList>
    231a:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxDelayedTaskList+0x1>
    231e:	05 80       	ldd	r0, Z+5	; 0x05
    2320:	f6 81       	ldd	r31, Z+6	; 0x06
    2322:	e0 2d       	mov	r30, r0
    2324:	c6 81       	ldd	r28, Z+6	; 0x06
    2326:	d7 81       	ldd	r29, Z+7	; 0x07
    2328:	8a 81       	ldd	r24, Y+2	; 0x02
    232a:	9b 81       	ldd	r25, Y+3	; 0x03
    232c:	e8 16       	cp	r14, r24
    232e:	f9 06       	cpc	r15, r25
    2330:	28 f4       	brcc	.+10     	; 0x233c <xTaskIncrementTick+0xba>
    2332:	90 93 3f 0d 	sts	0x0D3F, r25	; 0x800d3f <xNextTaskUnblockTime+0x1>
    2336:	80 93 3e 0d 	sts	0x0D3E, r24	; 0x800d3e <xNextTaskUnblockTime>
    233a:	2c c0       	rjmp	.+88     	; 0x2394 <xTaskIncrementTick+0x112>
    233c:	8e 01       	movw	r16, r28
    233e:	0e 5f       	subi	r16, 0xFE	; 254
    2340:	1f 4f       	sbci	r17, 0xFF	; 255
    2342:	c8 01       	movw	r24, r16
    2344:	ff d9       	rcall	.-3074   	; 0x1744 <uxListRemove>
    2346:	8c 89       	ldd	r24, Y+20	; 0x14
    2348:	9d 89       	ldd	r25, Y+21	; 0x15
    234a:	89 2b       	or	r24, r25
    234c:	19 f0       	breq	.+6      	; 0x2354 <xTaskIncrementTick+0xd2>
    234e:	ce 01       	movw	r24, r28
    2350:	0c 96       	adiw	r24, 0x0c	; 12
    2352:	f8 d9       	rcall	.-3088   	; 0x1744 <uxListRemove>
    2354:	8e 89       	ldd	r24, Y+22	; 0x16
    2356:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    235a:	98 17       	cp	r25, r24
    235c:	10 f4       	brcc	.+4      	; 0x2362 <xTaskIncrementTick+0xe0>
    235e:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	9c 01       	movw	r18, r24
    2366:	22 0f       	add	r18, r18
    2368:	33 1f       	adc	r19, r19
    236a:	22 0f       	add	r18, r18
    236c:	33 1f       	adc	r19, r19
    236e:	22 0f       	add	r18, r18
    2370:	33 1f       	adc	r19, r19
    2372:	82 0f       	add	r24, r18
    2374:	93 1f       	adc	r25, r19
    2376:	b8 01       	movw	r22, r16
    2378:	85 58       	subi	r24, 0x85	; 133
    237a:	92 4f       	sbci	r25, 0xF2	; 242
    237c:	91 d9       	rcall	.-3294   	; 0x16a0 <vListInsertEnd>
    237e:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2382:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2386:	9e 89       	ldd	r25, Y+22	; 0x16
    2388:	86 89       	ldd	r24, Z+22	; 0x16
    238a:	98 17       	cp	r25, r24
    238c:	08 f4       	brcc	.+2      	; 0x2390 <xTaskIncrementTick+0x10e>
    238e:	b5 cf       	rjmp	.-150    	; 0x22fa <xTaskIncrementTick+0x78>
    2390:	dc 2c       	mov	r13, r12
    2392:	b3 cf       	rjmp	.-154    	; 0x22fa <xTaskIncrementTick+0x78>
    2394:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2398:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    239c:	86 89       	ldd	r24, Z+22	; 0x16
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	fc 01       	movw	r30, r24
    23a2:	ee 0f       	add	r30, r30
    23a4:	ff 1f       	adc	r31, r31
    23a6:	ee 0f       	add	r30, r30
    23a8:	ff 1f       	adc	r31, r31
    23aa:	ee 0f       	add	r30, r30
    23ac:	ff 1f       	adc	r31, r31
    23ae:	8e 0f       	add	r24, r30
    23b0:	9f 1f       	adc	r25, r31
    23b2:	fc 01       	movw	r30, r24
    23b4:	e5 58       	subi	r30, 0x85	; 133
    23b6:	f2 4f       	sbci	r31, 0xF2	; 242
    23b8:	80 81       	ld	r24, Z
    23ba:	82 30       	cpi	r24, 0x02	; 2
    23bc:	48 f0       	brcs	.+18     	; 0x23d0 <xTaskIncrementTick+0x14e>
    23be:	dd 24       	eor	r13, r13
    23c0:	d3 94       	inc	r13
    23c2:	06 c0       	rjmp	.+12     	; 0x23d0 <xTaskIncrementTick+0x14e>
    23c4:	80 91 43 0d 	lds	r24, 0x0D43	; 0x800d43 <uxPendedTicks>
    23c8:	8f 5f       	subi	r24, 0xFF	; 255
    23ca:	80 93 43 0d 	sts	0x0D43, r24	; 0x800d43 <uxPendedTicks>
    23ce:	d1 2c       	mov	r13, r1
    23d0:	80 91 42 0d 	lds	r24, 0x0D42	; 0x800d42 <xYieldPending>
    23d4:	88 23       	and	r24, r24
    23d6:	11 f0       	breq	.+4      	; 0x23dc <xTaskIncrementTick+0x15a>
    23d8:	dd 24       	eor	r13, r13
    23da:	d3 94       	inc	r13
    23dc:	8d 2d       	mov	r24, r13
    23de:	df 91       	pop	r29
    23e0:	cf 91       	pop	r28
    23e2:	1f 91       	pop	r17
    23e4:	0f 91       	pop	r16
    23e6:	ff 90       	pop	r15
    23e8:	ef 90       	pop	r14
    23ea:	df 90       	pop	r13
    23ec:	cf 90       	pop	r12
    23ee:	08 95       	ret

000023f0 <xTaskResumeAll>:
    23f0:	df 92       	push	r13
    23f2:	ef 92       	push	r14
    23f4:	ff 92       	push	r15
    23f6:	0f 93       	push	r16
    23f8:	1f 93       	push	r17
    23fa:	cf 93       	push	r28
    23fc:	df 93       	push	r29
    23fe:	0f b6       	in	r0, 0x3f	; 63
    2400:	f8 94       	cli
    2402:	0f 92       	push	r0
    2404:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    2408:	81 50       	subi	r24, 0x01	; 1
    240a:	80 93 3b 0d 	sts	0x0D3B, r24	; 0x800d3b <uxSchedulerSuspended>
    240e:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    2412:	81 11       	cpse	r24, r1
    2414:	59 c0       	rjmp	.+178    	; 0x24c8 <xTaskResumeAll+0xd8>
    2416:	80 91 48 0d 	lds	r24, 0x0D48	; 0x800d48 <uxCurrentNumberOfTasks>
    241a:	81 11       	cpse	r24, r1
    241c:	30 c0       	rjmp	.+96     	; 0x247e <xTaskResumeAll+0x8e>
    241e:	57 c0       	rjmp	.+174    	; 0x24ce <xTaskResumeAll+0xde>
    2420:	d7 01       	movw	r26, r14
    2422:	15 96       	adiw	r26, 0x05	; 5
    2424:	ed 91       	ld	r30, X+
    2426:	fc 91       	ld	r31, X
    2428:	16 97       	sbiw	r26, 0x06	; 6
    242a:	c6 81       	ldd	r28, Z+6	; 0x06
    242c:	d7 81       	ldd	r29, Z+7	; 0x07
    242e:	ce 01       	movw	r24, r28
    2430:	0c 96       	adiw	r24, 0x0c	; 12
    2432:	88 d9       	rcall	.-3312   	; 0x1744 <uxListRemove>
    2434:	8e 01       	movw	r16, r28
    2436:	0e 5f       	subi	r16, 0xFE	; 254
    2438:	1f 4f       	sbci	r17, 0xFF	; 255
    243a:	c8 01       	movw	r24, r16
    243c:	83 d9       	rcall	.-3322   	; 0x1744 <uxListRemove>
    243e:	8e 89       	ldd	r24, Y+22	; 0x16
    2440:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    2444:	98 17       	cp	r25, r24
    2446:	10 f4       	brcc	.+4      	; 0x244c <xTaskResumeAll+0x5c>
    2448:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    244c:	90 e0       	ldi	r25, 0x00	; 0
    244e:	9c 01       	movw	r18, r24
    2450:	22 0f       	add	r18, r18
    2452:	33 1f       	adc	r19, r19
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	22 0f       	add	r18, r18
    245a:	33 1f       	adc	r19, r19
    245c:	82 0f       	add	r24, r18
    245e:	93 1f       	adc	r25, r19
    2460:	b8 01       	movw	r22, r16
    2462:	85 58       	subi	r24, 0x85	; 133
    2464:	92 4f       	sbci	r25, 0xF2	; 242
    2466:	1c d9       	rcall	.-3528   	; 0x16a0 <vListInsertEnd>
    2468:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    246c:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2470:	9e 89       	ldd	r25, Y+22	; 0x16
    2472:	86 89       	ldd	r24, Z+22	; 0x16
    2474:	98 17       	cp	r25, r24
    2476:	68 f0       	brcs	.+26     	; 0x2492 <xTaskResumeAll+0xa2>
    2478:	d0 92 42 0d 	sts	0x0D42, r13	; 0x800d42 <xYieldPending>
    247c:	0a c0       	rjmp	.+20     	; 0x2492 <xTaskResumeAll+0xa2>
    247e:	c0 e0       	ldi	r28, 0x00	; 0
    2480:	d0 e0       	ldi	r29, 0x00	; 0
    2482:	0f 2e       	mov	r0, r31
    2484:	fc e5       	ldi	r31, 0x5C	; 92
    2486:	ef 2e       	mov	r14, r31
    2488:	fd e0       	ldi	r31, 0x0D	; 13
    248a:	ff 2e       	mov	r15, r31
    248c:	f0 2d       	mov	r31, r0
    248e:	dd 24       	eor	r13, r13
    2490:	d3 94       	inc	r13
    2492:	f7 01       	movw	r30, r14
    2494:	80 81       	ld	r24, Z
    2496:	81 11       	cpse	r24, r1
    2498:	c3 cf       	rjmp	.-122    	; 0x2420 <xTaskResumeAll+0x30>
    249a:	cd 2b       	or	r28, r29
    249c:	09 f0       	breq	.+2      	; 0x24a0 <xTaskResumeAll+0xb0>
    249e:	52 dd       	rcall	.-1372   	; 0x1f44 <prvResetNextTaskUnblockTime>
    24a0:	c0 91 43 0d 	lds	r28, 0x0D43	; 0x800d43 <uxPendedTicks>
    24a4:	cc 23       	and	r28, r28
    24a6:	49 f0       	breq	.+18     	; 0x24ba <xTaskResumeAll+0xca>
    24a8:	d1 e0       	ldi	r29, 0x01	; 1
    24aa:	eb de       	rcall	.-554    	; 0x2282 <xTaskIncrementTick>
    24ac:	81 11       	cpse	r24, r1
    24ae:	d0 93 42 0d 	sts	0x0D42, r29	; 0x800d42 <xYieldPending>
    24b2:	c1 50       	subi	r28, 0x01	; 1
    24b4:	d1 f7       	brne	.-12     	; 0x24aa <xTaskResumeAll+0xba>
    24b6:	10 92 43 0d 	sts	0x0D43, r1	; 0x800d43 <uxPendedTicks>
    24ba:	80 91 42 0d 	lds	r24, 0x0D42	; 0x800d42 <xYieldPending>
    24be:	88 23       	and	r24, r24
    24c0:	29 f0       	breq	.+10     	; 0x24cc <xTaskResumeAll+0xdc>
    24c2:	07 da       	rcall	.-3058   	; 0x18d2 <vPortYield>
    24c4:	81 e0       	ldi	r24, 0x01	; 1
    24c6:	03 c0       	rjmp	.+6      	; 0x24ce <xTaskResumeAll+0xde>
    24c8:	80 e0       	ldi	r24, 0x00	; 0
    24ca:	01 c0       	rjmp	.+2      	; 0x24ce <xTaskResumeAll+0xde>
    24cc:	80 e0       	ldi	r24, 0x00	; 0
    24ce:	0f 90       	pop	r0
    24d0:	0f be       	out	0x3f, r0	; 63
    24d2:	df 91       	pop	r29
    24d4:	cf 91       	pop	r28
    24d6:	1f 91       	pop	r17
    24d8:	0f 91       	pop	r16
    24da:	ff 90       	pop	r15
    24dc:	ef 90       	pop	r14
    24de:	df 90       	pop	r13
    24e0:	08 95       	ret

000024e2 <vTaskDelay>:
    24e2:	cf 93       	push	r28
    24e4:	df 93       	push	r29
    24e6:	ec 01       	movw	r28, r24
    24e8:	89 2b       	or	r24, r25
    24ea:	39 f0       	breq	.+14     	; 0x24fa <vTaskDelay+0x18>
    24ec:	c4 de       	rcall	.-632    	; 0x2276 <vTaskSuspendAll>
    24ee:	60 e0       	ldi	r22, 0x00	; 0
    24f0:	ce 01       	movw	r24, r28
    24f2:	47 dd       	rcall	.-1394   	; 0x1f82 <prvAddCurrentTaskToDelayedList>
    24f4:	7d df       	rcall	.-262    	; 0x23f0 <xTaskResumeAll>
    24f6:	81 11       	cpse	r24, r1
    24f8:	01 c0       	rjmp	.+2      	; 0x24fc <vTaskDelay+0x1a>
    24fa:	eb d9       	rcall	.-3114   	; 0x18d2 <vPortYield>
    24fc:	df 91       	pop	r29
    24fe:	cf 91       	pop	r28
    2500:	08 95       	ret

00002502 <prvIdleTask>:
    2502:	03 e5       	ldi	r16, 0x53	; 83
    2504:	1d e0       	ldi	r17, 0x0D	; 13
    2506:	0f 2e       	mov	r0, r31
    2508:	fb e7       	ldi	r31, 0x7B	; 123
    250a:	ef 2e       	mov	r14, r31
    250c:	fd e0       	ldi	r31, 0x0D	; 13
    250e:	ff 2e       	mov	r15, r31
    2510:	f0 2d       	mov	r31, r0
    2512:	24 c0       	rjmp	.+72     	; 0x255c <prvIdleTask+0x5a>
    2514:	b0 de       	rcall	.-672    	; 0x2276 <vTaskSuspendAll>
    2516:	d8 01       	movw	r26, r16
    2518:	cc 91       	ld	r28, X
    251a:	6a df       	rcall	.-300    	; 0x23f0 <xTaskResumeAll>
    251c:	cc 23       	and	r28, r28
    251e:	f1 f0       	breq	.+60     	; 0x255c <prvIdleTask+0x5a>
    2520:	0f b6       	in	r0, 0x3f	; 63
    2522:	f8 94       	cli
    2524:	0f 92       	push	r0
    2526:	d8 01       	movw	r26, r16
    2528:	15 96       	adiw	r26, 0x05	; 5
    252a:	ed 91       	ld	r30, X+
    252c:	fc 91       	ld	r31, X
    252e:	16 97       	sbiw	r26, 0x06	; 6
    2530:	c6 81       	ldd	r28, Z+6	; 0x06
    2532:	d7 81       	ldd	r29, Z+7	; 0x07
    2534:	ce 01       	movw	r24, r28
    2536:	02 96       	adiw	r24, 0x02	; 2
    2538:	05 d9       	rcall	.-3574   	; 0x1744 <uxListRemove>
    253a:	80 91 48 0d 	lds	r24, 0x0D48	; 0x800d48 <uxCurrentNumberOfTasks>
    253e:	81 50       	subi	r24, 0x01	; 1
    2540:	80 93 48 0d 	sts	0x0D48, r24	; 0x800d48 <uxCurrentNumberOfTasks>
    2544:	80 91 52 0d 	lds	r24, 0x0D52	; 0x800d52 <uxDeletedTasksWaitingCleanUp>
    2548:	81 50       	subi	r24, 0x01	; 1
    254a:	80 93 52 0d 	sts	0x0D52, r24	; 0x800d52 <uxDeletedTasksWaitingCleanUp>
    254e:	0f 90       	pop	r0
    2550:	0f be       	out	0x3f, r0	; 63
    2552:	8f 89       	ldd	r24, Y+23	; 0x17
    2554:	98 8d       	ldd	r25, Y+24	; 0x18
    2556:	91 d8       	rcall	.-3806   	; 0x167a <vPortFree>
    2558:	ce 01       	movw	r24, r28
    255a:	8f d8       	rcall	.-3810   	; 0x167a <vPortFree>
    255c:	80 91 52 0d 	lds	r24, 0x0D52	; 0x800d52 <uxDeletedTasksWaitingCleanUp>
    2560:	81 11       	cpse	r24, r1
    2562:	d8 cf       	rjmp	.-80     	; 0x2514 <prvIdleTask+0x12>
    2564:	f7 01       	movw	r30, r14
    2566:	80 81       	ld	r24, Z
    2568:	82 30       	cpi	r24, 0x02	; 2
    256a:	c0 f3       	brcs	.-16     	; 0x255c <prvIdleTask+0x5a>
    256c:	b2 d9       	rcall	.-3228   	; 0x18d2 <vPortYield>
    256e:	f6 cf       	rjmp	.-20     	; 0x255c <prvIdleTask+0x5a>

00002570 <vTaskSwitchContext>:
    2570:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    2574:	88 23       	and	r24, r24
    2576:	21 f0       	breq	.+8      	; 0x2580 <vTaskSwitchContext+0x10>
    2578:	81 e0       	ldi	r24, 0x01	; 1
    257a:	80 93 42 0d 	sts	0x0D42, r24	; 0x800d42 <xYieldPending>
    257e:	08 95       	ret
    2580:	10 92 42 0d 	sts	0x0D42, r1	; 0x800d42 <xYieldPending>
    2584:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2588:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    258c:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2590:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2594:	2d 91       	ld	r18, X+
    2596:	3c 91       	ld	r19, X
    2598:	87 89       	ldd	r24, Z+23	; 0x17
    259a:	90 8d       	ldd	r25, Z+24	; 0x18
    259c:	82 17       	cp	r24, r18
    259e:	93 07       	cpc	r25, r19
    25a0:	58 f0       	brcs	.+22     	; 0x25b8 <vTaskSwitchContext+0x48>
    25a2:	60 91 9f 0d 	lds	r22, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    25a6:	70 91 a0 0d 	lds	r23, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    25aa:	80 91 9f 0d 	lds	r24, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    25ae:	90 91 a0 0d 	lds	r25, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    25b2:	67 5e       	subi	r22, 0xE7	; 231
    25b4:	7f 4f       	sbci	r23, 0xFF	; 255
    25b6:	2d d8       	rcall	.-4006   	; 0x1612 <vApplicationStackOverflowHook>
    25b8:	20 91 45 0d 	lds	r18, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    25bc:	82 2f       	mov	r24, r18
    25be:	90 e0       	ldi	r25, 0x00	; 0
    25c0:	fc 01       	movw	r30, r24
    25c2:	ee 0f       	add	r30, r30
    25c4:	ff 1f       	adc	r31, r31
    25c6:	ee 0f       	add	r30, r30
    25c8:	ff 1f       	adc	r31, r31
    25ca:	ee 0f       	add	r30, r30
    25cc:	ff 1f       	adc	r31, r31
    25ce:	e8 0f       	add	r30, r24
    25d0:	f9 1f       	adc	r31, r25
    25d2:	e5 58       	subi	r30, 0x85	; 133
    25d4:	f2 4f       	sbci	r31, 0xF2	; 242
    25d6:	30 81       	ld	r19, Z
    25d8:	31 11       	cpse	r19, r1
    25da:	11 c0       	rjmp	.+34     	; 0x25fe <vTaskSwitchContext+0x8e>
    25dc:	21 50       	subi	r18, 0x01	; 1
    25de:	82 2f       	mov	r24, r18
    25e0:	90 e0       	ldi	r25, 0x00	; 0
    25e2:	fc 01       	movw	r30, r24
    25e4:	ee 0f       	add	r30, r30
    25e6:	ff 1f       	adc	r31, r31
    25e8:	ee 0f       	add	r30, r30
    25ea:	ff 1f       	adc	r31, r31
    25ec:	ee 0f       	add	r30, r30
    25ee:	ff 1f       	adc	r31, r31
    25f0:	e8 0f       	add	r30, r24
    25f2:	f9 1f       	adc	r31, r25
    25f4:	e5 58       	subi	r30, 0x85	; 133
    25f6:	f2 4f       	sbci	r31, 0xF2	; 242
    25f8:	30 81       	ld	r19, Z
    25fa:	33 23       	and	r19, r19
    25fc:	79 f3       	breq	.-34     	; 0x25dc <vTaskSwitchContext+0x6c>
    25fe:	ac 01       	movw	r20, r24
    2600:	44 0f       	add	r20, r20
    2602:	55 1f       	adc	r21, r21
    2604:	44 0f       	add	r20, r20
    2606:	55 1f       	adc	r21, r21
    2608:	44 0f       	add	r20, r20
    260a:	55 1f       	adc	r21, r21
    260c:	48 0f       	add	r20, r24
    260e:	59 1f       	adc	r21, r25
    2610:	da 01       	movw	r26, r20
    2612:	a5 58       	subi	r26, 0x85	; 133
    2614:	b2 4f       	sbci	r27, 0xF2	; 242
    2616:	11 96       	adiw	r26, 0x01	; 1
    2618:	ed 91       	ld	r30, X+
    261a:	fc 91       	ld	r31, X
    261c:	12 97       	sbiw	r26, 0x02	; 2
    261e:	02 80       	ldd	r0, Z+2	; 0x02
    2620:	f3 81       	ldd	r31, Z+3	; 0x03
    2622:	e0 2d       	mov	r30, r0
    2624:	12 96       	adiw	r26, 0x02	; 2
    2626:	fc 93       	st	X, r31
    2628:	ee 93       	st	-X, r30
    262a:	11 97       	sbiw	r26, 0x01	; 1
    262c:	42 58       	subi	r20, 0x82	; 130
    262e:	52 4f       	sbci	r21, 0xF2	; 242
    2630:	e4 17       	cp	r30, r20
    2632:	f5 07       	cpc	r31, r21
    2634:	29 f4       	brne	.+10     	; 0x2640 <vTaskSwitchContext+0xd0>
    2636:	42 81       	ldd	r20, Z+2	; 0x02
    2638:	53 81       	ldd	r21, Z+3	; 0x03
    263a:	fd 01       	movw	r30, r26
    263c:	52 83       	std	Z+2, r21	; 0x02
    263e:	41 83       	std	Z+1, r20	; 0x01
    2640:	fc 01       	movw	r30, r24
    2642:	ee 0f       	add	r30, r30
    2644:	ff 1f       	adc	r31, r31
    2646:	ee 0f       	add	r30, r30
    2648:	ff 1f       	adc	r31, r31
    264a:	ee 0f       	add	r30, r30
    264c:	ff 1f       	adc	r31, r31
    264e:	8e 0f       	add	r24, r30
    2650:	9f 1f       	adc	r25, r31
    2652:	fc 01       	movw	r30, r24
    2654:	e5 58       	subi	r30, 0x85	; 133
    2656:	f2 4f       	sbci	r31, 0xF2	; 242
    2658:	01 80       	ldd	r0, Z+1	; 0x01
    265a:	f2 81       	ldd	r31, Z+2	; 0x02
    265c:	e0 2d       	mov	r30, r0
    265e:	86 81       	ldd	r24, Z+6	; 0x06
    2660:	97 81       	ldd	r25, Z+7	; 0x07
    2662:	90 93 a0 0d 	sts	0x0DA0, r25	; 0x800da0 <pxCurrentTCB+0x1>
    2666:	80 93 9f 0d 	sts	0x0D9F, r24	; 0x800d9f <pxCurrentTCB>
    266a:	20 93 45 0d 	sts	0x0D45, r18	; 0x800d45 <uxTopReadyPriority>
    266e:	08 95       	ret

00002670 <vTaskPlaceOnEventList>:
    2670:	cf 93       	push	r28
    2672:	df 93       	push	r29
    2674:	eb 01       	movw	r28, r22
    2676:	60 91 9f 0d 	lds	r22, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    267a:	70 91 a0 0d 	lds	r23, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    267e:	64 5f       	subi	r22, 0xF4	; 244
    2680:	7f 4f       	sbci	r23, 0xFF	; 255
    2682:	2f d8       	rcall	.-4002   	; 0x16e2 <vListInsert>
    2684:	61 e0       	ldi	r22, 0x01	; 1
    2686:	ce 01       	movw	r24, r28
    2688:	7c dc       	rcall	.-1800   	; 0x1f82 <prvAddCurrentTaskToDelayedList>
    268a:	df 91       	pop	r29
    268c:	cf 91       	pop	r28
    268e:	08 95       	ret

00002690 <xTaskRemoveFromEventList>:
    2690:	0f 93       	push	r16
    2692:	1f 93       	push	r17
    2694:	cf 93       	push	r28
    2696:	df 93       	push	r29
    2698:	dc 01       	movw	r26, r24
    269a:	15 96       	adiw	r26, 0x05	; 5
    269c:	ed 91       	ld	r30, X+
    269e:	fc 91       	ld	r31, X
    26a0:	16 97       	sbiw	r26, 0x06	; 6
    26a2:	c6 81       	ldd	r28, Z+6	; 0x06
    26a4:	d7 81       	ldd	r29, Z+7	; 0x07
    26a6:	8e 01       	movw	r16, r28
    26a8:	04 5f       	subi	r16, 0xF4	; 244
    26aa:	1f 4f       	sbci	r17, 0xFF	; 255
    26ac:	c8 01       	movw	r24, r16
    26ae:	4a d8       	rcall	.-3948   	; 0x1744 <uxListRemove>
    26b0:	80 91 3b 0d 	lds	r24, 0x0D3B	; 0x800d3b <uxSchedulerSuspended>
    26b4:	81 11       	cpse	r24, r1
    26b6:	1b c0       	rjmp	.+54     	; 0x26ee <xTaskRemoveFromEventList+0x5e>
    26b8:	0a 50       	subi	r16, 0x0A	; 10
    26ba:	11 09       	sbc	r17, r1
    26bc:	c8 01       	movw	r24, r16
    26be:	42 d8       	rcall	.-3964   	; 0x1744 <uxListRemove>
    26c0:	8e 89       	ldd	r24, Y+22	; 0x16
    26c2:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    26c6:	98 17       	cp	r25, r24
    26c8:	10 f4       	brcc	.+4      	; 0x26ce <xTaskRemoveFromEventList+0x3e>
    26ca:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	9c 01       	movw	r18, r24
    26d2:	22 0f       	add	r18, r18
    26d4:	33 1f       	adc	r19, r19
    26d6:	22 0f       	add	r18, r18
    26d8:	33 1f       	adc	r19, r19
    26da:	22 0f       	add	r18, r18
    26dc:	33 1f       	adc	r19, r19
    26de:	82 0f       	add	r24, r18
    26e0:	93 1f       	adc	r25, r19
    26e2:	b8 01       	movw	r22, r16
    26e4:	85 58       	subi	r24, 0x85	; 133
    26e6:	92 4f       	sbci	r25, 0xF2	; 242
    26e8:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vListInsertEnd>
    26ec:	05 c0       	rjmp	.+10     	; 0x26f8 <xTaskRemoveFromEventList+0x68>
    26ee:	b8 01       	movw	r22, r16
    26f0:	8c e5       	ldi	r24, 0x5C	; 92
    26f2:	9d e0       	ldi	r25, 0x0D	; 13
    26f4:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vListInsertEnd>
    26f8:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    26fc:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2700:	9e 89       	ldd	r25, Y+22	; 0x16
    2702:	86 89       	ldd	r24, Z+22	; 0x16
    2704:	89 17       	cp	r24, r25
    2706:	20 f4       	brcc	.+8      	; 0x2710 <xTaskRemoveFromEventList+0x80>
    2708:	81 e0       	ldi	r24, 0x01	; 1
    270a:	80 93 42 0d 	sts	0x0D42, r24	; 0x800d42 <xYieldPending>
    270e:	01 c0       	rjmp	.+2      	; 0x2712 <xTaskRemoveFromEventList+0x82>
    2710:	80 e0       	ldi	r24, 0x00	; 0
    2712:	df 91       	pop	r29
    2714:	cf 91       	pop	r28
    2716:	1f 91       	pop	r17
    2718:	0f 91       	pop	r16
    271a:	08 95       	ret

0000271c <vTaskSetTimeOutState>:
    271c:	20 91 41 0d 	lds	r18, 0x0D41	; 0x800d41 <xNumOfOverflows>
    2720:	fc 01       	movw	r30, r24
    2722:	20 83       	st	Z, r18
    2724:	20 91 46 0d 	lds	r18, 0x0D46	; 0x800d46 <xTickCount>
    2728:	30 91 47 0d 	lds	r19, 0x0D47	; 0x800d47 <xTickCount+0x1>
    272c:	32 83       	std	Z+2, r19	; 0x02
    272e:	21 83       	std	Z+1, r18	; 0x01
    2730:	08 95       	ret

00002732 <xTaskCheckForTimeOut>:
    2732:	0f b6       	in	r0, 0x3f	; 63
    2734:	f8 94       	cli
    2736:	0f 92       	push	r0
    2738:	40 91 46 0d 	lds	r20, 0x0D46	; 0x800d46 <xTickCount>
    273c:	50 91 47 0d 	lds	r21, 0x0D47	; 0x800d47 <xTickCount+0x1>
    2740:	db 01       	movw	r26, r22
    2742:	2d 91       	ld	r18, X+
    2744:	3c 91       	ld	r19, X
    2746:	2f 3f       	cpi	r18, 0xFF	; 255
    2748:	bf ef       	ldi	r27, 0xFF	; 255
    274a:	3b 07       	cpc	r19, r27
    274c:	11 f1       	breq	.+68     	; 0x2792 <xTaskCheckForTimeOut+0x60>
    274e:	e0 91 41 0d 	lds	r30, 0x0D41	; 0x800d41 <xNumOfOverflows>
    2752:	dc 01       	movw	r26, r24
    2754:	fc 91       	ld	r31, X
    2756:	fe 17       	cp	r31, r30
    2758:	39 f0       	breq	.+14     	; 0x2768 <xTaskCheckForTimeOut+0x36>
    275a:	11 96       	adiw	r26, 0x01	; 1
    275c:	ed 91       	ld	r30, X+
    275e:	fc 91       	ld	r31, X
    2760:	12 97       	sbiw	r26, 0x02	; 2
    2762:	4e 17       	cp	r20, r30
    2764:	5f 07       	cpc	r21, r31
    2766:	b8 f4       	brcc	.+46     	; 0x2796 <xTaskCheckForTimeOut+0x64>
    2768:	dc 01       	movw	r26, r24
    276a:	11 96       	adiw	r26, 0x01	; 1
    276c:	ed 91       	ld	r30, X+
    276e:	fc 91       	ld	r31, X
    2770:	12 97       	sbiw	r26, 0x02	; 2
    2772:	da 01       	movw	r26, r20
    2774:	ae 1b       	sub	r26, r30
    2776:	bf 0b       	sbc	r27, r31
    2778:	a2 17       	cp	r26, r18
    277a:	b3 07       	cpc	r27, r19
    277c:	70 f4       	brcc	.+28     	; 0x279a <xTaskCheckForTimeOut+0x68>
    277e:	db 01       	movw	r26, r22
    2780:	e4 1b       	sub	r30, r20
    2782:	f5 0b       	sbc	r31, r21
    2784:	2e 0f       	add	r18, r30
    2786:	3f 1f       	adc	r19, r31
    2788:	2d 93       	st	X+, r18
    278a:	3c 93       	st	X, r19
    278c:	c7 df       	rcall	.-114    	; 0x271c <vTaskSetTimeOutState>
    278e:	80 e0       	ldi	r24, 0x00	; 0
    2790:	05 c0       	rjmp	.+10     	; 0x279c <xTaskCheckForTimeOut+0x6a>
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	03 c0       	rjmp	.+6      	; 0x279c <xTaskCheckForTimeOut+0x6a>
    2796:	81 e0       	ldi	r24, 0x01	; 1
    2798:	01 c0       	rjmp	.+2      	; 0x279c <xTaskCheckForTimeOut+0x6a>
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	0f 90       	pop	r0
    279e:	0f be       	out	0x3f, r0	; 63
    27a0:	08 95       	ret

000027a2 <vTaskMissedYield>:
    27a2:	81 e0       	ldi	r24, 0x01	; 1
    27a4:	80 93 42 0d 	sts	0x0D42, r24	; 0x800d42 <xYieldPending>
    27a8:	08 95       	ret

000027aa <vTaskPriorityInherit>:
    27aa:	0f 93       	push	r16
    27ac:	1f 93       	push	r17
    27ae:	cf 93       	push	r28
    27b0:	df 93       	push	r29
    27b2:	fc 01       	movw	r30, r24
    27b4:	89 2b       	or	r24, r25
    27b6:	09 f4       	brne	.+2      	; 0x27ba <vTaskPriorityInherit+0x10>
    27b8:	55 c0       	rjmp	.+170    	; 0x2864 <vTaskPriorityInherit+0xba>
    27ba:	26 89       	ldd	r18, Z+22	; 0x16
    27bc:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    27c0:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    27c4:	56 96       	adiw	r26, 0x16	; 22
    27c6:	8c 91       	ld	r24, X
    27c8:	28 17       	cp	r18, r24
    27ca:	08 f0       	brcs	.+2      	; 0x27ce <vTaskPriorityInherit+0x24>
    27cc:	4b c0       	rjmp	.+150    	; 0x2864 <vTaskPriorityInherit+0xba>
    27ce:	84 85       	ldd	r24, Z+12	; 0x0c
    27d0:	95 85       	ldd	r25, Z+13	; 0x0d
    27d2:	99 23       	and	r25, r25
    27d4:	64 f0       	brlt	.+24     	; 0x27ee <vTaskPriorityInherit+0x44>
    27d6:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    27da:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    27de:	56 96       	adiw	r26, 0x16	; 22
    27e0:	3c 91       	ld	r19, X
    27e2:	84 e0       	ldi	r24, 0x04	; 4
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	83 1b       	sub	r24, r19
    27e8:	91 09       	sbc	r25, r1
    27ea:	95 87       	std	Z+13, r25	; 0x0d
    27ec:	84 87       	std	Z+12, r24	; 0x0c
    27ee:	30 e0       	ldi	r19, 0x00	; 0
    27f0:	c9 01       	movw	r24, r18
    27f2:	88 0f       	add	r24, r24
    27f4:	99 1f       	adc	r25, r25
    27f6:	88 0f       	add	r24, r24
    27f8:	99 1f       	adc	r25, r25
    27fa:	88 0f       	add	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	28 0f       	add	r18, r24
    2800:	39 1f       	adc	r19, r25
    2802:	25 58       	subi	r18, 0x85	; 133
    2804:	32 4f       	sbci	r19, 0xF2	; 242
    2806:	82 85       	ldd	r24, Z+10	; 0x0a
    2808:	93 85       	ldd	r25, Z+11	; 0x0b
    280a:	82 17       	cp	r24, r18
    280c:	93 07       	cpc	r25, r19
    280e:	19 f5       	brne	.+70     	; 0x2856 <vTaskPriorityInherit+0xac>
    2810:	8f 01       	movw	r16, r30
    2812:	ef 01       	movw	r28, r30
    2814:	22 96       	adiw	r28, 0x02	; 2
    2816:	ce 01       	movw	r24, r28
    2818:	0e 94 a2 0b 	call	0x1744	; 0x1744 <uxListRemove>
    281c:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    2820:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2824:	86 89       	ldd	r24, Z+22	; 0x16
    2826:	f8 01       	movw	r30, r16
    2828:	86 8b       	std	Z+22, r24	; 0x16
    282a:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    282e:	98 17       	cp	r25, r24
    2830:	10 f4       	brcc	.+4      	; 0x2836 <vTaskPriorityInherit+0x8c>
    2832:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	9c 01       	movw	r18, r24
    283a:	22 0f       	add	r18, r18
    283c:	33 1f       	adc	r19, r19
    283e:	22 0f       	add	r18, r18
    2840:	33 1f       	adc	r19, r19
    2842:	22 0f       	add	r18, r18
    2844:	33 1f       	adc	r19, r19
    2846:	82 0f       	add	r24, r18
    2848:	93 1f       	adc	r25, r19
    284a:	be 01       	movw	r22, r28
    284c:	85 58       	subi	r24, 0x85	; 133
    284e:	92 4f       	sbci	r25, 0xF2	; 242
    2850:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vListInsertEnd>
    2854:	07 c0       	rjmp	.+14     	; 0x2864 <vTaskPriorityInherit+0xba>
    2856:	a0 91 9f 0d 	lds	r26, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    285a:	b0 91 a0 0d 	lds	r27, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    285e:	56 96       	adiw	r26, 0x16	; 22
    2860:	8c 91       	ld	r24, X
    2862:	86 8b       	std	Z+22, r24	; 0x16
    2864:	df 91       	pop	r29
    2866:	cf 91       	pop	r28
    2868:	1f 91       	pop	r17
    286a:	0f 91       	pop	r16
    286c:	08 95       	ret

0000286e <xTaskPriorityDisinherit>:
    286e:	0f 93       	push	r16
    2870:	1f 93       	push	r17
    2872:	cf 93       	push	r28
    2874:	df 93       	push	r29
    2876:	fc 01       	movw	r30, r24
    2878:	89 2b       	or	r24, r25
    287a:	79 f1       	breq	.+94     	; 0x28da <xTaskPriorityDisinherit+0x6c>
    287c:	82 a1       	ldd	r24, Z+34	; 0x22
    287e:	81 50       	subi	r24, 0x01	; 1
    2880:	82 a3       	std	Z+34, r24	; 0x22
    2882:	26 89       	ldd	r18, Z+22	; 0x16
    2884:	91 a1       	ldd	r25, Z+33	; 0x21
    2886:	29 17       	cp	r18, r25
    2888:	51 f1       	breq	.+84     	; 0x28de <xTaskPriorityDisinherit+0x70>
    288a:	81 11       	cpse	r24, r1
    288c:	2a c0       	rjmp	.+84     	; 0x28e2 <xTaskPriorityDisinherit+0x74>
    288e:	ef 01       	movw	r28, r30
    2890:	8f 01       	movw	r16, r30
    2892:	0e 5f       	subi	r16, 0xFE	; 254
    2894:	1f 4f       	sbci	r17, 0xFF	; 255
    2896:	c8 01       	movw	r24, r16
    2898:	0e 94 a2 0b 	call	0x1744	; 0x1744 <uxListRemove>
    289c:	89 a1       	ldd	r24, Y+33	; 0x21
    289e:	8e 8b       	std	Y+22, r24	; 0x16
    28a0:	24 e0       	ldi	r18, 0x04	; 4
    28a2:	30 e0       	ldi	r19, 0x00	; 0
    28a4:	28 1b       	sub	r18, r24
    28a6:	31 09       	sbc	r19, r1
    28a8:	3d 87       	std	Y+13, r19	; 0x0d
    28aa:	2c 87       	std	Y+12, r18	; 0x0c
    28ac:	90 91 45 0d 	lds	r25, 0x0D45	; 0x800d45 <uxTopReadyPriority>
    28b0:	98 17       	cp	r25, r24
    28b2:	10 f4       	brcc	.+4      	; 0x28b8 <xTaskPriorityDisinherit+0x4a>
    28b4:	80 93 45 0d 	sts	0x0D45, r24	; 0x800d45 <uxTopReadyPriority>
    28b8:	90 e0       	ldi	r25, 0x00	; 0
    28ba:	9c 01       	movw	r18, r24
    28bc:	22 0f       	add	r18, r18
    28be:	33 1f       	adc	r19, r19
    28c0:	22 0f       	add	r18, r18
    28c2:	33 1f       	adc	r19, r19
    28c4:	22 0f       	add	r18, r18
    28c6:	33 1f       	adc	r19, r19
    28c8:	82 0f       	add	r24, r18
    28ca:	93 1f       	adc	r25, r19
    28cc:	b8 01       	movw	r22, r16
    28ce:	85 58       	subi	r24, 0x85	; 133
    28d0:	92 4f       	sbci	r25, 0xF2	; 242
    28d2:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vListInsertEnd>
    28d6:	81 e0       	ldi	r24, 0x01	; 1
    28d8:	05 c0       	rjmp	.+10     	; 0x28e4 <xTaskPriorityDisinherit+0x76>
    28da:	80 e0       	ldi	r24, 0x00	; 0
    28dc:	03 c0       	rjmp	.+6      	; 0x28e4 <xTaskPriorityDisinherit+0x76>
    28de:	80 e0       	ldi	r24, 0x00	; 0
    28e0:	01 c0       	rjmp	.+2      	; 0x28e4 <xTaskPriorityDisinherit+0x76>
    28e2:	80 e0       	ldi	r24, 0x00	; 0
    28e4:	df 91       	pop	r29
    28e6:	cf 91       	pop	r28
    28e8:	1f 91       	pop	r17
    28ea:	0f 91       	pop	r16
    28ec:	08 95       	ret

000028ee <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    28ee:	80 91 9f 0d 	lds	r24, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    28f2:	90 91 a0 0d 	lds	r25, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    28f6:	89 2b       	or	r24, r25
    28f8:	39 f0       	breq	.+14     	; 0x2908 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    28fa:	e0 91 9f 0d 	lds	r30, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    28fe:	f0 91 a0 0d 	lds	r31, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
    2902:	82 a1       	ldd	r24, Z+34	; 0x22
    2904:	8f 5f       	subi	r24, 0xFF	; 255
    2906:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2908:	80 91 9f 0d 	lds	r24, 0x0D9F	; 0x800d9f <pxCurrentTCB>
    290c:	90 91 a0 0d 	lds	r25, 0x0DA0	; 0x800da0 <pxCurrentTCB+0x1>
	}
    2910:	08 95       	ret

00002912 <__tablejump2__>:
    2912:	ee 0f       	add	r30, r30
    2914:	ff 1f       	adc	r31, r31
    2916:	00 24       	eor	r0, r0
    2918:	00 1c       	adc	r0, r0
    291a:	0b be       	out	0x3b, r0	; 59
    291c:	07 90       	elpm	r0, Z+
    291e:	f6 91       	elpm	r31, Z
    2920:	e0 2d       	mov	r30, r0
    2922:	09 94       	ijmp

00002924 <memcpy>:
    2924:	fb 01       	movw	r30, r22
    2926:	dc 01       	movw	r26, r24
    2928:	02 c0       	rjmp	.+4      	; 0x292e <memcpy+0xa>
    292a:	01 90       	ld	r0, Z+
    292c:	0d 92       	st	X+, r0
    292e:	41 50       	subi	r20, 0x01	; 1
    2930:	50 40       	sbci	r21, 0x00	; 0
    2932:	d8 f7       	brcc	.-10     	; 0x292a <memcpy+0x6>
    2934:	08 95       	ret

00002936 <__do_global_dtors>:
    2936:	10 e0       	ldi	r17, 0x00	; 0
    2938:	c7 e4       	ldi	r28, 0x47	; 71
    293a:	d0 e0       	ldi	r29, 0x00	; 0
    293c:	03 c0       	rjmp	.+6      	; 0x2944 <__do_global_dtors+0xe>
    293e:	fe 01       	movw	r30, r28
    2940:	e8 df       	rcall	.-48     	; 0x2912 <__tablejump2__>
    2942:	21 96       	adiw	r28, 0x01	; 1
    2944:	c8 34       	cpi	r28, 0x48	; 72
    2946:	d1 07       	cpc	r29, r17
    2948:	d1 f7       	brne	.-12     	; 0x293e <__do_global_dtors+0x8>
    294a:	f8 94       	cli

0000294c <__stop_program>:
    294c:	ff cf       	rjmp	.-2      	; 0x294c <__stop_program>
