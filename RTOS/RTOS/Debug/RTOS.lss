
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000094  00800100  00002832  000028c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002832  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000bd5  00800194  00800194  0000295a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000295a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000298c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000788  00000000  00000000  000029cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a28f  00000000  00000000  00003154  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002b45  00000000  00000000  0000d3e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000048c6  00000000  00000000  0000ff28  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001520  00000000  00000000  000147f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002e79  00000000  00000000  00015d10  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007811  00000000  00000000  00018b89  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007d8  00000000  00000000  0002039a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__dtors_end>
       2:	00 00       	nop
       4:	6f c0       	rjmp	.+222    	; 0xe4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c0       	rjmp	.+218    	; 0xe4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c0       	rjmp	.+214    	; 0xe4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c0       	rjmp	.+210    	; 0xe4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c0       	rjmp	.+206    	; 0xe4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c0       	rjmp	.+202    	; 0xe4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c0       	rjmp	.+198    	; 0xe4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c0       	rjmp	.+194    	; 0xe4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c0       	rjmp	.+190    	; 0xe4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c0       	rjmp	.+186    	; 0xe4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c0       	rjmp	.+182    	; 0xe4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <__vector_12>
      34:	57 c0       	rjmp	.+174    	; 0xe4 <__bad_interrupt>
      36:	00 00       	nop
      38:	55 c0       	rjmp	.+170    	; 0xe4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	53 c0       	rjmp	.+166    	; 0xe4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c0       	rjmp	.+162    	; 0xe4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c0       	rjmp	.+158    	; 0xe4 <__bad_interrupt>
      46:	00 00       	nop
      48:	5a c2       	rjmp	.+1204   	; 0x4fe <__vector_18>
      4a:	00 00       	nop
      4c:	4b c0       	rjmp	.+150    	; 0xe4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c0       	rjmp	.+146    	; 0xe4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c0       	rjmp	.+142    	; 0xe4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c0       	rjmp	.+138    	; 0xe4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c0       	rjmp	.+134    	; 0xe4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c0       	rjmp	.+130    	; 0xe4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c0       	rjmp	.+126    	; 0xe4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c0       	rjmp	.+122    	; 0xe4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c0       	rjmp	.+118    	; 0xe4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a7 c2       	rjmp	.+1358   	; 0x5c0 <__vector_28>
      72:	00 00       	nop
      74:	37 c0       	rjmp	.+110    	; 0xe4 <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c2       	rjmp	.+1252   	; 0x55e <__vector_30>
      7a:	00 00       	nop
      7c:	33 c0       	rjmp	.+102    	; 0xe4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c0       	rjmp	.+98     	; 0xe4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c0       	rjmp	.+94     	; 0xe4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c0       	rjmp	.+90     	; 0xe4 <__bad_interrupt>
	...

0000008c <__ctors_start>:
      8c:	2b 03       	fmul	r18, r19

0000008e <__ctors_end>:
      8e:	2f 03       	fmul	r18, r23

00000090 <__dtors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d0 e1       	ldi	r29, 0x10	; 16
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	e2 e3       	ldi	r30, 0x32	; 50
      a4:	f8 e2       	ldi	r31, 0x28	; 40
      a6:	00 e0       	ldi	r16, 0x00	; 0
      a8:	0b bf       	out	0x3b, r16	; 59
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x14>
      ac:	07 90       	elpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a4 39       	cpi	r26, 0x94	; 148
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0x10>

000000b6 <__do_clear_bss>:
      b6:	2d e0       	ldi	r18, 0x0D	; 13
      b8:	a4 e9       	ldi	r26, 0x94	; 148
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	a9 36       	cpi	r26, 0x69	; 105
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>

000000c6 <__do_global_ctors>:
      c6:	10 e0       	ldi	r17, 0x00	; 0
      c8:	c7 e4       	ldi	r28, 0x47	; 71
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      cc:	04 c0       	rjmp	.+8      	; 0xd6 <__do_global_ctors+0x10>
      ce:	21 97       	sbiw	r28, 0x01	; 1
      d0:	fe 01       	movw	r30, r28
      d2:	0e 94 fb 13 	call	0x27f6	; 0x27f6 <__tablejump2__>
      d6:	c6 34       	cpi	r28, 0x46	; 70
      d8:	d1 07       	cpc	r29, r17
      da:	c9 f7       	brne	.-14     	; 0xce <__do_global_ctors+0x8>
      dc:	0e 94 07 0a 	call	0x140e	; 0x140e <main>
      e0:	0c 94 0d 14 	jmp	0x281a	; 0x281a <__do_global_dtors>

000000e4 <__bad_interrupt>:
      e4:	8d cf       	rjmp	.-230    	; 0x0 <__vectors>

000000e6 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      e6:	fc 01       	movw	r30, r24
      e8:	68 0f       	add	r22, r24
      ea:	79 1f       	adc	r23, r25
      ec:	8f ef       	ldi	r24, 0xFF	; 255
      ee:	9f ef       	ldi	r25, 0xFF	; 255
      f0:	e6 17       	cp	r30, r22
      f2:	f7 07       	cpc	r31, r23
      f4:	99 f0       	breq	.+38     	; 0x11c <_Z5CRC16Phi+0x36>
      f6:	21 91       	ld	r18, Z+
      f8:	82 27       	eor	r24, r18
      fa:	28 e0       	ldi	r18, 0x08	; 8
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	ac 01       	movw	r20, r24
     100:	41 70       	andi	r20, 0x01	; 1
     102:	55 27       	eor	r21, r21
     104:	96 95       	lsr	r25
     106:	87 95       	ror	r24
     108:	45 2b       	or	r20, r21
     10a:	21 f0       	breq	.+8      	; 0x114 <_Z5CRC16Phi+0x2e>
     10c:	41 e0       	ldi	r20, 0x01	; 1
     10e:	84 27       	eor	r24, r20
     110:	40 ea       	ldi	r20, 0xA0	; 160
     112:	94 27       	eor	r25, r20
     114:	21 50       	subi	r18, 0x01	; 1
     116:	31 09       	sbc	r19, r1
     118:	91 f7       	brne	.-28     	; 0xfe <_Z5CRC16Phi+0x18>
     11a:	ea cf       	rjmp	.-44     	; 0xf0 <_Z5CRC16Phi+0xa>
     11c:	08 95       	ret

0000011e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	dc 01       	movw	r26, r24
     124:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     126:	8c 91       	ld	r24, X
     128:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     12a:	11 96       	adiw	r26, 0x01	; 1
     12c:	8c 91       	ld	r24, X
     12e:	11 97       	sbiw	r26, 0x01	; 1
     130:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     132:	13 96       	adiw	r26, 0x03	; 3
     134:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     136:	92 e0       	ldi	r25, 0x02	; 2
     138:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     13a:	e8 2f       	mov	r30, r24
     13c:	f0 e0       	ldi	r31, 0x00	; 0
     13e:	ee 0f       	add	r30, r30
     140:	ff 1f       	adc	r31, r31
     142:	e4 0f       	add	r30, r20
     144:	f5 1f       	adc	r31, r21
     146:	81 81       	ldd	r24, Z+1	; 0x01
     148:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     14a:	80 81       	ld	r24, Z
     14c:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     14e:	65 e0       	ldi	r22, 0x05	; 5
     150:	70 e0       	ldi	r23, 0x00	; 0
     152:	ce 01       	movw	r24, r28
     154:	c8 df       	rcall	.-112    	; 0xe6 <_Z5CRC16Phi>
	function04->CRC = crc16;
     156:	9e 83       	std	Y+6, r25	; 0x06
     158:	8d 83       	std	Y+5, r24	; 0x05
}
     15a:	df 91       	pop	r29
     15c:	cf 91       	pop	r28
     15e:	08 95       	ret

00000160 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	fc 01       	movw	r30, r24
     166:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     168:	80 81       	ld	r24, Z
     16a:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     170:	82 81       	ldd	r24, Z+2	; 0x02
     172:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     174:	83 81       	ldd	r24, Z+3	; 0x03
     176:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     178:	84 81       	ldd	r24, Z+4	; 0x04
     17a:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     17c:	85 81       	ldd	r24, Z+5	; 0x05
     17e:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     180:	66 e0       	ldi	r22, 0x06	; 6
     182:	70 e0       	ldi	r23, 0x00	; 0
     184:	ce 01       	movw	r24, r28
     186:	af df       	rcall	.-162    	; 0xe6 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     188:	9f 83       	std	Y+7, r25	; 0x07
     18a:	8e 83       	std	Y+6, r24	; 0x06
}
     18c:	df 91       	pop	r29
     18e:	cf 91       	pop	r28
     190:	08 95       	ret

00000192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     192:	cf 93       	push	r28
     194:	df 93       	push	r29
     196:	fc 01       	movw	r30, r24
     198:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     19a:	80 81       	ld	r24, Z
     19c:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     19e:	81 81       	ldd	r24, Z+1	; 0x01
     1a0:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1a2:	82 81       	ldd	r24, Z+2	; 0x02
     1a4:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1a6:	83 81       	ldd	r24, Z+3	; 0x03
     1a8:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1aa:	94 81       	ldd	r25, Z+4	; 0x04
     1ac:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1ae:	95 81       	ldd	r25, Z+5	; 0x05
     1b0:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1b2:	96 81       	ldd	r25, Z+6	; 0x06
     1b4:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1b6:	27 81       	ldd	r18, Z+7	; 0x07
     1b8:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1ba:	90 85       	ldd	r25, Z+8	; 0x08
     1bc:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1be:	e8 2f       	mov	r30, r24
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	ee 0f       	add	r30, r30
     1c4:	ff 1f       	adc	r31, r31
     1c6:	e4 0f       	add	r30, r20
     1c8:	f5 1f       	adc	r31, r21
     1ca:	89 2f       	mov	r24, r25
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	92 2b       	or	r25, r18
     1d0:	91 83       	std	Z+1, r25	; 0x01
     1d2:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1d4:	69 e0       	ldi	r22, 0x09	; 9
     1d6:	70 e0       	ldi	r23, 0x00	; 0
     1d8:	ce 01       	movw	r24, r28
     1da:	85 df       	rcall	.-246    	; 0xe6 <_Z5CRC16Phi>
	function10->CRC = crc16;
     1dc:	9a 87       	std	Y+10, r25	; 0x0a
     1de:	89 87       	std	Y+9, r24	; 0x09
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1e6:	cf 93       	push	r28
     1e8:	df 93       	push	r29
     1ea:	fc 01       	movw	r30, r24
     1ec:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1ee:	80 81       	ld	r24, Z
     1f0:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1f2:	81 81       	ldd	r24, Z+1	; 0x01
     1f4:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1f6:	82 81       	ldd	r24, Z+2	; 0x02
     1f8:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1fa:	83 81       	ldd	r24, Z+3	; 0x03
     1fc:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1fe:	84 81       	ldd	r24, Z+4	; 0x04
     200:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     202:	85 81       	ldd	r24, Z+5	; 0x05
     204:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	70 e0       	ldi	r23, 0x00	; 0
     20a:	ce 01       	movw	r24, r28
     20c:	6c df       	rcall	.-296    	; 0xe6 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     20e:	9f 83       	std	Y+7, r25	; 0x07
     210:	8e 83       	std	Y+6, r24	; 0x06
}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     21e:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     220:	81 e8       	ldi	r24, 0x81	; 129
     222:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     224:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	70 e0       	ldi	r23, 0x00	; 0
     22a:	ce 01       	movw	r24, r28
     22c:	5c df       	rcall	.-328    	; 0xe6 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     22e:	9c 83       	std	Y+4, r25	; 0x04
     230:	8b 83       	std	Y+3, r24	; 0x03
}
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	ec 01       	movw	r28, r24
     240:	cb 01       	movw	r24, r22
     242:	14 2f       	mov	r17, r20
     244:	fe 01       	movw	r30, r28
     246:	ea 57       	subi	r30, 0x7A	; 122
     248:	ff 4f       	sbci	r31, 0xFF	; 255
     24a:	71 83       	std	Z+1, r23	; 0x01
     24c:	60 83       	st	Z, r22
     24e:	64 2f       	mov	r22, r20
     250:	40 d1       	rcall	.+640    	; 0x4d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     252:	88 23       	and	r24, r24
     254:	71 f0       	breq	.+28     	; 0x272 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     256:	fe 01       	movw	r30, r28
     258:	eb 57       	subi	r30, 0x7B	; 123
     25a:	ff 4f       	sbci	r31, 0xFF	; 255
     25c:	10 83       	st	Z, r17
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	34 97       	sbiw	r30, 0x04	; 4
     264:	11 82       	std	Z+1, r1	; 0x01
     266:	10 82       	st	Z, r1
     268:	ce 57       	subi	r28, 0x7E	; 126
     26a:	df 4f       	sbci	r29, 0xFF	; 255
     26c:	19 82       	std	Y+1, r1	; 0x01
     26e:	18 82       	st	Y, r1
     270:	04 c0       	rjmp	.+8      	; 0x27a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     272:	ca 57       	subi	r28, 0x7A	; 122
     274:	df 4f       	sbci	r29, 0xFF	; 255
     276:	19 82       	std	Y+1, r1	; 0x01
     278:	18 82       	st	Y, r1
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	1f 91       	pop	r17
     280:	08 95       	ret

00000282 <_ZN12SerialBuffernwEj>:
     282:	0c 94 7c 0a 	jmp	0x14f8	; 0x14f8 <pvPortMalloc>
     286:	08 95       	ret

00000288 <_ZN12SerialBuffer11SerialstoreEc>:
     288:	fc 01       	movw	r30, r24
     28a:	e0 58       	subi	r30, 0x80	; 128
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	20 81       	ld	r18, Z
     290:	2f 5f       	subi	r18, 0xFF	; 255
     292:	2f 77       	andi	r18, 0x7F	; 127
     294:	19 f4       	brne	.+6      	; 0x29c <_ZN12SerialBuffer11SerialstoreEc+0x14>
     296:	11 82       	std	Z+1, r1	; 0x01
     298:	10 82       	st	Z, r1
     29a:	21 e0       	ldi	r18, 0x01	; 1
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	fc 01       	movw	r30, r24
     2a0:	ee 57       	subi	r30, 0x7E	; 126
     2a2:	ff 4f       	sbci	r31, 0xFF	; 255
     2a4:	40 81       	ld	r20, Z
     2a6:	51 81       	ldd	r21, Z+1	; 0x01
     2a8:	24 17       	cp	r18, r20
     2aa:	35 07       	cpc	r19, r21
     2ac:	89 f0       	breq	.+34     	; 0x2d0 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     2ae:	dc 01       	movw	r26, r24
     2b0:	a0 58       	subi	r26, 0x80	; 128
     2b2:	bf 4f       	sbci	r27, 0xFF	; 255
     2b4:	ed 91       	ld	r30, X+
     2b6:	fc 91       	ld	r31, X
     2b8:	11 97       	sbiw	r26, 0x01	; 1
     2ba:	e8 0f       	add	r30, r24
     2bc:	f9 1f       	adc	r31, r25
     2be:	61 83       	std	Z+1, r22	; 0x01
     2c0:	2d 93       	st	X+, r18
     2c2:	3c 93       	st	X, r19
     2c4:	fc 01       	movw	r30, r24
     2c6:	ec 57       	subi	r30, 0x7C	; 124
     2c8:	ff 4f       	sbci	r31, 0xFF	; 255
     2ca:	80 81       	ld	r24, Z
     2cc:	8f 5f       	subi	r24, 0xFF	; 255
     2ce:	80 83       	st	Z, r24
     2d0:	08 95       	ret

000002d2 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2d2:	af 92       	push	r10
     2d4:	bf 92       	push	r11
     2d6:	cf 92       	push	r12
     2d8:	df 92       	push	r13
     2da:	ef 92       	push	r14
     2dc:	ff 92       	push	r15
     2de:	0f 93       	push	r16
     2e0:	1f 93       	push	r17
     2e2:	cf 93       	push	r28
     2e4:	8c 01       	movw	r16, r24
     2e6:	6b 01       	movw	r12, r22
     2e8:	7a 01       	movw	r14, r20
     2ea:	dc 01       	movw	r26, r24
     2ec:	ab 57       	subi	r26, 0x7B	; 123
     2ee:	bf 4f       	sbci	r27, 0xFF	; 255
     2f0:	fc 01       	movw	r30, r24
     2f2:	ea 57       	subi	r30, 0x7A	; 122
     2f4:	ff 4f       	sbci	r31, 0xFF	; 255
     2f6:	6c 91       	ld	r22, X
     2f8:	80 81       	ld	r24, Z
     2fa:	91 81       	ldd	r25, Z+1	; 0x01
     2fc:	f7 d0       	rcall	.+494    	; 0x4ec <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>
     2fe:	89 2b       	or	r24, r25
     300:	d1 f0       	breq	.+52     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     302:	1e 14       	cp	r1, r14
     304:	1f 04       	cpc	r1, r15
     306:	bc f4       	brge	.+46     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     308:	c0 e0       	ldi	r28, 0x00	; 0
     30a:	58 01       	movw	r10, r16
     30c:	85 e8       	ldi	r24, 0x85	; 133
     30e:	a8 0e       	add	r10, r24
     310:	b1 1c       	adc	r11, r1
     312:	0a 57       	subi	r16, 0x7A	; 122
     314:	1f 4f       	sbci	r17, 0xFF	; 255
     316:	f6 01       	movw	r30, r12
     318:	ec 0f       	add	r30, r28
     31a:	f1 1d       	adc	r31, r1
     31c:	40 81       	ld	r20, Z
     31e:	f5 01       	movw	r30, r10
     320:	60 81       	ld	r22, Z
     322:	f8 01       	movw	r30, r16
     324:	80 81       	ld	r24, Z
     326:	91 81       	ldd	r25, Z+1	; 0x01
     328:	8d d0       	rcall	.+282    	; 0x444 <_ZN11Dev_Manager5WriteE8Dev_typec>
     32a:	cf 5f       	subi	r28, 0xFF	; 255
     32c:	2c 2f       	mov	r18, r28
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	2e 15       	cp	r18, r14
     332:	3f 05       	cpc	r19, r15
     334:	84 f3       	brlt	.-32     	; 0x316 <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	df 90       	pop	r13
     342:	cf 90       	pop	r12
     344:	bf 90       	pop	r11
     346:	af 90       	pop	r10
     348:	08 95       	ret

0000034a <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     34a:	fc 01       	movw	r30, r24
     34c:	ee 57       	subi	r30, 0x7E	; 126
     34e:	ff 4f       	sbci	r31, 0xFF	; 255
     350:	20 81       	ld	r18, Z
     352:	31 81       	ldd	r19, Z+1	; 0x01
     354:	32 97       	sbiw	r30, 0x02	; 2
     356:	40 81       	ld	r20, Z
     358:	51 81       	ldd	r21, Z+1	; 0x01
     35a:	42 17       	cp	r20, r18
     35c:	53 07       	cpc	r21, r19
     35e:	e9 f0       	breq	.+58     	; 0x39a <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     360:	2f 5f       	subi	r18, 0xFF	; 255
     362:	3f 4f       	sbci	r19, 0xFF	; 255
     364:	fc 01       	movw	r30, r24
     366:	e2 0f       	add	r30, r18
     368:	f3 1f       	adc	r31, r19
     36a:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     36c:	2f 77       	andi	r18, 0x7F	; 127
     36e:	33 27       	eor	r19, r19
     370:	fc 01       	movw	r30, r24
     372:	ee 57       	subi	r30, 0x7E	; 126
     374:	ff 4f       	sbci	r31, 0xFF	; 255
     376:	31 83       	std	Z+1, r19	; 0x01
     378:	20 83       	st	Z, r18
		if (ib.tail == num)
     37a:	32 96       	adiw	r30, 0x02	; 2
     37c:	60 81       	ld	r22, Z
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	26 17       	cp	r18, r22
     382:	37 07       	cpc	r19, r23
     384:	61 f4       	brne	.+24     	; 0x39e <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     386:	32 97       	sbiw	r30, 0x02	; 2
     388:	11 82       	std	Z+1, r1	; 0x01
     38a:	10 82       	st	Z, r1
			ib.head = 0;
     38c:	32 97       	sbiw	r30, 0x02	; 2
     38e:	11 82       	std	Z+1, r1	; 0x01
     390:	10 82       	st	Z, r1
			num = 0;
     392:	34 96       	adiw	r30, 0x04	; 4
     394:	10 82       	st	Z, r1
		}
		return data;
     396:	84 2f       	mov	r24, r20
     398:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     39a:	8f ef       	ldi	r24, 0xFF	; 255
     39c:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     39e:	84 2f       	mov	r24, r20
	}
}
     3a0:	08 95       	ret

000003a2 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     3a2:	dc 01       	movw	r26, r24
     3a4:	a0 58       	subi	r26, 0x80	; 128
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ee 57       	subi	r30, 0x7E	; 126
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	8c 91       	ld	r24, X
     3b0:	90 81       	ld	r25, Z
     3b2:	89 1b       	sub	r24, r25
}
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	08 95       	ret

000003b8 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     3b8:	fc 01       	movw	r30, r24
     3ba:	ee 57       	subi	r30, 0x7E	; 126
     3bc:	ff 4f       	sbci	r31, 0xFF	; 255
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	ib.head = 0;
     3c2:	32 97       	sbiw	r30, 0x02	; 2
     3c4:	11 82       	std	Z+1, r1	; 0x01
     3c6:	10 82       	st	Z, r1
	num = 0;
     3c8:	34 96       	adiw	r30, 0x04	; 4
     3ca:	10 82       	st	Z, r1
     3cc:	08 95       	ret

000003ce <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     3ce:	26 e0       	ldi	r18, 0x06	; 6
     3d0:	dc 01       	movw	r26, r24
     3d2:	e2 2f       	mov	r30, r18
     3d4:	1d 92       	st	X+, r1
     3d6:	ea 95       	dec	r30
     3d8:	e9 f7       	brne	.-6      	; 0x3d4 <_ZN11Dev_ManagerC1Ev+0x6>
     3da:	fc 01       	movw	r30, r24
     3dc:	36 96       	adiw	r30, 0x06	; 6
     3de:	df 01       	movw	r26, r30
     3e0:	1d 92       	st	X+, r1
     3e2:	2a 95       	dec	r18
     3e4:	e9 f7       	brne	.-6      	; 0x3e0 <_ZN11Dev_ManagerC1Ev+0x12>
     3e6:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <__data_end+0x1>
     3ea:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <__data_end>
     3ee:	08 95       	ret

000003f0 <_ZN11Dev_ManagerD1Ev>:
     3f0:	10 92 95 01 	sts	0x0195, r1	; 0x800195 <__data_end+0x1>
     3f4:	10 92 94 01 	sts	0x0194, r1	; 0x800194 <__data_end>
     3f8:	08 95       	ret

000003fa <_ZN11Dev_Manager11getInstanceEv>:
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <__data_end>
     402:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <__data_end+0x1>
     406:	89 2b       	or	r24, r25
     408:	51 f4       	brne	.+20     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 7c 0a 	call	0x14f8	; 0x14f8 <pvPortMalloc>
     412:	ec 01       	movw	r28, r24
     414:	dc df       	rcall	.-72     	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     416:	d0 93 95 01 	sts	0x0195, r29	; 0x800195 <__data_end+0x1>
     41a:	c0 93 94 01 	sts	0x0194, r28	; 0x800194 <__data_end>
     41e:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <__data_end>
     422:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <__data_end+0x1>
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	08 95       	ret

0000042c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     42c:	50 e0       	ldi	r21, 0x00	; 0
     42e:	44 0f       	add	r20, r20
     430:	55 1f       	adc	r21, r21
     432:	84 0f       	add	r24, r20
     434:	95 1f       	adc	r25, r21
     436:	fc 01       	movw	r30, r24
     438:	71 83       	std	Z+1, r23	; 0x01
     43a:	60 83       	st	Z, r22
     43c:	08 95       	ret

0000043e <_ZN11Dev_ManagernwEj>:
     43e:	0c 94 7c 0a 	jmp	0x14f8	; 0x14f8 <pvPortMalloc>
     442:	08 95       	ret

00000444 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     444:	26 2f       	mov	r18, r22
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	22 0f       	add	r18, r18
     44a:	33 1f       	adc	r19, r19
     44c:	82 0f       	add	r24, r18
     44e:	93 1f       	adc	r25, r19
     450:	dc 01       	movw	r26, r24
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	00 97       	sbiw	r24, 0x00	; 0
     458:	41 f0       	breq	.+16     	; 0x46a <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     45a:	64 2f       	mov	r22, r20
     45c:	dc 01       	movw	r26, r24
     45e:	ed 91       	ld	r30, X+
     460:	fc 91       	ld	r31, X
     462:	06 80       	ldd	r0, Z+6	; 0x06
     464:	f7 81       	ldd	r31, Z+7	; 0x07
     466:	e0 2d       	mov	r30, r0
     468:	09 95       	icall
     46a:	08 95       	ret

0000046c <_ZN11Dev_Manager6WritesE8Dev_typePc>:
     46c:	26 2f       	mov	r18, r22
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	22 0f       	add	r18, r18
     472:	33 1f       	adc	r19, r19
     474:	82 0f       	add	r24, r18
     476:	93 1f       	adc	r25, r19
     478:	dc 01       	movw	r26, r24
     47a:	8d 91       	ld	r24, X+
     47c:	9c 91       	ld	r25, X
     47e:	00 97       	sbiw	r24, 0x00	; 0
     480:	41 f0       	breq	.+16     	; 0x492 <_ZN11Dev_Manager6WritesE8Dev_typePc+0x26>
     482:	ba 01       	movw	r22, r20
     484:	dc 01       	movw	r26, r24
     486:	ed 91       	ld	r30, X+
     488:	fc 91       	ld	r31, X
     48a:	04 80       	ldd	r0, Z+4	; 0x04
     48c:	f5 81       	ldd	r31, Z+5	; 0x05
     48e:	e0 2d       	mov	r30, r0
     490:	09 95       	icall
     492:	08 95       	ret

00000494 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     494:	70 e0       	ldi	r23, 0x00	; 0
     496:	66 0f       	add	r22, r22
     498:	77 1f       	adc	r23, r23
     49a:	86 0f       	add	r24, r22
     49c:	97 1f       	adc	r25, r23
     49e:	dc 01       	movw	r26, r24
     4a0:	8d 91       	ld	r24, X+
     4a2:	9c 91       	ld	r25, X
     4a4:	00 97       	sbiw	r24, 0x00	; 0
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     4a8:	dc 01       	movw	r26, r24
     4aa:	ed 91       	ld	r30, X+
     4ac:	fc 91       	ld	r31, X
     4ae:	01 90       	ld	r0, Z+
     4b0:	f0 81       	ld	r31, Z
     4b2:	e0 2d       	mov	r30, r0
     4b4:	09 95       	icall
     4b6:	08 95       	ret

000004b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     4b8:	e6 2f       	mov	r30, r22
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 0f       	add	r30, r24
     4c2:	f9 1f       	adc	r31, r25
     4c4:	80 81       	ld	r24, Z
     4c6:	91 81       	ldd	r25, Z+1	; 0x01
     4c8:	89 2b       	or	r24, r25
     4ca:	11 f0       	breq	.+4      	; 0x4d0 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     4cc:	57 83       	std	Z+7, r21	; 0x07
     4ce:	46 83       	std	Z+6, r20	; 0x06
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	66 0f       	add	r22, r22
     4d6:	77 1f       	adc	r23, r23
     4d8:	fc 01       	movw	r30, r24
     4da:	e6 0f       	add	r30, r22
     4dc:	f7 1f       	adc	r31, r23
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	20 81       	ld	r18, Z
     4e2:	31 81       	ldd	r19, Z+1	; 0x01
     4e4:	23 2b       	or	r18, r19
     4e6:	09 f4       	brne	.+2      	; 0x4ea <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	08 95       	ret

000004ec <_ZN11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device)
{
	if(interface[Device])
     4ec:	70 e0       	ldi	r23, 0x00	; 0
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	86 0f       	add	r24, r22
     4f4:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     4f6:	fc 01       	movw	r30, r24
     4f8:	80 81       	ld	r24, Z
     4fa:	91 81       	ldd	r25, Z+1	; 0x01
     4fc:	08 95       	ret

000004fe <__vector_18>:
ISR(USART0_RX_vect)
{
     4fe:	1f 92       	push	r1
     500:	0f 92       	push	r0
     502:	0f b6       	in	r0, 0x3f	; 63
     504:	0f 92       	push	r0
     506:	11 24       	eor	r1, r1
     508:	0b b6       	in	r0, 0x3b	; 59
     50a:	0f 92       	push	r0
     50c:	2f 93       	push	r18
     50e:	3f 93       	push	r19
     510:	4f 93       	push	r20
     512:	5f 93       	push	r21
     514:	6f 93       	push	r22
     516:	7f 93       	push	r23
     518:	8f 93       	push	r24
     51a:	9f 93       	push	r25
     51c:	af 93       	push	r26
     51e:	bf 93       	push	r27
     520:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     522:	ff 93       	push	r31
     524:	6a df       	rcall	.-300    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     526:	6c b1       	in	r22, 0x0c	; 12
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	dc 01       	movw	r26, r24
     52c:	16 96       	adiw	r26, 0x06	; 6
     52e:	ed 91       	ld	r30, X+
     530:	fc 91       	ld	r31, X
     532:	17 97       	sbiw	r26, 0x07	; 7
     534:	80 e0       	ldi	r24, 0x00	; 0
}
     536:	09 95       	icall
     538:	ff 91       	pop	r31
     53a:	ef 91       	pop	r30
     53c:	bf 91       	pop	r27
     53e:	af 91       	pop	r26
     540:	9f 91       	pop	r25
     542:	8f 91       	pop	r24
     544:	7f 91       	pop	r23
     546:	6f 91       	pop	r22
     548:	5f 91       	pop	r21
     54a:	4f 91       	pop	r20
     54c:	3f 91       	pop	r19
     54e:	2f 91       	pop	r18
     550:	0f 90       	pop	r0
     552:	0b be       	out	0x3b, r0	; 59
     554:	0f 90       	pop	r0
     556:	0f be       	out	0x3f, r0	; 63
     558:	0f 90       	pop	r0
     55a:	1f 90       	pop	r1
     55c:	18 95       	reti

0000055e <__vector_30>:
ISR(USART1_RX_vect)
{
     55e:	1f 92       	push	r1
     560:	0f 92       	push	r0
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	0f 92       	push	r0
     566:	11 24       	eor	r1, r1
     568:	0b b6       	in	r0, 0x3b	; 59
     56a:	0f 92       	push	r0
     56c:	2f 93       	push	r18
     56e:	3f 93       	push	r19
     570:	4f 93       	push	r20
     572:	5f 93       	push	r21
     574:	6f 93       	push	r22
     576:	7f 93       	push	r23
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
     57c:	af 93       	push	r26
     57e:	bf 93       	push	r27
     580:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     582:	ff 93       	push	r31
     584:	3a df       	rcall	.-396    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     586:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	dc 01       	movw	r26, r24
     58e:	18 96       	adiw	r26, 0x08	; 8
     590:	ed 91       	ld	r30, X+
     592:	fc 91       	ld	r31, X
     594:	19 97       	sbiw	r26, 0x09	; 9
     596:	81 e0       	ldi	r24, 0x01	; 1
}
     598:	09 95       	icall
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	bf 91       	pop	r27
     5a0:	af 91       	pop	r26
     5a2:	9f 91       	pop	r25
     5a4:	8f 91       	pop	r24
     5a6:	7f 91       	pop	r23
     5a8:	6f 91       	pop	r22
     5aa:	5f 91       	pop	r21
     5ac:	4f 91       	pop	r20
     5ae:	3f 91       	pop	r19
     5b0:	2f 91       	pop	r18
     5b2:	0f 90       	pop	r0
     5b4:	0b be       	out	0x3b, r0	; 59
     5b6:	0f 90       	pop	r0
     5b8:	0f be       	out	0x3f, r0	; 63
     5ba:	0f 90       	pop	r0
     5bc:	1f 90       	pop	r1
     5be:	18 95       	reti

000005c0 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     5c0:	1f 92       	push	r1
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	0f 92       	push	r0
     5c8:	11 24       	eor	r1, r1
     5ca:	0b b6       	in	r0, 0x3b	; 59
     5cc:	0f 92       	push	r0
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,0);
     5e4:	ff 93       	push	r31
     5e6:	09 df       	rcall	.-494    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     5e8:	dc 01       	movw	r26, r24
     5ea:	1a 96       	adiw	r26, 0x0a	; 10
     5ec:	ed 91       	ld	r30, X+
     5ee:	fc 91       	ld	r31, X
     5f0:	1b 97       	sbiw	r26, 0x0b	; 11
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	82 e0       	ldi	r24, 0x02	; 2
     5f8:	09 95       	icall
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	bf 91       	pop	r27
     600:	af 91       	pop	r26
     602:	9f 91       	pop	r25
     604:	8f 91       	pop	r24
     606:	7f 91       	pop	r23
     608:	6f 91       	pop	r22
     60a:	5f 91       	pop	r21
     60c:	4f 91       	pop	r20
     60e:	3f 91       	pop	r19
     610:	2f 91       	pop	r18
     612:	0f 90       	pop	r0
     614:	0b be       	out	0x3b, r0	; 59
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0
     61c:	1f 90       	pop	r1
     61e:	18 95       	reti

00000620 <_ZN20DeviceDriveInterFace11Device_ReadEv>:
{
	return malloc(size);
}
void Timer::operator delete(void* ptr)
{
	free(ptr);
     620:	08 95       	ret

00000622 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
     622:	08 95       	ret

00000624 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
     624:	08 95       	ret

00000626 <_ZN5Timer11Device_InitEv>:
     626:	80 e4       	ldi	r24, 0x40	; 64
     628:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
     632:	88 e0       	ldi	r24, 0x08	; 8
     634:	9d e3       	ldi	r25, 0x3D	; 61
     636:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     63a:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     63e:	82 e0       	ldi	r24, 0x02	; 2
     640:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     644:	08 95       	ret

00000646 <_ZN5TimerC1Ev>:
     646:	2f e0       	ldi	r18, 0x0F	; 15
     648:	31 e0       	ldi	r19, 0x01	; 1
     64a:	fc 01       	movw	r30, r24
     64c:	31 83       	std	Z+1, r19	; 0x01
     64e:	20 83       	st	Z, r18
     650:	08 95       	ret

00000652 <_ZN5TimernwEj>:
     652:	52 c7       	rjmp	.+3748   	; 0x14f8 <pvPortMalloc>
     654:	08 95       	ret

00000656 <_GLOBAL__sub_I_dev1>:
 *
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"
Dev_Manager dev1;
     656:	86 e9       	ldi	r24, 0x96	; 150
     658:	91 e0       	ldi	r25, 0x01	; 1
     65a:	b9 ce       	rjmp	.-654    	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     65c:	08 95       	ret

0000065e <_GLOBAL__sub_D_dev1>:
	TCCR3B = 0x04;
	OCR3A = 15624;
	ETIMSK = 1 << OCIE3C;
}
void* Timer::operator new(size_t size)
{
     65e:	86 e9       	ldi	r24, 0x96	; 150
     660:	91 e0       	ldi	r25, 0x01	; 1
     662:	c6 ce       	rjmp	.-628    	; 0x3f0 <_ZN11Dev_ManagerD1Ev>
     664:	08 95       	ret

00000666 <_ZN11RS485Driver11Device_InitEv>:
     666:	cf 93       	push	r28
     668:	df 93       	push	r29
     66a:	ec 01       	movw	r28, r24
     66c:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     670:	88 e9       	ldi	r24, 0x98	; 152
     672:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     676:	86 e0       	ldi	r24, 0x06	; 6
     678:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     67c:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     680:	87 e6       	ldi	r24, 0x67	; 103
     682:	80 93 99 00 	sts	0x0099, r24	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     686:	81 e0       	ldi	r24, 0x01	; 1
     688:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <xQueueCreateMutex>
     68c:	9d 83       	std	Y+5, r25	; 0x05
     68e:	8c 83       	std	Y+4, r24	; 0x04
     690:	81 e0       	ldi	r24, 0x01	; 1
     692:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <xQueueCreateMutex>
     696:	9b 83       	std	Y+3, r25	; 0x03
     698:	8a 83       	std	Y+2, r24	; 0x02
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	08 95       	ret

000006a0 <_ZN11RS485DriverC1Ev>:
     6a0:	2b e1       	ldi	r18, 0x1B	; 27
     6a2:	31 e0       	ldi	r19, 0x01	; 1
     6a4:	fc 01       	movw	r30, r24
     6a6:	31 83       	std	Z+1, r19	; 0x01
     6a8:	20 83       	st	Z, r18
     6aa:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <_ZN11RS485Driver4instE>
     6ae:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <_ZN11RS485Driver4instE+0x1>
     6b2:	23 2b       	or	r18, r19
     6b4:	21 f4       	brne	.+8      	; 0x6be <_ZN11RS485DriverC1Ev+0x1e>
     6b6:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <_ZN11RS485Driver4instE+0x1>
     6ba:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <_ZN11RS485Driver4instE>
     6be:	08 95       	ret

000006c0 <_ZN11RS485DrivernwEj>:
     6c0:	1b c7       	rjmp	.+3638   	; 0x14f8 <pvPortMalloc>
     6c2:	08 95       	ret

000006c4 <_ZN11RS485Driver12UART_PutcharEc>:
     6c4:	1f 93       	push	r17
     6c6:	cf 93       	push	r28
     6c8:	df 93       	push	r29
     6ca:	ec 01       	movw	r28, r24
     6cc:	16 2f       	mov	r17, r22
     6ce:	20 e0       	ldi	r18, 0x00	; 0
     6d0:	44 e6       	ldi	r20, 0x64	; 100
     6d2:	50 e0       	ldi	r21, 0x00	; 0
     6d4:	60 e0       	ldi	r22, 0x00	; 0
     6d6:	70 e0       	ldi	r23, 0x00	; 0
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <xQueueGenericReceive>
     6e0:	81 30       	cpi	r24, 0x01	; 1
     6e2:	81 f4       	brne	.+32     	; 0x704 <_ZN11RS485Driver12UART_PutcharEc+0x40>
     6e4:	eb e9       	ldi	r30, 0x9B	; 155
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	80 81       	ld	r24, Z
     6ea:	85 ff       	sbrs	r24, 5
     6ec:	fd cf       	rjmp	.-6      	; 0x6e8 <_ZN11RS485Driver12UART_PutcharEc+0x24>
     6ee:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     6f2:	20 e0       	ldi	r18, 0x00	; 0
     6f4:	40 e0       	ldi	r20, 0x00	; 0
     6f6:	50 e0       	ldi	r21, 0x00	; 0
     6f8:	60 e0       	ldi	r22, 0x00	; 0
     6fa:	70 e0       	ldi	r23, 0x00	; 0
     6fc:	8a 81       	ldd	r24, Y+2	; 0x02
     6fe:	9b 81       	ldd	r25, Y+3	; 0x03
     700:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xQueueGenericSend>
     704:	df 91       	pop	r29
     706:	cf 91       	pop	r28
     708:	1f 91       	pop	r17
     70a:	08 95       	ret

0000070c <_ZN11RS485Driver12Device_WriteEc>:
     70c:	db cf       	rjmp	.-74     	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc>
     70e:	08 95       	ret

00000710 <_ZN11RS485Driver14UART_PutStringEPKc>:
     710:	0f 93       	push	r16
     712:	1f 93       	push	r17
     714:	cf 93       	push	r28
     716:	df 93       	push	r29
     718:	8c 01       	movw	r16, r24
     71a:	eb 01       	movw	r28, r22
     71c:	20 e0       	ldi	r18, 0x00	; 0
     71e:	44 e6       	ldi	r20, 0x64	; 100
     720:	50 e0       	ldi	r21, 0x00	; 0
     722:	60 e0       	ldi	r22, 0x00	; 0
     724:	70 e0       	ldi	r23, 0x00	; 0
     726:	fc 01       	movw	r30, r24
     728:	84 81       	ldd	r24, Z+4	; 0x04
     72a:	95 81       	ldd	r25, Z+5	; 0x05
     72c:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <xQueueGenericReceive>
     730:	81 30       	cpi	r24, 0x01	; 1
     732:	99 f4       	brne	.+38     	; 0x75a <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     734:	68 81       	ld	r22, Y
     736:	66 23       	and	r22, r22
     738:	31 f0       	breq	.+12     	; 0x746 <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     73a:	21 96       	adiw	r28, 0x01	; 1
     73c:	c8 01       	movw	r24, r16
     73e:	c2 df       	rcall	.-124    	; 0x6c4 <_ZN11RS485Driver12UART_PutcharEc>
     740:	69 91       	ld	r22, Y+
     742:	61 11       	cpse	r22, r1
     744:	fb cf       	rjmp	.-10     	; 0x73c <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	40 e0       	ldi	r20, 0x00	; 0
     74a:	50 e0       	ldi	r21, 0x00	; 0
     74c:	60 e0       	ldi	r22, 0x00	; 0
     74e:	70 e0       	ldi	r23, 0x00	; 0
     750:	f8 01       	movw	r30, r16
     752:	84 81       	ldd	r24, Z+4	; 0x04
     754:	95 81       	ldd	r25, Z+5	; 0x05
     756:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xQueueGenericSend>
     75a:	df 91       	pop	r29
     75c:	cf 91       	pop	r28
     75e:	1f 91       	pop	r17
     760:	0f 91       	pop	r16
     762:	08 95       	ret

00000764 <_ZN11RS485Driver13Device_WritesEPKc>:
     764:	d5 cf       	rjmp	.-86     	; 0x710 <_ZN11RS485Driver14UART_PutStringEPKc>
     766:	08 95       	ret

00000768 <_ZN10UartDriver11Device_InitEv>:
     768:	cf 93       	push	r28
     76a:	df 93       	push	r29
     76c:	ec 01       	movw	r28, r24
     76e:	88 e9       	ldi	r24, 0x98	; 152
     770:	8a b9       	out	0x0a, r24	; 10
     772:	86 e0       	ldi	r24, 0x06	; 6
     774:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     778:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     77c:	8f ec       	ldi	r24, 0xCF	; 207
     77e:	89 b9       	out	0x09, r24	; 9
     780:	81 e0       	ldi	r24, 0x01	; 1
     782:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <xQueueCreateMutex>
     786:	9d 83       	std	Y+5, r25	; 0x05
     788:	8c 83       	std	Y+4, r24	; 0x04
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <xQueueCreateMutex>
     790:	9b 83       	std	Y+3, r25	; 0x03
     792:	8a 83       	std	Y+2, r24	; 0x02
     794:	df 91       	pop	r29
     796:	cf 91       	pop	r28
     798:	08 95       	ret

0000079a <_ZN10UartDriverC1Ev>:
     79a:	27 e2       	ldi	r18, 0x27	; 39
     79c:	31 e0       	ldi	r19, 0x01	; 1
     79e:	fc 01       	movw	r30, r24
     7a0:	31 83       	std	Z+1, r19	; 0x01
     7a2:	20 83       	st	Z, r18
     7a4:	20 91 a4 01 	lds	r18, 0x01A4	; 0x8001a4 <_ZN10UartDriver4instE>
     7a8:	30 91 a5 01 	lds	r19, 0x01A5	; 0x8001a5 <_ZN10UartDriver4instE+0x1>
     7ac:	23 2b       	or	r18, r19
     7ae:	21 f4       	brne	.+8      	; 0x7b8 <_ZN10UartDriverC1Ev+0x1e>
     7b0:	90 93 a5 01 	sts	0x01A5, r25	; 0x8001a5 <_ZN10UartDriver4instE+0x1>
     7b4:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <_ZN10UartDriver4instE>
     7b8:	08 95       	ret

000007ba <_ZN10UartDrivernwEj>:
     7ba:	9e c6       	rjmp	.+3388   	; 0x14f8 <pvPortMalloc>
     7bc:	08 95       	ret

000007be <_ZN10UartDriver12UART_PutcharEc>:
     7be:	1f 93       	push	r17
     7c0:	cf 93       	push	r28
     7c2:	df 93       	push	r29
     7c4:	ec 01       	movw	r28, r24
     7c6:	16 2f       	mov	r17, r22
     7c8:	20 e0       	ldi	r18, 0x00	; 0
     7ca:	44 e6       	ldi	r20, 0x64	; 100
     7cc:	50 e0       	ldi	r21, 0x00	; 0
     7ce:	60 e0       	ldi	r22, 0x00	; 0
     7d0:	70 e0       	ldi	r23, 0x00	; 0
     7d2:	8a 81       	ldd	r24, Y+2	; 0x02
     7d4:	9b 81       	ldd	r25, Y+3	; 0x03
     7d6:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <xQueueGenericReceive>
     7da:	81 30       	cpi	r24, 0x01	; 1
     7dc:	61 f4       	brne	.+24     	; 0x7f6 <_ZN10UartDriver12UART_PutcharEc+0x38>
     7de:	5d 9b       	sbis	0x0b, 5	; 11
     7e0:	fe cf       	rjmp	.-4      	; 0x7de <_ZN10UartDriver12UART_PutcharEc+0x20>
     7e2:	1c b9       	out	0x0c, r17	; 12
     7e4:	20 e0       	ldi	r18, 0x00	; 0
     7e6:	40 e0       	ldi	r20, 0x00	; 0
     7e8:	50 e0       	ldi	r21, 0x00	; 0
     7ea:	60 e0       	ldi	r22, 0x00	; 0
     7ec:	70 e0       	ldi	r23, 0x00	; 0
     7ee:	8a 81       	ldd	r24, Y+2	; 0x02
     7f0:	9b 81       	ldd	r25, Y+3	; 0x03
     7f2:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xQueueGenericSend>
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	1f 91       	pop	r17
     7fc:	08 95       	ret

000007fe <_ZN10UartDriver12Device_WriteEc>:
     7fe:	df cf       	rjmp	.-66     	; 0x7be <_ZN10UartDriver12UART_PutcharEc>
     800:	08 95       	ret

00000802 <_ZN10UartDriver14UART_PutStringEPKc>:
     802:	0f 93       	push	r16
     804:	1f 93       	push	r17
     806:	cf 93       	push	r28
     808:	df 93       	push	r29
     80a:	8c 01       	movw	r16, r24
     80c:	eb 01       	movw	r28, r22
     80e:	20 e0       	ldi	r18, 0x00	; 0
     810:	44 e6       	ldi	r20, 0x64	; 100
     812:	50 e0       	ldi	r21, 0x00	; 0
     814:	60 e0       	ldi	r22, 0x00	; 0
     816:	70 e0       	ldi	r23, 0x00	; 0
     818:	fc 01       	movw	r30, r24
     81a:	84 81       	ldd	r24, Z+4	; 0x04
     81c:	95 81       	ldd	r25, Z+5	; 0x05
     81e:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <xQueueGenericReceive>
     822:	81 30       	cpi	r24, 0x01	; 1
     824:	99 f4       	brne	.+38     	; 0x84c <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     826:	68 81       	ld	r22, Y
     828:	66 23       	and	r22, r22
     82a:	31 f0       	breq	.+12     	; 0x838 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     82c:	21 96       	adiw	r28, 0x01	; 1
     82e:	c8 01       	movw	r24, r16
     830:	c6 df       	rcall	.-116    	; 0x7be <_ZN10UartDriver12UART_PutcharEc>
     832:	69 91       	ld	r22, Y+
     834:	61 11       	cpse	r22, r1
     836:	fb cf       	rjmp	.-10     	; 0x82e <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     838:	20 e0       	ldi	r18, 0x00	; 0
     83a:	40 e0       	ldi	r20, 0x00	; 0
     83c:	50 e0       	ldi	r21, 0x00	; 0
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	70 e0       	ldi	r23, 0x00	; 0
     842:	f8 01       	movw	r30, r16
     844:	84 81       	ldd	r24, Z+4	; 0x04
     846:	95 81       	ldd	r25, Z+5	; 0x05
     848:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <xQueueGenericSend>
     84c:	df 91       	pop	r29
     84e:	cf 91       	pop	r28
     850:	1f 91       	pop	r17
     852:	0f 91       	pop	r16
     854:	08 95       	ret

00000856 <_ZN10UartDriver13Device_WritesEPKc>:
     856:	d5 cf       	rjmp	.-86     	; 0x802 <_ZN10UartDriver14UART_PutStringEPKc>
     858:	08 95       	ret

0000085a <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     85a:	c0 98       	cbi	0x18, 0	; 24
     85c:	96 2f       	mov	r25, r22
     85e:	6f 71       	andi	r22, 0x1F	; 31
     860:	86 2b       	or	r24, r22
     862:	8f b9       	out	0x0f, r24	; 15
     864:	77 9b       	sbis	0x0e, 7	; 14
     866:	fe cf       	rjmp	.-4      	; 0x864 <_Z14enc28j60ReadOphh+0xa>
     868:	1f b8       	out	0x0f, r1	; 15
     86a:	77 9b       	sbis	0x0e, 7	; 14
     86c:	fe cf       	rjmp	.-4      	; 0x86a <_Z14enc28j60ReadOphh+0x10>
     86e:	99 23       	and	r25, r25
     870:	1c f4       	brge	.+6      	; 0x878 <_Z14enc28j60ReadOphh+0x1e>
     872:	1f b8       	out	0x0f, r1	; 15
     874:	77 9b       	sbis	0x0e, 7	; 14
     876:	fe cf       	rjmp	.-4      	; 0x874 <_Z14enc28j60ReadOphh+0x1a>
     878:	c0 9a       	sbi	0x18, 0	; 24
     87a:	8f b1       	in	r24, 0x0f	; 15
     87c:	08 95       	ret

0000087e <_Z15enc28j60WriteOphhh>:
     87e:	c0 98       	cbi	0x18, 0	; 24
     880:	6f 71       	andi	r22, 0x1F	; 31
     882:	86 2b       	or	r24, r22
     884:	8f b9       	out	0x0f, r24	; 15
     886:	77 9b       	sbis	0x0e, 7	; 14
     888:	fe cf       	rjmp	.-4      	; 0x886 <_Z15enc28j60WriteOphhh+0x8>
     88a:	4f b9       	out	0x0f, r20	; 15
     88c:	77 9b       	sbis	0x0e, 7	; 14
     88e:	fe cf       	rjmp	.-4      	; 0x88c <_Z15enc28j60WriteOphhh+0xe>
     890:	c0 9a       	sbi	0x18, 0	; 24
     892:	08 95       	ret

00000894 <_Z18enc28j60ReadBufferjPh>:
     894:	fb 01       	movw	r30, r22
     896:	c0 98       	cbi	0x18, 0	; 24
     898:	2a e3       	ldi	r18, 0x3A	; 58
     89a:	2f b9       	out	0x0f, r18	; 15
     89c:	77 9b       	sbis	0x0e, 7	; 14
     89e:	fe cf       	rjmp	.-4      	; 0x89c <_Z18enc28j60ReadBufferjPh+0x8>
     8a0:	00 97       	sbiw	r24, 0x00	; 0
     8a2:	61 f0       	breq	.+24     	; 0x8bc <_Z18enc28j60ReadBufferjPh+0x28>
     8a4:	df 01       	movw	r26, r30
     8a6:	a8 0f       	add	r26, r24
     8a8:	b9 1f       	adc	r27, r25
     8aa:	1f b8       	out	0x0f, r1	; 15
     8ac:	77 9b       	sbis	0x0e, 7	; 14
     8ae:	fe cf       	rjmp	.-4      	; 0x8ac <_Z18enc28j60ReadBufferjPh+0x18>
     8b0:	9f b1       	in	r25, 0x0f	; 15
     8b2:	91 93       	st	Z+, r25
     8b4:	ae 17       	cp	r26, r30
     8b6:	bf 07       	cpc	r27, r31
     8b8:	c1 f7       	brne	.-16     	; 0x8aa <_Z18enc28j60ReadBufferjPh+0x16>
     8ba:	01 c0       	rjmp	.+2      	; 0x8be <_Z18enc28j60ReadBufferjPh+0x2a>
     8bc:	df 01       	movw	r26, r30
     8be:	1c 92       	st	X, r1
     8c0:	c0 9a       	sbi	0x18, 0	; 24
     8c2:	08 95       	ret

000008c4 <_Z19enc28j60WriteBufferjPh>:
     8c4:	fb 01       	movw	r30, r22
     8c6:	c0 98       	cbi	0x18, 0	; 24
     8c8:	2a e7       	ldi	r18, 0x7A	; 122
     8ca:	2f b9       	out	0x0f, r18	; 15
     8cc:	77 9b       	sbis	0x0e, 7	; 14
     8ce:	fe cf       	rjmp	.-4      	; 0x8cc <_Z19enc28j60WriteBufferjPh+0x8>
     8d0:	00 97       	sbiw	r24, 0x00	; 0
     8d2:	61 f0       	breq	.+24     	; 0x8ec <_Z19enc28j60WriteBufferjPh+0x28>
     8d4:	9f 01       	movw	r18, r30
     8d6:	28 0f       	add	r18, r24
     8d8:	39 1f       	adc	r19, r25
     8da:	03 c0       	rjmp	.+6      	; 0x8e2 <_Z19enc28j60WriteBufferjPh+0x1e>
     8dc:	2e 17       	cp	r18, r30
     8de:	3f 07       	cpc	r19, r31
     8e0:	29 f0       	breq	.+10     	; 0x8ec <_Z19enc28j60WriteBufferjPh+0x28>
     8e2:	91 91       	ld	r25, Z+
     8e4:	9f b9       	out	0x0f, r25	; 15
     8e6:	77 9b       	sbis	0x0e, 7	; 14
     8e8:	fe cf       	rjmp	.-4      	; 0x8e6 <_Z19enc28j60WriteBufferjPh+0x22>
     8ea:	f8 cf       	rjmp	.-16     	; 0x8dc <_Z19enc28j60WriteBufferjPh+0x18>
     8ec:	c0 9a       	sbi	0x18, 0	; 24
     8ee:	08 95       	ret

000008f0 <_Z15enc28j60SetBankh>:
     8f0:	1f 93       	push	r17
     8f2:	cf 93       	push	r28
     8f4:	df 93       	push	r29
     8f6:	18 2f       	mov	r17, r24
     8f8:	10 76       	andi	r17, 0x60	; 96
     8fa:	c1 2f       	mov	r28, r17
     8fc:	d0 e0       	ldi	r29, 0x00	; 0
     8fe:	80 91 a8 01 	lds	r24, 0x01A8	; 0x8001a8 <_ZL12Enc28j60Bank>
     902:	90 e0       	ldi	r25, 0x00	; 0
     904:	c8 17       	cp	r28, r24
     906:	d9 07       	cpc	r29, r25
     908:	a1 f0       	breq	.+40     	; 0x932 <_Z15enc28j60SetBankh+0x42>
     90a:	43 e0       	ldi	r20, 0x03	; 3
     90c:	6f e1       	ldi	r22, 0x1F	; 31
     90e:	80 ea       	ldi	r24, 0xA0	; 160
     910:	b6 df       	rcall	.-148    	; 0x87e <_Z15enc28j60WriteOphhh>
     912:	ae 01       	movw	r20, r28
     914:	55 95       	asr	r21
     916:	47 95       	ror	r20
     918:	55 95       	asr	r21
     91a:	47 95       	ror	r20
     91c:	55 95       	asr	r21
     91e:	47 95       	ror	r20
     920:	55 95       	asr	r21
     922:	47 95       	ror	r20
     924:	55 95       	asr	r21
     926:	47 95       	ror	r20
     928:	6f e1       	ldi	r22, 0x1F	; 31
     92a:	80 e8       	ldi	r24, 0x80	; 128
     92c:	a8 df       	rcall	.-176    	; 0x87e <_Z15enc28j60WriteOphhh>
     92e:	10 93 a8 01 	sts	0x01A8, r17	; 0x8001a8 <_ZL12Enc28j60Bank>
     932:	df 91       	pop	r29
     934:	cf 91       	pop	r28
     936:	1f 91       	pop	r17
     938:	08 95       	ret

0000093a <_Z12enc28j60Readh>:
     93a:	cf 93       	push	r28
     93c:	c8 2f       	mov	r28, r24
     93e:	d8 df       	rcall	.-80     	; 0x8f0 <_Z15enc28j60SetBankh>
     940:	6c 2f       	mov	r22, r28
     942:	80 e0       	ldi	r24, 0x00	; 0
     944:	8a df       	rcall	.-236    	; 0x85a <_Z14enc28j60ReadOphh>
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_Z13enc28j60Writehh>:
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	c8 2f       	mov	r28, r24
     950:	d6 2f       	mov	r29, r22
     952:	ce df       	rcall	.-100    	; 0x8f0 <_Z15enc28j60SetBankh>
     954:	4d 2f       	mov	r20, r29
     956:	6c 2f       	mov	r22, r28
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	91 df       	rcall	.-222    	; 0x87e <_Z15enc28j60WriteOphhh>
     95c:	df 91       	pop	r29
     95e:	cf 91       	pop	r28
     960:	08 95       	ret

00000962 <_Z16enc28j60PhyWritehj>:
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	d6 2f       	mov	r29, r22
     968:	c7 2f       	mov	r28, r23
     96a:	68 2f       	mov	r22, r24
     96c:	84 ed       	ldi	r24, 0xD4	; 212
     96e:	ed df       	rcall	.-38     	; 0x94a <_Z13enc28j60Writehh>
     970:	6d 2f       	mov	r22, r29
     972:	86 ed       	ldi	r24, 0xD6	; 214
     974:	ea df       	rcall	.-44     	; 0x94a <_Z13enc28j60Writehh>
     976:	6c 2f       	mov	r22, r28
     978:	87 ed       	ldi	r24, 0xD7	; 215
     97a:	e7 df       	rcall	.-50     	; 0x94a <_Z13enc28j60Writehh>
     97c:	8a ee       	ldi	r24, 0xEA	; 234
     97e:	dd df       	rcall	.-70     	; 0x93a <_Z12enc28j60Readh>
     980:	80 ff       	sbrs	r24, 0
     982:	04 c0       	rjmp	.+8      	; 0x98c <_Z16enc28j60PhyWritehj+0x2a>
     984:	85 e0       	ldi	r24, 0x05	; 5
     986:	8a 95       	dec	r24
     988:	f1 f7       	brne	.-4      	; 0x986 <_Z16enc28j60PhyWritehj+0x24>
     98a:	f8 cf       	rjmp	.-16     	; 0x97c <_Z16enc28j60PhyWritehj+0x1a>
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	08 95       	ret

00000992 <_Z14enc28j60clkouth>:
     992:	68 2f       	mov	r22, r24
     994:	67 70       	andi	r22, 0x07	; 7
     996:	85 e7       	ldi	r24, 0x75	; 117
     998:	d8 cf       	rjmp	.-80     	; 0x94a <_Z13enc28j60Writehh>
     99a:	08 95       	ret

0000099c <_Z12enc28j60InitPh>:
     99c:	cf 93       	push	r28
     99e:	df 93       	push	r29
     9a0:	ec 01       	movw	r28, r24
     9a2:	b8 9a       	sbi	0x17, 0	; 23
     9a4:	c0 9a       	sbi	0x18, 0	; 24
     9a6:	a6 d2       	rcall	.+1356   	; 0xef4 <_Z8spi_initv>
     9a8:	4f ef       	ldi	r20, 0xFF	; 255
     9aa:	60 e0       	ldi	r22, 0x00	; 0
     9ac:	8f ef       	ldi	r24, 0xFF	; 255
     9ae:	67 df       	rcall	.-306    	; 0x87e <_Z15enc28j60WriteOphhh>
     9b0:	82 e3       	ldi	r24, 0x32	; 50
     9b2:	90 e0       	ldi	r25, 0x00	; 0
     9b4:	ac d2       	rcall	.+1368   	; 0xf0e <_Z8delay_msj>
     9b6:	10 92 a7 01 	sts	0x01A7, r1	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
     9ba:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <_ZL13NextPacketPtr>
     9be:	60 e0       	ldi	r22, 0x00	; 0
     9c0:	88 e0       	ldi	r24, 0x08	; 8
     9c2:	c3 df       	rcall	.-122    	; 0x94a <_Z13enc28j60Writehh>
     9c4:	60 e0       	ldi	r22, 0x00	; 0
     9c6:	89 e0       	ldi	r24, 0x09	; 9
     9c8:	c0 df       	rcall	.-128    	; 0x94a <_Z13enc28j60Writehh>
     9ca:	60 e0       	ldi	r22, 0x00	; 0
     9cc:	8c e0       	ldi	r24, 0x0C	; 12
     9ce:	bd df       	rcall	.-134    	; 0x94a <_Z13enc28j60Writehh>
     9d0:	60 e0       	ldi	r22, 0x00	; 0
     9d2:	8d e0       	ldi	r24, 0x0D	; 13
     9d4:	ba df       	rcall	.-140    	; 0x94a <_Z13enc28j60Writehh>
     9d6:	6e ef       	ldi	r22, 0xFE	; 254
     9d8:	8a e0       	ldi	r24, 0x0A	; 10
     9da:	b7 df       	rcall	.-146    	; 0x94a <_Z13enc28j60Writehh>
     9dc:	69 e1       	ldi	r22, 0x19	; 25
     9de:	8b e0       	ldi	r24, 0x0B	; 11
     9e0:	b4 df       	rcall	.-152    	; 0x94a <_Z13enc28j60Writehh>
     9e2:	6f ef       	ldi	r22, 0xFF	; 255
     9e4:	84 e0       	ldi	r24, 0x04	; 4
     9e6:	b1 df       	rcall	.-158    	; 0x94a <_Z13enc28j60Writehh>
     9e8:	69 e1       	ldi	r22, 0x19	; 25
     9ea:	85 e0       	ldi	r24, 0x05	; 5
     9ec:	ae df       	rcall	.-164    	; 0x94a <_Z13enc28j60Writehh>
     9ee:	6f ef       	ldi	r22, 0xFF	; 255
     9f0:	86 e0       	ldi	r24, 0x06	; 6
     9f2:	ab df       	rcall	.-170    	; 0x94a <_Z13enc28j60Writehh>
     9f4:	6f e1       	ldi	r22, 0x1F	; 31
     9f6:	87 e0       	ldi	r24, 0x07	; 7
     9f8:	a8 df       	rcall	.-176    	; 0x94a <_Z13enc28j60Writehh>
     9fa:	60 eb       	ldi	r22, 0xB0	; 176
     9fc:	88 e3       	ldi	r24, 0x38	; 56
     9fe:	a5 df       	rcall	.-182    	; 0x94a <_Z13enc28j60Writehh>
     a00:	6f e3       	ldi	r22, 0x3F	; 63
     a02:	88 e2       	ldi	r24, 0x28	; 40
     a04:	a2 df       	rcall	.-188    	; 0x94a <_Z13enc28j60Writehh>
     a06:	60 e3       	ldi	r22, 0x30	; 48
     a08:	89 e2       	ldi	r24, 0x29	; 41
     a0a:	9f df       	rcall	.-194    	; 0x94a <_Z13enc28j60Writehh>
     a0c:	69 ef       	ldi	r22, 0xF9	; 249
     a0e:	80 e3       	ldi	r24, 0x30	; 48
     a10:	9c df       	rcall	.-200    	; 0x94a <_Z13enc28j60Writehh>
     a12:	67 ef       	ldi	r22, 0xF7	; 247
     a14:	81 e3       	ldi	r24, 0x31	; 49
     a16:	99 df       	rcall	.-206    	; 0x94a <_Z13enc28j60Writehh>
     a18:	6d e0       	ldi	r22, 0x0D	; 13
     a1a:	80 ec       	ldi	r24, 0xC0	; 192
     a1c:	96 df       	rcall	.-212    	; 0x94a <_Z13enc28j60Writehh>
     a1e:	60 e0       	ldi	r22, 0x00	; 0
     a20:	81 ec       	ldi	r24, 0xC1	; 193
     a22:	93 df       	rcall	.-218    	; 0x94a <_Z13enc28j60Writehh>
     a24:	42 e3       	ldi	r20, 0x32	; 50
     a26:	62 ec       	ldi	r22, 0xC2	; 194
     a28:	80 e8       	ldi	r24, 0x80	; 128
     a2a:	29 df       	rcall	.-430    	; 0x87e <_Z15enc28j60WriteOphhh>
     a2c:	62 e1       	ldi	r22, 0x12	; 18
     a2e:	86 ec       	ldi	r24, 0xC6	; 198
     a30:	8c df       	rcall	.-232    	; 0x94a <_Z13enc28j60Writehh>
     a32:	6c e0       	ldi	r22, 0x0C	; 12
     a34:	87 ec       	ldi	r24, 0xC7	; 199
     a36:	89 df       	rcall	.-238    	; 0x94a <_Z13enc28j60Writehh>
     a38:	62 e1       	ldi	r22, 0x12	; 18
     a3a:	84 ec       	ldi	r24, 0xC4	; 196
     a3c:	86 df       	rcall	.-244    	; 0x94a <_Z13enc28j60Writehh>
     a3e:	6c ed       	ldi	r22, 0xDC	; 220
     a40:	8a ec       	ldi	r24, 0xCA	; 202
     a42:	83 df       	rcall	.-250    	; 0x94a <_Z13enc28j60Writehh>
     a44:	65 e0       	ldi	r22, 0x05	; 5
     a46:	8b ec       	ldi	r24, 0xCB	; 203
     a48:	80 df       	rcall	.-256    	; 0x94a <_Z13enc28j60Writehh>
     a4a:	68 81       	ld	r22, Y
     a4c:	84 ee       	ldi	r24, 0xE4	; 228
     a4e:	7d df       	rcall	.-262    	; 0x94a <_Z13enc28j60Writehh>
     a50:	69 81       	ldd	r22, Y+1	; 0x01
     a52:	85 ee       	ldi	r24, 0xE5	; 229
     a54:	7a df       	rcall	.-268    	; 0x94a <_Z13enc28j60Writehh>
     a56:	6a 81       	ldd	r22, Y+2	; 0x02
     a58:	82 ee       	ldi	r24, 0xE2	; 226
     a5a:	77 df       	rcall	.-274    	; 0x94a <_Z13enc28j60Writehh>
     a5c:	6b 81       	ldd	r22, Y+3	; 0x03
     a5e:	83 ee       	ldi	r24, 0xE3	; 227
     a60:	74 df       	rcall	.-280    	; 0x94a <_Z13enc28j60Writehh>
     a62:	6c 81       	ldd	r22, Y+4	; 0x04
     a64:	80 ee       	ldi	r24, 0xE0	; 224
     a66:	71 df       	rcall	.-286    	; 0x94a <_Z13enc28j60Writehh>
     a68:	6d 81       	ldd	r22, Y+5	; 0x05
     a6a:	81 ee       	ldi	r24, 0xE1	; 225
     a6c:	6e df       	rcall	.-292    	; 0x94a <_Z13enc28j60Writehh>
     a6e:	60 e0       	ldi	r22, 0x00	; 0
     a70:	71 e0       	ldi	r23, 0x01	; 1
     a72:	80 e1       	ldi	r24, 0x10	; 16
     a74:	76 df       	rcall	.-276    	; 0x962 <_Z16enc28j60PhyWritehj>
     a76:	8f e1       	ldi	r24, 0x1F	; 31
     a78:	3b df       	rcall	.-394    	; 0x8f0 <_Z15enc28j60SetBankh>
     a7a:	40 ec       	ldi	r20, 0xC0	; 192
     a7c:	6b e1       	ldi	r22, 0x1B	; 27
     a7e:	80 e8       	ldi	r24, 0x80	; 128
     a80:	fe de       	rcall	.-516    	; 0x87e <_Z15enc28j60WriteOphhh>
     a82:	44 e0       	ldi	r20, 0x04	; 4
     a84:	6f e1       	ldi	r22, 0x1F	; 31
     a86:	80 e8       	ldi	r24, 0x80	; 128
     a88:	fa de       	rcall	.-524    	; 0x87e <_Z15enc28j60WriteOphhh>
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	08 95       	ret

00000a90 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     a90:	0f 93       	push	r16
     a92:	1f 93       	push	r17
     a94:	cf 93       	push	r28
     a96:	df 93       	push	r29
     a98:	ec 01       	movw	r28, r24
     a9a:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     a9c:	6f ef       	ldi	r22, 0xFF	; 255
     a9e:	82 e0       	ldi	r24, 0x02	; 2
     aa0:	54 df       	rcall	.-344    	; 0x94a <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     aa2:	69 e1       	ldi	r22, 0x19	; 25
     aa4:	83 e0       	ldi	r24, 0x03	; 3
     aa6:	51 df       	rcall	.-350    	; 0x94a <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     aa8:	6c 2f       	mov	r22, r28
     aaa:	61 50       	subi	r22, 0x01	; 1
     aac:	86 e0       	ldi	r24, 0x06	; 6
     aae:	4d df       	rcall	.-358    	; 0x94a <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     ab0:	ce 01       	movw	r24, r28
     ab2:	81 50       	subi	r24, 0x01	; 1
     ab4:	96 4e       	sbci	r25, 0xE6	; 230
     ab6:	69 2f       	mov	r22, r25
     ab8:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     aba:	47 df       	rcall	.-370    	; 0x94a <_Z13enc28j60Writehh>
     abc:	40 e0       	ldi	r20, 0x00	; 0
     abe:	60 e0       	ldi	r22, 0x00	; 0
     ac0:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     ac2:	dd de       	rcall	.-582    	; 0x87e <_Z15enc28j60WriteOphhh>
     ac4:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     ac6:	ce 01       	movw	r24, r28
     ac8:	fd de       	rcall	.-518    	; 0x8c4 <_Z19enc28j60WriteBufferjPh>
     aca:	48 e0       	ldi	r20, 0x08	; 8
     acc:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     ace:	80 e8       	ldi	r24, 0x80	; 128
     ad0:	d6 de       	rcall	.-596    	; 0x87e <_Z15enc28j60WriteOphhh>
     ad2:	8c e1       	ldi	r24, 0x1C	; 28
     ad4:	32 df       	rcall	.-412    	; 0x93a <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     ad6:	81 ff       	sbrs	r24, 1
     ad8:	04 c0       	rjmp	.+8      	; 0xae2 <_Z18enc28j60PacketSendjPh+0x52>
     ada:	48 e0       	ldi	r20, 0x08	; 8
     adc:	6f e1       	ldi	r22, 0x1F	; 31
     ade:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     ae0:	ce de       	rcall	.-612    	; 0x87e <_Z15enc28j60WriteOphhh>
     ae2:	df 91       	pop	r29
     ae4:	cf 91       	pop	r28
     ae6:	1f 91       	pop	r17
     ae8:	0f 91       	pop	r16
     aea:	08 95       	ret

00000aec <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     aec:	9f 92       	push	r9
     aee:	af 92       	push	r10
     af0:	bf 92       	push	r11
     af2:	cf 92       	push	r12
     af4:	df 92       	push	r13
     af6:	ef 92       	push	r14
     af8:	ff 92       	push	r15
     afa:	0f 93       	push	r16
     afc:	1f 93       	push	r17
     afe:	cf 93       	push	r28
     b00:	df 93       	push	r29
     b02:	5c 01       	movw	r10, r24
     b04:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     b06:	89 e3       	ldi	r24, 0x39	; 57
     b08:	18 df       	rcall	.-464    	; 0x93a <_Z12enc28j60Readh>
     b0a:	88 23       	and	r24, r24
     b0c:	09 f4       	brne	.+2      	; 0xb10 <_Z21enc28j60PacketReceivejPh+0x24>
     b0e:	45 c0       	rjmp	.+138    	; 0xb9a <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     b10:	60 91 a6 01 	lds	r22, 0x01A6	; 0x8001a6 <_ZL13NextPacketPtr>
     b14:	c0 91 a7 01 	lds	r28, 0x01A7	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
     b18:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     b1a:	17 df       	rcall	.-466    	; 0x94a <_Z13enc28j60Writehh>
     b1c:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b1e:	81 e0       	ldi	r24, 0x01	; 1
     b20:	14 df       	rcall	.-472    	; 0x94a <_Z13enc28j60Writehh>
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b26:	99 de       	rcall	.-718    	; 0x85a <_Z14enc28j60ReadOphh>
     b28:	c8 2f       	mov	r28, r24
     b2a:	60 e0       	ldi	r22, 0x00	; 0
     b2c:	8a e3       	ldi	r24, 0x3A	; 58
     b2e:	95 de       	rcall	.-726    	; 0x85a <_Z14enc28j60ReadOphh>
     b30:	d0 e0       	ldi	r29, 0x00	; 0
     b32:	d8 2b       	or	r29, r24
     b34:	d0 93 a7 01 	sts	0x01A7, r29	; 0x8001a7 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b38:	c0 93 a6 01 	sts	0x01A6, r28	; 0x8001a6 <_ZL13NextPacketPtr>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b3e:	8a e3       	ldi	r24, 0x3A	; 58
     b40:	8c de       	rcall	.-744    	; 0x85a <_Z14enc28j60ReadOphh>
     b42:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     b44:	60 e0       	ldi	r22, 0x00	; 0
     b46:	8a e3       	ldi	r24, 0x3A	; 58
     b48:	88 de       	rcall	.-752    	; 0x85a <_Z14enc28j60ReadOphh>
     b4a:	98 2e       	mov	r9, r24
     b4c:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     b4e:	8a e3       	ldi	r24, 0x3A	; 58
     b50:	84 de       	rcall	.-760    	; 0x85a <_Z14enc28j60ReadOphh>
     b52:	c8 2e       	mov	r12, r24
     b54:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     b56:	8a e3       	ldi	r24, 0x3A	; 58
     b58:	80 de       	rcall	.-768    	; 0x85a <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     b5a:	c7 fe       	sbrs	r12, 7
     b5c:	0f c0       	rjmp	.+30     	; 0xb7c <_Z21enc28j60PacketReceivejPh+0x90>
     b5e:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     b60:	a8 1a       	sub	r10, r24
     b62:	b1 08       	sbc	r11, r1
     b64:	10 e0       	ldi	r17, 0x00	; 0
     b66:	19 29       	or	r17, r9
     b68:	04 50       	subi	r16, 0x04	; 4
     b6a:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     b6c:	a0 16       	cp	r10, r16
     b6e:	b1 06       	cpc	r11, r17
     b70:	08 f4       	brcc	.+2      	; 0xb74 <_Z21enc28j60PacketReceivejPh+0x88>
     b72:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     b74:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     b76:	c8 01       	movw	r24, r16
     b78:	8d de       	rcall	.-742    	; 0x894 <_Z18enc28j60ReadBufferjPh>
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <_Z21enc28j60PacketReceivejPh+0x94>
     b7c:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     b7e:	10 e0       	ldi	r17, 0x00	; 0
     b80:	6c 2f       	mov	r22, r28
     b82:	8c e0       	ldi	r24, 0x0C	; 12
     b84:	e2 de       	rcall	.-572    	; 0x94a <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     b86:	6d 2f       	mov	r22, r29
     b88:	8d e0       	ldi	r24, 0x0D	; 13
     b8a:	df de       	rcall	.-578    	; 0x94a <_Z13enc28j60Writehh>
     b8c:	40 e4       	ldi	r20, 0x40	; 64
     b8e:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     b90:	80 e8       	ldi	r24, 0x80	; 128
     b92:	75 de       	rcall	.-790    	; 0x87e <_Z15enc28j60WriteOphhh>
     b94:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     b96:	91 2f       	mov	r25, r17
     b98:	02 c0       	rjmp	.+4      	; 0xb9e <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     b9a:	80 e0       	ldi	r24, 0x00	; 0
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	df 91       	pop	r29
     ba0:	cf 91       	pop	r28
     ba2:	1f 91       	pop	r17
     ba4:	0f 91       	pop	r16
     ba6:	ff 90       	pop	r15
     ba8:	ef 90       	pop	r14
     baa:	df 90       	pop	r13
     bac:	cf 90       	pop	r12
     bae:	bf 90       	pop	r11
     bb0:	af 90       	pop	r10
     bb2:	9f 90       	pop	r9
     bb4:	08 95       	ret

00000bb6 <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     bb6:	cf 92       	push	r12
     bb8:	df 92       	push	r13
     bba:	ef 92       	push	r14
     bbc:	ff 92       	push	r15
     bbe:	cf 93       	push	r28
     bc0:	df 93       	push	r29
     bc2:	ec 01       	movw	r28, r24
     bc4:	db 01       	movw	r26, r22
     bc6:	41 30       	cpi	r20, 0x01	; 1
     bc8:	61 f4       	brne	.+24     	; 0xbe2 <_Z8checksumPhjh+0x2c>
     bca:	6b 01       	movw	r12, r22
     bcc:	88 e0       	ldi	r24, 0x08	; 8
     bce:	c8 1a       	sub	r12, r24
     bd0:	d1 08       	sbc	r13, r1
     bd2:	e1 2c       	mov	r14, r1
     bd4:	f1 2c       	mov	r15, r1
     bd6:	81 e1       	ldi	r24, 0x11	; 17
     bd8:	c8 0e       	add	r12, r24
     bda:	d1 1c       	adc	r13, r1
     bdc:	e1 1c       	adc	r14, r1
     bde:	f1 1c       	adc	r15, r1
     be0:	11 c0       	rjmp	.+34     	; 0xc04 <_Z8checksumPhjh+0x4e>
     be2:	42 30       	cpi	r20, 0x02	; 2
     be4:	61 f4       	brne	.+24     	; 0xbfe <_Z8checksumPhjh+0x48>
     be6:	6b 01       	movw	r12, r22
     be8:	88 e0       	ldi	r24, 0x08	; 8
     bea:	c8 1a       	sub	r12, r24
     bec:	d1 08       	sbc	r13, r1
     bee:	e1 2c       	mov	r14, r1
     bf0:	f1 2c       	mov	r15, r1
     bf2:	86 e0       	ldi	r24, 0x06	; 6
     bf4:	c8 0e       	add	r12, r24
     bf6:	d1 1c       	adc	r13, r1
     bf8:	e1 1c       	adc	r14, r1
     bfa:	f1 1c       	adc	r15, r1
     bfc:	03 c0       	rjmp	.+6      	; 0xc04 <_Z8checksumPhjh+0x4e>
     bfe:	c1 2c       	mov	r12, r1
     c00:	d1 2c       	mov	r13, r1
     c02:	76 01       	movw	r14, r12
     c04:	a2 30       	cpi	r26, 0x02	; 2
     c06:	b1 05       	cpc	r27, r1
     c08:	f0 f0       	brcs	.+60     	; 0xc46 <_Z8checksumPhjh+0x90>
     c0a:	9d 01       	movw	r18, r26
     c0c:	fe 01       	movw	r30, r28
     c0e:	40 81       	ld	r20, Z
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	60 e0       	ldi	r22, 0x00	; 0
     c14:	70 e0       	ldi	r23, 0x00	; 0
     c16:	76 2f       	mov	r23, r22
     c18:	65 2f       	mov	r22, r21
     c1a:	54 2f       	mov	r21, r20
     c1c:	44 27       	eor	r20, r20
     c1e:	81 81       	ldd	r24, Z+1	; 0x01
     c20:	48 2b       	or	r20, r24
     c22:	c4 0e       	add	r12, r20
     c24:	d5 1e       	adc	r13, r21
     c26:	e6 1e       	adc	r14, r22
     c28:	f7 1e       	adc	r15, r23
     c2a:	32 96       	adiw	r30, 0x02	; 2
     c2c:	22 50       	subi	r18, 0x02	; 2
     c2e:	31 09       	sbc	r19, r1
     c30:	22 30       	cpi	r18, 0x02	; 2
     c32:	31 05       	cpc	r19, r1
     c34:	60 f7       	brcc	.-40     	; 0xc0e <_Z8checksumPhjh+0x58>
     c36:	cd 01       	movw	r24, r26
     c38:	02 97       	sbiw	r24, 0x02	; 2
     c3a:	8e 7f       	andi	r24, 0xFE	; 254
     c3c:	02 96       	adiw	r24, 0x02	; 2
     c3e:	c8 0f       	add	r28, r24
     c40:	d9 1f       	adc	r29, r25
     c42:	a1 70       	andi	r26, 0x01	; 1
     c44:	bb 27       	eor	r27, r27
     c46:	ab 2b       	or	r26, r27
     c48:	61 f0       	breq	.+24     	; 0xc62 <_Z8checksumPhjh+0xac>
     c4a:	88 81       	ld	r24, Y
     c4c:	90 e0       	ldi	r25, 0x00	; 0
     c4e:	a0 e0       	ldi	r26, 0x00	; 0
     c50:	b0 e0       	ldi	r27, 0x00	; 0
     c52:	ba 2f       	mov	r27, r26
     c54:	a9 2f       	mov	r26, r25
     c56:	98 2f       	mov	r25, r24
     c58:	88 27       	eor	r24, r24
     c5a:	c8 0e       	add	r12, r24
     c5c:	d9 1e       	adc	r13, r25
     c5e:	ea 1e       	adc	r14, r26
     c60:	fb 1e       	adc	r15, r27
     c62:	a7 01       	movw	r20, r14
     c64:	66 27       	eor	r22, r22
     c66:	77 27       	eor	r23, r23
     c68:	41 15       	cp	r20, r1
     c6a:	51 05       	cpc	r21, r1
     c6c:	61 05       	cpc	r22, r1
     c6e:	71 05       	cpc	r23, r1
     c70:	71 f0       	breq	.+28     	; 0xc8e <_Z8checksumPhjh+0xd8>
     c72:	ee 24       	eor	r14, r14
     c74:	ff 24       	eor	r15, r15
     c76:	c4 0e       	add	r12, r20
     c78:	d5 1e       	adc	r13, r21
     c7a:	e6 1e       	adc	r14, r22
     c7c:	f7 1e       	adc	r15, r23
     c7e:	a7 01       	movw	r20, r14
     c80:	66 27       	eor	r22, r22
     c82:	77 27       	eor	r23, r23
     c84:	41 15       	cp	r20, r1
     c86:	51 05       	cpc	r21, r1
     c88:	61 05       	cpc	r22, r1
     c8a:	71 05       	cpc	r23, r1
     c8c:	91 f7       	brne	.-28     	; 0xc72 <_Z8checksumPhjh+0xbc>
     c8e:	c6 01       	movw	r24, r12
     c90:	80 95       	com	r24
     c92:	90 95       	com	r25
     c94:	df 91       	pop	r29
     c96:	cf 91       	pop	r28
     c98:	ff 90       	pop	r15
     c9a:	ef 90       	pop	r14
     c9c:	df 90       	pop	r13
     c9e:	cf 90       	pop	r12
     ca0:	08 95       	ret

00000ca2 <_Z19init_ip_arp_udp_tcpPhS_h>:
     ca2:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     ca6:	a6 2f       	mov	r26, r22
     ca8:	b7 2f       	mov	r27, r23
     caa:	e9 ea       	ldi	r30, 0xA9	; 169
     cac:	f1 e0       	ldi	r31, 0x01	; 1
     cae:	4d ea       	ldi	r20, 0xAD	; 173
     cb0:	51 e0       	ldi	r21, 0x01	; 1
     cb2:	2d 91       	ld	r18, X+
     cb4:	21 93       	st	Z+, r18
     cb6:	e4 17       	cp	r30, r20
     cb8:	f5 07       	cpc	r31, r21
     cba:	d9 f7       	brne	.-10     	; 0xcb2 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     cbc:	a8 2f       	mov	r26, r24
     cbe:	b9 2f       	mov	r27, r25
     cc0:	ed ea       	ldi	r30, 0xAD	; 173
     cc2:	f1 e0       	ldi	r31, 0x01	; 1
     cc4:	23 eb       	ldi	r18, 0xB3	; 179
     cc6:	31 e0       	ldi	r19, 0x01	; 1
     cc8:	8d 91       	ld	r24, X+
     cca:	81 93       	st	Z+, r24
     ccc:	e2 17       	cp	r30, r18
     cce:	f3 07       	cpc	r31, r19
     cd0:	d9 f7       	brne	.-10     	; 0xcc8 <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     cd2:	08 95       	ret

00000cd4 <_Z25eth_type_is_arp_and_my_ipPhj>:
     cd4:	69 32       	cpi	r22, 0x29	; 41
     cd6:	71 05       	cpc	r23, r1
     cd8:	c8 f0       	brcs	.+50     	; 0xd0c <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     cda:	fc 01       	movw	r30, r24
     cdc:	24 85       	ldd	r18, Z+12	; 0x0c
     cde:	28 30       	cpi	r18, 0x08	; 8
     ce0:	b9 f4       	brne	.+46     	; 0xd10 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     ce2:	25 85       	ldd	r18, Z+13	; 0x0d
     ce4:	26 30       	cpi	r18, 0x06	; 6
     ce6:	b1 f4       	brne	.+44     	; 0xd14 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     ce8:	36 a1       	ldd	r19, Z+38	; 0x26
     cea:	20 91 a9 01 	lds	r18, 0x01A9	; 0x8001a9 <_ZL6ipaddr>
     cee:	32 13       	cpse	r19, r18
     cf0:	13 c0       	rjmp	.+38     	; 0xd18 <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     cf2:	b7 96       	adiw	r30, 0x27	; 39
     cf4:	aa ea       	ldi	r26, 0xAA	; 170
     cf6:	b1 e0       	ldi	r27, 0x01	; 1
     cf8:	8a 96       	adiw	r24, 0x2a	; 42
     cfa:	31 91       	ld	r19, Z+
     cfc:	2d 91       	ld	r18, X+
     cfe:	32 13       	cpse	r19, r18
     d00:	0d c0       	rjmp	.+26     	; 0xd1c <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     d02:	e8 17       	cp	r30, r24
     d04:	f9 07       	cpc	r31, r25
     d06:	c9 f7       	brne	.-14     	; 0xcfa <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	08 95       	ret
     d0c:	80 e0       	ldi	r24, 0x00	; 0
     d0e:	08 95       	ret
     d10:	80 e0       	ldi	r24, 0x00	; 0
     d12:	08 95       	ret
     d14:	80 e0       	ldi	r24, 0x00	; 0
     d16:	08 95       	ret
     d18:	80 e0       	ldi	r24, 0x00	; 0
     d1a:	08 95       	ret
     d1c:	80 e0       	ldi	r24, 0x00	; 0
     d1e:	08 95       	ret

00000d20 <_Z24eth_type_is_ip_and_my_ipPhj>:
     d20:	cf 93       	push	r28
     d22:	df 93       	push	r29
     d24:	fc 01       	movw	r30, r24
     d26:	6a 32       	cpi	r22, 0x2A	; 42
     d28:	71 05       	cpc	r23, r1
     d2a:	e0 f0       	brcs	.+56     	; 0xd64 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     d2c:	84 85       	ldd	r24, Z+12	; 0x0c
     d2e:	88 30       	cpi	r24, 0x08	; 8
     d30:	d9 f4       	brne	.+54     	; 0xd68 <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     d32:	85 85       	ldd	r24, Z+13	; 0x0d
     d34:	81 11       	cpse	r24, r1
     d36:	1a c0       	rjmp	.+52     	; 0xd6c <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     d38:	96 85       	ldd	r25, Z+14	; 0x0e
     d3a:	95 34       	cpi	r25, 0x45	; 69
     d3c:	c1 f4       	brne	.+48     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d3e:	26 8d       	ldd	r18, Z+30	; 0x1e
     d40:	90 91 a9 01 	lds	r25, 0x01A9	; 0x8001a9 <_ZL6ipaddr>
     d44:	29 13       	cpse	r18, r25
     d46:	13 c0       	rjmp	.+38     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d48:	df 01       	movw	r26, r30
     d4a:	5f 96       	adiw	r26, 0x1f	; 31
     d4c:	ca ea       	ldi	r28, 0xAA	; 170
     d4e:	d1 e0       	ldi	r29, 0x01	; 1
     d50:	b2 96       	adiw	r30, 0x22	; 34
     d52:	2d 91       	ld	r18, X+
     d54:	99 91       	ld	r25, Y+
     d56:	29 13       	cpse	r18, r25
     d58:	0a c0       	rjmp	.+20     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d5a:	ae 17       	cp	r26, r30
     d5c:	bf 07       	cpc	r27, r31
     d5e:	c9 f7       	brne	.-14     	; 0xd52 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	05 c0       	rjmp	.+10     	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d64:	80 e0       	ldi	r24, 0x00	; 0
     d66:	03 c0       	rjmp	.+6      	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d68:	80 e0       	ldi	r24, 0x00	; 0
     d6a:	01 c0       	rjmp	.+2      	; 0xd6e <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     d6c:	80 e0       	ldi	r24, 0x00	; 0
     d6e:	df 91       	pop	r29
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <_Z8make_ethPh>:
     d74:	fc 01       	movw	r30, r24
     d76:	ad ea       	ldi	r26, 0xAD	; 173
     d78:	b1 e0       	ldi	r27, 0x01	; 1
     d7a:	9c 01       	movw	r18, r24
     d7c:	2a 5f       	subi	r18, 0xFA	; 250
     d7e:	3f 4f       	sbci	r19, 0xFF	; 255
     d80:	86 81       	ldd	r24, Z+6	; 0x06
     d82:	81 93       	st	Z+, r24
     d84:	8d 91       	ld	r24, X+
     d86:	85 83       	std	Z+5, r24	; 0x05
     d88:	e2 17       	cp	r30, r18
     d8a:	f3 07       	cpc	r31, r19
     d8c:	c9 f7       	brne	.-14     	; 0xd80 <_Z8make_ethPh+0xc>
     d8e:	08 95       	ret

00000d90 <_Z20fill_ip_hdr_checksumPh>:
     d90:	cf 93       	push	r28
     d92:	df 93       	push	r29
     d94:	ec 01       	movw	r28, r24
     d96:	18 8e       	std	Y+24, r1	; 0x18
     d98:	19 8e       	std	Y+25, r1	; 0x19
     d9a:	80 e4       	ldi	r24, 0x40	; 64
     d9c:	8c 8b       	std	Y+20, r24	; 0x14
     d9e:	1d 8a       	std	Y+21, r1	; 0x15
     da0:	8e 8b       	std	Y+22, r24	; 0x16
     da2:	40 e0       	ldi	r20, 0x00	; 0
     da4:	64 e1       	ldi	r22, 0x14	; 20
     da6:	70 e0       	ldi	r23, 0x00	; 0
     da8:	ce 01       	movw	r24, r28
     daa:	0e 96       	adiw	r24, 0x0e	; 14
     dac:	04 df       	rcall	.-504    	; 0xbb6 <_Z8checksumPhjh>
     dae:	98 8f       	std	Y+24, r25	; 0x18
     db0:	89 8f       	std	Y+25, r24	; 0x19
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	08 95       	ret

00000db8 <_Z7make_ipPh>:
     db8:	ac 01       	movw	r20, r24
     dba:	a9 ea       	ldi	r26, 0xA9	; 169
     dbc:	b1 e0       	ldi	r27, 0x01	; 1
     dbe:	fc 01       	movw	r30, r24
     dc0:	7a 96       	adiw	r30, 0x1a	; 26
     dc2:	2d ea       	ldi	r18, 0xAD	; 173
     dc4:	31 e0       	ldi	r19, 0x01	; 1
     dc6:	90 81       	ld	r25, Z
     dc8:	94 83       	std	Z+4, r25	; 0x04
     dca:	9d 91       	ld	r25, X+
     dcc:	91 93       	st	Z+, r25
     dce:	a2 17       	cp	r26, r18
     dd0:	b3 07       	cpc	r27, r19
     dd2:	c9 f7       	brne	.-14     	; 0xdc6 <_Z7make_ipPh+0xe>
     dd4:	ca 01       	movw	r24, r20
     dd6:	dc cf       	rjmp	.-72     	; 0xd90 <_Z20fill_ip_hdr_checksumPh>
     dd8:	08 95       	ret

00000dda <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
     dda:	cf 93       	push	r28
     ddc:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
     dde:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
     de0:	c9 df       	rcall	.-110    	; 0xd74 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
     de2:	1c 8a       	std	Y+20, r1	; 0x14
     de4:	82 e0       	ldi	r24, 0x02	; 2
     de6:	8d 8b       	std	Y+21, r24	; 0x15
     de8:	ad ea       	ldi	r26, 0xAD	; 173
     dea:	b1 e0       	ldi	r27, 0x01	; 1
     dec:	fe 01       	movw	r30, r28
     dee:	76 96       	adiw	r30, 0x16	; 22
     df0:	23 eb       	ldi	r18, 0xB3	; 179
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
     df2:	31 e0       	ldi	r19, 0x01	; 1
     df4:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
     df6:	82 87       	std	Z+10, r24	; 0x0a
     df8:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
     dfa:	81 93       	st	Z+, r24
     dfc:	a2 17       	cp	r26, r18
     dfe:	b3 07       	cpc	r27, r19
     e00:	c9 f7       	brne	.-14     	; 0xdf4 <_Z28make_arp_answer_from_requestPh+0x1a>
     e02:	a9 ea       	ldi	r26, 0xA9	; 169
     e04:	b1 e0       	ldi	r27, 0x01	; 1
     e06:	fe 01       	movw	r30, r28
     e08:	7c 96       	adiw	r30, 0x1c	; 28
     e0a:	2d ea       	ldi	r18, 0xAD	; 173
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
     e0c:	31 e0       	ldi	r19, 0x01	; 1
     e0e:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
     e10:	82 87       	std	Z+10, r24	; 0x0a
     e12:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
     e14:	81 93       	st	Z+, r24
     e16:	a2 17       	cp	r26, r18
     e18:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
     e1a:	c9 f7       	brne	.-14     	; 0xe0e <_Z28make_arp_answer_from_requestPh+0x34>
     e1c:	be 01       	movw	r22, r28
     e1e:	8a e2       	ldi	r24, 0x2A	; 42
     e20:	90 e0       	ldi	r25, 0x00	; 0
}
     e22:	36 de       	rcall	.-916    	; 0xa90 <_Z18enc28j60PacketSendjPh>
     e24:	df 91       	pop	r29
     e26:	cf 91       	pop	r28
     e28:	08 95       	ret

00000e2a <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
     e30:	df 93       	push	r29
     e32:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
     e34:	8b 01       	movw	r16, r22
     e36:	9e df       	rcall	.-196    	; 0xd74 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
     e38:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
     e3a:	be df       	rcall	.-132    	; 0xdb8 <_Z7make_ipPh>
     e3c:	1a a2       	std	Y+34, r1	; 0x22
     e3e:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
     e40:	88 3f       	cpi	r24, 0xF8	; 248
     e42:	18 f0       	brcs	.+6      	; 0xe4a <_Z28make_echo_reply_from_requestPhj+0x20>
     e44:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
     e46:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
     e48:	9d a3       	std	Y+37, r25	; 0x25
     e4a:	88 5f       	subi	r24, 0xF8	; 248
     e4c:	8c a3       	std	Y+36, r24	; 0x24
}
     e4e:	be 01       	movw	r22, r28
     e50:	c8 01       	movw	r24, r16
     e52:	1e de       	rcall	.-964    	; 0xa90 <_Z18enc28j60PacketSendjPh>
     e54:	df 91       	pop	r29
     e56:	cf 91       	pop	r28
     e58:	1f 91       	pop	r17
     e5a:	0f 91       	pop	r16
     e5c:	08 95       	ret

00000e5e <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
     e5e:	df 92       	push	r13
     e60:	ef 92       	push	r14
     e62:	ff 92       	push	r15
     e64:	0f 93       	push	r16
     e66:	1f 93       	push	r17
     e68:	cf 93       	push	r28
     e6a:	df 93       	push	r29
     e6c:	ec 01       	movw	r28, r24
     e6e:	d6 2e       	mov	r13, r22
     e70:	e7 2e       	mov	r14, r23
     e72:	04 2f       	mov	r16, r20
     e74:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
     e76:	f3 2e       	mov	r15, r19
     e78:	7d df       	rcall	.-262    	; 0xd74 <_Z8make_ethPh>
     e7a:	0d 3d       	cpi	r16, 0xDD	; 221
     e7c:	08 f0       	brcs	.+2      	; 0xe80 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
     e7e:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
     e80:	18 8a       	std	Y+16, r1	; 0x10
     e82:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
     e84:	80 0f       	add	r24, r16
     e86:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
     e88:	ce 01       	movw	r24, r28
     e8a:	96 df       	rcall	.-212    	; 0xdb8 <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
     e8c:	8a a1       	ldd	r24, Y+34	; 0x22
     e8e:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
     e90:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
     e92:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
     e94:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
     e96:	1b a3       	std	Y+35, r17	; 0x23
     e98:	1e a2       	std	Y+38, r1	; 0x26
     e9a:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
     e9c:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
     e9e:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
     ea0:	18 a6       	std	Y+40, r1	; 0x28
     ea2:	19 a6       	std	Y+41, r1	; 0x29
     ea4:	00 23       	and	r16, r16
     ea6:	81 f0       	breq	.+32     	; 0xec8 <_Z27make_udp_reply_from_requestPhPchj+0x6a>
     ea8:	ad 2d       	mov	r26, r13
     eaa:	be 2d       	mov	r27, r14
     eac:	fe 01       	movw	r30, r28
     eae:	ba 96       	adiw	r30, 0x2a	; 42
     eb0:	2f ef       	ldi	r18, 0xFF	; 255
     eb2:	20 0f       	add	r18, r16
     eb4:	30 e0       	ldi	r19, 0x00	; 0
     eb6:	25 5d       	subi	r18, 0xD5	; 213
     eb8:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
     eba:	2c 0f       	add	r18, r28
     ebc:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
     ebe:	9d 91       	ld	r25, X+
     ec0:	91 93       	st	Z+, r25
     ec2:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
     ec4:	f3 07       	cpc	r31, r19
     ec6:	d9 f7       	brne	.-10     	; 0xebe <_Z27make_udp_reply_from_requestPhPchj+0x60>
     ec8:	10 e0       	ldi	r17, 0x00	; 0
     eca:	b8 01       	movw	r22, r16
     ecc:	60 5f       	subi	r22, 0xF0	; 240
     ece:	7f 4f       	sbci	r23, 0xFF	; 255
     ed0:	41 e0       	ldi	r20, 0x01	; 1
     ed2:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
     ed4:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
     ed6:	6f de       	rcall	.-802    	; 0xbb6 <_Z8checksumPhjh>
     ed8:	98 a7       	std	Y+40, r25	; 0x28
     eda:	89 a7       	std	Y+41, r24	; 0x29
     edc:	be 01       	movw	r22, r28
}
     ede:	c8 01       	movw	r24, r16
     ee0:	8a 96       	adiw	r24, 0x2a	; 42
     ee2:	d6 dd       	rcall	.-1108   	; 0xa90 <_Z18enc28j60PacketSendjPh>
     ee4:	df 91       	pop	r29
     ee6:	cf 91       	pop	r28
     ee8:	1f 91       	pop	r17
     eea:	0f 91       	pop	r16
     eec:	ff 90       	pop	r15
     eee:	ef 90       	pop	r14
     ef0:	df 90       	pop	r13
     ef2:	08 95       	ret

00000ef4 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
     ef4:	87 b3       	in	r24, 0x17	; 23
     ef6:	86 60       	ori	r24, 0x06	; 6
     ef8:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
     efa:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
     efc:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
     efe:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
     f00:	80 e5       	ldi	r24, 0x50	; 80
     f02:	8d b9       	out	0x0d, r24	; 13
    SPCR &= 0xFC; // SPR1=0, SPR0 = 0  this is ori
     f04:	8d b1       	in	r24, 0x0d	; 13
     f06:	8c 7f       	andi	r24, 0xFC	; 252
     f08:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	SPSR = 0x00;
     f0a:	1e b8       	out	0x0e, r1	; 14
     f0c:	08 95       	ret

00000f0e <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f0e:	00 97       	sbiw	r24, 0x00	; 0
     f10:	41 f0       	breq	.+16     	; 0xf22 <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f12:	ef eb       	ldi	r30, 0xBF	; 191
     f14:	f0 e0       	ldi	r31, 0x00	; 0
     f16:	31 97       	sbiw	r30, 0x01	; 1
     f18:	f1 f7       	brne	.-4      	; 0xf16 <_Z8delay_msj+0x8>
     f1a:	00 c0       	rjmp	.+0      	; 0xf1c <_Z8delay_msj+0xe>
     f1c:	00 00       	nop
                _delay_ms(0.96);
                ms--;
     f1e:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     f20:	c1 f7       	brne	.-16     	; 0xf12 <_Z8delay_msj+0x4>
     f22:	08 95       	ret

00000f24 <_Z9Timer_ISR8Dev_typej>:
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
     f24:	ea eb       	ldi	r30, 0xBA	; 186
     f26:	f3 e0       	ldi	r31, 0x03	; 3
     f28:	84 85       	ldd	r24, Z+12	; 0x0c
     f2a:	95 85       	ldd	r25, Z+13	; 0x0d
     f2c:	01 96       	adiw	r24, 0x01	; 1
     f2e:	95 87       	std	Z+13, r25	; 0x0d
     f30:	84 87       	std	Z+12, r24	; 0x0c
     f32:	08 95       	ret

00000f34 <_ZL5proc2Pv>:
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {192,168,0,108};
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
    char str[30];
	 enc28j60Init(mymac);
     f34:	85 e0       	ldi	r24, 0x05	; 5
     f36:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
     f38:	31 dd       	rcall	.-1438   	; 0x99c <_Z12enc28j60InitPh>
     f3a:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
     f3c:	2a dd       	rcall	.-1452   	; 0x992 <_Z14enc28j60clkouth>
     f3e:	8a e0       	ldi	r24, 0x0A	; 10
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
     f46:	66 e7       	ldi	r22, 0x76	; 118
     f48:	74 e0       	ldi	r23, 0x04	; 4
     f4a:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
     f4c:	0a dd       	rcall	.-1516   	; 0x962 <_Z16enc28j60PhyWritehj>
     f4e:	84 e1       	ldi	r24, 0x14	; 20
     f50:	90 e0       	ldi	r25, 0x00	; 0
     f52:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
     f56:	40 e5       	ldi	r20, 0x50	; 80
     f58:	61 e0       	ldi	r22, 0x01	; 1
     f5a:	71 e0       	ldi	r23, 0x01	; 1
     f5c:	85 e0       	ldi	r24, 0x05	; 5
     f5e:	91 e0       	ldi	r25, 0x01	; 1
			continue;
		 }
		 else//(mem4[SEC] % 5 == 0)
		 {
			 static int data[3] = {0};
			 data[0] = mem4[TEMP];
     f60:	a0 de       	rcall	.-704    	; 0xca2 <_Z19init_ip_arp_udp_tcpPhS_h>
     f62:	03 eb       	ldi	r16, 0xB3	; 179
     f64:	11 e0       	ldi	r17, 0x01	; 1
     f66:	0f 2e       	mov	r0, r31
     f68:	fa eb       	ldi	r31, 0xBA	; 186
     f6a:	ef 2e       	mov	r14, r31
     f6c:	f3 e0       	ldi	r31, 0x03	; 3
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
     f6e:	ff 2e       	mov	r15, r31
     f70:	f0 2d       	mov	r31, r0
     f72:	69 eb       	ldi	r22, 0xB9	; 185
     f74:	71 e0       	ldi	r23, 0x01	; 1
     f76:	80 e0       	ldi	r24, 0x00	; 0
		 if(plen==0)
     f78:	92 e0       	ldi	r25, 0x02	; 2
		 {
				continue;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
     f7a:	b8 dd       	rcall	.-1168   	; 0xaec <_Z21enc28j60PacketReceivejPh>
     f7c:	ec 01       	movw	r28, r24
     f7e:	00 97       	sbiw	r24, 0x00	; 0
     f80:	c1 f3       	breq	.-16     	; 0xf72 <_ZL5proc2Pv+0x3e>
     f82:	bc 01       	movw	r22, r24
     f84:	89 eb       	ldi	r24, 0xB9	; 185
		 {
			 make_arp_answer_from_request(buf);
     f86:	91 e0       	ldi	r25, 0x01	; 1
     f88:	a5 de       	rcall	.-694    	; 0xcd4 <_Z25eth_type_is_arp_and_my_ipPhj>
     f8a:	88 23       	and	r24, r24
			 continue;
     f8c:	21 f0       	breq	.+8      	; 0xf96 <_ZL5proc2Pv+0x62>
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
     f8e:	89 eb       	ldi	r24, 0xB9	; 185
     f90:	91 e0       	ldi	r25, 0x01	; 1
     f92:	23 df       	rcall	.-442    	; 0xdda <_Z28make_arp_answer_from_requestPh>
     f94:	ee cf       	rjmp	.-36     	; 0xf72 <_ZL5proc2Pv+0x3e>
     f96:	be 01       	movw	r22, r28
     f98:	89 eb       	ldi	r24, 0xB9	; 185
     f9a:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
     f9c:	c1 de       	rcall	.-638    	; 0xd20 <_Z24eth_type_is_ip_and_my_ipPhj>
     f9e:	88 23       	and	r24, r24
     fa0:	41 f3       	breq	.-48     	; 0xf72 <_ZL5proc2Pv+0x3e>
     fa2:	80 91 d0 01 	lds	r24, 0x01D0	; 0x8001d0 <_ZZL5proc2PvE3buf+0x17>
     fa6:	81 30       	cpi	r24, 0x01	; 1
     fa8:	49 f4       	brne	.+18     	; 0xfbc <_ZL5proc2Pv+0x88>
		 {
			make_echo_reply_from_request(buf,plen);
     faa:	80 91 db 01 	lds	r24, 0x01DB	; 0x8001db <_ZZL5proc2PvE3buf+0x22>
     fae:	88 30       	cpi	r24, 0x08	; 8
     fb0:	29 f4       	brne	.+10     	; 0xfbc <_ZL5proc2Pv+0x88>
     fb2:	be 01       	movw	r22, r28
			continue;
     fb4:	89 eb       	ldi	r24, 0xB9	; 185
		 }
		 else//(mem4[SEC] % 5 == 0)
		 {
			 static int data[3] = {0};
			 data[0] = mem4[TEMP];
     fb6:	91 e0       	ldi	r25, 0x01	; 1
     fb8:	38 df       	rcall	.-400    	; 0xe2a <_Z28make_echo_reply_from_requestPhj>
     fba:	db cf       	rjmp	.-74     	; 0xf72 <_ZL5proc2Pv+0x3e>
     fbc:	f7 01       	movw	r30, r14
     fbe:	82 81       	ldd	r24, Z+2	; 0x02
     fc0:	93 81       	ldd	r25, Z+3	; 0x03
			 data[1] = mem4[COUNT];
     fc2:	f8 01       	movw	r30, r16
     fc4:	91 83       	std	Z+1, r25	; 0x01
     fc6:	80 83       	st	Z, r24
     fc8:	f7 01       	movw	r30, r14
     fca:	86 81       	ldd	r24, Z+6	; 0x06
     fcc:	97 81       	ldd	r25, Z+7	; 0x07
			 data[2] = mem4[PRESSURE];
     fce:	f8 01       	movw	r30, r16
     fd0:	93 83       	std	Z+3, r25	; 0x03
     fd2:	82 83       	std	Z+2, r24	; 0x02
     fd4:	f7 01       	movw	r30, r14
     fd6:	84 81       	ldd	r24, Z+4	; 0x04
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
     fd8:	95 81       	ldd	r25, Z+5	; 0x05
     fda:	f8 01       	movw	r30, r16
     fdc:	95 83       	std	Z+5, r25	; 0x05
     fde:	84 83       	std	Z+4, r24	; 0x04
     fe0:	2f e0       	ldi	r18, 0x0F	; 15
     fe2:	37 e2       	ldi	r19, 0x27	; 39
     fe4:	46 e0       	ldi	r20, 0x06	; 6
     fe6:	b8 01       	movw	r22, r16
     fe8:	89 eb       	ldi	r24, 0xB9	; 185
     fea:	91 e0       	ldi	r25, 0x01	; 1
     fec:	38 df       	rcall	.-400    	; 0xe5e <_Z27make_udp_reply_from_requestPhPchj>
     fee:	c1 cf       	rjmp	.-126    	; 0xf72 <_ZL5proc2Pv+0x3e>

00000ff0 <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
     ff0:	cf 93       	push	r28
     ff2:	df 93       	push	r29
     ff4:	cd b7       	in	r28, 0x3d	; 61
     ff6:	de b7       	in	r29, 0x3e	; 62
     ff8:	2f 97       	sbiw	r28, 0x0f	; 15
     ffa:	0f b6       	in	r0, 0x3f	; 63
     ffc:	f8 94       	cli
     ffe:	de bf       	out	0x3e, r29	; 62
    1000:	0f be       	out	0x3f, r0	; 63
    1002:	cd bf       	out	0x3d, r28	; 61
    1004:	7c 01       	movw	r14, r24
	//UART1 
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
    1006:	fe 01       	movw	r30, r28
    1008:	31 96       	adiw	r30, 0x01	; 1
    100a:	8f e0       	ldi	r24, 0x0F	; 15
    100c:	df 01       	movw	r26, r30
    100e:	1d 92       	st	X+, r1
    1010:	8a 95       	dec	r24
    1012:	e9 f7       	brne	.-6      	; 0x100e <_ZL5proc1Pv+0x1e>
    1014:	6e 01       	movw	r12, r28
    1016:	b0 e1       	ldi	r27, 0x10	; 16
    1018:	cb 0e       	add	r12, r27
    101a:	d1 1c       	adc	r13, r1
			}
			else
			{
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    101c:	0f 2e       	mov	r0, r31
    101e:	fa e9       	ldi	r31, 0x9A	; 154
    1020:	8f 2e       	mov	r8, r31
    1022:	91 2c       	mov	r9, r1
    1024:	f0 2d       	mov	r31, r0
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
				mem4[TEMP] = current_temp;
    1026:	0f 2e       	mov	r0, r31
    1028:	fa eb       	ldi	r31, 0xBA	; 186
    102a:	af 2e       	mov	r10, r31
    102c:	f3 e0       	ldi	r31, 0x03	; 3
    102e:	bf 2e       	mov	r11, r31
    1030:	f0 2d       	mov	r31, r0
				mem4[COUNT] = count_number;
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1032:	0f 2e       	mov	r0, r31
    1034:	f3 e0       	ldi	r31, 0x03	; 3
    1036:	6f 2e       	mov	r6, r31
    1038:	71 2c       	mov	r7, r1
    103a:	f0 2d       	mov	r31, r0
	SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
		if(sb->SerialAvailable() >= 15)
    103c:	c7 01       	movw	r24, r14
    103e:	b1 d9       	rcall	.-3230   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1040:	8f 30       	cpi	r24, 0x0F	; 15
    1042:	e0 f3       	brcs	.-8      	; 0x103c <_ZL5proc1Pv+0x4c>
    1044:	8e 01       	movw	r16, r28
    1046:	0f 5f       	subi	r16, 0xFF	; 255
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    1048:	1f 4f       	sbci	r17, 0xFF	; 255
    104a:	c7 01       	movw	r24, r14
    104c:	7e d9       	rcall	.-3332   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    104e:	f8 01       	movw	r30, r16
    1050:	81 93       	st	Z+, r24
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    1052:	8f 01       	movw	r16, r30
    1054:	ec 15       	cp	r30, r12
    1056:	fd 05       	cpc	r31, r13
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    1058:	c1 f7       	brne	.-16     	; 0x104a <_ZL5proc1Pv+0x5a>
    105a:	89 81       	ldd	r24, Y+1	; 0x01
    105c:	82 30       	cpi	r24, 0x02	; 2
    105e:	09 f0       	breq	.+2      	; 0x1062 <_ZL5proc1Pv+0x72>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    1060:	3f c0       	rjmp	.+126    	; 0x10e0 <_ZL5proc1Pv+0xf0>
    1062:	88 85       	ldd	r24, Y+8	; 0x08
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	98 2f       	mov	r25, r24
    1068:	88 27       	eor	r24, r24
    106a:	29 85       	ldd	r18, Y+9	; 0x09
    106c:	82 2b       	or	r24, r18
    106e:	90 93 d3 03 	sts	0x03D3, r25	; 0x8003d3 <count_number+0x1>
    1072:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    1076:	4a 85       	ldd	r20, Y+10	; 0x0a
    1078:	50 e0       	ldi	r21, 0x00	; 0
    107a:	54 2f       	mov	r21, r20
    107c:	44 27       	eor	r20, r20
    107e:	2b 85       	ldd	r18, Y+11	; 0x0b
    1080:	42 2b       	or	r20, r18
    1082:	50 93 d1 03 	sts	0x03D1, r21	; 0x8003d1 <current_temp+0x1>
    1086:	40 93 d0 03 	sts	0x03D0, r20	; 0x8003d0 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    108a:	2c 85       	ldd	r18, Y+12	; 0x0c
    108c:	30 e0       	ldi	r19, 0x00	; 0
    108e:	32 2f       	mov	r19, r18
    1090:	22 27       	eor	r18, r18
    1092:	6d 85       	ldd	r22, Y+13	; 0x0d
    1094:	26 2b       	or	r18, r22
    1096:	30 93 cf 03 	sts	0x03CF, r19	; 0x8003cf <current_pressure+0x1>
    109a:	20 93 ce 03 	sts	0x03CE, r18	; 0x8003ce <current_pressure>
				mem4[TEMP] = current_temp;
    109e:	d5 01       	movw	r26, r10
    10a0:	13 96       	adiw	r26, 0x03	; 3
    10a2:	5c 93       	st	X, r21
    10a4:	4e 93       	st	-X, r20
				mem4[COUNT] = count_number;
    10a6:	12 97       	sbiw	r26, 0x02	; 2
    10a8:	17 96       	adiw	r26, 0x07	; 7
    10aa:	9c 93       	st	X, r25
    10ac:	8e 93       	st	-X, r24
				mem4[PRESSURE] = current_pressure;
    10ae:	16 97       	sbiw	r26, 0x06	; 6
    10b0:	15 96       	adiw	r26, 0x05	; 5
    10b2:	3c 93       	st	X, r19
    10b4:	2e 93       	st	-X, r18
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    10b6:	14 97       	sbiw	r26, 0x04	; 4
    10b8:	50 96       	adiw	r26, 0x10	; 16
    10ba:	2d 91       	ld	r18, X+
    10bc:	3c 91       	ld	r19, X
    10be:	51 97       	sbiw	r26, 0x11	; 17
    10c0:	82 17       	cp	r24, r18
    10c2:	93 07       	cpc	r25, r19
    10c4:	09 f0       	breq	.+2      	; 0x10c8 <_ZL5proc1Pv+0xd8>
    10c6:	ba cf       	rjmp	.-140    	; 0x103c <_ZL5proc1Pv+0x4c>
    10c8:	52 96       	adiw	r26, 0x12	; 18
    10ca:	8d 91       	ld	r24, X+
    10cc:	9c 91       	ld	r25, X
    10ce:	53 97       	sbiw	r26, 0x13	; 19
    10d0:	89 2b       	or	r24, r25
    10d2:	09 f0       	breq	.+2      	; 0x10d6 <_ZL5proc1Pv+0xe6>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    10d4:	b3 cf       	rjmp	.-154    	; 0x103c <_ZL5proc1Pv+0x4c>
    10d6:	53 96       	adiw	r26, 0x13	; 19
    10d8:	7c 92       	st	X, r7
    10da:	6e 92       	st	-X, r6
    10dc:	52 97       	sbiw	r26, 0x12	; 18
				}
			}
			else
			{
				GetExceptionCode(&exception,0x01,0x06);
    10de:	ae cf       	rjmp	.-164    	; 0x103c <_ZL5proc1Pv+0x4c>
    10e0:	46 e0       	ldi	r20, 0x06	; 6
    10e2:	61 e0       	ldi	r22, 0x01	; 1
    10e4:	8c ed       	ldi	r24, 0xDC	; 220
    10e6:	93 e0       	ldi	r25, 0x03	; 3
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    10e8:	97 d8       	rcall	.-3794   	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
    10ea:	45 e0       	ldi	r20, 0x05	; 5
    10ec:	50 e0       	ldi	r21, 0x00	; 0
    10ee:	6c ed       	ldi	r22, 0xDC	; 220
    10f0:	73 e0       	ldi	r23, 0x03	; 3
    10f2:	c7 01       	movw	r24, r14
				cbi(UCSR1B,RXCIE0);
    10f4:	ee d8       	rcall	.-3620   	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    10f6:	f4 01       	movw	r30, r8
    10f8:	80 81       	ld	r24, Z
				sb->SerialFlush();
    10fa:	8f 77       	andi	r24, 0x7F	; 127
    10fc:	80 83       	st	Z, r24
    10fe:	c7 01       	movw	r24, r14
				sbi(UCSR1B,RXCIE0);
    1100:	5b d9       	rcall	.-3402   	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
    1102:	d4 01       	movw	r26, r8
    1104:	8c 91       	ld	r24, X
    1106:	80 68       	ori	r24, 0x80	; 128
    1108:	8c 93       	st	X, r24
    110a:	98 cf       	rjmp	.-208    	; 0x103c <_ZL5proc1Pv+0x4c>

0000110c <_ZL4procPv>:
	#if USE_SYSTEM_SEC
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    110c:	cf 93       	push	r28
    110e:	df 93       	push	r29
    1110:	cd b7       	in	r28, 0x3d	; 61
    1112:	de b7       	in	r29, 0x3e	; 62
    1114:	2a 97       	sbiw	r28, 0x0a	; 10
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	f8 94       	cli
    111a:	de bf       	out	0x3e, r29	; 62
    111c:	0f be       	out	0x3f, r0	; 63
    111e:	cd bf       	out	0x3d, r28	; 61
    1120:	6c 01       	movw	r12, r24
	char read_Flag = 0;
	char function_code;
	char buf1[10];
	DDRG = 0xff;
    1122:	8f ef       	ldi	r24, 0xFF	; 255
    1124:	80 93 64 00 	sts	0x0064, r24	; 0x800064 <__TEXT_REGION_LENGTH__+0x7e0064>
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
	char read_Flag = 0;
    1128:	b1 2c       	mov	r11, r1
	DDRG = 0xff;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
		
	while(1)
	{
		if(mem4[SEC] >= 60)
    112a:	0a eb       	ldi	r16, 0xBA	; 186
    112c:	13 e0       	ldi	r17, 0x03	; 3
    112e:	2e 01       	movw	r4, r28
    1130:	8c e0       	ldi	r24, 0x0C	; 12
    1132:	48 0e       	add	r4, r24
    1134:	51 1c       	adc	r5, r1
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    1136:	0f 2e       	mov	r0, r31
    1138:	f5 e6       	ldi	r31, 0x65	; 101
    113a:	ef 2e       	mov	r14, r31
    113c:	f1 2c       	mov	r15, r1
    113e:	f0 2d       	mov	r31, r0
    1140:	77 24       	eor	r7, r7
    1142:	7a 94       	dec	r7
    1144:	67 2c       	mov	r6, r7
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    1146:	21 2c       	mov	r2, r1
    1148:	33 24       	eor	r3, r3
    114a:	33 94       	inc	r3
    114c:	4e 01       	movw	r8, r28
    114e:	e9 e0       	ldi	r30, 0x09	; 9
    1150:	8e 0e       	add	r8, r30
    1152:	91 1c       	adc	r9, r1
    1154:	15 c0       	rjmp	.+42     	; 0x1180 <_ZL4procPv+0x74>
    1156:	a3 2c       	mov	r10, r3
    1158:	b3 2c       	mov	r11, r3
    115a:	12 c0       	rjmp	.+36     	; 0x1180 <_ZL4procPv+0x74>
    115c:	a3 2c       	mov	r10, r3
    115e:	b3 2c       	mov	r11, r3
    1160:	0f c0       	rjmp	.+30     	; 0x1180 <_ZL4procPv+0x74>
    1162:	68 94       	set
    1164:	aa 24       	eor	r10, r10
    1166:	a2 f8       	bld	r10, 2
    1168:	b3 2c       	mov	r11, r3
    116a:	0a c0       	rjmp	.+20     	; 0x1180 <_ZL4procPv+0x74>
    116c:	0f 2e       	mov	r0, r31
    116e:	f5 e0       	ldi	r31, 0x05	; 5
    1170:	af 2e       	mov	r10, r31
    1172:	f0 2d       	mov	r31, r0
    1174:	b3 2c       	mov	r11, r3
    1176:	04 c0       	rjmp	.+8      	; 0x1180 <_ZL4procPv+0x74>
    1178:	68 94       	set
    117a:	aa 24       	eor	r10, r10
    117c:	a4 f8       	bld	r10, 4
    117e:	b3 2c       	mov	r11, r3
	DDRG = 0xff;
	SerialBuffer *sb = (SerialBuffer*)pvParam;
		
	while(1)
	{
		if(mem4[SEC] >= 60)
    1180:	f8 01       	movw	r30, r16
    1182:	84 85       	ldd	r24, Z+12	; 0x0c
    1184:	95 85       	ldd	r25, Z+13	; 0x0d
    1186:	cc 97       	sbiw	r24, 0x3c	; 60
    1188:	9c f0       	brlt	.+38     	; 0x11b0 <_ZL4procPv+0xa4>
		{
			mem4[SEC] = 0;
    118a:	15 86       	std	Z+13, r1	; 0x0d
    118c:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    118e:	82 85       	ldd	r24, Z+10	; 0x0a
    1190:	93 85       	ldd	r25, Z+11	; 0x0b
    1192:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    1194:	8c 33       	cpi	r24, 0x3C	; 60
    1196:	91 05       	cpc	r25, r1
    1198:	1c f4       	brge	.+6      	; 0x11a0 <_ZL4procPv+0x94>
	while(1)
	{
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    119a:	93 87       	std	Z+11, r25	; 0x0b
    119c:	82 87       	std	Z+10, r24	; 0x0a
    119e:	08 c0       	rjmp	.+16     	; 0x11b0 <_ZL4procPv+0xa4>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    11a0:	f8 01       	movw	r30, r16
    11a2:	13 86       	std	Z+11, r1	; 0x0b
    11a4:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    11a6:	80 85       	ldd	r24, Z+8	; 0x08
    11a8:	91 85       	ldd	r25, Z+9	; 0x09
    11aa:	01 96       	adiw	r24, 0x01	; 1
    11ac:	91 87       	std	Z+9, r25	; 0x09
    11ae:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    11b0:	b1 10       	cpse	r11, r1
    11b2:	2a c0       	rjmp	.+84     	; 0x1208 <_ZL4procPv+0xfc>
		{
			if(sb->SerialAvailable() >= 2)
    11b4:	c6 01       	movw	r24, r12
    11b6:	f5 d8       	rcall	.-3606   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    11b8:	82 30       	cpi	r24, 0x02	; 2
    11ba:	10 f3       	brcs	.-60     	; 0x1180 <_ZL4procPv+0x74>
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
    11bc:	f7 01       	movw	r30, r14
					buf1[i] = sb->SerialRead();
    11be:	70 82       	st	Z, r7
    11c0:	c6 01       	movw	r24, r12
    11c2:	c3 d8       	rcall	.-3706   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
				    PORTG = 0x00;
    11c4:	89 83       	std	Y+1, r24	; 0x01
			if(sb->SerialAvailable() >= 2)
			{
				for(int i=0;i<2;i++)
				{
					PORTG = 0xff;
					buf1[i] = sb->SerialRead();
    11c6:	f7 01       	movw	r30, r14
    11c8:	10 82       	st	Z, r1
    11ca:	70 82       	st	Z, r7
    11cc:	c6 01       	movw	r24, r12
				    PORTG = 0x00;
    11ce:	bd d8       	rcall	.-3718   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    11d0:	8a 83       	std	Y+2, r24	; 0x02
				}
				if(buf1[0] != 0x01)
				{
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    11d2:	f7 01       	movw	r30, r14
    11d4:	10 82       	st	Z, r1
    11d6:	8a 81       	ldd	r24, Y+2	; 0x02
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    11d8:	81 30       	cpi	r24, 0x01	; 1
    11da:	d9 f0       	breq	.+54     	; 0x1212 <_ZL4procPv+0x106>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    11dc:	84 30       	cpi	r24, 0x04	; 4
    11de:	91 f1       	breq	.+100    	; 0x1244 <_ZL4procPv+0x138>
    11e0:	85 30       	cpi	r24, 0x05	; 5
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    11e2:	09 f4       	brne	.+2      	; 0x11e6 <_ZL4procPv+0xda>
    11e4:	59 c0       	rjmp	.+178    	; 0x1298 <_ZL4procPv+0x18c>
    11e6:	80 31       	cpi	r24, 0x10	; 16
				else
				{
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);                                                                                                                                                                                                                  
    11e8:	09 f4       	brne	.+2      	; 0x11ec <_ZL4procPv+0xe0>
    11ea:	81 c0       	rjmp	.+258    	; 0x12ee <_ZL4procPv+0x1e2>
    11ec:	43 2d       	mov	r20, r3
    11ee:	63 2d       	mov	r22, r3
					sb->SerialFlush();
    11f0:	8c ed       	ldi	r24, 0xDC	; 220
    11f2:	93 e0       	ldi	r25, 0x03	; 3
					sb->SerialWrite((char*)&exception,sizeof(exception));
    11f4:	11 d8       	rcall	.-4062   	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
    11f6:	c6 01       	movw	r24, r12
    11f8:	df d8       	rcall	.-3650   	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
    11fa:	45 e0       	ldi	r20, 0x05	; 5
    11fc:	50 e0       	ldi	r21, 0x00	; 0
    11fe:	6c ed       	ldi	r22, 0xDC	; 220
    1200:	73 e0       	ldi	r23, 0x03	; 3
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1202:	c6 01       	movw	r24, r12
    1204:	66 d8       	rcall	.-3892   	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
		{
			if(function_code == 0x01)  
    1206:	bc cf       	rjmp	.-136    	; 0x1180 <_ZL4procPv+0x74>
    1208:	f1 e0       	ldi	r31, 0x01	; 1
			{
				if(sb->SerialAvailable() >= 6)
    120a:	bf 12       	cpse	r11, r31
    120c:	b9 cf       	rjmp	.-142    	; 0x1180 <_ZL4procPv+0x74>
    120e:	af 12       	cpse	r10, r31
    1210:	16 c0       	rjmp	.+44     	; 0x123e <_ZL4procPv+0x132>
    1212:	c6 01       	movw	r24, r12
    1214:	c6 d8       	rcall	.-3700   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1216:	86 30       	cpi	r24, 0x06	; 6
    1218:	08 f4       	brcc	.+2      	; 0x121c <_ZL4procPv+0x110>
    121a:	9d cf       	rjmp	.-198    	; 0x1156 <_ZL4procPv+0x4a>
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    121c:	5e 01       	movw	r10, r28
    121e:	83 e0       	ldi	r24, 0x03	; 3
						buf1[i] = sb->SerialRead();
    1220:	a8 0e       	add	r10, r24
    1222:	b1 1c       	adc	r11, r1
    1224:	f7 01       	movw	r30, r14
    1226:	60 82       	st	Z, r6
    1228:	c6 01       	movw	r24, r12
    122a:	8f d8       	rcall	.-3810   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
						PORTG = 0x00;
    122c:	f5 01       	movw	r30, r10
    122e:	81 93       	st	Z+, r24
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1230:	5f 01       	movw	r10, r30
    1232:	f7 01       	movw	r30, r14
    1234:	10 82       	st	Z, r1
						PORTG = 0x00;
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1236:	8a 14       	cp	r8, r10
    1238:	9b 04       	cpc	r9, r11
    123a:	a1 f7       	brne	.-24     	; 0x1224 <_ZL4procPv+0x118>
			{
				if(sb->SerialAvailable() >= 6)
    123c:	8f cf       	rjmp	.-226    	; 0x115c <_ZL4procPv+0x50>
    123e:	f4 e0       	ldi	r31, 0x04	; 4
    1240:	af 12       	cpse	r10, r31
    1242:	27 c0       	rjmp	.+78     	; 0x1292 <_ZL4procPv+0x186>
    1244:	c6 01       	movw	r24, r12
    1246:	ad d8       	rcall	.-3750   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1248:	86 30       	cpi	r24, 0x06	; 6
    124a:	08 f4       	brcc	.+2      	; 0x124e <_ZL4procPv+0x142>
    124c:	8a cf       	rjmp	.-236    	; 0x1162 <_ZL4procPv+0x56>
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    124e:	5e 01       	movw	r10, r28
    1250:	83 e0       	ldi	r24, 0x03	; 3
						buf1[i] = sb->SerialRead();
    1252:	a8 0e       	add	r10, r24
    1254:	b1 1c       	adc	r11, r1
    1256:	f7 01       	movw	r30, r14
    1258:	60 82       	st	Z, r6
    125a:	c6 01       	movw	r24, r12
    125c:	76 d8       	rcall	.-3860   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
						PORTG = 0x00;
    125e:	f5 01       	movw	r30, r10
    1260:	81 93       	st	Z+, r24
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    1262:	5f 01       	movw	r10, r30
    1264:	f7 01       	movw	r30, r14
    1266:	10 82       	st	Z, r1
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc04Data(buf1,&func04,mem4);
    1268:	a8 14       	cp	r10, r8
    126a:	b9 04       	cpc	r11, r9
    126c:	a1 f7       	brne	.-24     	; 0x1256 <_ZL4procPv+0x14a>
    126e:	a8 01       	movw	r20, r16
    1270:	6c ee       	ldi	r22, 0xEC	; 236
    1272:	73 e0       	ldi	r23, 0x03	; 3
					sb->SerialWrite((char*)&func04,sizeof(func04));
    1274:	ce 01       	movw	r24, r28
    1276:	01 96       	adiw	r24, 0x01	; 1
    1278:	0e 94 8f 00 	call	0x11e	; 0x11e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
    127c:	47 e0       	ldi	r20, 0x07	; 7
    127e:	50 e0       	ldi	r21, 0x00	; 0
    1280:	6c ee       	ldi	r22, 0xEC	; 236
    1282:	73 e0       	ldi	r23, 0x03	; 3
    1284:	c6 01       	movw	r24, r12
					read_Flag = 0;
    1286:	25 d8       	rcall	.-4022   	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    1288:	68 94       	set
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    128a:	aa 24       	eor	r10, r10
    128c:	a2 f8       	bld	r10, 2
    128e:	b2 2c       	mov	r11, r2
			{
				if(sb->SerialAvailable() >= 6)
    1290:	77 cf       	rjmp	.-274    	; 0x1180 <_ZL4procPv+0x74>
    1292:	f5 e0       	ldi	r31, 0x05	; 5
    1294:	af 12       	cpse	r10, r31
    1296:	28 c0       	rjmp	.+80     	; 0x12e8 <_ZL4procPv+0x1dc>
    1298:	c6 01       	movw	r24, r12
    129a:	83 d8       	rcall	.-3834   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    129c:	86 30       	cpi	r24, 0x06	; 6
    129e:	08 f4       	brcc	.+2      	; 0x12a2 <_ZL4procPv+0x196>
    12a0:	65 cf       	rjmp	.-310    	; 0x116c <_ZL4procPv+0x60>
				{
					for(int i=2;i<8;i++)
					{
						PORTG = 0xff;
    12a2:	5e 01       	movw	r10, r28
    12a4:	83 e0       	ldi	r24, 0x03	; 3
						buf1[i] = sb->SerialRead();
    12a6:	a8 0e       	add	r10, r24
    12a8:	b1 1c       	adc	r11, r1
    12aa:	f7 01       	movw	r30, r14
    12ac:	60 82       	st	Z, r6
    12ae:	c6 01       	movw	r24, r12
    12b0:	4c d8       	rcall	.-3944   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
						PORTG = 0x00;
    12b2:	f5 01       	movw	r30, r10
    12b4:	81 93       	st	Z+, r24
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    12b6:	5f 01       	movw	r10, r30
    12b8:	f7 01       	movw	r30, r14
    12ba:	10 82       	st	Z, r1
					{
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						PORTG = 0x00;
					}
					GetFunc05Data(buf1,&func05);
    12bc:	8a 14       	cp	r8, r10
    12be:	9b 04       	cpc	r9, r11
    12c0:	a1 f7       	brne	.-24     	; 0x12aa <_ZL4procPv+0x19e>
    12c2:	63 ef       	ldi	r22, 0xF3	; 243
    12c4:	73 e0       	ldi	r23, 0x03	; 3
    12c6:	ce 01       	movw	r24, r28
					sb->SerialWrite((char*)&func05,sizeof(func05));
    12c8:	01 96       	adiw	r24, 0x01	; 1
    12ca:	0e 94 b0 00 	call	0x160	; 0x160 <_Z13GetFunc05DataPcP17GetFunctionCode05>
    12ce:	48 e0       	ldi	r20, 0x08	; 8
    12d0:	50 e0       	ldi	r21, 0x00	; 0
    12d2:	63 ef       	ldi	r22, 0xF3	; 243
    12d4:	73 e0       	ldi	r23, 0x03	; 3
    12d6:	c6 01       	movw	r24, r12
    12d8:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					read_Flag = 0;
    12dc:	0f 2e       	mov	r0, r31
    12de:	f5 e0       	ldi	r31, 0x05	; 5
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    12e0:	af 2e       	mov	r10, r31
    12e2:	f0 2d       	mov	r31, r0
			{
				if(sb->SerialAvailable() >= 9)
    12e4:	b2 2c       	mov	r11, r2
    12e6:	4c cf       	rjmp	.-360    	; 0x1180 <_ZL4procPv+0x74>
    12e8:	f0 e1       	ldi	r31, 0x10	; 16
    12ea:	af 12       	cpse	r10, r31
    12ec:	49 cf       	rjmp	.-366    	; 0x1180 <_ZL4procPv+0x74>
    12ee:	c6 01       	movw	r24, r12
    12f0:	58 d8       	rcall	.-3920   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    12f2:	89 30       	cpi	r24, 0x09	; 9
    12f4:	08 f4       	brcc	.+2      	; 0x12f8 <_ZL4procPv+0x1ec>
    12f6:	40 cf       	rjmp	.-384    	; 0x1178 <_ZL4procPv+0x6c>
				{
					for(int i=2;i<11;i++)
					{
						PORTG = 0xff;
    12f8:	5e 01       	movw	r10, r28
    12fa:	83 e0       	ldi	r24, 0x03	; 3
						buf1[i] = sb->SerialRead();
    12fc:	a8 0e       	add	r10, r24
    12fe:	b1 1c       	adc	r11, r1
    1300:	f7 01       	movw	r30, r14
    1302:	60 82       	st	Z, r6
    1304:	c6 01       	movw	r24, r12
    1306:	21 d8       	rcall	.-4030   	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
    1308:	f5 01       	movw	r30, r10
    130a:	81 93       	st	Z+, r24
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    130c:	5f 01       	movw	r10, r30
    130e:	f7 01       	movw	r30, r14
    1310:	10 82       	st	Z, r1
						PORTG = 0xff;
						buf1[i] = sb->SerialRead();
						//sb->SerialWrite(buf1[i]);
						PORTG = 0x00;
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    1312:	4a 14       	cp	r4, r10
    1314:	5b 04       	cpc	r5, r11
    1316:	a1 f7       	brne	.-24     	; 0x1300 <_ZL4procPv+0x1f4>
    1318:	a8 01       	movw	r20, r16
    131a:	61 ee       	ldi	r22, 0xE1	; 225
    131c:	73 e0       	ldi	r23, 0x03	; 3
    131e:	ce 01       	movw	r24, r28
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    1320:	01 96       	adiw	r24, 0x01	; 1
    1322:	0e 94 c9 00 	call	0x192	; 0x192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
    1326:	64 ed       	ldi	r22, 0xD4	; 212
    1328:	73 e0       	ldi	r23, 0x03	; 3
    132a:	ce 01       	movw	r24, r28
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    132c:	01 96       	adiw	r24, 0x01	; 1
    132e:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
    1332:	48 e0       	ldi	r20, 0x08	; 8
    1334:	50 e0       	ldi	r21, 0x00	; 0
    1336:	64 ed       	ldi	r22, 0xD4	; 212
    1338:	73 e0       	ldi	r23, 0x03	; 3
    133a:	c6 01       	movw	r24, r12
    133c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					//sb->SerialWrite((char*)&rsp10,sizeof(rsp10));
					read_Flag = 0;
    1340:	68 94       	set
    1342:	aa 24       	eor	r10, r10
    1344:	a4 f8       	bld	r10, 4
    1346:	b2 2c       	mov	r11, r2
    1348:	1b cf       	rjmp	.-458    	; 0x1180 <_ZL4procPv+0x74>

0000134a <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    134a:	80 91 fb 03 	lds	r24, 0x03FB	; 0x8003fb <DataStruct>
    134e:	90 91 fc 03 	lds	r25, 0x03FC	; 0x8003fc <DataStruct+0x1>
    1352:	0c 94 44 01 	jmp	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
    1356:	08 95       	ret

00001358 <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    1358:	80 91 fd 03 	lds	r24, 0x03FD	; 0x8003fd <DataStruct+0x2>
    135c:	90 91 fe 03 	lds	r25, 0x03FE	; 0x8003fe <DataStruct+0x3>
    1360:	0c 94 44 01 	jmp	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
    1364:	08 95       	ret

00001366 <_Z8Init_Devv>:
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}

void Init_Dev()
{
    1366:	cf 93       	push	r28
    1368:	df 93       	push	r29
	dev = new Dev_Manager();
    136a:	8c e0       	ldi	r24, 0x0C	; 12
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	67 d8       	rcall	.-3890   	; 0x43e <_ZN11Dev_ManagernwEj>
    1370:	ec 01       	movw	r28, r24
    1372:	2d d8       	rcall	.-4006   	; 0x3ce <_ZN11Dev_ManagerC1Ev>
    1374:	d0 93 02 04 	sts	0x0402, r29	; 0x800402 <dev+0x1>
    1378:	c0 93 01 04 	sts	0x0401, r28	; 0x800401 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    137c:	86 e0       	ldi	r24, 0x06	; 6
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	1c da       	rcall	.-3016   	; 0x7ba <_ZN10UartDrivernwEj>
    1382:	ec 01       	movw	r28, r24
    1384:	0a da       	rcall	.-3052   	; 0x79a <_ZN10UartDriverC1Ev>
    1386:	40 e0       	ldi	r20, 0x00	; 0
    1388:	be 01       	movw	r22, r28
    138a:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    138e:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
	dev->Register_Dev(new RS485Driver,RS485);
    1392:	4c d8       	rcall	.-3944   	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    1394:	86 e0       	ldi	r24, 0x06	; 6
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	93 d9       	rcall	.-3290   	; 0x6c0 <_ZN11RS485DrivernwEj>
    139a:	ec 01       	movw	r28, r24
    139c:	81 d9       	rcall	.-3326   	; 0x6a0 <_ZN11RS485DriverC1Ev>
    139e:	41 e0       	ldi	r20, 0x01	; 1
    13a0:	be 01       	movw	r22, r28
    13a2:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
	dev->Register_Dev(new Timer,SEC_TIMER);
    13a6:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13aa:	40 d8       	rcall	.-3968   	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    13ac:	82 e0       	ldi	r24, 0x02	; 2
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	50 d9       	rcall	.-3424   	; 0x652 <_ZN5TimernwEj>
    13b2:	ec 01       	movw	r28, r24
    13b4:	48 d9       	rcall	.-3440   	; 0x646 <_ZN5TimerC1Ev>
    13b6:	42 e0       	ldi	r20, 0x02	; 2
    13b8:	be 01       	movw	r22, r28
    13ba:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
	dev->Device_Init(UART0);
    13be:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13c2:	34 d8       	rcall	.-3992   	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
    13c4:	60 e0       	ldi	r22, 0x00	; 0
	dev->Device_Init(RS485);
    13c6:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    13ca:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13ce:	62 d8       	rcall	.-3900   	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    13d0:	61 e0       	ldi	r22, 0x01	; 1
	dev->Device_Init(SEC_TIMER);
    13d2:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    13d6:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13da:	5c d8       	rcall	.-3912   	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    13dc:	62 e0       	ldi	r22, 0x02	; 2
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    13de:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    13e2:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13e6:	56 d8       	rcall	.-3924   	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
    13e8:	4f e2       	ldi	r20, 0x2F	; 47
    13ea:	51 e0       	ldi	r21, 0x01	; 1
    13ec:	60 e0       	ldi	r22, 0x00	; 0
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    13ee:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    13f2:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    13f6:	3a d8       	rcall	.-3980   	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePc>
    13f8:	45 e5       	ldi	r20, 0x55	; 85
    13fa:	51 e0       	ldi	r21, 0x01	; 1
    13fc:	61 e0       	ldi	r22, 0x01	; 1
    13fe:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
}
    1402:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
    1406:	32 d8       	rcall	.-3996   	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePc>
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	08 95       	ret

0000140e <main>:
int current_pressure = 0;

int mem4[MAX_ENUM] = {0};

int main( void )
{
    140e:	cf 92       	push	r12
    1410:	df 92       	push	r13
    1412:	ef 92       	push	r14
    1414:	ff 92       	push	r15
    1416:	0f 93       	push	r16
    1418:	cf 93       	push	r28
    141a:	df 93       	push	r29
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    141c:	f8 94       	cli
	
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    141e:	a3 df       	rcall	.-186    	; 0x1366 <_Z8Init_Devv>
    1420:	45 ea       	ldi	r20, 0xA5	; 165
    1422:	59 e0       	ldi	r21, 0x09	; 9
    1424:	60 e0       	ldi	r22, 0x00	; 0
    1426:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    142a:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    142e:	44 d8       	rcall	.-3960   	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
    1430:	4c ea       	ldi	r20, 0xAC	; 172
    1432:	59 e0       	ldi	r21, 0x09	; 9
    1434:	61 e0       	ldi	r22, 0x01	; 1
    1436:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    143a:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    143e:	3c d8       	rcall	.-3976   	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
    1440:	42 e9       	ldi	r20, 0x92	; 146
    1442:	57 e0       	ldi	r21, 0x07	; 7
    1444:	62 e0       	ldi	r22, 0x02	; 2
    1446:	80 91 01 04 	lds	r24, 0x0401	; 0x800401 <dev>
    144a:	90 91 02 04 	lds	r25, 0x0402	; 0x800402 <dev+0x1>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    144e:	34 d8       	rcall	.-3992   	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
    1450:	88 e8       	ldi	r24, 0x88	; 136
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    1458:	6c 01       	movw	r12, r24
    145a:	60 91 01 04 	lds	r22, 0x0401	; 0x800401 <dev>
    145e:	70 91 02 04 	lds	r23, 0x0402	; 0x800402 <dev+0x1>
    1462:	40 e0       	ldi	r20, 0x00	; 0
    1464:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1468:	c1 14       	cp	r12, r1
    146a:	d1 04       	cpc	r13, r1
	{
		#if DEBUG 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    146c:	21 f4       	brne	.+8      	; 0x1476 <main+0x68>
    146e:	81 e0       	ldi	r24, 0x01	; 1
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	0e 94 0d 14 	call	0x281a	; 0x281a <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		#endif
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1476:	88 e8       	ldi	r24, 0x88	; 136
    1478:	90 e0       	ldi	r25, 0x00	; 0
    147a:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    147e:	ec 01       	movw	r28, r24
    1480:	60 91 01 04 	lds	r22, 0x0401	; 0x800401 <dev>
    1484:	70 91 02 04 	lds	r23, 0x0402	; 0x800402 <dev+0x1>
    1488:	41 e0       	ldi	r20, 0x01	; 1
    148a:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    148e:	20 97       	sbiw	r28, 0x00	; 0
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    1490:	21 f4       	brne	.+8      	; 0x149a <main+0x8c>
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	90 e0       	ldi	r25, 0x00	; 0
    1496:	0e 94 0d 14 	call	0x281a	; 0x281a <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		#endif
	}
	DataStruct[UART0] = sb;
    149a:	eb ef       	ldi	r30, 0xFB	; 251
    149c:	f3 e0       	ldi	r31, 0x03	; 3
    149e:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    14a0:	c0 82       	st	Z, r12
    14a2:	d3 83       	std	Z+3, r29	; 0x03
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			#endif
		}
	}

	sei(); //인터럽트 사용 
    14a4:	c2 83       	std	Z+2, r28	; 0x02
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    14a6:	78 94       	sei
    14a8:	e1 2c       	mov	r14, r1
    14aa:	f1 2c       	mov	r15, r1
    14ac:	02 e0       	ldi	r16, 0x02	; 2
    14ae:	96 01       	movw	r18, r12
    14b0:	4e e5       	ldi	r20, 0x5E	; 94
    14b2:	51 e0       	ldi	r21, 0x01	; 1
    14b4:	6c e7       	ldi	r22, 0x7C	; 124
    14b6:	71 e0       	ldi	r23, 0x01	; 1
    14b8:	86 e8       	ldi	r24, 0x86	; 134
    14ba:	98 e0       	ldi	r25, 0x08	; 8
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    14bc:	28 d5       	rcall	.+2640   	; 0x1f0e <xTaskCreate>
    14be:	9e 01       	movw	r18, r28
    14c0:	4e e5       	ldi	r20, 0x5E	; 94
    14c2:	51 e0       	ldi	r21, 0x01	; 1
    14c4:	62 e8       	ldi	r22, 0x82	; 130
    14c6:	71 e0       	ldi	r23, 0x01	; 1
    14c8:	88 ef       	ldi	r24, 0xF8	; 248
    14ca:	97 e0       	ldi	r25, 0x07	; 7
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위
				NULL                   //태스크 핸들
				);
    14cc:	20 d5       	rcall	.+2624   	; 0x1f0e <xTaskCreate>
    14ce:	20 e0       	ldi	r18, 0x00	; 0
    14d0:	30 e0       	ldi	r19, 0x00	; 0
    14d2:	40 ef       	ldi	r20, 0xF0	; 240
    14d4:	50 e0       	ldi	r21, 0x00	; 0
    14d6:	68 e8       	ldi	r22, 0x88	; 136
    14d8:	71 e0       	ldi	r23, 0x01	; 1
    14da:	8a e9       	ldi	r24, 0x9A	; 154
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    14dc:	97 e0       	ldi	r25, 0x07	; 7
    14de:	17 d5       	rcall	.+2606   	; 0x1f0e <xTaskCreate>
	return 0;
}
    14e0:	14 d6       	rcall	.+3112   	; 0x210a <vTaskStartScheduler>
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	90 e0       	ldi	r25, 0x00	; 0
    14e6:	df 91       	pop	r29
    14e8:	cf 91       	pop	r28
    14ea:	0f 91       	pop	r16
    14ec:	ff 90       	pop	r15
    14ee:	ef 90       	pop	r14
    14f0:	df 90       	pop	r13
    14f2:	cf 90       	pop	r12
    14f4:	08 95       	ret

000014f6 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    14f6:	08 95       	ret

000014f8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    14f8:	cf 93       	push	r28
    14fa:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    14fc:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    14fe:	2d d6       	rcall	.+3162   	; 0x215a <vTaskSuspendAll>
    1500:	80 91 03 04 	lds	r24, 0x0403	; 0x800403 <pucAlignedHeap.2069>
    1504:	90 91 04 04 	lds	r25, 0x0404	; 0x800404 <pucAlignedHeap.2069+0x1>
    1508:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    150a:	31 f4       	brne	.+12     	; 0x1518 <pvPortMalloc+0x20>
    150c:	88 e0       	ldi	r24, 0x08	; 8
    150e:	94 e0       	ldi	r25, 0x04	; 4
    1510:	90 93 04 04 	sts	0x0404, r25	; 0x800404 <pucAlignedHeap.2069+0x1>
    1514:	80 93 03 04 	sts	0x0403, r24	; 0x800403 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1518:	20 91 05 04 	lds	r18, 0x0405	; 0x800405 <xNextFreeByte>
    151c:	30 91 06 04 	lds	r19, 0x0406	; 0x800406 <xNextFreeByte+0x1>
    1520:	c9 01       	movw	r24, r18
    1522:	8c 0f       	add	r24, r28
    1524:	9d 1f       	adc	r25, r29
    1526:	8b 3f       	cpi	r24, 0xFB	; 251
    1528:	48 e0       	ldi	r20, 0x08	; 8
    152a:	94 07       	cpc	r25, r20
    152c:	70 f4       	brcc	.+28     	; 0x154a <pvPortMalloc+0x52>
    152e:	28 17       	cp	r18, r24
    1530:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1532:	70 f4       	brcc	.+28     	; 0x1550 <pvPortMalloc+0x58>
    1534:	c0 91 03 04 	lds	r28, 0x0403	; 0x800403 <pucAlignedHeap.2069>
    1538:	d0 91 04 04 	lds	r29, 0x0404	; 0x800404 <pucAlignedHeap.2069+0x1>
    153c:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    153e:	d3 1f       	adc	r29, r19
    1540:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <xNextFreeByte+0x1>
    1544:	80 93 05 04 	sts	0x0405, r24	; 0x800405 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1548:	05 c0       	rjmp	.+10     	; 0x1554 <pvPortMalloc+0x5c>
    154a:	c0 e0       	ldi	r28, 0x00	; 0
    154c:	d0 e0       	ldi	r29, 0x00	; 0
    154e:	02 c0       	rjmp	.+4      	; 0x1554 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1550:	c0 e0       	ldi	r28, 0x00	; 0
    1552:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    1554:	bf d6       	rcall	.+3454   	; 0x22d4 <xTaskResumeAll>
    1556:	ce 01       	movw	r24, r28
    1558:	df 91       	pop	r29
    155a:	cf 91       	pop	r28
    155c:	08 95       	ret

0000155e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    155e:	08 95       	ret

00001560 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1560:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1562:	03 96       	adiw	r24, 0x03	; 3
    1564:	92 83       	std	Z+2, r25	; 0x02
    1566:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1568:	2f ef       	ldi	r18, 0xFF	; 255
    156a:	3f ef       	ldi	r19, 0xFF	; 255
    156c:	34 83       	std	Z+4, r19	; 0x04
    156e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1570:	96 83       	std	Z+6, r25	; 0x06
    1572:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1574:	90 87       	std	Z+8, r25	; 0x08
    1576:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1578:	10 82       	st	Z, r1
    157a:	08 95       	ret

0000157c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    157c:	fc 01       	movw	r30, r24
    157e:	11 86       	std	Z+9, r1	; 0x09
    1580:	10 86       	std	Z+8, r1	; 0x08
    1582:	08 95       	ret

00001584 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	9c 01       	movw	r18, r24
    158a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    158c:	dc 01       	movw	r26, r24
    158e:	11 96       	adiw	r26, 0x01	; 1
    1590:	cd 91       	ld	r28, X+
    1592:	dc 91       	ld	r29, X
    1594:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1596:	d3 83       	std	Z+3, r29	; 0x03
    1598:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    159a:	8c 81       	ldd	r24, Y+4	; 0x04
    159c:	9d 81       	ldd	r25, Y+5	; 0x05
    159e:	95 83       	std	Z+5, r25	; 0x05
    15a0:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    15a2:	8c 81       	ldd	r24, Y+4	; 0x04
    15a4:	9d 81       	ldd	r25, Y+5	; 0x05
    15a6:	dc 01       	movw	r26, r24
    15a8:	13 96       	adiw	r26, 0x03	; 3
    15aa:	7c 93       	st	X, r23
    15ac:	6e 93       	st	-X, r22
    15ae:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    15b0:	7d 83       	std	Y+5, r23	; 0x05
    15b2:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    15b4:	31 87       	std	Z+9, r19	; 0x09
    15b6:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    15b8:	f9 01       	movw	r30, r18
    15ba:	80 81       	ld	r24, Z
    15bc:	8f 5f       	subi	r24, 0xFF	; 255
    15be:	80 83       	st	Z, r24
}
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	08 95       	ret

000015c6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    15c6:	cf 93       	push	r28
    15c8:	df 93       	push	r29
    15ca:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    15cc:	48 81       	ld	r20, Y
    15ce:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15d0:	4f 3f       	cpi	r20, 0xFF	; 255
    15d2:	2f ef       	ldi	r18, 0xFF	; 255
    15d4:	52 07       	cpc	r21, r18
    15d6:	21 f4       	brne	.+8      	; 0x15e0 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15d8:	fc 01       	movw	r30, r24
    15da:	a7 81       	ldd	r26, Z+7	; 0x07
    15dc:	b0 85       	ldd	r27, Z+8	; 0x08
    15de:	0d c0       	rjmp	.+26     	; 0x15fa <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    15e0:	dc 01       	movw	r26, r24
    15e2:	13 96       	adiw	r26, 0x03	; 3
    15e4:	01 c0       	rjmp	.+2      	; 0x15e8 <vListInsert+0x22>
    15e6:	df 01       	movw	r26, r30
    15e8:	12 96       	adiw	r26, 0x02	; 2
    15ea:	ed 91       	ld	r30, X+
    15ec:	fc 91       	ld	r31, X
    15ee:	13 97       	sbiw	r26, 0x03	; 3
    15f0:	20 81       	ld	r18, Z
    15f2:	31 81       	ldd	r19, Z+1	; 0x01
    15f4:	42 17       	cp	r20, r18
    15f6:	53 07       	cpc	r21, r19
    15f8:	b0 f7       	brcc	.-20     	; 0x15e6 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    15fa:	12 96       	adiw	r26, 0x02	; 2
    15fc:	ed 91       	ld	r30, X+
    15fe:	fc 91       	ld	r31, X
    1600:	13 97       	sbiw	r26, 0x03	; 3
    1602:	fb 83       	std	Y+3, r31	; 0x03
    1604:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1606:	d5 83       	std	Z+5, r29	; 0x05
    1608:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    160a:	bd 83       	std	Y+5, r27	; 0x05
    160c:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    160e:	13 96       	adiw	r26, 0x03	; 3
    1610:	dc 93       	st	X, r29
    1612:	ce 93       	st	-X, r28
    1614:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1616:	99 87       	std	Y+9, r25	; 0x09
    1618:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    161a:	fc 01       	movw	r30, r24
    161c:	20 81       	ld	r18, Z
    161e:	2f 5f       	subi	r18, 0xFF	; 255
    1620:	20 83       	st	Z, r18
}
    1622:	df 91       	pop	r29
    1624:	cf 91       	pop	r28
    1626:	08 95       	ret

00001628 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1628:	cf 93       	push	r28
    162a:	df 93       	push	r29
    162c:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    162e:	a0 85       	ldd	r26, Z+8	; 0x08
    1630:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1632:	c2 81       	ldd	r28, Z+2	; 0x02
    1634:	d3 81       	ldd	r29, Z+3	; 0x03
    1636:	84 81       	ldd	r24, Z+4	; 0x04
    1638:	95 81       	ldd	r25, Z+5	; 0x05
    163a:	9d 83       	std	Y+5, r25	; 0x05
    163c:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    163e:	c4 81       	ldd	r28, Z+4	; 0x04
    1640:	d5 81       	ldd	r29, Z+5	; 0x05
    1642:	82 81       	ldd	r24, Z+2	; 0x02
    1644:	93 81       	ldd	r25, Z+3	; 0x03
    1646:	9b 83       	std	Y+3, r25	; 0x03
    1648:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    164a:	11 96       	adiw	r26, 0x01	; 1
    164c:	8d 91       	ld	r24, X+
    164e:	9c 91       	ld	r25, X
    1650:	12 97       	sbiw	r26, 0x02	; 2
    1652:	e8 17       	cp	r30, r24
    1654:	f9 07       	cpc	r31, r25
    1656:	31 f4       	brne	.+12     	; 0x1664 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1658:	84 81       	ldd	r24, Z+4	; 0x04
    165a:	95 81       	ldd	r25, Z+5	; 0x05
    165c:	12 96       	adiw	r26, 0x02	; 2
    165e:	9c 93       	st	X, r25
    1660:	8e 93       	st	-X, r24
    1662:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1664:	11 86       	std	Z+9, r1	; 0x09
    1666:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1668:	8c 91       	ld	r24, X
    166a:	81 50       	subi	r24, 0x01	; 1
    166c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    166e:	df 91       	pop	r29
    1670:	cf 91       	pop	r28
    1672:	08 95       	ret

00001674 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1674:	31 e1       	ldi	r19, 0x11	; 17
    1676:	fc 01       	movw	r30, r24
    1678:	30 83       	st	Z, r19
    167a:	31 97       	sbiw	r30, 0x01	; 1
    167c:	22 e2       	ldi	r18, 0x22	; 34
    167e:	20 83       	st	Z, r18
    1680:	31 97       	sbiw	r30, 0x01	; 1
    1682:	a3 e3       	ldi	r26, 0x33	; 51
    1684:	a0 83       	st	Z, r26
    1686:	31 97       	sbiw	r30, 0x01	; 1
    1688:	60 83       	st	Z, r22
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	70 83       	st	Z, r23
    168e:	31 97       	sbiw	r30, 0x01	; 1
    1690:	10 82       	st	Z, r1
    1692:	31 97       	sbiw	r30, 0x01	; 1
    1694:	60 e8       	ldi	r22, 0x80	; 128
    1696:	60 83       	st	Z, r22
    1698:	31 97       	sbiw	r30, 0x01	; 1
    169a:	10 82       	st	Z, r1
    169c:	31 97       	sbiw	r30, 0x01	; 1
    169e:	62 e0       	ldi	r22, 0x02	; 2
    16a0:	60 83       	st	Z, r22
    16a2:	31 97       	sbiw	r30, 0x01	; 1
    16a4:	63 e0       	ldi	r22, 0x03	; 3
    16a6:	60 83       	st	Z, r22
    16a8:	31 97       	sbiw	r30, 0x01	; 1
    16aa:	64 e0       	ldi	r22, 0x04	; 4
    16ac:	60 83       	st	Z, r22
    16ae:	31 97       	sbiw	r30, 0x01	; 1
    16b0:	65 e0       	ldi	r22, 0x05	; 5
    16b2:	60 83       	st	Z, r22
    16b4:	31 97       	sbiw	r30, 0x01	; 1
    16b6:	66 e0       	ldi	r22, 0x06	; 6
    16b8:	60 83       	st	Z, r22
    16ba:	31 97       	sbiw	r30, 0x01	; 1
    16bc:	67 e0       	ldi	r22, 0x07	; 7
    16be:	60 83       	st	Z, r22
    16c0:	31 97       	sbiw	r30, 0x01	; 1
    16c2:	68 e0       	ldi	r22, 0x08	; 8
    16c4:	60 83       	st	Z, r22
    16c6:	31 97       	sbiw	r30, 0x01	; 1
    16c8:	69 e0       	ldi	r22, 0x09	; 9
    16ca:	60 83       	st	Z, r22
    16cc:	31 97       	sbiw	r30, 0x01	; 1
    16ce:	60 e1       	ldi	r22, 0x10	; 16
    16d0:	60 83       	st	Z, r22
    16d2:	31 97       	sbiw	r30, 0x01	; 1
    16d4:	30 83       	st	Z, r19
    16d6:	31 97       	sbiw	r30, 0x01	; 1
    16d8:	32 e1       	ldi	r19, 0x12	; 18
    16da:	30 83       	st	Z, r19
    16dc:	31 97       	sbiw	r30, 0x01	; 1
    16de:	33 e1       	ldi	r19, 0x13	; 19
    16e0:	30 83       	st	Z, r19
    16e2:	31 97       	sbiw	r30, 0x01	; 1
    16e4:	34 e1       	ldi	r19, 0x14	; 20
    16e6:	30 83       	st	Z, r19
    16e8:	31 97       	sbiw	r30, 0x01	; 1
    16ea:	35 e1       	ldi	r19, 0x15	; 21
    16ec:	30 83       	st	Z, r19
    16ee:	31 97       	sbiw	r30, 0x01	; 1
    16f0:	36 e1       	ldi	r19, 0x16	; 22
    16f2:	30 83       	st	Z, r19
    16f4:	31 97       	sbiw	r30, 0x01	; 1
    16f6:	37 e1       	ldi	r19, 0x17	; 23
    16f8:	30 83       	st	Z, r19
    16fa:	31 97       	sbiw	r30, 0x01	; 1
    16fc:	38 e1       	ldi	r19, 0x18	; 24
    16fe:	30 83       	st	Z, r19
    1700:	31 97       	sbiw	r30, 0x01	; 1
    1702:	39 e1       	ldi	r19, 0x19	; 25
    1704:	30 83       	st	Z, r19
    1706:	31 97       	sbiw	r30, 0x01	; 1
    1708:	30 e2       	ldi	r19, 0x20	; 32
    170a:	30 83       	st	Z, r19
    170c:	31 97       	sbiw	r30, 0x01	; 1
    170e:	31 e2       	ldi	r19, 0x21	; 33
    1710:	30 83       	st	Z, r19
    1712:	31 97       	sbiw	r30, 0x01	; 1
    1714:	20 83       	st	Z, r18
    1716:	31 97       	sbiw	r30, 0x01	; 1
    1718:	23 e2       	ldi	r18, 0x23	; 35
    171a:	20 83       	st	Z, r18
    171c:	31 97       	sbiw	r30, 0x01	; 1
    171e:	40 83       	st	Z, r20
    1720:	31 97       	sbiw	r30, 0x01	; 1
    1722:	50 83       	st	Z, r21
    1724:	31 97       	sbiw	r30, 0x01	; 1
    1726:	26 e2       	ldi	r18, 0x26	; 38
    1728:	20 83       	st	Z, r18
    172a:	31 97       	sbiw	r30, 0x01	; 1
    172c:	27 e2       	ldi	r18, 0x27	; 39
    172e:	20 83       	st	Z, r18
    1730:	31 97       	sbiw	r30, 0x01	; 1
    1732:	28 e2       	ldi	r18, 0x28	; 40
    1734:	20 83       	st	Z, r18
    1736:	31 97       	sbiw	r30, 0x01	; 1
    1738:	29 e2       	ldi	r18, 0x29	; 41
    173a:	20 83       	st	Z, r18
    173c:	31 97       	sbiw	r30, 0x01	; 1
    173e:	20 e3       	ldi	r18, 0x30	; 48
    1740:	20 83       	st	Z, r18
    1742:	31 97       	sbiw	r30, 0x01	; 1
    1744:	21 e3       	ldi	r18, 0x31	; 49
    1746:	20 83       	st	Z, r18
    1748:	86 97       	sbiw	r24, 0x26	; 38
    174a:	08 95       	ret

0000174c <xPortStartScheduler>:
    174c:	1b bc       	out	0x2b, r1	; 43
    174e:	89 ef       	ldi	r24, 0xF9	; 249
    1750:	8a bd       	out	0x2a, r24	; 42
    1752:	8b e0       	ldi	r24, 0x0B	; 11
    1754:	8e bd       	out	0x2e, r24	; 46
    1756:	87 b7       	in	r24, 0x37	; 55
    1758:	80 61       	ori	r24, 0x10	; 16
    175a:	87 bf       	out	0x37, r24	; 55
    175c:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1760:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1764:	cd 91       	ld	r28, X+
    1766:	cd bf       	out	0x3d, r28	; 61
    1768:	dd 91       	ld	r29, X+
    176a:	de bf       	out	0x3e, r29	; 62
    176c:	ff 91       	pop	r31
    176e:	ef 91       	pop	r30
    1770:	df 91       	pop	r29
    1772:	cf 91       	pop	r28
    1774:	bf 91       	pop	r27
    1776:	af 91       	pop	r26
    1778:	9f 91       	pop	r25
    177a:	8f 91       	pop	r24
    177c:	7f 91       	pop	r23
    177e:	6f 91       	pop	r22
    1780:	5f 91       	pop	r21
    1782:	4f 91       	pop	r20
    1784:	3f 91       	pop	r19
    1786:	2f 91       	pop	r18
    1788:	1f 91       	pop	r17
    178a:	0f 91       	pop	r16
    178c:	ff 90       	pop	r15
    178e:	ef 90       	pop	r14
    1790:	df 90       	pop	r13
    1792:	cf 90       	pop	r12
    1794:	bf 90       	pop	r11
    1796:	af 90       	pop	r10
    1798:	9f 90       	pop	r9
    179a:	8f 90       	pop	r8
    179c:	7f 90       	pop	r7
    179e:	6f 90       	pop	r6
    17a0:	5f 90       	pop	r5
    17a2:	4f 90       	pop	r4
    17a4:	3f 90       	pop	r3
    17a6:	2f 90       	pop	r2
    17a8:	1f 90       	pop	r1
    17aa:	0f 90       	pop	r0
    17ac:	0f be       	out	0x3f, r0	; 63
    17ae:	0f 90       	pop	r0
    17b0:	08 95       	ret
    17b2:	81 e0       	ldi	r24, 0x01	; 1
    17b4:	08 95       	ret

000017b6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    17b6:	0f 92       	push	r0
    17b8:	0f b6       	in	r0, 0x3f	; 63
    17ba:	f8 94       	cli
    17bc:	0f 92       	push	r0
    17be:	1f 92       	push	r1
    17c0:	11 24       	eor	r1, r1
    17c2:	2f 92       	push	r2
    17c4:	3f 92       	push	r3
    17c6:	4f 92       	push	r4
    17c8:	5f 92       	push	r5
    17ca:	6f 92       	push	r6
    17cc:	7f 92       	push	r7
    17ce:	8f 92       	push	r8
    17d0:	9f 92       	push	r9
    17d2:	af 92       	push	r10
    17d4:	bf 92       	push	r11
    17d6:	cf 92       	push	r12
    17d8:	df 92       	push	r13
    17da:	ef 92       	push	r14
    17dc:	ff 92       	push	r15
    17de:	0f 93       	push	r16
    17e0:	1f 93       	push	r17
    17e2:	2f 93       	push	r18
    17e4:	3f 93       	push	r19
    17e6:	4f 93       	push	r20
    17e8:	5f 93       	push	r21
    17ea:	6f 93       	push	r22
    17ec:	7f 93       	push	r23
    17ee:	8f 93       	push	r24
    17f0:	9f 93       	push	r25
    17f2:	af 93       	push	r26
    17f4:	bf 93       	push	r27
    17f6:	cf 93       	push	r28
    17f8:	df 93       	push	r29
    17fa:	ef 93       	push	r30
    17fc:	ff 93       	push	r31
    17fe:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1802:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1806:	0d b6       	in	r0, 0x3d	; 61
    1808:	0d 92       	st	X+, r0
    180a:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    180c:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    180e:	22 d6       	rcall	.+3140   	; 0x2454 <vTaskSwitchContext>
    1810:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1814:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1818:	cd 91       	ld	r28, X+
    181a:	cd bf       	out	0x3d, r28	; 61
    181c:	dd 91       	ld	r29, X+
    181e:	de bf       	out	0x3e, r29	; 62
    1820:	ff 91       	pop	r31
    1822:	ef 91       	pop	r30
    1824:	df 91       	pop	r29
    1826:	cf 91       	pop	r28
    1828:	bf 91       	pop	r27
    182a:	af 91       	pop	r26
    182c:	9f 91       	pop	r25
    182e:	8f 91       	pop	r24
    1830:	7f 91       	pop	r23
    1832:	6f 91       	pop	r22
    1834:	5f 91       	pop	r21
    1836:	4f 91       	pop	r20
    1838:	3f 91       	pop	r19
    183a:	2f 91       	pop	r18
    183c:	1f 91       	pop	r17
    183e:	0f 91       	pop	r16
    1840:	ff 90       	pop	r15
    1842:	ef 90       	pop	r14
    1844:	df 90       	pop	r13
    1846:	cf 90       	pop	r12
    1848:	bf 90       	pop	r11
    184a:	af 90       	pop	r10
    184c:	9f 90       	pop	r9
    184e:	8f 90       	pop	r8
    1850:	7f 90       	pop	r7
    1852:	6f 90       	pop	r6
    1854:	5f 90       	pop	r5
    1856:	4f 90       	pop	r4
    1858:	3f 90       	pop	r3
    185a:	2f 90       	pop	r2
    185c:	1f 90       	pop	r1
    185e:	0f 90       	pop	r0
    1860:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1862:	0f 90       	pop	r0
    1864:	08 95       	ret

00001866 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1866:	0f 92       	push	r0
    1868:	0f b6       	in	r0, 0x3f	; 63
    186a:	f8 94       	cli
    186c:	0f 92       	push	r0
    186e:	1f 92       	push	r1
    1870:	11 24       	eor	r1, r1
    1872:	2f 92       	push	r2
    1874:	3f 92       	push	r3
    1876:	4f 92       	push	r4
    1878:	5f 92       	push	r5
    187a:	6f 92       	push	r6
    187c:	7f 92       	push	r7
    187e:	8f 92       	push	r8
    1880:	9f 92       	push	r9
    1882:	af 92       	push	r10
    1884:	bf 92       	push	r11
    1886:	cf 92       	push	r12
    1888:	df 92       	push	r13
    188a:	ef 92       	push	r14
    188c:	ff 92       	push	r15
    188e:	0f 93       	push	r16
    1890:	1f 93       	push	r17
    1892:	2f 93       	push	r18
    1894:	3f 93       	push	r19
    1896:	4f 93       	push	r20
    1898:	5f 93       	push	r21
    189a:	6f 93       	push	r22
    189c:	7f 93       	push	r23
    189e:	8f 93       	push	r24
    18a0:	9f 93       	push	r25
    18a2:	af 93       	push	r26
    18a4:	bf 93       	push	r27
    18a6:	cf 93       	push	r28
    18a8:	df 93       	push	r29
    18aa:	ef 93       	push	r30
    18ac:	ff 93       	push	r31
    18ae:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    18b2:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    18b6:	0d b6       	in	r0, 0x3d	; 61
    18b8:	0d 92       	st	X+, r0
    18ba:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    18bc:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    18be:	53 d4       	rcall	.+2214   	; 0x2166 <xTaskIncrementTick>
    18c0:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    18c2:	c8 d5       	rcall	.+2960   	; 0x2454 <vTaskSwitchContext>
    18c4:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    18c8:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    18cc:	cd 91       	ld	r28, X+
    18ce:	cd bf       	out	0x3d, r28	; 61
    18d0:	dd 91       	ld	r29, X+
    18d2:	de bf       	out	0x3e, r29	; 62
    18d4:	ff 91       	pop	r31
    18d6:	ef 91       	pop	r30
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	bf 91       	pop	r27
    18de:	af 91       	pop	r26
    18e0:	9f 91       	pop	r25
    18e2:	8f 91       	pop	r24
    18e4:	7f 91       	pop	r23
    18e6:	6f 91       	pop	r22
    18e8:	5f 91       	pop	r21
    18ea:	4f 91       	pop	r20
    18ec:	3f 91       	pop	r19
    18ee:	2f 91       	pop	r18
    18f0:	1f 91       	pop	r17
    18f2:	0f 91       	pop	r16
    18f4:	ff 90       	pop	r15
    18f6:	ef 90       	pop	r14
    18f8:	df 90       	pop	r13
    18fa:	cf 90       	pop	r12
    18fc:	bf 90       	pop	r11
    18fe:	af 90       	pop	r10
    1900:	9f 90       	pop	r9
    1902:	8f 90       	pop	r8
    1904:	7f 90       	pop	r7
    1906:	6f 90       	pop	r6
    1908:	5f 90       	pop	r5
    190a:	4f 90       	pop	r4
    190c:	3f 90       	pop	r3
    190e:	2f 90       	pop	r2
    1910:	1f 90       	pop	r1
    1912:	0f 90       	pop	r0
    1914:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1916:	0f 90       	pop	r0
    1918:	08 95       	ret

0000191a <__vector_12>:
    191a:	a5 df       	rcall	.-182    	; 0x1866 <vPortYieldFromTick>
    191c:	18 95       	reti

0000191e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    191e:	0f 93       	push	r16
    1920:	1f 93       	push	r17
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
    1926:	ec 01       	movw	r28, r24
    1928:	04 2f       	mov	r16, r20
    192a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    192c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    192e:	41 11       	cpse	r20, r1
    1930:	0b c0       	rjmp	.+22     	; 0x1948 <prvCopyDataToQueue+0x2a>
    1932:	88 81       	ld	r24, Y
    1934:	99 81       	ldd	r25, Y+1	; 0x01
    1936:	89 2b       	or	r24, r25
    1938:	09 f0       	breq	.+2      	; 0x193c <prvCopyDataToQueue+0x1e>
    193a:	3f c0       	rjmp	.+126    	; 0x19ba <prvCopyDataToQueue+0x9c>
    193c:	8a 81       	ldd	r24, Y+2	; 0x02
    193e:	9b 81       	ldd	r25, Y+3	; 0x03
    1940:	08 d7       	rcall	.+3600   	; 0x2752 <xTaskPriorityDisinherit>
    1942:	1b 82       	std	Y+3, r1	; 0x03
    1944:	1a 82       	std	Y+2, r1	; 0x02
    1946:	40 c0       	rjmp	.+128    	; 0x19c8 <prvCopyDataToQueue+0xaa>
    1948:	01 11       	cpse	r16, r1
    194a:	16 c0       	rjmp	.+44     	; 0x1978 <prvCopyDataToQueue+0x5a>
    194c:	50 e0       	ldi	r21, 0x00	; 0
    194e:	8c 81       	ldd	r24, Y+4	; 0x04
    1950:	9d 81       	ldd	r25, Y+5	; 0x05
    1952:	5a d7       	rcall	.+3764   	; 0x2808 <memcpy>
    1954:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1956:	8c 81       	ldd	r24, Y+4	; 0x04
    1958:	9d 81       	ldd	r25, Y+5	; 0x05
    195a:	82 0f       	add	r24, r18
    195c:	91 1d       	adc	r25, r1
    195e:	9d 83       	std	Y+5, r25	; 0x05
    1960:	8c 83       	std	Y+4, r24	; 0x04
    1962:	2a 81       	ldd	r18, Y+2	; 0x02
    1964:	3b 81       	ldd	r19, Y+3	; 0x03
    1966:	82 17       	cp	r24, r18
    1968:	93 07       	cpc	r25, r19
    196a:	48 f1       	brcs	.+82     	; 0x19be <prvCopyDataToQueue+0xa0>
    196c:	88 81       	ld	r24, Y
    196e:	99 81       	ldd	r25, Y+1	; 0x01
    1970:	9d 83       	std	Y+5, r25	; 0x05
    1972:	8c 83       	std	Y+4, r24	; 0x04
    1974:	80 e0       	ldi	r24, 0x00	; 0
    1976:	28 c0       	rjmp	.+80     	; 0x19c8 <prvCopyDataToQueue+0xaa>
    1978:	50 e0       	ldi	r21, 0x00	; 0
    197a:	8e 81       	ldd	r24, Y+6	; 0x06
    197c:	9f 81       	ldd	r25, Y+7	; 0x07
    197e:	44 d7       	rcall	.+3720   	; 0x2808 <memcpy>
    1980:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	91 95       	neg	r25
    1986:	81 95       	neg	r24
    1988:	91 09       	sbc	r25, r1
    198a:	2e 81       	ldd	r18, Y+6	; 0x06
    198c:	3f 81       	ldd	r19, Y+7	; 0x07
    198e:	28 0f       	add	r18, r24
    1990:	39 1f       	adc	r19, r25
    1992:	3f 83       	std	Y+7, r19	; 0x07
    1994:	2e 83       	std	Y+6, r18	; 0x06
    1996:	48 81       	ld	r20, Y
    1998:	59 81       	ldd	r21, Y+1	; 0x01
    199a:	24 17       	cp	r18, r20
    199c:	35 07       	cpc	r19, r21
    199e:	30 f4       	brcc	.+12     	; 0x19ac <prvCopyDataToQueue+0x8e>
    19a0:	2a 81       	ldd	r18, Y+2	; 0x02
    19a2:	3b 81       	ldd	r19, Y+3	; 0x03
    19a4:	82 0f       	add	r24, r18
    19a6:	93 1f       	adc	r25, r19
    19a8:	9f 83       	std	Y+7, r25	; 0x07
    19aa:	8e 83       	std	Y+6, r24	; 0x06
    19ac:	02 30       	cpi	r16, 0x02	; 2
    19ae:	49 f4       	brne	.+18     	; 0x19c2 <prvCopyDataToQueue+0xa4>
    19b0:	11 23       	and	r17, r17
    19b2:	49 f0       	breq	.+18     	; 0x19c6 <prvCopyDataToQueue+0xa8>
    19b4:	11 50       	subi	r17, 0x01	; 1
    19b6:	80 e0       	ldi	r24, 0x00	; 0
    19b8:	07 c0       	rjmp	.+14     	; 0x19c8 <prvCopyDataToQueue+0xaa>
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	05 c0       	rjmp	.+10     	; 0x19c8 <prvCopyDataToQueue+0xaa>
    19be:	80 e0       	ldi	r24, 0x00	; 0
    19c0:	03 c0       	rjmp	.+6      	; 0x19c8 <prvCopyDataToQueue+0xaa>
    19c2:	80 e0       	ldi	r24, 0x00	; 0
    19c4:	01 c0       	rjmp	.+2      	; 0x19c8 <prvCopyDataToQueue+0xaa>
    19c6:	80 e0       	ldi	r24, 0x00	; 0
    19c8:	1f 5f       	subi	r17, 0xFF	; 255
    19ca:	1a 8f       	std	Y+26, r17	; 0x1a
    19cc:	df 91       	pop	r29
    19ce:	cf 91       	pop	r28
    19d0:	1f 91       	pop	r17
    19d2:	0f 91       	pop	r16
    19d4:	08 95       	ret

000019d6 <prvCopyDataFromQueue>:
    19d6:	fc 01       	movw	r30, r24
    19d8:	44 8d       	ldd	r20, Z+28	; 0x1c
    19da:	44 23       	and	r20, r20
    19dc:	a1 f0       	breq	.+40     	; 0x1a06 <prvCopyDataFromQueue+0x30>
    19de:	50 e0       	ldi	r21, 0x00	; 0
    19e0:	26 81       	ldd	r18, Z+6	; 0x06
    19e2:	37 81       	ldd	r19, Z+7	; 0x07
    19e4:	24 0f       	add	r18, r20
    19e6:	35 1f       	adc	r19, r21
    19e8:	37 83       	std	Z+7, r19	; 0x07
    19ea:	26 83       	std	Z+6, r18	; 0x06
    19ec:	82 81       	ldd	r24, Z+2	; 0x02
    19ee:	93 81       	ldd	r25, Z+3	; 0x03
    19f0:	28 17       	cp	r18, r24
    19f2:	39 07       	cpc	r19, r25
    19f4:	20 f0       	brcs	.+8      	; 0x19fe <prvCopyDataFromQueue+0x28>
    19f6:	80 81       	ld	r24, Z
    19f8:	91 81       	ldd	r25, Z+1	; 0x01
    19fa:	97 83       	std	Z+7, r25	; 0x07
    19fc:	86 83       	std	Z+6, r24	; 0x06
    19fe:	cb 01       	movw	r24, r22
    1a00:	66 81       	ldd	r22, Z+6	; 0x06
    1a02:	77 81       	ldd	r23, Z+7	; 0x07
    1a04:	01 c7       	rjmp	.+3586   	; 0x2808 <memcpy>
    1a06:	08 95       	ret

00001a08 <prvUnlockQueue>:
    1a08:	ef 92       	push	r14
    1a0a:	ff 92       	push	r15
    1a0c:	0f 93       	push	r16
    1a0e:	1f 93       	push	r17
    1a10:	cf 93       	push	r28
    1a12:	8c 01       	movw	r16, r24
    1a14:	0f b6       	in	r0, 0x3f	; 63
    1a16:	f8 94       	cli
    1a18:	0f 92       	push	r0
    1a1a:	fc 01       	movw	r30, r24
    1a1c:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1a1e:	1c 16       	cp	r1, r28
    1a20:	9c f4       	brge	.+38     	; 0x1a48 <prvUnlockQueue+0x40>
    1a22:	81 89       	ldd	r24, Z+17	; 0x11
    1a24:	81 11       	cpse	r24, r1
    1a26:	06 c0       	rjmp	.+12     	; 0x1a34 <prvUnlockQueue+0x2c>
    1a28:	0f c0       	rjmp	.+30     	; 0x1a48 <prvUnlockQueue+0x40>
    1a2a:	f8 01       	movw	r30, r16
    1a2c:	81 89       	ldd	r24, Z+17	; 0x11
    1a2e:	81 11       	cpse	r24, r1
    1a30:	05 c0       	rjmp	.+10     	; 0x1a3c <prvUnlockQueue+0x34>
    1a32:	0a c0       	rjmp	.+20     	; 0x1a48 <prvUnlockQueue+0x40>
    1a34:	78 01       	movw	r14, r16
    1a36:	f1 e1       	ldi	r31, 0x11	; 17
    1a38:	ef 0e       	add	r14, r31
    1a3a:	f1 1c       	adc	r15, r1
    1a3c:	c7 01       	movw	r24, r14
    1a3e:	9a d5       	rcall	.+2868   	; 0x2574 <xTaskRemoveFromEventList>
    1a40:	81 11       	cpse	r24, r1
    1a42:	21 d6       	rcall	.+3138   	; 0x2686 <vTaskMissedYield>
    1a44:	c1 50       	subi	r28, 0x01	; 1
    1a46:	89 f7       	brne	.-30     	; 0x1a2a <prvUnlockQueue+0x22>
    1a48:	8f ef       	ldi	r24, 0xFF	; 255
    1a4a:	f8 01       	movw	r30, r16
    1a4c:	86 8f       	std	Z+30, r24	; 0x1e
    1a4e:	0f 90       	pop	r0
    1a50:	0f be       	out	0x3f, r0	; 63
    1a52:	0f b6       	in	r0, 0x3f	; 63
    1a54:	f8 94       	cli
    1a56:	0f 92       	push	r0
    1a58:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1a5a:	1c 16       	cp	r1, r28
    1a5c:	9c f4       	brge	.+38     	; 0x1a84 <prvUnlockQueue+0x7c>
    1a5e:	80 85       	ldd	r24, Z+8	; 0x08
    1a60:	81 11       	cpse	r24, r1
    1a62:	06 c0       	rjmp	.+12     	; 0x1a70 <prvUnlockQueue+0x68>
    1a64:	0f c0       	rjmp	.+30     	; 0x1a84 <prvUnlockQueue+0x7c>
    1a66:	f8 01       	movw	r30, r16
    1a68:	80 85       	ldd	r24, Z+8	; 0x08
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	05 c0       	rjmp	.+10     	; 0x1a78 <prvUnlockQueue+0x70>
    1a6e:	0a c0       	rjmp	.+20     	; 0x1a84 <prvUnlockQueue+0x7c>
    1a70:	78 01       	movw	r14, r16
    1a72:	f8 e0       	ldi	r31, 0x08	; 8
    1a74:	ef 0e       	add	r14, r31
    1a76:	f1 1c       	adc	r15, r1
    1a78:	c7 01       	movw	r24, r14
    1a7a:	7c d5       	rcall	.+2808   	; 0x2574 <xTaskRemoveFromEventList>
    1a7c:	81 11       	cpse	r24, r1
    1a7e:	03 d6       	rcall	.+3078   	; 0x2686 <vTaskMissedYield>
    1a80:	c1 50       	subi	r28, 0x01	; 1
    1a82:	89 f7       	brne	.-30     	; 0x1a66 <prvUnlockQueue+0x5e>
    1a84:	8f ef       	ldi	r24, 0xFF	; 255
    1a86:	f8 01       	movw	r30, r16
    1a88:	85 8f       	std	Z+29, r24	; 0x1d
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	cf 91       	pop	r28
    1a90:	1f 91       	pop	r17
    1a92:	0f 91       	pop	r16
    1a94:	ff 90       	pop	r15
    1a96:	ef 90       	pop	r14
    1a98:	08 95       	ret

00001a9a <xQueueGenericReset>:
    1a9a:	cf 93       	push	r28
    1a9c:	df 93       	push	r29
    1a9e:	ec 01       	movw	r28, r24
    1aa0:	0f b6       	in	r0, 0x3f	; 63
    1aa2:	f8 94       	cli
    1aa4:	0f 92       	push	r0
    1aa6:	48 81       	ld	r20, Y
    1aa8:	59 81       	ldd	r21, Y+1	; 0x01
    1aaa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1ab0:	72 9f       	mul	r23, r18
    1ab2:	c0 01       	movw	r24, r0
    1ab4:	73 9f       	mul	r23, r19
    1ab6:	90 0d       	add	r25, r0
    1ab8:	11 24       	eor	r1, r1
    1aba:	fa 01       	movw	r30, r20
    1abc:	e8 0f       	add	r30, r24
    1abe:	f9 1f       	adc	r31, r25
    1ac0:	fb 83       	std	Y+3, r31	; 0x03
    1ac2:	ea 83       	std	Y+2, r30	; 0x02
    1ac4:	1a 8e       	std	Y+26, r1	; 0x1a
    1ac6:	5d 83       	std	Y+5, r21	; 0x05
    1ac8:	4c 83       	std	Y+4, r20	; 0x04
    1aca:	82 1b       	sub	r24, r18
    1acc:	93 0b       	sbc	r25, r19
    1ace:	84 0f       	add	r24, r20
    1ad0:	95 1f       	adc	r25, r21
    1ad2:	9f 83       	std	Y+7, r25	; 0x07
    1ad4:	8e 83       	std	Y+6, r24	; 0x06
    1ad6:	8f ef       	ldi	r24, 0xFF	; 255
    1ad8:	8d 8f       	std	Y+29, r24	; 0x1d
    1ada:	8e 8f       	std	Y+30, r24	; 0x1e
    1adc:	61 11       	cpse	r22, r1
    1ade:	0a c0       	rjmp	.+20     	; 0x1af4 <xQueueGenericReset+0x5a>
    1ae0:	88 85       	ldd	r24, Y+8	; 0x08
    1ae2:	88 23       	and	r24, r24
    1ae4:	69 f0       	breq	.+26     	; 0x1b00 <xQueueGenericReset+0x66>
    1ae6:	ce 01       	movw	r24, r28
    1ae8:	08 96       	adiw	r24, 0x08	; 8
    1aea:	44 d5       	rcall	.+2696   	; 0x2574 <xTaskRemoveFromEventList>
    1aec:	88 23       	and	r24, r24
    1aee:	41 f0       	breq	.+16     	; 0x1b00 <xQueueGenericReset+0x66>
    1af0:	62 de       	rcall	.-828    	; 0x17b6 <vPortYield>
    1af2:	06 c0       	rjmp	.+12     	; 0x1b00 <xQueueGenericReset+0x66>
    1af4:	ce 01       	movw	r24, r28
    1af6:	08 96       	adiw	r24, 0x08	; 8
    1af8:	33 dd       	rcall	.-1434   	; 0x1560 <vListInitialise>
    1afa:	ce 01       	movw	r24, r28
    1afc:	41 96       	adiw	r24, 0x11	; 17
    1afe:	30 dd       	rcall	.-1440   	; 0x1560 <vListInitialise>
    1b00:	0f 90       	pop	r0
    1b02:	0f be       	out	0x3f, r0	; 63
    1b04:	81 e0       	ldi	r24, 0x01	; 1
    1b06:	df 91       	pop	r29
    1b08:	cf 91       	pop	r28
    1b0a:	08 95       	ret

00001b0c <xQueueGenericCreate>:
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	08 2f       	mov	r16, r24
    1b16:	16 2f       	mov	r17, r22
    1b18:	66 23       	and	r22, r22
    1b1a:	b1 f0       	breq	.+44     	; 0x1b48 <xQueueGenericCreate+0x3c>
    1b1c:	86 9f       	mul	r24, r22
    1b1e:	c0 01       	movw	r24, r0
    1b20:	11 24       	eor	r1, r1
    1b22:	4f 96       	adiw	r24, 0x1f	; 31
    1b24:	e9 dc       	rcall	.-1582   	; 0x14f8 <pvPortMalloc>
    1b26:	ec 01       	movw	r28, r24
    1b28:	00 97       	sbiw	r24, 0x00	; 0
    1b2a:	39 f4       	brne	.+14     	; 0x1b3a <xQueueGenericCreate+0x2e>
    1b2c:	13 c0       	rjmp	.+38     	; 0x1b54 <xQueueGenericCreate+0x48>
    1b2e:	0b 8f       	std	Y+27, r16	; 0x1b
    1b30:	1c 8f       	std	Y+28, r17	; 0x1c
    1b32:	61 e0       	ldi	r22, 0x01	; 1
    1b34:	ce 01       	movw	r24, r28
    1b36:	b1 df       	rcall	.-158    	; 0x1a9a <xQueueGenericReset>
    1b38:	0d c0       	rjmp	.+26     	; 0x1b54 <xQueueGenericCreate+0x48>
    1b3a:	4f 96       	adiw	r24, 0x1f	; 31
    1b3c:	99 83       	std	Y+1, r25	; 0x01
    1b3e:	88 83       	st	Y, r24
    1b40:	f6 cf       	rjmp	.-20     	; 0x1b2e <xQueueGenericCreate+0x22>
    1b42:	d9 83       	std	Y+1, r29	; 0x01
    1b44:	c8 83       	st	Y, r28
    1b46:	f3 cf       	rjmp	.-26     	; 0x1b2e <xQueueGenericCreate+0x22>
    1b48:	8f e1       	ldi	r24, 0x1F	; 31
    1b4a:	90 e0       	ldi	r25, 0x00	; 0
    1b4c:	d5 dc       	rcall	.-1622   	; 0x14f8 <pvPortMalloc>
    1b4e:	ec 01       	movw	r28, r24
    1b50:	89 2b       	or	r24, r25
    1b52:	b9 f7       	brne	.-18     	; 0x1b42 <xQueueGenericCreate+0x36>
    1b54:	ce 01       	movw	r24, r28
    1b56:	df 91       	pop	r29
    1b58:	cf 91       	pop	r28
    1b5a:	1f 91       	pop	r17
    1b5c:	0f 91       	pop	r16
    1b5e:	08 95       	ret

00001b60 <xQueueGenericSend>:
    1b60:	9f 92       	push	r9
    1b62:	af 92       	push	r10
    1b64:	bf 92       	push	r11
    1b66:	cf 92       	push	r12
    1b68:	df 92       	push	r13
    1b6a:	ef 92       	push	r14
    1b6c:	ff 92       	push	r15
    1b6e:	0f 93       	push	r16
    1b70:	1f 93       	push	r17
    1b72:	cf 93       	push	r28
    1b74:	df 93       	push	r29
    1b76:	00 d0       	rcall	.+0      	; 0x1b78 <xQueueGenericSend+0x18>
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <xQueueGenericSend+0x1a>
    1b7a:	1f 92       	push	r1
    1b7c:	cd b7       	in	r28, 0x3d	; 61
    1b7e:	de b7       	in	r29, 0x3e	; 62
    1b80:	8c 01       	movw	r16, r24
    1b82:	6b 01       	movw	r12, r22
    1b84:	5d 83       	std	Y+5, r21	; 0x05
    1b86:	4c 83       	std	Y+4, r20	; 0x04
    1b88:	a2 2e       	mov	r10, r18
    1b8a:	b1 2c       	mov	r11, r1
    1b8c:	99 24       	eor	r9, r9
    1b8e:	93 94       	inc	r9
    1b90:	7c 01       	movw	r14, r24
    1b92:	88 e0       	ldi	r24, 0x08	; 8
    1b94:	e8 0e       	add	r14, r24
    1b96:	f1 1c       	adc	r15, r1
    1b98:	0f b6       	in	r0, 0x3f	; 63
    1b9a:	f8 94       	cli
    1b9c:	0f 92       	push	r0
    1b9e:	f8 01       	movw	r30, r16
    1ba0:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ba2:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ba4:	98 17       	cp	r25, r24
    1ba6:	18 f0       	brcs	.+6      	; 0x1bae <xQueueGenericSend+0x4e>
    1ba8:	f2 e0       	ldi	r31, 0x02	; 2
    1baa:	af 12       	cpse	r10, r31
    1bac:	15 c0       	rjmp	.+42     	; 0x1bd8 <xQueueGenericSend+0x78>
    1bae:	4a 2d       	mov	r20, r10
    1bb0:	b6 01       	movw	r22, r12
    1bb2:	c8 01       	movw	r24, r16
    1bb4:	b4 de       	rcall	.-664    	; 0x191e <prvCopyDataToQueue>
    1bb6:	f8 01       	movw	r30, r16
    1bb8:	91 89       	ldd	r25, Z+17	; 0x11
    1bba:	99 23       	and	r25, r25
    1bbc:	39 f0       	breq	.+14     	; 0x1bcc <xQueueGenericSend+0x6c>
    1bbe:	c8 01       	movw	r24, r16
    1bc0:	41 96       	adiw	r24, 0x11	; 17
    1bc2:	d8 d4       	rcall	.+2480   	; 0x2574 <xTaskRemoveFromEventList>
    1bc4:	88 23       	and	r24, r24
    1bc6:	21 f0       	breq	.+8      	; 0x1bd0 <xQueueGenericSend+0x70>
    1bc8:	f6 dd       	rcall	.-1044   	; 0x17b6 <vPortYield>
    1bca:	02 c0       	rjmp	.+4      	; 0x1bd0 <xQueueGenericSend+0x70>
    1bcc:	81 11       	cpse	r24, r1
    1bce:	f3 dd       	rcall	.-1050   	; 0x17b6 <vPortYield>
    1bd0:	0f 90       	pop	r0
    1bd2:	0f be       	out	0x3f, r0	; 63
    1bd4:	81 e0       	ldi	r24, 0x01	; 1
    1bd6:	45 c0       	rjmp	.+138    	; 0x1c62 <xQueueGenericSend+0x102>
    1bd8:	8c 81       	ldd	r24, Y+4	; 0x04
    1bda:	9d 81       	ldd	r25, Y+5	; 0x05
    1bdc:	89 2b       	or	r24, r25
    1bde:	21 f4       	brne	.+8      	; 0x1be8 <xQueueGenericSend+0x88>
    1be0:	0f 90       	pop	r0
    1be2:	0f be       	out	0x3f, r0	; 63
    1be4:	80 e0       	ldi	r24, 0x00	; 0
    1be6:	3d c0       	rjmp	.+122    	; 0x1c62 <xQueueGenericSend+0x102>
    1be8:	b1 10       	cpse	r11, r1
    1bea:	04 c0       	rjmp	.+8      	; 0x1bf4 <xQueueGenericSend+0x94>
    1bec:	ce 01       	movw	r24, r28
    1bee:	01 96       	adiw	r24, 0x01	; 1
    1bf0:	07 d5       	rcall	.+2574   	; 0x2600 <vTaskSetTimeOutState>
    1bf2:	b9 2c       	mov	r11, r9
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	b0 d2       	rcall	.+1376   	; 0x215a <vTaskSuspendAll>
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	0f 92       	push	r0
    1c00:	f8 01       	movw	r30, r16
    1c02:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c04:	8f 3f       	cpi	r24, 0xFF	; 255
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <xQueueGenericSend+0xaa>
    1c08:	15 8e       	std	Z+29, r1	; 0x1d
    1c0a:	f8 01       	movw	r30, r16
    1c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c10:	09 f4       	brne	.+2      	; 0x1c14 <xQueueGenericSend+0xb4>
    1c12:	16 8e       	std	Z+30, r1	; 0x1e
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
    1c18:	be 01       	movw	r22, r28
    1c1a:	6c 5f       	subi	r22, 0xFC	; 252
    1c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1e:	ce 01       	movw	r24, r28
    1c20:	01 96       	adiw	r24, 0x01	; 1
    1c22:	f9 d4       	rcall	.+2546   	; 0x2616 <xTaskCheckForTimeOut>
    1c24:	81 11       	cpse	r24, r1
    1c26:	19 c0       	rjmp	.+50     	; 0x1c5a <xQueueGenericSend+0xfa>
    1c28:	0f b6       	in	r0, 0x3f	; 63
    1c2a:	f8 94       	cli
    1c2c:	0f 92       	push	r0
    1c2e:	f8 01       	movw	r30, r16
    1c30:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c32:	0f 90       	pop	r0
    1c34:	0f be       	out	0x3f, r0	; 63
    1c36:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c38:	98 13       	cpse	r25, r24
    1c3a:	0b c0       	rjmp	.+22     	; 0x1c52 <xQueueGenericSend+0xf2>
    1c3c:	6c 81       	ldd	r22, Y+4	; 0x04
    1c3e:	7d 81       	ldd	r23, Y+5	; 0x05
    1c40:	c7 01       	movw	r24, r14
    1c42:	88 d4       	rcall	.+2320   	; 0x2554 <vTaskPlaceOnEventList>
    1c44:	c8 01       	movw	r24, r16
    1c46:	e0 de       	rcall	.-576    	; 0x1a08 <prvUnlockQueue>
    1c48:	45 d3       	rcall	.+1674   	; 0x22d4 <xTaskResumeAll>
    1c4a:	81 11       	cpse	r24, r1
    1c4c:	a5 cf       	rjmp	.-182    	; 0x1b98 <xQueueGenericSend+0x38>
    1c4e:	b3 dd       	rcall	.-1178   	; 0x17b6 <vPortYield>
    1c50:	a3 cf       	rjmp	.-186    	; 0x1b98 <xQueueGenericSend+0x38>
    1c52:	c8 01       	movw	r24, r16
    1c54:	d9 de       	rcall	.-590    	; 0x1a08 <prvUnlockQueue>
    1c56:	3e d3       	rcall	.+1660   	; 0x22d4 <xTaskResumeAll>
    1c58:	9f cf       	rjmp	.-194    	; 0x1b98 <xQueueGenericSend+0x38>
    1c5a:	c8 01       	movw	r24, r16
    1c5c:	d5 de       	rcall	.-598    	; 0x1a08 <prvUnlockQueue>
    1c5e:	3a d3       	rcall	.+1652   	; 0x22d4 <xTaskResumeAll>
    1c60:	80 e0       	ldi	r24, 0x00	; 0
    1c62:	0f 90       	pop	r0
    1c64:	0f 90       	pop	r0
    1c66:	0f 90       	pop	r0
    1c68:	0f 90       	pop	r0
    1c6a:	0f 90       	pop	r0
    1c6c:	df 91       	pop	r29
    1c6e:	cf 91       	pop	r28
    1c70:	1f 91       	pop	r17
    1c72:	0f 91       	pop	r16
    1c74:	ff 90       	pop	r15
    1c76:	ef 90       	pop	r14
    1c78:	df 90       	pop	r13
    1c7a:	cf 90       	pop	r12
    1c7c:	bf 90       	pop	r11
    1c7e:	af 90       	pop	r10
    1c80:	9f 90       	pop	r9
    1c82:	08 95       	ret

00001c84 <xQueueCreateMutex>:
    1c84:	cf 93       	push	r28
    1c86:	df 93       	push	r29
    1c88:	48 2f       	mov	r20, r24
    1c8a:	60 e0       	ldi	r22, 0x00	; 0
    1c8c:	81 e0       	ldi	r24, 0x01	; 1
    1c8e:	3e df       	rcall	.-388    	; 0x1b0c <xQueueGenericCreate>
    1c90:	ec 01       	movw	r28, r24
    1c92:	00 97       	sbiw	r24, 0x00	; 0
    1c94:	59 f0       	breq	.+22     	; 0x1cac <xQueueCreateMutex+0x28>
    1c96:	1b 82       	std	Y+3, r1	; 0x03
    1c98:	1a 82       	std	Y+2, r1	; 0x02
    1c9a:	19 82       	std	Y+1, r1	; 0x01
    1c9c:	18 82       	st	Y, r1
    1c9e:	1e 82       	std	Y+6, r1	; 0x06
    1ca0:	20 e0       	ldi	r18, 0x00	; 0
    1ca2:	40 e0       	ldi	r20, 0x00	; 0
    1ca4:	50 e0       	ldi	r21, 0x00	; 0
    1ca6:	60 e0       	ldi	r22, 0x00	; 0
    1ca8:	70 e0       	ldi	r23, 0x00	; 0
    1caa:	5a df       	rcall	.-332    	; 0x1b60 <xQueueGenericSend>
    1cac:	ce 01       	movw	r24, r28
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	08 95       	ret

00001cb4 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1cb4:	8f 92       	push	r8
    1cb6:	9f 92       	push	r9
    1cb8:	af 92       	push	r10
    1cba:	bf 92       	push	r11
    1cbc:	cf 92       	push	r12
    1cbe:	df 92       	push	r13
    1cc0:	ef 92       	push	r14
    1cc2:	ff 92       	push	r15
    1cc4:	0f 93       	push	r16
    1cc6:	1f 93       	push	r17
    1cc8:	cf 93       	push	r28
    1cca:	df 93       	push	r29
    1ccc:	00 d0       	rcall	.+0      	; 0x1cce <xQueueGenericReceive+0x1a>
    1cce:	00 d0       	rcall	.+0      	; 0x1cd0 <xQueueGenericReceive+0x1c>
    1cd0:	1f 92       	push	r1
    1cd2:	cd b7       	in	r28, 0x3d	; 61
    1cd4:	de b7       	in	r29, 0x3e	; 62
    1cd6:	8c 01       	movw	r16, r24
    1cd8:	5b 01       	movw	r10, r22
    1cda:	5d 83       	std	Y+5, r21	; 0x05
    1cdc:	4c 83       	std	Y+4, r20	; 0x04
    1cde:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1ce0:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ce2:	99 24       	eor	r9, r9
    1ce4:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1ce6:	6c 01       	movw	r12, r24
    1ce8:	81 e1       	ldi	r24, 0x11	; 17
    1cea:	c8 0e       	add	r12, r24
    1cec:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1cee:	0f b6       	in	r0, 0x3f	; 63
    1cf0:	f8 94       	cli
    1cf2:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1cf4:	f8 01       	movw	r30, r16
    1cf6:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1cf8:	ff 20       	and	r15, r15
    1cfa:	61 f1       	breq	.+88     	; 0x1d54 <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1cfc:	c6 80       	ldd	r12, Z+6	; 0x06
    1cfe:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1d00:	b5 01       	movw	r22, r10
    1d02:	c8 01       	movw	r24, r16
    1d04:	68 de       	rcall	.-816    	; 0x19d6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1d06:	81 10       	cpse	r8, r1
    1d08:	16 c0       	rjmp	.+44     	; 0x1d36 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    1d0a:	fa 94       	dec	r15
    1d0c:	f8 01       	movw	r30, r16
    1d0e:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1d10:	80 81       	ld	r24, Z
    1d12:	91 81       	ldd	r25, Z+1	; 0x01
    1d14:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1d16:	21 f4       	brne	.+8      	; 0x1d20 <xQueueGenericReceive+0x6c>
    1d18:	5c d5       	rcall	.+2744   	; 0x27d2 <pvTaskIncrementMutexHeldCount>
    1d1a:	f8 01       	movw	r30, r16
    1d1c:	93 83       	std	Z+3, r25	; 0x03
    1d1e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1d20:	f8 01       	movw	r30, r16
    1d22:	80 85       	ldd	r24, Z+8	; 0x08
    1d24:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1d26:	91 f0       	breq	.+36     	; 0x1d4c <xQueueGenericReceive+0x98>
    1d28:	c8 01       	movw	r24, r16
    1d2a:	08 96       	adiw	r24, 0x08	; 8
    1d2c:	23 d4       	rcall	.+2118   	; 0x2574 <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1d2e:	88 23       	and	r24, r24
    1d30:	69 f0       	breq	.+26     	; 0x1d4c <xQueueGenericReceive+0x98>
    1d32:	41 dd       	rcall	.-1406   	; 0x17b6 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1d34:	0b c0       	rjmp	.+22     	; 0x1d4c <xQueueGenericReceive+0x98>
    1d36:	f8 01       	movw	r30, r16
    1d38:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d3a:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1d3c:	81 89       	ldd	r24, Z+17	; 0x11
    1d3e:	88 23       	and	r24, r24
    1d40:	29 f0       	breq	.+10     	; 0x1d4c <xQueueGenericReceive+0x98>
    1d42:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1d44:	41 96       	adiw	r24, 0x11	; 17
    1d46:	16 d4       	rcall	.+2092   	; 0x2574 <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1d48:	81 11       	cpse	r24, r1
    1d4a:	35 dd       	rcall	.-1430   	; 0x17b6 <vPortYield>
				return pdPASS;
    1d4c:	0f 90       	pop	r0
    1d4e:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1d50:	81 e0       	ldi	r24, 0x01	; 1
    1d52:	58 c0       	rjmp	.+176    	; 0x1e04 <xQueueGenericReceive+0x150>
    1d54:	8c 81       	ldd	r24, Y+4	; 0x04
    1d56:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1d58:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1d5a:	21 f4       	brne	.+8      	; 0x1d64 <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    1d5c:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1d5e:	0f be       	out	0x3f, r0	; 63
    1d60:	80 e0       	ldi	r24, 0x00	; 0
    1d62:	50 c0       	rjmp	.+160    	; 0x1e04 <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    1d64:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1d66:	04 c0       	rjmp	.+8      	; 0x1d70 <xQueueGenericReceive+0xbc>
    1d68:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1d6a:	01 96       	adiw	r24, 0x01	; 1
    1d6c:	49 d4       	rcall	.+2194   	; 0x2600 <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    1d6e:	e9 2c       	mov	r14, r9
    1d70:	0f 90       	pop	r0
    1d72:	0f be       	out	0x3f, r0	; 63
    1d74:	f2 d1       	rcall	.+996    	; 0x215a <vTaskSuspendAll>
    1d76:	0f b6       	in	r0, 0x3f	; 63
    1d78:	f8 94       	cli
    1d7a:	0f 92       	push	r0
    1d7c:	f8 01       	movw	r30, r16
    1d7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d80:	8f 3f       	cpi	r24, 0xFF	; 255
    1d82:	09 f4       	brne	.+2      	; 0x1d86 <xQueueGenericReceive+0xd2>
    1d84:	15 8e       	std	Z+29, r1	; 0x1d
    1d86:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1d88:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <xQueueGenericReceive+0xdc>
    1d8e:	16 8e       	std	Z+30, r1	; 0x1e
    1d90:	0f 90       	pop	r0
    1d92:	0f be       	out	0x3f, r0	; 63
    1d94:	be 01       	movw	r22, r28
    1d96:	6c 5f       	subi	r22, 0xFC	; 252
    1d98:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1d9a:	ce 01       	movw	r24, r28
    1d9c:	01 96       	adiw	r24, 0x01	; 1
    1d9e:	3b d4       	rcall	.+2166   	; 0x2616 <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1da0:	81 11       	cpse	r24, r1
    1da2:	24 c0       	rjmp	.+72     	; 0x1dec <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1da8:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1daa:	f8 01       	movw	r30, r16
    1dac:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dae:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    1db0:	0f be       	out	0x3f, r0	; 63
    1db2:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1db4:	17 c0       	rjmp	.+46     	; 0x1de4 <xQueueGenericReceive+0x130>
    1db6:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    1db8:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1dba:	89 2b       	or	r24, r25
    1dbc:	41 f4       	brne	.+16     	; 0x1dce <xQueueGenericReceive+0x11a>
    1dbe:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    1dc0:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    1dc2:	0f 92       	push	r0
    1dc4:	82 81       	ldd	r24, Z+2	; 0x02
    1dc6:	93 81       	ldd	r25, Z+3	; 0x03
    1dc8:	62 d4       	rcall	.+2244   	; 0x268e <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    1dca:	0f 90       	pop	r0
    1dcc:	0f be       	out	0x3f, r0	; 63
    1dce:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1dd0:	7d 81       	ldd	r23, Y+5	; 0x05
    1dd2:	c6 01       	movw	r24, r12
    1dd4:	bf d3       	rcall	.+1918   	; 0x2554 <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    1dd6:	c8 01       	movw	r24, r16
    1dd8:	17 de       	rcall	.-978    	; 0x1a08 <prvUnlockQueue>
    1dda:	7c d2       	rcall	.+1272   	; 0x22d4 <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1ddc:	81 11       	cpse	r24, r1
    1dde:	87 cf       	rjmp	.-242    	; 0x1cee <xQueueGenericReceive+0x3a>
    1de0:	ea dc       	rcall	.-1580   	; 0x17b6 <vPortYield>
			( void ) xTaskResumeAll();
    1de2:	85 cf       	rjmp	.-246    	; 0x1cee <xQueueGenericReceive+0x3a>
    1de4:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1de6:	10 de       	rcall	.-992    	; 0x1a08 <prvUnlockQueue>
    1de8:	75 d2       	rcall	.+1258   	; 0x22d4 <xTaskResumeAll>
    1dea:	81 cf       	rjmp	.-254    	; 0x1cee <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1dec:	c8 01       	movw	r24, r16
    1dee:	0c de       	rcall	.-1000   	; 0x1a08 <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1df0:	71 d2       	rcall	.+1250   	; 0x22d4 <xTaskResumeAll>
    1df2:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1df4:	f8 94       	cli
    1df6:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    1df8:	f8 01       	movw	r30, r16
    1dfa:	82 8d       	ldd	r24, Z+26	; 0x1a
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63
    1e00:	81 11       	cpse	r24, r1
    1e02:	75 cf       	rjmp	.-278    	; 0x1cee <xQueueGenericReceive+0x3a>
    1e04:	0f 90       	pop	r0
    1e06:	0f 90       	pop	r0
    1e08:	0f 90       	pop	r0
    1e0a:	0f 90       	pop	r0
    1e0c:	0f 90       	pop	r0
    1e0e:	df 91       	pop	r29
    1e10:	cf 91       	pop	r28
    1e12:	1f 91       	pop	r17
    1e14:	0f 91       	pop	r16
    1e16:	ff 90       	pop	r15
    1e18:	ef 90       	pop	r14
    1e1a:	df 90       	pop	r13
    1e1c:	cf 90       	pop	r12
    1e1e:	bf 90       	pop	r11
    1e20:	af 90       	pop	r10
    1e22:	9f 90       	pop	r9
    1e24:	8f 90       	pop	r8
    1e26:	08 95       	ret

00001e28 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    1e28:	e0 91 2f 0d 	lds	r30, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    1e2c:	f0 91 30 0d 	lds	r31, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    1e30:	80 81       	ld	r24, Z
    1e32:	81 11       	cpse	r24, r1
    1e34:	07 c0       	rjmp	.+14     	; 0x1e44 <prvResetNextTaskUnblockTime+0x1c>
    1e36:	8f ef       	ldi	r24, 0xFF	; 255
    1e38:	9f ef       	ldi	r25, 0xFF	; 255
    1e3a:	90 93 07 0d 	sts	0x0D07, r25	; 0x800d07 <xNextTaskUnblockTime+0x1>
    1e3e:	80 93 06 0d 	sts	0x0D06, r24	; 0x800d06 <xNextTaskUnblockTime>
    1e42:	08 95       	ret
    1e44:	e0 91 2f 0d 	lds	r30, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    1e48:	f0 91 30 0d 	lds	r31, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    1e4c:	05 80       	ldd	r0, Z+5	; 0x05
    1e4e:	f6 81       	ldd	r31, Z+6	; 0x06
    1e50:	e0 2d       	mov	r30, r0
    1e52:	06 80       	ldd	r0, Z+6	; 0x06
    1e54:	f7 81       	ldd	r31, Z+7	; 0x07
    1e56:	e0 2d       	mov	r30, r0
    1e58:	82 81       	ldd	r24, Z+2	; 0x02
    1e5a:	93 81       	ldd	r25, Z+3	; 0x03
    1e5c:	90 93 07 0d 	sts	0x0D07, r25	; 0x800d07 <xNextTaskUnblockTime+0x1>
    1e60:	80 93 06 0d 	sts	0x0D06, r24	; 0x800d06 <xNextTaskUnblockTime>
    1e64:	08 95       	ret

00001e66 <prvAddCurrentTaskToDelayedList>:
    1e66:	ff 92       	push	r15
    1e68:	0f 93       	push	r16
    1e6a:	1f 93       	push	r17
    1e6c:	cf 93       	push	r28
    1e6e:	df 93       	push	r29
    1e70:	ec 01       	movw	r28, r24
    1e72:	f6 2e       	mov	r15, r22
    1e74:	00 91 0e 0d 	lds	r16, 0x0D0E	; 0x800d0e <xTickCount>
    1e78:	10 91 0f 0d 	lds	r17, 0x0D0F	; 0x800d0f <xTickCount+0x1>
    1e7c:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1e80:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1e84:	02 96       	adiw	r24, 0x02	; 2
    1e86:	d0 db       	rcall	.-2144   	; 0x1628 <uxListRemove>
    1e88:	cf 3f       	cpi	r28, 0xFF	; 255
    1e8a:	8f ef       	ldi	r24, 0xFF	; 255
    1e8c:	d8 07       	cpc	r29, r24
    1e8e:	61 f4       	brne	.+24     	; 0x1ea8 <prvAddCurrentTaskToDelayedList+0x42>
    1e90:	ff 20       	and	r15, r15
    1e92:	51 f0       	breq	.+20     	; 0x1ea8 <prvAddCurrentTaskToDelayedList+0x42>
    1e94:	60 91 67 0d 	lds	r22, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1e98:	70 91 68 0d 	lds	r23, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1e9c:	6e 5f       	subi	r22, 0xFE	; 254
    1e9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ea0:	81 e1       	ldi	r24, 0x11	; 17
    1ea2:	9d e0       	ldi	r25, 0x0D	; 13
    1ea4:	6f db       	rcall	.-2338   	; 0x1584 <vListInsertEnd>
    1ea6:	2d c0       	rjmp	.+90     	; 0x1f02 <prvAddCurrentTaskToDelayedList+0x9c>
    1ea8:	c0 0f       	add	r28, r16
    1eaa:	d1 1f       	adc	r29, r17
    1eac:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1eb0:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1eb4:	d3 83       	std	Z+3, r29	; 0x03
    1eb6:	c2 83       	std	Z+2, r28	; 0x02
    1eb8:	c0 17       	cp	r28, r16
    1eba:	d1 07       	cpc	r29, r17
    1ebc:	60 f4       	brcc	.+24     	; 0x1ed6 <prvAddCurrentTaskToDelayedList+0x70>
    1ebe:	60 91 67 0d 	lds	r22, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1ec2:	70 91 68 0d 	lds	r23, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1ec6:	80 91 2d 0d 	lds	r24, 0x0D2D	; 0x800d2d <pxOverflowDelayedTaskList>
    1eca:	90 91 2e 0d 	lds	r25, 0x0D2E	; 0x800d2e <pxOverflowDelayedTaskList+0x1>
    1ece:	6e 5f       	subi	r22, 0xFE	; 254
    1ed0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed2:	79 db       	rcall	.-2318   	; 0x15c6 <vListInsert>
    1ed4:	16 c0       	rjmp	.+44     	; 0x1f02 <prvAddCurrentTaskToDelayedList+0x9c>
    1ed6:	60 91 67 0d 	lds	r22, 0x0D67	; 0x800d67 <pxCurrentTCB>
    1eda:	70 91 68 0d 	lds	r23, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    1ede:	80 91 2f 0d 	lds	r24, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    1ee2:	90 91 30 0d 	lds	r25, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    1ee6:	6e 5f       	subi	r22, 0xFE	; 254
    1ee8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eea:	6d db       	rcall	.-2342   	; 0x15c6 <vListInsert>
    1eec:	80 91 06 0d 	lds	r24, 0x0D06	; 0x800d06 <xNextTaskUnblockTime>
    1ef0:	90 91 07 0d 	lds	r25, 0x0D07	; 0x800d07 <xNextTaskUnblockTime+0x1>
    1ef4:	c8 17       	cp	r28, r24
    1ef6:	d9 07       	cpc	r29, r25
    1ef8:	20 f4       	brcc	.+8      	; 0x1f02 <prvAddCurrentTaskToDelayedList+0x9c>
    1efa:	d0 93 07 0d 	sts	0x0D07, r29	; 0x800d07 <xNextTaskUnblockTime+0x1>
    1efe:	c0 93 06 0d 	sts	0x0D06, r28	; 0x800d06 <xNextTaskUnblockTime>
    1f02:	df 91       	pop	r29
    1f04:	cf 91       	pop	r28
    1f06:	1f 91       	pop	r17
    1f08:	0f 91       	pop	r16
    1f0a:	ff 90       	pop	r15
    1f0c:	08 95       	ret

00001f0e <xTaskCreate>:
    1f0e:	4f 92       	push	r4
    1f10:	5f 92       	push	r5
    1f12:	6f 92       	push	r6
    1f14:	7f 92       	push	r7
    1f16:	8f 92       	push	r8
    1f18:	9f 92       	push	r9
    1f1a:	af 92       	push	r10
    1f1c:	bf 92       	push	r11
    1f1e:	cf 92       	push	r12
    1f20:	df 92       	push	r13
    1f22:	ef 92       	push	r14
    1f24:	ff 92       	push	r15
    1f26:	0f 93       	push	r16
    1f28:	cf 93       	push	r28
    1f2a:	df 93       	push	r29
    1f2c:	4c 01       	movw	r8, r24
    1f2e:	6b 01       	movw	r12, r22
    1f30:	5a 01       	movw	r10, r20
    1f32:	29 01       	movw	r4, r18
    1f34:	ca 01       	movw	r24, r20
    1f36:	e0 da       	rcall	.-2624   	; 0x14f8 <pvPortMalloc>
    1f38:	3c 01       	movw	r6, r24
    1f3a:	89 2b       	or	r24, r25
    1f3c:	09 f4       	brne	.+2      	; 0x1f40 <xTaskCreate+0x32>
    1f3e:	d4 c0       	rjmp	.+424    	; 0x20e8 <xTaskCreate+0x1da>
    1f40:	88 e2       	ldi	r24, 0x28	; 40
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	d9 da       	rcall	.-2638   	; 0x14f8 <pvPortMalloc>
    1f46:	ec 01       	movw	r28, r24
    1f48:	89 2b       	or	r24, r25
    1f4a:	71 f0       	breq	.+28     	; 0x1f68 <xTaskCreate+0x5a>
    1f4c:	78 8e       	std	Y+24, r7	; 0x18
    1f4e:	6f 8a       	std	Y+23, r6	; 0x17
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	a8 1a       	sub	r10, r24
    1f54:	b1 08       	sbc	r11, r1
    1f56:	6a 0c       	add	r6, r10
    1f58:	7b 1c       	adc	r7, r11
    1f5a:	d6 01       	movw	r26, r12
    1f5c:	8c 91       	ld	r24, X
    1f5e:	89 8f       	std	Y+25, r24	; 0x19
    1f60:	8c 91       	ld	r24, X
    1f62:	81 11       	cpse	r24, r1
    1f64:	04 c0       	rjmp	.+8      	; 0x1f6e <xTaskCreate+0x60>
    1f66:	17 c0       	rjmp	.+46     	; 0x1f96 <xTaskCreate+0x88>
    1f68:	c3 01       	movw	r24, r6
    1f6a:	f9 da       	rcall	.-2574   	; 0x155e <vPortFree>
    1f6c:	bd c0       	rjmp	.+378    	; 0x20e8 <xTaskCreate+0x1da>
    1f6e:	ae 01       	movw	r20, r28
    1f70:	46 5e       	subi	r20, 0xE6	; 230
    1f72:	5f 4f       	sbci	r21, 0xFF	; 255
    1f74:	f6 01       	movw	r30, r12
    1f76:	31 96       	adiw	r30, 0x01	; 1
    1f78:	b8 e0       	ldi	r27, 0x08	; 8
    1f7a:	cb 0e       	add	r12, r27
    1f7c:	d1 1c       	adc	r13, r1
    1f7e:	cf 01       	movw	r24, r30
    1f80:	21 91       	ld	r18, Z+
    1f82:	da 01       	movw	r26, r20
    1f84:	2d 93       	st	X+, r18
    1f86:	ad 01       	movw	r20, r26
    1f88:	dc 01       	movw	r26, r24
    1f8a:	8c 91       	ld	r24, X
    1f8c:	88 23       	and	r24, r24
    1f8e:	19 f0       	breq	.+6      	; 0x1f96 <xTaskCreate+0x88>
    1f90:	ec 15       	cp	r30, r12
    1f92:	fd 05       	cpc	r31, r13
    1f94:	a1 f7       	brne	.-24     	; 0x1f7e <xTaskCreate+0x70>
    1f96:	18 a2       	std	Y+32, r1	; 0x20
    1f98:	04 30       	cpi	r16, 0x04	; 4
    1f9a:	08 f0       	brcs	.+2      	; 0x1f9e <xTaskCreate+0x90>
    1f9c:	03 e0       	ldi	r16, 0x03	; 3
    1f9e:	0e 8b       	std	Y+22, r16	; 0x16
    1fa0:	09 a3       	std	Y+33, r16	; 0x21
    1fa2:	1a a2       	std	Y+34, r1	; 0x22
    1fa4:	6e 01       	movw	r12, r28
    1fa6:	b2 e0       	ldi	r27, 0x02	; 2
    1fa8:	cb 0e       	add	r12, r27
    1faa:	d1 1c       	adc	r13, r1
    1fac:	c6 01       	movw	r24, r12
    1fae:	e6 da       	rcall	.-2612   	; 0x157c <vListInitialiseItem>
    1fb0:	ce 01       	movw	r24, r28
    1fb2:	0c 96       	adiw	r24, 0x0c	; 12
    1fb4:	e3 da       	rcall	.-2618   	; 0x157c <vListInitialiseItem>
    1fb6:	d9 87       	std	Y+9, r29	; 0x09
    1fb8:	c8 87       	std	Y+8, r28	; 0x08
    1fba:	84 e0       	ldi	r24, 0x04	; 4
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	80 1b       	sub	r24, r16
    1fc0:	91 09       	sbc	r25, r1
    1fc2:	9d 87       	std	Y+13, r25	; 0x0d
    1fc4:	8c 87       	std	Y+12, r24	; 0x0c
    1fc6:	db 8b       	std	Y+19, r29	; 0x13
    1fc8:	ca 8b       	std	Y+18, r28	; 0x12
    1fca:	1b a2       	std	Y+35, r1	; 0x23
    1fcc:	1c a2       	std	Y+36, r1	; 0x24
    1fce:	1d a2       	std	Y+37, r1	; 0x25
    1fd0:	1e a2       	std	Y+38, r1	; 0x26
    1fd2:	1f a2       	std	Y+39, r1	; 0x27
    1fd4:	a2 01       	movw	r20, r4
    1fd6:	b4 01       	movw	r22, r8
    1fd8:	c3 01       	movw	r24, r6
    1fda:	4c db       	rcall	.-2408   	; 0x1674 <pxPortInitialiseStack>
    1fdc:	99 83       	std	Y+1, r25	; 0x01
    1fde:	88 83       	st	Y, r24
    1fe0:	e1 14       	cp	r14, r1
    1fe2:	f1 04       	cpc	r15, r1
    1fe4:	19 f0       	breq	.+6      	; 0x1fec <xTaskCreate+0xde>
    1fe6:	f7 01       	movw	r30, r14
    1fe8:	d1 83       	std	Z+1, r29	; 0x01
    1fea:	c0 83       	st	Z, r28
    1fec:	0f b6       	in	r0, 0x3f	; 63
    1fee:	f8 94       	cli
    1ff0:	0f 92       	push	r0
    1ff2:	80 91 10 0d 	lds	r24, 0x0D10	; 0x800d10 <uxCurrentNumberOfTasks>
    1ff6:	8f 5f       	subi	r24, 0xFF	; 255
    1ff8:	80 93 10 0d 	sts	0x0D10, r24	; 0x800d10 <uxCurrentNumberOfTasks>
    1ffc:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2000:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2004:	89 2b       	or	r24, r25
    2006:	89 f5       	brne	.+98     	; 0x206a <xTaskCreate+0x15c>
    2008:	d0 93 68 0d 	sts	0x0D68, r29	; 0x800d68 <pxCurrentTCB+0x1>
    200c:	c0 93 67 0d 	sts	0x0D67, r28	; 0x800d67 <pxCurrentTCB>
    2010:	80 91 10 0d 	lds	r24, 0x0D10	; 0x800d10 <uxCurrentNumberOfTasks>
    2014:	81 30       	cpi	r24, 0x01	; 1
    2016:	09 f0       	breq	.+2      	; 0x201a <xTaskCreate+0x10c>
    2018:	38 c0       	rjmp	.+112    	; 0x208a <xTaskCreate+0x17c>
    201a:	83 e4       	ldi	r24, 0x43	; 67
    201c:	9d e0       	ldi	r25, 0x0D	; 13
    201e:	a0 da       	rcall	.-2752   	; 0x1560 <vListInitialise>
    2020:	8c e4       	ldi	r24, 0x4C	; 76
    2022:	9d e0       	ldi	r25, 0x0D	; 13
    2024:	9d da       	rcall	.-2758   	; 0x1560 <vListInitialise>
    2026:	85 e5       	ldi	r24, 0x55	; 85
    2028:	9d e0       	ldi	r25, 0x0D	; 13
    202a:	9a da       	rcall	.-2764   	; 0x1560 <vListInitialise>
    202c:	8e e5       	ldi	r24, 0x5E	; 94
    202e:	9d e0       	ldi	r25, 0x0D	; 13
    2030:	97 da       	rcall	.-2770   	; 0x1560 <vListInitialise>
    2032:	8a e3       	ldi	r24, 0x3A	; 58
    2034:	9d e0       	ldi	r25, 0x0D	; 13
    2036:	94 da       	rcall	.-2776   	; 0x1560 <vListInitialise>
    2038:	81 e3       	ldi	r24, 0x31	; 49
    203a:	9d e0       	ldi	r25, 0x0D	; 13
    203c:	91 da       	rcall	.-2782   	; 0x1560 <vListInitialise>
    203e:	84 e2       	ldi	r24, 0x24	; 36
    2040:	9d e0       	ldi	r25, 0x0D	; 13
    2042:	8e da       	rcall	.-2788   	; 0x1560 <vListInitialise>
    2044:	8b e1       	ldi	r24, 0x1B	; 27
    2046:	9d e0       	ldi	r25, 0x0D	; 13
    2048:	8b da       	rcall	.-2794   	; 0x1560 <vListInitialise>
    204a:	81 e1       	ldi	r24, 0x11	; 17
    204c:	9d e0       	ldi	r25, 0x0D	; 13
    204e:	88 da       	rcall	.-2800   	; 0x1560 <vListInitialise>
    2050:	8a e3       	ldi	r24, 0x3A	; 58
    2052:	9d e0       	ldi	r25, 0x0D	; 13
    2054:	90 93 30 0d 	sts	0x0D30, r25	; 0x800d30 <pxDelayedTaskList+0x1>
    2058:	80 93 2f 0d 	sts	0x0D2F, r24	; 0x800d2f <pxDelayedTaskList>
    205c:	81 e3       	ldi	r24, 0x31	; 49
    205e:	9d e0       	ldi	r25, 0x0D	; 13
    2060:	90 93 2e 0d 	sts	0x0D2E, r25	; 0x800d2e <pxOverflowDelayedTaskList+0x1>
    2064:	80 93 2d 0d 	sts	0x0D2D, r24	; 0x800d2d <pxOverflowDelayedTaskList>
    2068:	10 c0       	rjmp	.+32     	; 0x208a <xTaskCreate+0x17c>
    206a:	80 91 0c 0d 	lds	r24, 0x0D0C	; 0x800d0c <xSchedulerRunning>
    206e:	81 11       	cpse	r24, r1
    2070:	0c c0       	rjmp	.+24     	; 0x208a <xTaskCreate+0x17c>
    2072:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2076:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    207a:	96 89       	ldd	r25, Z+22	; 0x16
    207c:	8e 89       	ldd	r24, Y+22	; 0x16
    207e:	89 17       	cp	r24, r25
    2080:	20 f0       	brcs	.+8      	; 0x208a <xTaskCreate+0x17c>
    2082:	d0 93 68 0d 	sts	0x0D68, r29	; 0x800d68 <pxCurrentTCB+0x1>
    2086:	c0 93 67 0d 	sts	0x0D67, r28	; 0x800d67 <pxCurrentTCB>
    208a:	80 91 08 0d 	lds	r24, 0x0D08	; 0x800d08 <uxTaskNumber>
    208e:	8f 5f       	subi	r24, 0xFF	; 255
    2090:	80 93 08 0d 	sts	0x0D08, r24	; 0x800d08 <uxTaskNumber>
    2094:	8e 89       	ldd	r24, Y+22	; 0x16
    2096:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    209a:	98 17       	cp	r25, r24
    209c:	10 f4       	brcc	.+4      	; 0x20a2 <xTaskCreate+0x194>
    209e:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	9c 01       	movw	r18, r24
    20a6:	22 0f       	add	r18, r18
    20a8:	33 1f       	adc	r19, r19
    20aa:	22 0f       	add	r18, r18
    20ac:	33 1f       	adc	r19, r19
    20ae:	22 0f       	add	r18, r18
    20b0:	33 1f       	adc	r19, r19
    20b2:	82 0f       	add	r24, r18
    20b4:	93 1f       	adc	r25, r19
    20b6:	b6 01       	movw	r22, r12
    20b8:	8d 5b       	subi	r24, 0xBD	; 189
    20ba:	92 4f       	sbci	r25, 0xF2	; 242
    20bc:	63 da       	rcall	.-2874   	; 0x1584 <vListInsertEnd>
    20be:	0f 90       	pop	r0
    20c0:	0f be       	out	0x3f, r0	; 63
    20c2:	80 91 0c 0d 	lds	r24, 0x0D0C	; 0x800d0c <xSchedulerRunning>
    20c6:	88 23       	and	r24, r24
    20c8:	59 f0       	breq	.+22     	; 0x20e0 <xTaskCreate+0x1d2>
    20ca:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    20ce:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    20d2:	96 89       	ldd	r25, Z+22	; 0x16
    20d4:	8e 89       	ldd	r24, Y+22	; 0x16
    20d6:	98 17       	cp	r25, r24
    20d8:	28 f4       	brcc	.+10     	; 0x20e4 <xTaskCreate+0x1d6>
    20da:	6d db       	rcall	.-2342   	; 0x17b6 <vPortYield>
    20dc:	81 e0       	ldi	r24, 0x01	; 1
    20de:	05 c0       	rjmp	.+10     	; 0x20ea <xTaskCreate+0x1dc>
    20e0:	81 e0       	ldi	r24, 0x01	; 1
    20e2:	03 c0       	rjmp	.+6      	; 0x20ea <xTaskCreate+0x1dc>
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	01 c0       	rjmp	.+2      	; 0x20ea <xTaskCreate+0x1dc>
    20e8:	8f ef       	ldi	r24, 0xFF	; 255
    20ea:	df 91       	pop	r29
    20ec:	cf 91       	pop	r28
    20ee:	0f 91       	pop	r16
    20f0:	ff 90       	pop	r15
    20f2:	ef 90       	pop	r14
    20f4:	df 90       	pop	r13
    20f6:	cf 90       	pop	r12
    20f8:	bf 90       	pop	r11
    20fa:	af 90       	pop	r10
    20fc:	9f 90       	pop	r9
    20fe:	8f 90       	pop	r8
    2100:	7f 90       	pop	r7
    2102:	6f 90       	pop	r6
    2104:	5f 90       	pop	r5
    2106:	4f 90       	pop	r4
    2108:	08 95       	ret

0000210a <vTaskStartScheduler>:
    210a:	ef 92       	push	r14
    210c:	ff 92       	push	r15
    210e:	0f 93       	push	r16
    2110:	0f 2e       	mov	r0, r31
    2112:	f4 e0       	ldi	r31, 0x04	; 4
    2114:	ef 2e       	mov	r14, r31
    2116:	fd e0       	ldi	r31, 0x0D	; 13
    2118:	ff 2e       	mov	r15, r31
    211a:	f0 2d       	mov	r31, r0
    211c:	00 e0       	ldi	r16, 0x00	; 0
    211e:	20 e0       	ldi	r18, 0x00	; 0
    2120:	30 e0       	ldi	r19, 0x00	; 0
    2122:	45 e5       	ldi	r20, 0x55	; 85
    2124:	50 e0       	ldi	r21, 0x00	; 0
    2126:	6e e8       	ldi	r22, 0x8E	; 142
    2128:	71 e0       	ldi	r23, 0x01	; 1
    212a:	83 ef       	ldi	r24, 0xF3	; 243
    212c:	91 e1       	ldi	r25, 0x11	; 17
    212e:	ef de       	rcall	.-546    	; 0x1f0e <xTaskCreate>
    2130:	81 30       	cpi	r24, 0x01	; 1
    2132:	79 f4       	brne	.+30     	; 0x2152 <vTaskStartScheduler+0x48>
    2134:	f8 94       	cli
    2136:	8f ef       	ldi	r24, 0xFF	; 255
    2138:	9f ef       	ldi	r25, 0xFF	; 255
    213a:	90 93 07 0d 	sts	0x0D07, r25	; 0x800d07 <xNextTaskUnblockTime+0x1>
    213e:	80 93 06 0d 	sts	0x0D06, r24	; 0x800d06 <xNextTaskUnblockTime>
    2142:	81 e0       	ldi	r24, 0x01	; 1
    2144:	80 93 0c 0d 	sts	0x0D0C, r24	; 0x800d0c <xSchedulerRunning>
    2148:	10 92 0f 0d 	sts	0x0D0F, r1	; 0x800d0f <xTickCount+0x1>
    214c:	10 92 0e 0d 	sts	0x0D0E, r1	; 0x800d0e <xTickCount>
    2150:	fd da       	rcall	.-2566   	; 0x174c <xPortStartScheduler>
    2152:	0f 91       	pop	r16
    2154:	ff 90       	pop	r15
    2156:	ef 90       	pop	r14
    2158:	08 95       	ret

0000215a <vTaskSuspendAll>:
    215a:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    215e:	8f 5f       	subi	r24, 0xFF	; 255
    2160:	80 93 03 0d 	sts	0x0D03, r24	; 0x800d03 <uxSchedulerSuspended>
    2164:	08 95       	ret

00002166 <xTaskIncrementTick>:
    2166:	cf 92       	push	r12
    2168:	df 92       	push	r13
    216a:	ef 92       	push	r14
    216c:	ff 92       	push	r15
    216e:	0f 93       	push	r16
    2170:	1f 93       	push	r17
    2172:	cf 93       	push	r28
    2174:	df 93       	push	r29
    2176:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    217a:	81 11       	cpse	r24, r1
    217c:	95 c0       	rjmp	.+298    	; 0x22a8 <xTaskIncrementTick+0x142>
    217e:	e0 90 0e 0d 	lds	r14, 0x0D0E	; 0x800d0e <xTickCount>
    2182:	f0 90 0f 0d 	lds	r15, 0x0D0F	; 0x800d0f <xTickCount+0x1>
    2186:	8f ef       	ldi	r24, 0xFF	; 255
    2188:	e8 1a       	sub	r14, r24
    218a:	f8 0a       	sbc	r15, r24
    218c:	f0 92 0f 0d 	sts	0x0D0F, r15	; 0x800d0f <xTickCount+0x1>
    2190:	e0 92 0e 0d 	sts	0x0D0E, r14	; 0x800d0e <xTickCount>
    2194:	e1 14       	cp	r14, r1
    2196:	f1 04       	cpc	r15, r1
    2198:	b1 f4       	brne	.+44     	; 0x21c6 <xTaskIncrementTick+0x60>
    219a:	80 91 2f 0d 	lds	r24, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    219e:	90 91 30 0d 	lds	r25, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    21a2:	20 91 2d 0d 	lds	r18, 0x0D2D	; 0x800d2d <pxOverflowDelayedTaskList>
    21a6:	30 91 2e 0d 	lds	r19, 0x0D2E	; 0x800d2e <pxOverflowDelayedTaskList+0x1>
    21aa:	30 93 30 0d 	sts	0x0D30, r19	; 0x800d30 <pxDelayedTaskList+0x1>
    21ae:	20 93 2f 0d 	sts	0x0D2F, r18	; 0x800d2f <pxDelayedTaskList>
    21b2:	90 93 2e 0d 	sts	0x0D2E, r25	; 0x800d2e <pxOverflowDelayedTaskList+0x1>
    21b6:	80 93 2d 0d 	sts	0x0D2D, r24	; 0x800d2d <pxOverflowDelayedTaskList>
    21ba:	80 91 09 0d 	lds	r24, 0x0D09	; 0x800d09 <xNumOfOverflows>
    21be:	8f 5f       	subi	r24, 0xFF	; 255
    21c0:	80 93 09 0d 	sts	0x0D09, r24	; 0x800d09 <xNumOfOverflows>
    21c4:	31 de       	rcall	.-926    	; 0x1e28 <prvResetNextTaskUnblockTime>
    21c6:	80 91 06 0d 	lds	r24, 0x0D06	; 0x800d06 <xNextTaskUnblockTime>
    21ca:	90 91 07 0d 	lds	r25, 0x0D07	; 0x800d07 <xNextTaskUnblockTime+0x1>
    21ce:	e8 16       	cp	r14, r24
    21d0:	f9 06       	cpc	r15, r25
    21d2:	10 f4       	brcc	.+4      	; 0x21d8 <xTaskIncrementTick+0x72>
    21d4:	d1 2c       	mov	r13, r1
    21d6:	50 c0       	rjmp	.+160    	; 0x2278 <xTaskIncrementTick+0x112>
    21d8:	d1 2c       	mov	r13, r1
    21da:	cc 24       	eor	r12, r12
    21dc:	c3 94       	inc	r12
    21de:	e0 91 2f 0d 	lds	r30, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    21e2:	f0 91 30 0d 	lds	r31, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    21e6:	80 81       	ld	r24, Z
    21e8:	81 11       	cpse	r24, r1
    21ea:	07 c0       	rjmp	.+14     	; 0x21fa <xTaskIncrementTick+0x94>
    21ec:	8f ef       	ldi	r24, 0xFF	; 255
    21ee:	9f ef       	ldi	r25, 0xFF	; 255
    21f0:	90 93 07 0d 	sts	0x0D07, r25	; 0x800d07 <xNextTaskUnblockTime+0x1>
    21f4:	80 93 06 0d 	sts	0x0D06, r24	; 0x800d06 <xNextTaskUnblockTime>
    21f8:	3f c0       	rjmp	.+126    	; 0x2278 <xTaskIncrementTick+0x112>
    21fa:	e0 91 2f 0d 	lds	r30, 0x0D2F	; 0x800d2f <pxDelayedTaskList>
    21fe:	f0 91 30 0d 	lds	r31, 0x0D30	; 0x800d30 <pxDelayedTaskList+0x1>
    2202:	05 80       	ldd	r0, Z+5	; 0x05
    2204:	f6 81       	ldd	r31, Z+6	; 0x06
    2206:	e0 2d       	mov	r30, r0
    2208:	c6 81       	ldd	r28, Z+6	; 0x06
    220a:	d7 81       	ldd	r29, Z+7	; 0x07
    220c:	8a 81       	ldd	r24, Y+2	; 0x02
    220e:	9b 81       	ldd	r25, Y+3	; 0x03
    2210:	e8 16       	cp	r14, r24
    2212:	f9 06       	cpc	r15, r25
    2214:	28 f4       	brcc	.+10     	; 0x2220 <xTaskIncrementTick+0xba>
    2216:	90 93 07 0d 	sts	0x0D07, r25	; 0x800d07 <xNextTaskUnblockTime+0x1>
    221a:	80 93 06 0d 	sts	0x0D06, r24	; 0x800d06 <xNextTaskUnblockTime>
    221e:	2c c0       	rjmp	.+88     	; 0x2278 <xTaskIncrementTick+0x112>
    2220:	8e 01       	movw	r16, r28
    2222:	0e 5f       	subi	r16, 0xFE	; 254
    2224:	1f 4f       	sbci	r17, 0xFF	; 255
    2226:	c8 01       	movw	r24, r16
    2228:	ff d9       	rcall	.-3074   	; 0x1628 <uxListRemove>
    222a:	8c 89       	ldd	r24, Y+20	; 0x14
    222c:	9d 89       	ldd	r25, Y+21	; 0x15
    222e:	89 2b       	or	r24, r25
    2230:	19 f0       	breq	.+6      	; 0x2238 <xTaskIncrementTick+0xd2>
    2232:	ce 01       	movw	r24, r28
    2234:	0c 96       	adiw	r24, 0x0c	; 12
    2236:	f8 d9       	rcall	.-3088   	; 0x1628 <uxListRemove>
    2238:	8e 89       	ldd	r24, Y+22	; 0x16
    223a:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    223e:	98 17       	cp	r25, r24
    2240:	10 f4       	brcc	.+4      	; 0x2246 <xTaskIncrementTick+0xe0>
    2242:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    2246:	90 e0       	ldi	r25, 0x00	; 0
    2248:	9c 01       	movw	r18, r24
    224a:	22 0f       	add	r18, r18
    224c:	33 1f       	adc	r19, r19
    224e:	22 0f       	add	r18, r18
    2250:	33 1f       	adc	r19, r19
    2252:	22 0f       	add	r18, r18
    2254:	33 1f       	adc	r19, r19
    2256:	82 0f       	add	r24, r18
    2258:	93 1f       	adc	r25, r19
    225a:	b8 01       	movw	r22, r16
    225c:	8d 5b       	subi	r24, 0xBD	; 189
    225e:	92 4f       	sbci	r25, 0xF2	; 242
    2260:	91 d9       	rcall	.-3294   	; 0x1584 <vListInsertEnd>
    2262:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2266:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    226a:	9e 89       	ldd	r25, Y+22	; 0x16
    226c:	86 89       	ldd	r24, Z+22	; 0x16
    226e:	98 17       	cp	r25, r24
    2270:	08 f4       	brcc	.+2      	; 0x2274 <xTaskIncrementTick+0x10e>
    2272:	b5 cf       	rjmp	.-150    	; 0x21de <xTaskIncrementTick+0x78>
    2274:	dc 2c       	mov	r13, r12
    2276:	b3 cf       	rjmp	.-154    	; 0x21de <xTaskIncrementTick+0x78>
    2278:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    227c:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2280:	86 89       	ldd	r24, Z+22	; 0x16
    2282:	90 e0       	ldi	r25, 0x00	; 0
    2284:	fc 01       	movw	r30, r24
    2286:	ee 0f       	add	r30, r30
    2288:	ff 1f       	adc	r31, r31
    228a:	ee 0f       	add	r30, r30
    228c:	ff 1f       	adc	r31, r31
    228e:	ee 0f       	add	r30, r30
    2290:	ff 1f       	adc	r31, r31
    2292:	8e 0f       	add	r24, r30
    2294:	9f 1f       	adc	r25, r31
    2296:	fc 01       	movw	r30, r24
    2298:	ed 5b       	subi	r30, 0xBD	; 189
    229a:	f2 4f       	sbci	r31, 0xF2	; 242
    229c:	80 81       	ld	r24, Z
    229e:	82 30       	cpi	r24, 0x02	; 2
    22a0:	48 f0       	brcs	.+18     	; 0x22b4 <xTaskIncrementTick+0x14e>
    22a2:	dd 24       	eor	r13, r13
    22a4:	d3 94       	inc	r13
    22a6:	06 c0       	rjmp	.+12     	; 0x22b4 <xTaskIncrementTick+0x14e>
    22a8:	80 91 0b 0d 	lds	r24, 0x0D0B	; 0x800d0b <uxPendedTicks>
    22ac:	8f 5f       	subi	r24, 0xFF	; 255
    22ae:	80 93 0b 0d 	sts	0x0D0B, r24	; 0x800d0b <uxPendedTicks>
    22b2:	d1 2c       	mov	r13, r1
    22b4:	80 91 0a 0d 	lds	r24, 0x0D0A	; 0x800d0a <xYieldPending>
    22b8:	88 23       	and	r24, r24
    22ba:	11 f0       	breq	.+4      	; 0x22c0 <xTaskIncrementTick+0x15a>
    22bc:	dd 24       	eor	r13, r13
    22be:	d3 94       	inc	r13
    22c0:	8d 2d       	mov	r24, r13
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	ff 90       	pop	r15
    22cc:	ef 90       	pop	r14
    22ce:	df 90       	pop	r13
    22d0:	cf 90       	pop	r12
    22d2:	08 95       	ret

000022d4 <xTaskResumeAll>:
    22d4:	df 92       	push	r13
    22d6:	ef 92       	push	r14
    22d8:	ff 92       	push	r15
    22da:	0f 93       	push	r16
    22dc:	1f 93       	push	r17
    22de:	cf 93       	push	r28
    22e0:	df 93       	push	r29
    22e2:	0f b6       	in	r0, 0x3f	; 63
    22e4:	f8 94       	cli
    22e6:	0f 92       	push	r0
    22e8:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    22ec:	81 50       	subi	r24, 0x01	; 1
    22ee:	80 93 03 0d 	sts	0x0D03, r24	; 0x800d03 <uxSchedulerSuspended>
    22f2:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    22f6:	81 11       	cpse	r24, r1
    22f8:	59 c0       	rjmp	.+178    	; 0x23ac <xTaskResumeAll+0xd8>
    22fa:	80 91 10 0d 	lds	r24, 0x0D10	; 0x800d10 <uxCurrentNumberOfTasks>
    22fe:	81 11       	cpse	r24, r1
    2300:	30 c0       	rjmp	.+96     	; 0x2362 <xTaskResumeAll+0x8e>
    2302:	57 c0       	rjmp	.+174    	; 0x23b2 <xTaskResumeAll+0xde>
    2304:	d7 01       	movw	r26, r14
    2306:	15 96       	adiw	r26, 0x05	; 5
    2308:	ed 91       	ld	r30, X+
    230a:	fc 91       	ld	r31, X
    230c:	16 97       	sbiw	r26, 0x06	; 6
    230e:	c6 81       	ldd	r28, Z+6	; 0x06
    2310:	d7 81       	ldd	r29, Z+7	; 0x07
    2312:	ce 01       	movw	r24, r28
    2314:	0c 96       	adiw	r24, 0x0c	; 12
    2316:	88 d9       	rcall	.-3312   	; 0x1628 <uxListRemove>
    2318:	8e 01       	movw	r16, r28
    231a:	0e 5f       	subi	r16, 0xFE	; 254
    231c:	1f 4f       	sbci	r17, 0xFF	; 255
    231e:	c8 01       	movw	r24, r16
    2320:	83 d9       	rcall	.-3322   	; 0x1628 <uxListRemove>
    2322:	8e 89       	ldd	r24, Y+22	; 0x16
    2324:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    2328:	98 17       	cp	r25, r24
    232a:	10 f4       	brcc	.+4      	; 0x2330 <xTaskResumeAll+0x5c>
    232c:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	9c 01       	movw	r18, r24
    2334:	22 0f       	add	r18, r18
    2336:	33 1f       	adc	r19, r19
    2338:	22 0f       	add	r18, r18
    233a:	33 1f       	adc	r19, r19
    233c:	22 0f       	add	r18, r18
    233e:	33 1f       	adc	r19, r19
    2340:	82 0f       	add	r24, r18
    2342:	93 1f       	adc	r25, r19
    2344:	b8 01       	movw	r22, r16
    2346:	8d 5b       	subi	r24, 0xBD	; 189
    2348:	92 4f       	sbci	r25, 0xF2	; 242
    234a:	1c d9       	rcall	.-3528   	; 0x1584 <vListInsertEnd>
    234c:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2350:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2354:	9e 89       	ldd	r25, Y+22	; 0x16
    2356:	86 89       	ldd	r24, Z+22	; 0x16
    2358:	98 17       	cp	r25, r24
    235a:	68 f0       	brcs	.+26     	; 0x2376 <xTaskResumeAll+0xa2>
    235c:	d0 92 0a 0d 	sts	0x0D0A, r13	; 0x800d0a <xYieldPending>
    2360:	0a c0       	rjmp	.+20     	; 0x2376 <xTaskResumeAll+0xa2>
    2362:	c0 e0       	ldi	r28, 0x00	; 0
    2364:	d0 e0       	ldi	r29, 0x00	; 0
    2366:	0f 2e       	mov	r0, r31
    2368:	f4 e2       	ldi	r31, 0x24	; 36
    236a:	ef 2e       	mov	r14, r31
    236c:	fd e0       	ldi	r31, 0x0D	; 13
    236e:	ff 2e       	mov	r15, r31
    2370:	f0 2d       	mov	r31, r0
    2372:	dd 24       	eor	r13, r13
    2374:	d3 94       	inc	r13
    2376:	f7 01       	movw	r30, r14
    2378:	80 81       	ld	r24, Z
    237a:	81 11       	cpse	r24, r1
    237c:	c3 cf       	rjmp	.-122    	; 0x2304 <xTaskResumeAll+0x30>
    237e:	cd 2b       	or	r28, r29
    2380:	09 f0       	breq	.+2      	; 0x2384 <xTaskResumeAll+0xb0>
    2382:	52 dd       	rcall	.-1372   	; 0x1e28 <prvResetNextTaskUnblockTime>
    2384:	c0 91 0b 0d 	lds	r28, 0x0D0B	; 0x800d0b <uxPendedTicks>
    2388:	cc 23       	and	r28, r28
    238a:	49 f0       	breq	.+18     	; 0x239e <xTaskResumeAll+0xca>
    238c:	d1 e0       	ldi	r29, 0x01	; 1
    238e:	eb de       	rcall	.-554    	; 0x2166 <xTaskIncrementTick>
    2390:	81 11       	cpse	r24, r1
    2392:	d0 93 0a 0d 	sts	0x0D0A, r29	; 0x800d0a <xYieldPending>
    2396:	c1 50       	subi	r28, 0x01	; 1
    2398:	d1 f7       	brne	.-12     	; 0x238e <xTaskResumeAll+0xba>
    239a:	10 92 0b 0d 	sts	0x0D0B, r1	; 0x800d0b <uxPendedTicks>
    239e:	80 91 0a 0d 	lds	r24, 0x0D0A	; 0x800d0a <xYieldPending>
    23a2:	88 23       	and	r24, r24
    23a4:	29 f0       	breq	.+10     	; 0x23b0 <xTaskResumeAll+0xdc>
    23a6:	07 da       	rcall	.-3058   	; 0x17b6 <vPortYield>
    23a8:	81 e0       	ldi	r24, 0x01	; 1
    23aa:	03 c0       	rjmp	.+6      	; 0x23b2 <xTaskResumeAll+0xde>
    23ac:	80 e0       	ldi	r24, 0x00	; 0
    23ae:	01 c0       	rjmp	.+2      	; 0x23b2 <xTaskResumeAll+0xde>
    23b0:	80 e0       	ldi	r24, 0x00	; 0
    23b2:	0f 90       	pop	r0
    23b4:	0f be       	out	0x3f, r0	; 63
    23b6:	df 91       	pop	r29
    23b8:	cf 91       	pop	r28
    23ba:	1f 91       	pop	r17
    23bc:	0f 91       	pop	r16
    23be:	ff 90       	pop	r15
    23c0:	ef 90       	pop	r14
    23c2:	df 90       	pop	r13
    23c4:	08 95       	ret

000023c6 <vTaskDelay>:
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
    23ca:	ec 01       	movw	r28, r24
    23cc:	89 2b       	or	r24, r25
    23ce:	39 f0       	breq	.+14     	; 0x23de <vTaskDelay+0x18>
    23d0:	c4 de       	rcall	.-632    	; 0x215a <vTaskSuspendAll>
    23d2:	60 e0       	ldi	r22, 0x00	; 0
    23d4:	ce 01       	movw	r24, r28
    23d6:	47 dd       	rcall	.-1394   	; 0x1e66 <prvAddCurrentTaskToDelayedList>
    23d8:	7d df       	rcall	.-262    	; 0x22d4 <xTaskResumeAll>
    23da:	81 11       	cpse	r24, r1
    23dc:	01 c0       	rjmp	.+2      	; 0x23e0 <vTaskDelay+0x1a>
    23de:	eb d9       	rcall	.-3114   	; 0x17b6 <vPortYield>
    23e0:	df 91       	pop	r29
    23e2:	cf 91       	pop	r28
    23e4:	08 95       	ret

000023e6 <prvIdleTask>:
    23e6:	0b e1       	ldi	r16, 0x1B	; 27
    23e8:	1d e0       	ldi	r17, 0x0D	; 13
    23ea:	0f 2e       	mov	r0, r31
    23ec:	f3 e4       	ldi	r31, 0x43	; 67
    23ee:	ef 2e       	mov	r14, r31
    23f0:	fd e0       	ldi	r31, 0x0D	; 13
    23f2:	ff 2e       	mov	r15, r31
    23f4:	f0 2d       	mov	r31, r0
    23f6:	24 c0       	rjmp	.+72     	; 0x2440 <prvIdleTask+0x5a>
    23f8:	b0 de       	rcall	.-672    	; 0x215a <vTaskSuspendAll>
    23fa:	d8 01       	movw	r26, r16
    23fc:	cc 91       	ld	r28, X
    23fe:	6a df       	rcall	.-300    	; 0x22d4 <xTaskResumeAll>
    2400:	cc 23       	and	r28, r28
    2402:	f1 f0       	breq	.+60     	; 0x2440 <prvIdleTask+0x5a>
    2404:	0f b6       	in	r0, 0x3f	; 63
    2406:	f8 94       	cli
    2408:	0f 92       	push	r0
    240a:	d8 01       	movw	r26, r16
    240c:	15 96       	adiw	r26, 0x05	; 5
    240e:	ed 91       	ld	r30, X+
    2410:	fc 91       	ld	r31, X
    2412:	16 97       	sbiw	r26, 0x06	; 6
    2414:	c6 81       	ldd	r28, Z+6	; 0x06
    2416:	d7 81       	ldd	r29, Z+7	; 0x07
    2418:	ce 01       	movw	r24, r28
    241a:	02 96       	adiw	r24, 0x02	; 2
    241c:	05 d9       	rcall	.-3574   	; 0x1628 <uxListRemove>
    241e:	80 91 10 0d 	lds	r24, 0x0D10	; 0x800d10 <uxCurrentNumberOfTasks>
    2422:	81 50       	subi	r24, 0x01	; 1
    2424:	80 93 10 0d 	sts	0x0D10, r24	; 0x800d10 <uxCurrentNumberOfTasks>
    2428:	80 91 1a 0d 	lds	r24, 0x0D1A	; 0x800d1a <uxDeletedTasksWaitingCleanUp>
    242c:	81 50       	subi	r24, 0x01	; 1
    242e:	80 93 1a 0d 	sts	0x0D1A, r24	; 0x800d1a <uxDeletedTasksWaitingCleanUp>
    2432:	0f 90       	pop	r0
    2434:	0f be       	out	0x3f, r0	; 63
    2436:	8f 89       	ldd	r24, Y+23	; 0x17
    2438:	98 8d       	ldd	r25, Y+24	; 0x18
    243a:	91 d8       	rcall	.-3806   	; 0x155e <vPortFree>
    243c:	ce 01       	movw	r24, r28
    243e:	8f d8       	rcall	.-3810   	; 0x155e <vPortFree>
    2440:	80 91 1a 0d 	lds	r24, 0x0D1A	; 0x800d1a <uxDeletedTasksWaitingCleanUp>
    2444:	81 11       	cpse	r24, r1
    2446:	d8 cf       	rjmp	.-80     	; 0x23f8 <prvIdleTask+0x12>
    2448:	f7 01       	movw	r30, r14
    244a:	80 81       	ld	r24, Z
    244c:	82 30       	cpi	r24, 0x02	; 2
    244e:	c0 f3       	brcs	.-16     	; 0x2440 <prvIdleTask+0x5a>
    2450:	b2 d9       	rcall	.-3228   	; 0x17b6 <vPortYield>
    2452:	f6 cf       	rjmp	.-20     	; 0x2440 <prvIdleTask+0x5a>

00002454 <vTaskSwitchContext>:
    2454:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    2458:	88 23       	and	r24, r24
    245a:	21 f0       	breq	.+8      	; 0x2464 <vTaskSwitchContext+0x10>
    245c:	81 e0       	ldi	r24, 0x01	; 1
    245e:	80 93 0a 0d 	sts	0x0D0A, r24	; 0x800d0a <xYieldPending>
    2462:	08 95       	ret
    2464:	10 92 0a 0d 	sts	0x0D0A, r1	; 0x800d0a <xYieldPending>
    2468:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    246c:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2470:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2474:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2478:	2d 91       	ld	r18, X+
    247a:	3c 91       	ld	r19, X
    247c:	87 89       	ldd	r24, Z+23	; 0x17
    247e:	90 8d       	ldd	r25, Z+24	; 0x18
    2480:	82 17       	cp	r24, r18
    2482:	93 07       	cpc	r25, r19
    2484:	58 f0       	brcs	.+22     	; 0x249c <vTaskSwitchContext+0x48>
    2486:	60 91 67 0d 	lds	r22, 0x0D67	; 0x800d67 <pxCurrentTCB>
    248a:	70 91 68 0d 	lds	r23, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    248e:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2492:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2496:	67 5e       	subi	r22, 0xE7	; 231
    2498:	7f 4f       	sbci	r23, 0xFF	; 255
    249a:	2d d8       	rcall	.-4006   	; 0x14f6 <vApplicationStackOverflowHook>
    249c:	20 91 0d 0d 	lds	r18, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    24a0:	82 2f       	mov	r24, r18
    24a2:	90 e0       	ldi	r25, 0x00	; 0
    24a4:	fc 01       	movw	r30, r24
    24a6:	ee 0f       	add	r30, r30
    24a8:	ff 1f       	adc	r31, r31
    24aa:	ee 0f       	add	r30, r30
    24ac:	ff 1f       	adc	r31, r31
    24ae:	ee 0f       	add	r30, r30
    24b0:	ff 1f       	adc	r31, r31
    24b2:	e8 0f       	add	r30, r24
    24b4:	f9 1f       	adc	r31, r25
    24b6:	ed 5b       	subi	r30, 0xBD	; 189
    24b8:	f2 4f       	sbci	r31, 0xF2	; 242
    24ba:	30 81       	ld	r19, Z
    24bc:	31 11       	cpse	r19, r1
    24be:	11 c0       	rjmp	.+34     	; 0x24e2 <vTaskSwitchContext+0x8e>
    24c0:	21 50       	subi	r18, 0x01	; 1
    24c2:	82 2f       	mov	r24, r18
    24c4:	90 e0       	ldi	r25, 0x00	; 0
    24c6:	fc 01       	movw	r30, r24
    24c8:	ee 0f       	add	r30, r30
    24ca:	ff 1f       	adc	r31, r31
    24cc:	ee 0f       	add	r30, r30
    24ce:	ff 1f       	adc	r31, r31
    24d0:	ee 0f       	add	r30, r30
    24d2:	ff 1f       	adc	r31, r31
    24d4:	e8 0f       	add	r30, r24
    24d6:	f9 1f       	adc	r31, r25
    24d8:	ed 5b       	subi	r30, 0xBD	; 189
    24da:	f2 4f       	sbci	r31, 0xF2	; 242
    24dc:	30 81       	ld	r19, Z
    24de:	33 23       	and	r19, r19
    24e0:	79 f3       	breq	.-34     	; 0x24c0 <vTaskSwitchContext+0x6c>
    24e2:	ac 01       	movw	r20, r24
    24e4:	44 0f       	add	r20, r20
    24e6:	55 1f       	adc	r21, r21
    24e8:	44 0f       	add	r20, r20
    24ea:	55 1f       	adc	r21, r21
    24ec:	44 0f       	add	r20, r20
    24ee:	55 1f       	adc	r21, r21
    24f0:	48 0f       	add	r20, r24
    24f2:	59 1f       	adc	r21, r25
    24f4:	da 01       	movw	r26, r20
    24f6:	ad 5b       	subi	r26, 0xBD	; 189
    24f8:	b2 4f       	sbci	r27, 0xF2	; 242
    24fa:	11 96       	adiw	r26, 0x01	; 1
    24fc:	ed 91       	ld	r30, X+
    24fe:	fc 91       	ld	r31, X
    2500:	12 97       	sbiw	r26, 0x02	; 2
    2502:	02 80       	ldd	r0, Z+2	; 0x02
    2504:	f3 81       	ldd	r31, Z+3	; 0x03
    2506:	e0 2d       	mov	r30, r0
    2508:	12 96       	adiw	r26, 0x02	; 2
    250a:	fc 93       	st	X, r31
    250c:	ee 93       	st	-X, r30
    250e:	11 97       	sbiw	r26, 0x01	; 1
    2510:	4a 5b       	subi	r20, 0xBA	; 186
    2512:	52 4f       	sbci	r21, 0xF2	; 242
    2514:	e4 17       	cp	r30, r20
    2516:	f5 07       	cpc	r31, r21
    2518:	29 f4       	brne	.+10     	; 0x2524 <vTaskSwitchContext+0xd0>
    251a:	42 81       	ldd	r20, Z+2	; 0x02
    251c:	53 81       	ldd	r21, Z+3	; 0x03
    251e:	fd 01       	movw	r30, r26
    2520:	52 83       	std	Z+2, r21	; 0x02
    2522:	41 83       	std	Z+1, r20	; 0x01
    2524:	fc 01       	movw	r30, r24
    2526:	ee 0f       	add	r30, r30
    2528:	ff 1f       	adc	r31, r31
    252a:	ee 0f       	add	r30, r30
    252c:	ff 1f       	adc	r31, r31
    252e:	ee 0f       	add	r30, r30
    2530:	ff 1f       	adc	r31, r31
    2532:	8e 0f       	add	r24, r30
    2534:	9f 1f       	adc	r25, r31
    2536:	fc 01       	movw	r30, r24
    2538:	ed 5b       	subi	r30, 0xBD	; 189
    253a:	f2 4f       	sbci	r31, 0xF2	; 242
    253c:	01 80       	ldd	r0, Z+1	; 0x01
    253e:	f2 81       	ldd	r31, Z+2	; 0x02
    2540:	e0 2d       	mov	r30, r0
    2542:	86 81       	ldd	r24, Z+6	; 0x06
    2544:	97 81       	ldd	r25, Z+7	; 0x07
    2546:	90 93 68 0d 	sts	0x0D68, r25	; 0x800d68 <pxCurrentTCB+0x1>
    254a:	80 93 67 0d 	sts	0x0D67, r24	; 0x800d67 <pxCurrentTCB>
    254e:	20 93 0d 0d 	sts	0x0D0D, r18	; 0x800d0d <uxTopReadyPriority>
    2552:	08 95       	ret

00002554 <vTaskPlaceOnEventList>:
    2554:	cf 93       	push	r28
    2556:	df 93       	push	r29
    2558:	eb 01       	movw	r28, r22
    255a:	60 91 67 0d 	lds	r22, 0x0D67	; 0x800d67 <pxCurrentTCB>
    255e:	70 91 68 0d 	lds	r23, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2562:	64 5f       	subi	r22, 0xF4	; 244
    2564:	7f 4f       	sbci	r23, 0xFF	; 255
    2566:	2f d8       	rcall	.-4002   	; 0x15c6 <vListInsert>
    2568:	61 e0       	ldi	r22, 0x01	; 1
    256a:	ce 01       	movw	r24, r28
    256c:	7c dc       	rcall	.-1800   	; 0x1e66 <prvAddCurrentTaskToDelayedList>
    256e:	df 91       	pop	r29
    2570:	cf 91       	pop	r28
    2572:	08 95       	ret

00002574 <xTaskRemoveFromEventList>:
    2574:	0f 93       	push	r16
    2576:	1f 93       	push	r17
    2578:	cf 93       	push	r28
    257a:	df 93       	push	r29
    257c:	dc 01       	movw	r26, r24
    257e:	15 96       	adiw	r26, 0x05	; 5
    2580:	ed 91       	ld	r30, X+
    2582:	fc 91       	ld	r31, X
    2584:	16 97       	sbiw	r26, 0x06	; 6
    2586:	c6 81       	ldd	r28, Z+6	; 0x06
    2588:	d7 81       	ldd	r29, Z+7	; 0x07
    258a:	8e 01       	movw	r16, r28
    258c:	04 5f       	subi	r16, 0xF4	; 244
    258e:	1f 4f       	sbci	r17, 0xFF	; 255
    2590:	c8 01       	movw	r24, r16
    2592:	4a d8       	rcall	.-3948   	; 0x1628 <uxListRemove>
    2594:	80 91 03 0d 	lds	r24, 0x0D03	; 0x800d03 <uxSchedulerSuspended>
    2598:	81 11       	cpse	r24, r1
    259a:	1b c0       	rjmp	.+54     	; 0x25d2 <xTaskRemoveFromEventList+0x5e>
    259c:	0a 50       	subi	r16, 0x0A	; 10
    259e:	11 09       	sbc	r17, r1
    25a0:	c8 01       	movw	r24, r16
    25a2:	42 d8       	rcall	.-3964   	; 0x1628 <uxListRemove>
    25a4:	8e 89       	ldd	r24, Y+22	; 0x16
    25a6:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    25aa:	98 17       	cp	r25, r24
    25ac:	10 f4       	brcc	.+4      	; 0x25b2 <xTaskRemoveFromEventList+0x3e>
    25ae:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    25b2:	90 e0       	ldi	r25, 0x00	; 0
    25b4:	9c 01       	movw	r18, r24
    25b6:	22 0f       	add	r18, r18
    25b8:	33 1f       	adc	r19, r19
    25ba:	22 0f       	add	r18, r18
    25bc:	33 1f       	adc	r19, r19
    25be:	22 0f       	add	r18, r18
    25c0:	33 1f       	adc	r19, r19
    25c2:	82 0f       	add	r24, r18
    25c4:	93 1f       	adc	r25, r19
    25c6:	b8 01       	movw	r22, r16
    25c8:	8d 5b       	subi	r24, 0xBD	; 189
    25ca:	92 4f       	sbci	r25, 0xF2	; 242
    25cc:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    25d0:	05 c0       	rjmp	.+10     	; 0x25dc <xTaskRemoveFromEventList+0x68>
    25d2:	b8 01       	movw	r22, r16
    25d4:	84 e2       	ldi	r24, 0x24	; 36
    25d6:	9d e0       	ldi	r25, 0x0D	; 13
    25d8:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    25dc:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    25e0:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    25e4:	9e 89       	ldd	r25, Y+22	; 0x16
    25e6:	86 89       	ldd	r24, Z+22	; 0x16
    25e8:	89 17       	cp	r24, r25
    25ea:	20 f4       	brcc	.+8      	; 0x25f4 <xTaskRemoveFromEventList+0x80>
    25ec:	81 e0       	ldi	r24, 0x01	; 1
    25ee:	80 93 0a 0d 	sts	0x0D0A, r24	; 0x800d0a <xYieldPending>
    25f2:	01 c0       	rjmp	.+2      	; 0x25f6 <xTaskRemoveFromEventList+0x82>
    25f4:	80 e0       	ldi	r24, 0x00	; 0
    25f6:	df 91       	pop	r29
    25f8:	cf 91       	pop	r28
    25fa:	1f 91       	pop	r17
    25fc:	0f 91       	pop	r16
    25fe:	08 95       	ret

00002600 <vTaskSetTimeOutState>:
    2600:	20 91 09 0d 	lds	r18, 0x0D09	; 0x800d09 <xNumOfOverflows>
    2604:	fc 01       	movw	r30, r24
    2606:	20 83       	st	Z, r18
    2608:	20 91 0e 0d 	lds	r18, 0x0D0E	; 0x800d0e <xTickCount>
    260c:	30 91 0f 0d 	lds	r19, 0x0D0F	; 0x800d0f <xTickCount+0x1>
    2610:	32 83       	std	Z+2, r19	; 0x02
    2612:	21 83       	std	Z+1, r18	; 0x01
    2614:	08 95       	ret

00002616 <xTaskCheckForTimeOut>:
    2616:	0f b6       	in	r0, 0x3f	; 63
    2618:	f8 94       	cli
    261a:	0f 92       	push	r0
    261c:	40 91 0e 0d 	lds	r20, 0x0D0E	; 0x800d0e <xTickCount>
    2620:	50 91 0f 0d 	lds	r21, 0x0D0F	; 0x800d0f <xTickCount+0x1>
    2624:	db 01       	movw	r26, r22
    2626:	2d 91       	ld	r18, X+
    2628:	3c 91       	ld	r19, X
    262a:	2f 3f       	cpi	r18, 0xFF	; 255
    262c:	bf ef       	ldi	r27, 0xFF	; 255
    262e:	3b 07       	cpc	r19, r27
    2630:	11 f1       	breq	.+68     	; 0x2676 <xTaskCheckForTimeOut+0x60>
    2632:	e0 91 09 0d 	lds	r30, 0x0D09	; 0x800d09 <xNumOfOverflows>
    2636:	dc 01       	movw	r26, r24
    2638:	fc 91       	ld	r31, X
    263a:	fe 17       	cp	r31, r30
    263c:	39 f0       	breq	.+14     	; 0x264c <xTaskCheckForTimeOut+0x36>
    263e:	11 96       	adiw	r26, 0x01	; 1
    2640:	ed 91       	ld	r30, X+
    2642:	fc 91       	ld	r31, X
    2644:	12 97       	sbiw	r26, 0x02	; 2
    2646:	4e 17       	cp	r20, r30
    2648:	5f 07       	cpc	r21, r31
    264a:	b8 f4       	brcc	.+46     	; 0x267a <xTaskCheckForTimeOut+0x64>
    264c:	dc 01       	movw	r26, r24
    264e:	11 96       	adiw	r26, 0x01	; 1
    2650:	ed 91       	ld	r30, X+
    2652:	fc 91       	ld	r31, X
    2654:	12 97       	sbiw	r26, 0x02	; 2
    2656:	da 01       	movw	r26, r20
    2658:	ae 1b       	sub	r26, r30
    265a:	bf 0b       	sbc	r27, r31
    265c:	a2 17       	cp	r26, r18
    265e:	b3 07       	cpc	r27, r19
    2660:	70 f4       	brcc	.+28     	; 0x267e <xTaskCheckForTimeOut+0x68>
    2662:	db 01       	movw	r26, r22
    2664:	e4 1b       	sub	r30, r20
    2666:	f5 0b       	sbc	r31, r21
    2668:	2e 0f       	add	r18, r30
    266a:	3f 1f       	adc	r19, r31
    266c:	2d 93       	st	X+, r18
    266e:	3c 93       	st	X, r19
    2670:	c7 df       	rcall	.-114    	; 0x2600 <vTaskSetTimeOutState>
    2672:	80 e0       	ldi	r24, 0x00	; 0
    2674:	05 c0       	rjmp	.+10     	; 0x2680 <xTaskCheckForTimeOut+0x6a>
    2676:	80 e0       	ldi	r24, 0x00	; 0
    2678:	03 c0       	rjmp	.+6      	; 0x2680 <xTaskCheckForTimeOut+0x6a>
    267a:	81 e0       	ldi	r24, 0x01	; 1
    267c:	01 c0       	rjmp	.+2      	; 0x2680 <xTaskCheckForTimeOut+0x6a>
    267e:	81 e0       	ldi	r24, 0x01	; 1
    2680:	0f 90       	pop	r0
    2682:	0f be       	out	0x3f, r0	; 63
    2684:	08 95       	ret

00002686 <vTaskMissedYield>:
    2686:	81 e0       	ldi	r24, 0x01	; 1
    2688:	80 93 0a 0d 	sts	0x0D0A, r24	; 0x800d0a <xYieldPending>
    268c:	08 95       	ret

0000268e <vTaskPriorityInherit>:
    268e:	0f 93       	push	r16
    2690:	1f 93       	push	r17
    2692:	cf 93       	push	r28
    2694:	df 93       	push	r29
    2696:	fc 01       	movw	r30, r24
    2698:	89 2b       	or	r24, r25
    269a:	09 f4       	brne	.+2      	; 0x269e <vTaskPriorityInherit+0x10>
    269c:	55 c0       	rjmp	.+170    	; 0x2748 <vTaskPriorityInherit+0xba>
    269e:	26 89       	ldd	r18, Z+22	; 0x16
    26a0:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    26a4:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    26a8:	56 96       	adiw	r26, 0x16	; 22
    26aa:	8c 91       	ld	r24, X
    26ac:	28 17       	cp	r18, r24
    26ae:	08 f0       	brcs	.+2      	; 0x26b2 <vTaskPriorityInherit+0x24>
    26b0:	4b c0       	rjmp	.+150    	; 0x2748 <vTaskPriorityInherit+0xba>
    26b2:	84 85       	ldd	r24, Z+12	; 0x0c
    26b4:	95 85       	ldd	r25, Z+13	; 0x0d
    26b6:	99 23       	and	r25, r25
    26b8:	64 f0       	brlt	.+24     	; 0x26d2 <vTaskPriorityInherit+0x44>
    26ba:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    26be:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    26c2:	56 96       	adiw	r26, 0x16	; 22
    26c4:	3c 91       	ld	r19, X
    26c6:	84 e0       	ldi	r24, 0x04	; 4
    26c8:	90 e0       	ldi	r25, 0x00	; 0
    26ca:	83 1b       	sub	r24, r19
    26cc:	91 09       	sbc	r25, r1
    26ce:	95 87       	std	Z+13, r25	; 0x0d
    26d0:	84 87       	std	Z+12, r24	; 0x0c
    26d2:	30 e0       	ldi	r19, 0x00	; 0
    26d4:	c9 01       	movw	r24, r18
    26d6:	88 0f       	add	r24, r24
    26d8:	99 1f       	adc	r25, r25
    26da:	88 0f       	add	r24, r24
    26dc:	99 1f       	adc	r25, r25
    26de:	88 0f       	add	r24, r24
    26e0:	99 1f       	adc	r25, r25
    26e2:	28 0f       	add	r18, r24
    26e4:	39 1f       	adc	r19, r25
    26e6:	2d 5b       	subi	r18, 0xBD	; 189
    26e8:	32 4f       	sbci	r19, 0xF2	; 242
    26ea:	82 85       	ldd	r24, Z+10	; 0x0a
    26ec:	93 85       	ldd	r25, Z+11	; 0x0b
    26ee:	82 17       	cp	r24, r18
    26f0:	93 07       	cpc	r25, r19
    26f2:	19 f5       	brne	.+70     	; 0x273a <vTaskPriorityInherit+0xac>
    26f4:	8f 01       	movw	r16, r30
    26f6:	ef 01       	movw	r28, r30
    26f8:	22 96       	adiw	r28, 0x02	; 2
    26fa:	ce 01       	movw	r24, r28
    26fc:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2700:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    2704:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2708:	86 89       	ldd	r24, Z+22	; 0x16
    270a:	f8 01       	movw	r30, r16
    270c:	86 8b       	std	Z+22, r24	; 0x16
    270e:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    2712:	98 17       	cp	r25, r24
    2714:	10 f4       	brcc	.+4      	; 0x271a <vTaskPriorityInherit+0x8c>
    2716:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    271a:	90 e0       	ldi	r25, 0x00	; 0
    271c:	9c 01       	movw	r18, r24
    271e:	22 0f       	add	r18, r18
    2720:	33 1f       	adc	r19, r19
    2722:	22 0f       	add	r18, r18
    2724:	33 1f       	adc	r19, r19
    2726:	22 0f       	add	r18, r18
    2728:	33 1f       	adc	r19, r19
    272a:	82 0f       	add	r24, r18
    272c:	93 1f       	adc	r25, r19
    272e:	be 01       	movw	r22, r28
    2730:	8d 5b       	subi	r24, 0xBD	; 189
    2732:	92 4f       	sbci	r25, 0xF2	; 242
    2734:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    2738:	07 c0       	rjmp	.+14     	; 0x2748 <vTaskPriorityInherit+0xba>
    273a:	a0 91 67 0d 	lds	r26, 0x0D67	; 0x800d67 <pxCurrentTCB>
    273e:	b0 91 68 0d 	lds	r27, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    2742:	56 96       	adiw	r26, 0x16	; 22
    2744:	8c 91       	ld	r24, X
    2746:	86 8b       	std	Z+22, r24	; 0x16
    2748:	df 91       	pop	r29
    274a:	cf 91       	pop	r28
    274c:	1f 91       	pop	r17
    274e:	0f 91       	pop	r16
    2750:	08 95       	ret

00002752 <xTaskPriorityDisinherit>:
    2752:	0f 93       	push	r16
    2754:	1f 93       	push	r17
    2756:	cf 93       	push	r28
    2758:	df 93       	push	r29
    275a:	fc 01       	movw	r30, r24
    275c:	89 2b       	or	r24, r25
    275e:	79 f1       	breq	.+94     	; 0x27be <xTaskPriorityDisinherit+0x6c>
    2760:	82 a1       	ldd	r24, Z+34	; 0x22
    2762:	81 50       	subi	r24, 0x01	; 1
    2764:	82 a3       	std	Z+34, r24	; 0x22
    2766:	26 89       	ldd	r18, Z+22	; 0x16
    2768:	91 a1       	ldd	r25, Z+33	; 0x21
    276a:	29 17       	cp	r18, r25
    276c:	51 f1       	breq	.+84     	; 0x27c2 <xTaskPriorityDisinherit+0x70>
    276e:	81 11       	cpse	r24, r1
    2770:	2a c0       	rjmp	.+84     	; 0x27c6 <xTaskPriorityDisinherit+0x74>
    2772:	ef 01       	movw	r28, r30
    2774:	8f 01       	movw	r16, r30
    2776:	0e 5f       	subi	r16, 0xFE	; 254
    2778:	1f 4f       	sbci	r17, 0xFF	; 255
    277a:	c8 01       	movw	r24, r16
    277c:	0e 94 14 0b 	call	0x1628	; 0x1628 <uxListRemove>
    2780:	89 a1       	ldd	r24, Y+33	; 0x21
    2782:	8e 8b       	std	Y+22, r24	; 0x16
    2784:	24 e0       	ldi	r18, 0x04	; 4
    2786:	30 e0       	ldi	r19, 0x00	; 0
    2788:	28 1b       	sub	r18, r24
    278a:	31 09       	sbc	r19, r1
    278c:	3d 87       	std	Y+13, r19	; 0x0d
    278e:	2c 87       	std	Y+12, r18	; 0x0c
    2790:	90 91 0d 0d 	lds	r25, 0x0D0D	; 0x800d0d <uxTopReadyPriority>
    2794:	98 17       	cp	r25, r24
    2796:	10 f4       	brcc	.+4      	; 0x279c <xTaskPriorityDisinherit+0x4a>
    2798:	80 93 0d 0d 	sts	0x0D0D, r24	; 0x800d0d <uxTopReadyPriority>
    279c:	90 e0       	ldi	r25, 0x00	; 0
    279e:	9c 01       	movw	r18, r24
    27a0:	22 0f       	add	r18, r18
    27a2:	33 1f       	adc	r19, r19
    27a4:	22 0f       	add	r18, r18
    27a6:	33 1f       	adc	r19, r19
    27a8:	22 0f       	add	r18, r18
    27aa:	33 1f       	adc	r19, r19
    27ac:	82 0f       	add	r24, r18
    27ae:	93 1f       	adc	r25, r19
    27b0:	b8 01       	movw	r22, r16
    27b2:	8d 5b       	subi	r24, 0xBD	; 189
    27b4:	92 4f       	sbci	r25, 0xF2	; 242
    27b6:	0e 94 c2 0a 	call	0x1584	; 0x1584 <vListInsertEnd>
    27ba:	81 e0       	ldi	r24, 0x01	; 1
    27bc:	05 c0       	rjmp	.+10     	; 0x27c8 <xTaskPriorityDisinherit+0x76>
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	03 c0       	rjmp	.+6      	; 0x27c8 <xTaskPriorityDisinherit+0x76>
    27c2:	80 e0       	ldi	r24, 0x00	; 0
    27c4:	01 c0       	rjmp	.+2      	; 0x27c8 <xTaskPriorityDisinherit+0x76>
    27c6:	80 e0       	ldi	r24, 0x00	; 0
    27c8:	df 91       	pop	r29
    27ca:	cf 91       	pop	r28
    27cc:	1f 91       	pop	r17
    27ce:	0f 91       	pop	r16
    27d0:	08 95       	ret

000027d2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    27d2:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxCurrentTCB>
    27d6:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    27da:	89 2b       	or	r24, r25
    27dc:	39 f0       	breq	.+14     	; 0x27ec <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    27de:	e0 91 67 0d 	lds	r30, 0x0D67	; 0x800d67 <pxCurrentTCB>
    27e2:	f0 91 68 0d 	lds	r31, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
    27e6:	82 a1       	ldd	r24, Z+34	; 0x22
    27e8:	8f 5f       	subi	r24, 0xFF	; 255
    27ea:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    27ec:	80 91 67 0d 	lds	r24, 0x0D67	; 0x800d67 <pxCurrentTCB>
    27f0:	90 91 68 0d 	lds	r25, 0x0D68	; 0x800d68 <pxCurrentTCB+0x1>
	}
    27f4:	08 95       	ret

000027f6 <__tablejump2__>:
    27f6:	ee 0f       	add	r30, r30
    27f8:	ff 1f       	adc	r31, r31
    27fa:	00 24       	eor	r0, r0
    27fc:	00 1c       	adc	r0, r0
    27fe:	0b be       	out	0x3b, r0	; 59
    2800:	07 90       	elpm	r0, Z+
    2802:	f6 91       	elpm	r31, Z
    2804:	e0 2d       	mov	r30, r0
    2806:	09 94       	ijmp

00002808 <memcpy>:
    2808:	fb 01       	movw	r30, r22
    280a:	dc 01       	movw	r26, r24
    280c:	02 c0       	rjmp	.+4      	; 0x2812 <memcpy+0xa>
    280e:	01 90       	ld	r0, Z+
    2810:	0d 92       	st	X+, r0
    2812:	41 50       	subi	r20, 0x01	; 1
    2814:	50 40       	sbci	r21, 0x00	; 0
    2816:	d8 f7       	brcc	.-10     	; 0x280e <memcpy+0x6>
    2818:	08 95       	ret

0000281a <__do_global_dtors>:
    281a:	10 e0       	ldi	r17, 0x00	; 0
    281c:	c7 e4       	ldi	r28, 0x47	; 71
    281e:	d0 e0       	ldi	r29, 0x00	; 0
    2820:	03 c0       	rjmp	.+6      	; 0x2828 <__do_global_dtors+0xe>
    2822:	fe 01       	movw	r30, r28
    2824:	e8 df       	rcall	.-48     	; 0x27f6 <__tablejump2__>
    2826:	21 96       	adiw	r28, 0x01	; 1
    2828:	c8 34       	cpi	r28, 0x48	; 72
    282a:	d1 07       	cpc	r29, r17
    282c:	d1 f7       	brne	.-12     	; 0x2822 <__do_global_dtors+0x8>
    282e:	f8 94       	cli

00002830 <__stop_program>:
    2830:	ff cf       	rjmp	.-2      	; 0x2830 <__stop_program>
