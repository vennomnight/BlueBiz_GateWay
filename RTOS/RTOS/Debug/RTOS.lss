
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000090  00800100  00002e8c  00002f20  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002e8c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c1d  00800190  00800190  00002fb0  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00002fb0  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002fe0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000808  00000000  00000000  00003020  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000ad64  00000000  00000000  00003828  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002e25  00000000  00000000  0000e58c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00004d51  00000000  00000000  000113b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000015b4  00000000  00000000  00016104  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00003103  00000000  00000000  000176b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007bd8  00000000  00000000  0001a7bb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000828  00000000  00000000  00022393  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	47 c0       	rjmp	.+142    	; 0x90 <__dtors_end>
       2:	00 00       	nop
       4:	6f c0       	rjmp	.+222    	; 0xe4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c0       	rjmp	.+218    	; 0xe4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c0       	rjmp	.+214    	; 0xe4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c0       	rjmp	.+210    	; 0xe4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c0       	rjmp	.+206    	; 0xe4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c0       	rjmp	.+202    	; 0xe4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c0       	rjmp	.+198    	; 0xe4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c0       	rjmp	.+194    	; 0xe4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c0       	rjmp	.+190    	; 0xe4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c0       	rjmp	.+186    	; 0xe4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c0       	rjmp	.+182    	; 0xe4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__vector_12>
      34:	57 c0       	rjmp	.+174    	; 0xe4 <__bad_interrupt>
      36:	00 00       	nop
      38:	55 c0       	rjmp	.+170    	; 0xe4 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	53 c0       	rjmp	.+166    	; 0xe4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c0       	rjmp	.+162    	; 0xe4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c0       	rjmp	.+158    	; 0xe4 <__bad_interrupt>
      46:	00 00       	nop
      48:	5a c2       	rjmp	.+1204   	; 0x4fe <__vector_18>
      4a:	00 00       	nop
      4c:	4b c0       	rjmp	.+150    	; 0xe4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c0       	rjmp	.+146    	; 0xe4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c0       	rjmp	.+142    	; 0xe4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c0       	rjmp	.+138    	; 0xe4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c0       	rjmp	.+134    	; 0xe4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c0       	rjmp	.+130    	; 0xe4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c0       	rjmp	.+126    	; 0xe4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c0       	rjmp	.+122    	; 0xe4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c0       	rjmp	.+118    	; 0xe4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	a7 c2       	rjmp	.+1358   	; 0x5c0 <__vector_28>
      72:	00 00       	nop
      74:	37 c0       	rjmp	.+110    	; 0xe4 <__bad_interrupt>
      76:	00 00       	nop
      78:	72 c2       	rjmp	.+1252   	; 0x55e <__vector_30>
      7a:	00 00       	nop
      7c:	33 c0       	rjmp	.+102    	; 0xe4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c0       	rjmp	.+98     	; 0xe4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c0       	rjmp	.+94     	; 0xe4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c0       	rjmp	.+90     	; 0xe4 <__bad_interrupt>
	...

0000008c <__ctors_start>:
      8c:	2d 03       	fmul	r18, r21

0000008e <__ctors_end>:
      8e:	31 03       	mulsu	r19, r17

00000090 <__dtors_end>:
      90:	11 24       	eor	r1, r1
      92:	1f be       	out	0x3f, r1	; 63
      94:	cf ef       	ldi	r28, 0xFF	; 255
      96:	d0 e1       	ldi	r29, 0x10	; 16
      98:	de bf       	out	0x3e, r29	; 62
      9a:	cd bf       	out	0x3d, r28	; 61

0000009c <__do_copy_data>:
      9c:	11 e0       	ldi	r17, 0x01	; 1
      9e:	a0 e0       	ldi	r26, 0x00	; 0
      a0:	b1 e0       	ldi	r27, 0x01	; 1
      a2:	ec e8       	ldi	r30, 0x8C	; 140
      a4:	fe e2       	ldi	r31, 0x2E	; 46
      a6:	00 e0       	ldi	r16, 0x00	; 0
      a8:	0b bf       	out	0x3b, r16	; 59
      aa:	02 c0       	rjmp	.+4      	; 0xb0 <__do_copy_data+0x14>
      ac:	07 90       	elpm	r0, Z+
      ae:	0d 92       	st	X+, r0
      b0:	a0 39       	cpi	r26, 0x90	; 144
      b2:	b1 07       	cpc	r27, r17
      b4:	d9 f7       	brne	.-10     	; 0xac <__do_copy_data+0x10>

000000b6 <__do_clear_bss>:
      b6:	2d e0       	ldi	r18, 0x0D	; 13
      b8:	a0 e9       	ldi	r26, 0x90	; 144
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	01 c0       	rjmp	.+2      	; 0xc0 <.do_clear_bss_start>

000000be <.do_clear_bss_loop>:
      be:	1d 92       	st	X+, r1

000000c0 <.do_clear_bss_start>:
      c0:	ad 3a       	cpi	r26, 0xAD	; 173
      c2:	b2 07       	cpc	r27, r18
      c4:	e1 f7       	brne	.-8      	; 0xbe <.do_clear_bss_loop>

000000c6 <__do_global_ctors>:
      c6:	10 e0       	ldi	r17, 0x00	; 0
      c8:	c7 e4       	ldi	r28, 0x47	; 71
      ca:	d0 e0       	ldi	r29, 0x00	; 0
      cc:	04 c0       	rjmp	.+8      	; 0xd6 <__do_global_ctors+0x10>
      ce:	21 97       	sbiw	r28, 0x01	; 1
      d0:	fe 01       	movw	r30, r28
      d2:	0e 94 0f 17 	call	0x2e1e	; 0x2e1e <__tablejump2__>
      d6:	c6 34       	cpi	r28, 0x46	; 70
      d8:	d1 07       	cpc	r29, r17
      da:	c9 f7       	brne	.-14     	; 0xce <__do_global_ctors+0x8>
      dc:	0e 94 a6 0b 	call	0x174c	; 0x174c <main>
      e0:	0c 94 3a 17 	jmp	0x2e74	; 0x2e74 <__do_global_dtors>

000000e4 <__bad_interrupt>:
      e4:	8d cf       	rjmp	.-230    	; 0x0 <__vectors>

000000e6 <_Z5CRC16Phi>:
	function01->ByteCount = 0x02;
	function01->OutPutStatus1 = func1mem[*(buf + 3)];
	function01->OutPutStatus2 = func1mem[(*(buf + 3)) + 1];
	crc16 = CRC16((unsigned char*)function01, BUFSIZE - 2);
	function01->CRC = crc16;
}
      e6:	fc 01       	movw	r30, r24
      e8:	68 0f       	add	r22, r24
      ea:	79 1f       	adc	r23, r25
      ec:	8f ef       	ldi	r24, 0xFF	; 255
      ee:	9f ef       	ldi	r25, 0xFF	; 255
      f0:	e6 17       	cp	r30, r22
      f2:	f7 07       	cpc	r31, r23
      f4:	99 f0       	breq	.+38     	; 0x11c <_Z5CRC16Phi+0x36>
      f6:	21 91       	ld	r18, Z+
      f8:	82 27       	eor	r24, r18
      fa:	28 e0       	ldi	r18, 0x08	; 8
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	ac 01       	movw	r20, r24
     100:	41 70       	andi	r20, 0x01	; 1
     102:	55 27       	eor	r21, r21
     104:	96 95       	lsr	r25
     106:	87 95       	ror	r24
     108:	45 2b       	or	r20, r21
     10a:	21 f0       	breq	.+8      	; 0x114 <_Z5CRC16Phi+0x2e>
     10c:	41 e0       	ldi	r20, 0x01	; 1
     10e:	84 27       	eor	r24, r20
     110:	40 ea       	ldi	r20, 0xA0	; 160
     112:	94 27       	eor	r25, r20
     114:	21 50       	subi	r18, 0x01	; 1
     116:	31 09       	sbc	r19, r1
     118:	91 f7       	brne	.-28     	; 0xfe <_Z5CRC16Phi+0x18>
     11a:	ea cf       	rjmp	.-44     	; 0xf0 <_Z5CRC16Phi+0xa>
     11c:	08 95       	ret

0000011e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>:
void GetFunc04Data(char* buf,GetFunctionCode04* function04,int* func4mem)
{
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	dc 01       	movw	r26, r24
     124:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode04);
	char address = 0;
	function04->Address = *(buf + 0);
     126:	8c 91       	ld	r24, X
     128:	88 83       	st	Y, r24
	function04->FunctionCode = *(buf + 1);
     12a:	11 96       	adiw	r26, 0x01	; 1
     12c:	8c 91       	ld	r24, X
     12e:	11 97       	sbiw	r26, 0x01	; 1
     130:	89 83       	std	Y+1, r24	; 0x01
	address = *(buf + 3);
     132:	13 96       	adiw	r26, 0x03	; 3
     134:	8c 91       	ld	r24, X
	function04->ByteCount = 0x02;
     136:	92 e0       	ldi	r25, 0x02	; 2
     138:	9a 83       	std	Y+2, r25	; 0x02
	function04->InputRegHi = (func4mem[address] >> 8);
     13a:	e8 2f       	mov	r30, r24
     13c:	f0 e0       	ldi	r31, 0x00	; 0
     13e:	ee 0f       	add	r30, r30
     140:	ff 1f       	adc	r31, r31
     142:	e4 0f       	add	r30, r20
     144:	f5 1f       	adc	r31, r21
     146:	81 81       	ldd	r24, Z+1	; 0x01
     148:	8b 83       	std	Y+3, r24	; 0x03
	function04->InputRegLo = func4mem[address];
     14a:	80 81       	ld	r24, Z
     14c:	8c 83       	std	Y+4, r24	; 0x04
	crc16 = CRC16((unsigned char*)function04, BUFSIZE - 2);
     14e:	65 e0       	ldi	r22, 0x05	; 5
     150:	70 e0       	ldi	r23, 0x00	; 0
     152:	ce 01       	movw	r24, r28
     154:	c8 df       	rcall	.-112    	; 0xe6 <_Z5CRC16Phi>
	function04->CRC = crc16;
     156:	9e 83       	std	Y+6, r25	; 0x06
     158:	8d 83       	std	Y+5, r24	; 0x05
}
     15a:	df 91       	pop	r29
     15c:	cf 91       	pop	r28
     15e:	08 95       	ret

00000160 <_Z13GetFunc05DataPcP17GetFunctionCode05>:
void GetFunc05Data(char* buf,GetFunctionCode05* function05)
{
     160:	cf 93       	push	r28
     162:	df 93       	push	r29
     164:	fc 01       	movw	r30, r24
     166:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode05);
	function05->Address = *(buf + 0);
     168:	80 81       	ld	r24, Z
     16a:	88 83       	st	Y, r24
	function05->FunctionCode = *(buf + 1);
     16c:	81 81       	ldd	r24, Z+1	; 0x01
     16e:	89 83       	std	Y+1, r24	; 0x01
	function05->OutputAddressHi = *(buf + 2);
     170:	82 81       	ldd	r24, Z+2	; 0x02
     172:	8a 83       	std	Y+2, r24	; 0x02
	function05->OutputAddressLo = *(buf + 3);
     174:	83 81       	ldd	r24, Z+3	; 0x03
     176:	8b 83       	std	Y+3, r24	; 0x03
	function05->OutputValueHi = *(buf + 4);
     178:	84 81       	ldd	r24, Z+4	; 0x04
     17a:	8c 83       	std	Y+4, r24	; 0x04
	function05->OutputValueLo = *(buf + 5);
     17c:	85 81       	ldd	r24, Z+5	; 0x05
     17e:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)function05, BUFSIZE - 2);
     180:	66 e0       	ldi	r22, 0x06	; 6
     182:	70 e0       	ldi	r23, 0x00	; 0
     184:	ce 01       	movw	r24, r28
     186:	af df       	rcall	.-162    	; 0xe6 <_Z5CRC16Phi>
	function05->CRC = crc16;//to_little(crc16);
     188:	9f 83       	std	Y+7, r25	; 0x07
     18a:	8e 83       	std	Y+6, r24	; 0x06
}
     18c:	df 91       	pop	r29
     18e:	cf 91       	pop	r28
     190:	08 95       	ret

00000192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>:
void GetFucc10Data(char* buf,GetFunctionCode10* function10,int* func4mem)
{
     192:	cf 93       	push	r28
     194:	df 93       	push	r29
     196:	fc 01       	movw	r30, r24
     198:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(GetFunctionCode10);
	function10->address = *(buf + 0);
     19a:	80 81       	ld	r24, Z
     19c:	88 83       	st	Y, r24
	function10->functionCode = *(buf + 1);
     19e:	81 81       	ldd	r24, Z+1	; 0x01
     1a0:	89 83       	std	Y+1, r24	; 0x01
	function10->startingAddressHi = *(buf + 2);
     1a2:	82 81       	ldd	r24, Z+2	; 0x02
     1a4:	8a 83       	std	Y+2, r24	; 0x02
	function10->startingAddressLo = *(buf + 3);
     1a6:	83 81       	ldd	r24, Z+3	; 0x03
     1a8:	8b 83       	std	Y+3, r24	; 0x03
	function10->quantityOfRegistersHi = *(buf + 4);
     1aa:	94 81       	ldd	r25, Z+4	; 0x04
     1ac:	9c 83       	std	Y+4, r25	; 0x04
	function10->quantityOfRegistersLo = *(buf + 5);
     1ae:	95 81       	ldd	r25, Z+5	; 0x05
     1b0:	9d 83       	std	Y+5, r25	; 0x05
	function10->byteCount = *(buf + 6);
     1b2:	96 81       	ldd	r25, Z+6	; 0x06
     1b4:	9e 83       	std	Y+6, r25	; 0x06
	function10->registerValueHi = *(buf + 7);
     1b6:	27 81       	ldd	r18, Z+7	; 0x07
     1b8:	2f 83       	std	Y+7, r18	; 0x07
	function10->registerValueLo = *(buf + 8);
     1ba:	90 85       	ldd	r25, Z+8	; 0x08
     1bc:	98 87       	std	Y+8, r25	; 0x08
	func4mem[function10->startingAddressLo] = ((function10->registerValueHi << 8) | (function10->registerValueLo));
     1be:	e8 2f       	mov	r30, r24
     1c0:	f0 e0       	ldi	r31, 0x00	; 0
     1c2:	ee 0f       	add	r30, r30
     1c4:	ff 1f       	adc	r31, r31
     1c6:	e4 0f       	add	r30, r20
     1c8:	f5 1f       	adc	r31, r21
     1ca:	89 2f       	mov	r24, r25
     1cc:	90 e0       	ldi	r25, 0x00	; 0
     1ce:	92 2b       	or	r25, r18
     1d0:	91 83       	std	Z+1, r25	; 0x01
     1d2:	80 83       	st	Z, r24
	crc16 = CRC16((unsigned char*)function10, BUFSIZE - 2);
     1d4:	69 e0       	ldi	r22, 0x09	; 9
     1d6:	70 e0       	ldi	r23, 0x00	; 0
     1d8:	ce 01       	movw	r24, r28
     1da:	85 df       	rcall	.-246    	; 0xe6 <_Z5CRC16Phi>
	function10->CRC = crc16;
     1dc:	9a 87       	std	Y+10, r25	; 0x0a
     1de:	89 87       	std	Y+9, r24	; 0x09
}
     1e0:	df 91       	pop	r29
     1e2:	cf 91       	pop	r28
     1e4:	08 95       	ret

000001e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>:
void ResponseFucc10Data(char* buf,ResponseFunctionCode10 *rfunction10)
{
     1e6:	cf 93       	push	r28
     1e8:	df 93       	push	r29
     1ea:	fc 01       	movw	r30, r24
     1ec:	eb 01       	movw	r28, r22
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(ResponseFunctionCode10);
	rfunction10->address = *(buf + 0);
     1ee:	80 81       	ld	r24, Z
     1f0:	88 83       	st	Y, r24
	rfunction10->functionCode = *(buf + 1);
     1f2:	81 81       	ldd	r24, Z+1	; 0x01
     1f4:	89 83       	std	Y+1, r24	; 0x01
	rfunction10->startingAddressHi = *(buf + 2);
     1f6:	82 81       	ldd	r24, Z+2	; 0x02
     1f8:	8a 83       	std	Y+2, r24	; 0x02
	rfunction10->startingAddressLo = *(buf + 3);
     1fa:	83 81       	ldd	r24, Z+3	; 0x03
     1fc:	8b 83       	std	Y+3, r24	; 0x03
	rfunction10->quantityOfRegistersHi = *(buf + 4);
     1fe:	84 81       	ldd	r24, Z+4	; 0x04
     200:	8c 83       	std	Y+4, r24	; 0x04
	rfunction10->quantityOfRegistersLo = *(buf + 5);
     202:	85 81       	ldd	r24, Z+5	; 0x05
     204:	8d 83       	std	Y+5, r24	; 0x05
	crc16 = CRC16((unsigned char*)rfunction10, BUFSIZE - 2);
     206:	66 e0       	ldi	r22, 0x06	; 6
     208:	70 e0       	ldi	r23, 0x00	; 0
     20a:	ce 01       	movw	r24, r28
     20c:	6c df       	rcall	.-296    	; 0xe6 <_Z5CRC16Phi>
	rfunction10->CRC = crc16;
     20e:	9f 83       	std	Y+7, r25	; 0x07
     210:	8e 83       	std	Y+6, r24	; 0x06
}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <_Z16GetExceptionCodeP16RspExceptionCodecc>:
void GetExceptionCode(RspExceptionCode* Exception,char adr,char Exception_code)
{
     218:	cf 93       	push	r28
     21a:	df 93       	push	r29
     21c:	ec 01       	movw	r28, r24
	unsigned short crc16;
	unsigned int BUFSIZE = sizeof(RspExceptionCode);
	Exception->Address = adr;
     21e:	68 83       	st	Y, r22
	Exception->FunctionCode = 0x81;
     220:	81 e8       	ldi	r24, 0x81	; 129
     222:	89 83       	std	Y+1, r24	; 0x01
	Exception->ExceptionCode = Exception_code;
     224:	4a 83       	std	Y+2, r20	; 0x02
	crc16 = CRC16((unsigned char*)Exception, BUFSIZE - 2);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	70 e0       	ldi	r23, 0x00	; 0
     22a:	ce 01       	movw	r24, r28
     22c:	5c df       	rcall	.-328    	; 0xe6 <_Z5CRC16Phi>
	Exception->CRC = crc16;
     22e:	9c 83       	std	Y+4, r25	; 0x04
     230:	8b 83       	std	Y+3, r24	; 0x03
}
     232:	df 91       	pop	r29
     234:	cf 91       	pop	r28
     236:	08 95       	ret

00000238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>:
	Temp = Integer % 10;	
	Temp = HexaString[Temp];
	dev->Write(this->type,Temp);

	
}
     238:	1f 93       	push	r17
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	ec 01       	movw	r28, r24
     240:	cb 01       	movw	r24, r22
     242:	14 2f       	mov	r17, r20
     244:	fe 01       	movw	r30, r28
     246:	ea 57       	subi	r30, 0x7A	; 122
     248:	ff 4f       	sbci	r31, 0xFF	; 255
     24a:	71 83       	std	Z+1, r23	; 0x01
     24c:	60 83       	st	Z, r22
     24e:	64 2f       	mov	r22, r20
     250:	40 d1       	rcall	.+640    	; 0x4d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>
     252:	88 23       	and	r24, r24
     254:	71 f0       	breq	.+28     	; 0x272 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x3a>
     256:	fe 01       	movw	r30, r28
     258:	eb 57       	subi	r30, 0x7B	; 123
     25a:	ff 4f       	sbci	r31, 0xFF	; 255
     25c:	10 83       	st	Z, r17
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	10 82       	st	Z, r1
     262:	34 97       	sbiw	r30, 0x04	; 4
     264:	11 82       	std	Z+1, r1	; 0x01
     266:	10 82       	st	Z, r1
     268:	ce 57       	subi	r28, 0x7E	; 126
     26a:	df 4f       	sbci	r29, 0xFF	; 255
     26c:	19 82       	std	Y+1, r1	; 0x01
     26e:	18 82       	st	Y, r1
     270:	04 c0       	rjmp	.+8      	; 0x27a <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type+0x42>
     272:	ca 57       	subi	r28, 0x7A	; 122
     274:	df 4f       	sbci	r29, 0xFF	; 255
     276:	19 82       	std	Y+1, r1	; 0x01
     278:	18 82       	st	Y, r1
     27a:	df 91       	pop	r29
     27c:	cf 91       	pop	r28
     27e:	1f 91       	pop	r17
     280:	08 95       	ret

00000282 <_ZN12SerialBuffernwEj>:
     282:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <pvPortMalloc>
     286:	08 95       	ret

00000288 <_ZN12SerialBuffer11SerialstoreEc>:
     288:	fc 01       	movw	r30, r24
     28a:	e0 58       	subi	r30, 0x80	; 128
     28c:	ff 4f       	sbci	r31, 0xFF	; 255
     28e:	20 81       	ld	r18, Z
     290:	2f 5f       	subi	r18, 0xFF	; 255
     292:	2f 77       	andi	r18, 0x7F	; 127
     294:	19 f4       	brne	.+6      	; 0x29c <_ZN12SerialBuffer11SerialstoreEc+0x14>
     296:	11 82       	std	Z+1, r1	; 0x01
     298:	10 82       	st	Z, r1
     29a:	21 e0       	ldi	r18, 0x01	; 1
     29c:	30 e0       	ldi	r19, 0x00	; 0
     29e:	fc 01       	movw	r30, r24
     2a0:	ee 57       	subi	r30, 0x7E	; 126
     2a2:	ff 4f       	sbci	r31, 0xFF	; 255
     2a4:	40 81       	ld	r20, Z
     2a6:	51 81       	ldd	r21, Z+1	; 0x01
     2a8:	24 17       	cp	r18, r20
     2aa:	35 07       	cpc	r19, r21
     2ac:	89 f0       	breq	.+34     	; 0x2d0 <_ZN12SerialBuffer11SerialstoreEc+0x48>
     2ae:	dc 01       	movw	r26, r24
     2b0:	a0 58       	subi	r26, 0x80	; 128
     2b2:	bf 4f       	sbci	r27, 0xFF	; 255
     2b4:	ed 91       	ld	r30, X+
     2b6:	fc 91       	ld	r31, X
     2b8:	11 97       	sbiw	r26, 0x01	; 1
     2ba:	e8 0f       	add	r30, r24
     2bc:	f9 1f       	adc	r31, r25
     2be:	61 83       	std	Z+1, r22	; 0x01
     2c0:	2d 93       	st	X+, r18
     2c2:	3c 93       	st	X, r19
     2c4:	fc 01       	movw	r30, r24
     2c6:	ec 57       	subi	r30, 0x7C	; 124
     2c8:	ff 4f       	sbci	r31, 0xFF	; 255
     2ca:	80 81       	ld	r24, Z
     2cc:	8f 5f       	subi	r24, 0xFF	; 255
     2ce:	80 83       	st	Z, r24
     2d0:	08 95       	ret

000002d2 <_ZN12SerialBuffer11SerialWriteEPKci>:
     2d2:	af 92       	push	r10
     2d4:	bf 92       	push	r11
     2d6:	cf 92       	push	r12
     2d8:	df 92       	push	r13
     2da:	ef 92       	push	r14
     2dc:	ff 92       	push	r15
     2de:	0f 93       	push	r16
     2e0:	1f 93       	push	r17
     2e2:	cf 93       	push	r28
     2e4:	8c 01       	movw	r16, r24
     2e6:	6b 01       	movw	r12, r22
     2e8:	7a 01       	movw	r14, r20
     2ea:	dc 01       	movw	r26, r24
     2ec:	ab 57       	subi	r26, 0x7B	; 123
     2ee:	bf 4f       	sbci	r27, 0xFF	; 255
     2f0:	fc 01       	movw	r30, r24
     2f2:	ea 57       	subi	r30, 0x7A	; 122
     2f4:	ff 4f       	sbci	r31, 0xFF	; 255
     2f6:	6c 91       	ld	r22, X
     2f8:	80 81       	ld	r24, Z
     2fa:	91 81       	ldd	r25, Z+1	; 0x01
     2fc:	f7 d0       	rcall	.+494    	; 0x4ec <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>
     2fe:	89 2b       	or	r24, r25
     300:	d1 f0       	breq	.+52     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     302:	1e 14       	cp	r1, r14
     304:	1f 04       	cpc	r1, r15
     306:	bc f4       	brge	.+46     	; 0x336 <_ZN12SerialBuffer11SerialWriteEPKci+0x64>
     308:	c0 e0       	ldi	r28, 0x00	; 0
     30a:	58 01       	movw	r10, r16
     30c:	85 e8       	ldi	r24, 0x85	; 133
     30e:	a8 0e       	add	r10, r24
     310:	b1 1c       	adc	r11, r1
     312:	0a 57       	subi	r16, 0x7A	; 122
     314:	1f 4f       	sbci	r17, 0xFF	; 255
     316:	f6 01       	movw	r30, r12
     318:	ec 0f       	add	r30, r28
     31a:	f1 1d       	adc	r31, r1
     31c:	40 81       	ld	r20, Z
     31e:	f5 01       	movw	r30, r10
     320:	60 81       	ld	r22, Z
     322:	f8 01       	movw	r30, r16
     324:	80 81       	ld	r24, Z
     326:	91 81       	ldd	r25, Z+1	; 0x01
     328:	8d d0       	rcall	.+282    	; 0x444 <_ZN11Dev_Manager5WriteE8Dev_typec>
     32a:	cf 5f       	subi	r28, 0xFF	; 255
     32c:	2c 2f       	mov	r18, r28
     32e:	30 e0       	ldi	r19, 0x00	; 0
     330:	2e 15       	cp	r18, r14
     332:	3f 05       	cpc	r19, r15
     334:	84 f3       	brlt	.-32     	; 0x316 <_ZN12SerialBuffer11SerialWriteEPKci+0x44>
     336:	cf 91       	pop	r28
     338:	1f 91       	pop	r17
     33a:	0f 91       	pop	r16
     33c:	ff 90       	pop	r15
     33e:	ef 90       	pop	r14
     340:	df 90       	pop	r13
     342:	cf 90       	pop	r12
     344:	bf 90       	pop	r11
     346:	af 90       	pop	r10
     348:	08 95       	ret

0000034a <_ZN12SerialBuffer10SerialReadEv>:
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
     34a:	fc 01       	movw	r30, r24
     34c:	ee 57       	subi	r30, 0x7E	; 126
     34e:	ff 4f       	sbci	r31, 0xFF	; 255
     350:	20 81       	ld	r18, Z
     352:	31 81       	ldd	r19, Z+1	; 0x01
     354:	32 97       	sbiw	r30, 0x02	; 2
     356:	40 81       	ld	r20, Z
     358:	51 81       	ldd	r21, Z+1	; 0x01
     35a:	42 17       	cp	r20, r18
     35c:	53 07       	cpc	r21, r19
     35e:	e9 f0       	breq	.+58     	; 0x39a <_ZN12SerialBuffer10SerialReadEv+0x50>
	{
		return -1;
	}
	else
	{
		unsigned char data = ib.internalBuffer[ib.tail + 1];
     360:	2f 5f       	subi	r18, 0xFF	; 255
     362:	3f 4f       	sbci	r19, 0xFF	; 255
     364:	fc 01       	movw	r30, r24
     366:	e2 0f       	add	r30, r18
     368:	f3 1f       	adc	r31, r19
     36a:	40 81       	ld	r20, Z
		ib.tail = (ib.tail + 1) % RX_BUFFER_SIZE;
     36c:	2f 77       	andi	r18, 0x7F	; 127
     36e:	33 27       	eor	r19, r19
     370:	fc 01       	movw	r30, r24
     372:	ee 57       	subi	r30, 0x7E	; 126
     374:	ff 4f       	sbci	r31, 0xFF	; 255
     376:	31 83       	std	Z+1, r19	; 0x01
     378:	20 83       	st	Z, r18
		if (ib.tail == num)
     37a:	32 96       	adiw	r30, 0x02	; 2
     37c:	60 81       	ld	r22, Z
     37e:	70 e0       	ldi	r23, 0x00	; 0
     380:	26 17       	cp	r18, r22
     382:	37 07       	cpc	r19, r23
     384:	61 f4       	brne	.+24     	; 0x39e <_ZN12SerialBuffer10SerialReadEv+0x54>
		{
			ib.tail = 0;
     386:	32 97       	sbiw	r30, 0x02	; 2
     388:	11 82       	std	Z+1, r1	; 0x01
     38a:	10 82       	st	Z, r1
			ib.head = 0;
     38c:	32 97       	sbiw	r30, 0x02	; 2
     38e:	11 82       	std	Z+1, r1	; 0x01
     390:	10 82       	st	Z, r1
			num = 0;
     392:	34 96       	adiw	r30, 0x04	; 4
     394:	10 82       	st	Z, r1
		}
		return data;
     396:	84 2f       	mov	r24, r20
     398:	08 95       	ret
}
char SerialBuffer::SerialRead(void) //데이터 읽기
{
	if (ib.head == ib.tail)
	{
		return -1;
     39a:	8f ef       	ldi	r24, 0xFF	; 255
     39c:	08 95       	ret
		{
			ib.tail = 0;
			ib.head = 0;
			num = 0;
		}
		return data;
     39e:	84 2f       	mov	r24, r20
	}
}
     3a0:	08 95       	ret

000003a2 <_ZN12SerialBuffer15SerialAvailableEv>:
unsigned char SerialBuffer::SerialAvailable(void) // 가용 자원수 확인
{
	return (unsigned char)(RX_BUFFER_SIZE + (ib.head - ib.tail)) % RX_BUFFER_SIZE;
     3a2:	dc 01       	movw	r26, r24
     3a4:	a0 58       	subi	r26, 0x80	; 128
     3a6:	bf 4f       	sbci	r27, 0xFF	; 255
     3a8:	fc 01       	movw	r30, r24
     3aa:	ee 57       	subi	r30, 0x7E	; 126
     3ac:	ff 4f       	sbci	r31, 0xFF	; 255
     3ae:	8c 91       	ld	r24, X
     3b0:	90 81       	ld	r25, Z
     3b2:	89 1b       	sub	r24, r25
}
     3b4:	8f 77       	andi	r24, 0x7F	; 127
     3b6:	08 95       	ret

000003b8 <_ZN12SerialBuffer11SerialFlushEv>:

void SerialBuffer::SerialFlush(void)// 버퍼를 비운다.
{
	ib.tail = 0;
     3b8:	fc 01       	movw	r30, r24
     3ba:	ee 57       	subi	r30, 0x7E	; 126
     3bc:	ff 4f       	sbci	r31, 0xFF	; 255
     3be:	11 82       	std	Z+1, r1	; 0x01
     3c0:	10 82       	st	Z, r1
	ib.head = 0;
     3c2:	32 97       	sbiw	r30, 0x02	; 2
     3c4:	11 82       	std	Z+1, r1	; 0x01
     3c6:	10 82       	st	Z, r1
	num = 0;
     3c8:	34 96       	adiw	r30, 0x04	; 4
     3ca:	10 82       	st	Z, r1
     3cc:	08 95       	ret

000003ce <_ZN11Dev_ManagerC1Ev>:
}
void Dev_Manager::Close_Handle(Dev_type Device)
{
	if(interface[Device])
	{
		isr_handle[Device] = nullptr;
     3ce:	26 e0       	ldi	r18, 0x06	; 6
     3d0:	dc 01       	movw	r26, r24
     3d2:	e2 2f       	mov	r30, r18
     3d4:	1d 92       	st	X+, r1
     3d6:	ea 95       	dec	r30
     3d8:	e9 f7       	brne	.-6      	; 0x3d4 <_ZN11Dev_ManagerC1Ev+0x6>
     3da:	fc 01       	movw	r30, r24
     3dc:	36 96       	adiw	r30, 0x06	; 6
     3de:	df 01       	movw	r26, r30
     3e0:	1d 92       	st	X+, r1
     3e2:	2a 95       	dec	r18
     3e4:	e9 f7       	brne	.-6      	; 0x3e0 <_ZN11Dev_ManagerC1Ev+0x12>
     3e6:	90 93 91 01 	sts	0x0191, r25	; 0x800191 <__data_end+0x1>
     3ea:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <__data_end>
     3ee:	08 95       	ret

000003f0 <_ZN11Dev_ManagerD1Ev>:
     3f0:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <__data_end+0x1>
     3f4:	10 92 90 01 	sts	0x0190, r1	; 0x800190 <__data_end>
     3f8:	08 95       	ret

000003fa <_ZN11Dev_Manager11getInstanceEv>:
     3fa:	cf 93       	push	r28
     3fc:	df 93       	push	r29
     3fe:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <__data_end>
     402:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <__data_end+0x1>
     406:	89 2b       	or	r24, r25
     408:	51 f4       	brne	.+20     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     40a:	8c e0       	ldi	r24, 0x0C	; 12
     40c:	90 e0       	ldi	r25, 0x00	; 0
     40e:	0e 94 4c 0c 	call	0x1898	; 0x1898 <pvPortMalloc>
     412:	ec 01       	movw	r28, r24
     414:	dc df       	rcall	.-72     	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     416:	d0 93 91 01 	sts	0x0191, r29	; 0x800191 <__data_end+0x1>
     41a:	c0 93 90 01 	sts	0x0190, r28	; 0x800190 <__data_end>
     41e:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <__data_end>
     422:	90 91 91 01 	lds	r25, 0x0191	; 0x800191 <__data_end+0x1>
     426:	df 91       	pop	r29
     428:	cf 91       	pop	r28
     42a:	08 95       	ret

0000042c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>:
     42c:	50 e0       	ldi	r21, 0x00	; 0
     42e:	44 0f       	add	r20, r20
     430:	55 1f       	adc	r21, r21
     432:	84 0f       	add	r24, r20
     434:	95 1f       	adc	r25, r21
     436:	fc 01       	movw	r30, r24
     438:	71 83       	std	Z+1, r23	; 0x01
     43a:	60 83       	st	Z, r22
     43c:	08 95       	ret

0000043e <_ZN11Dev_ManagernwEj>:
     43e:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <pvPortMalloc>
     442:	08 95       	ret

00000444 <_ZN11Dev_Manager5WriteE8Dev_typec>:
     444:	26 2f       	mov	r18, r22
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	22 0f       	add	r18, r18
     44a:	33 1f       	adc	r19, r19
     44c:	82 0f       	add	r24, r18
     44e:	93 1f       	adc	r25, r19
     450:	dc 01       	movw	r26, r24
     452:	8d 91       	ld	r24, X+
     454:	9c 91       	ld	r25, X
     456:	00 97       	sbiw	r24, 0x00	; 0
     458:	41 f0       	breq	.+16     	; 0x46a <_ZN11Dev_Manager5WriteE8Dev_typec+0x26>
     45a:	64 2f       	mov	r22, r20
     45c:	dc 01       	movw	r26, r24
     45e:	ed 91       	ld	r30, X+
     460:	fc 91       	ld	r31, X
     462:	06 80       	ldd	r0, Z+6	; 0x06
     464:	f7 81       	ldd	r31, Z+7	; 0x07
     466:	e0 2d       	mov	r30, r0
     468:	09 95       	icall
     46a:	08 95       	ret

0000046c <_ZN11Dev_Manager6WritesE8Dev_typePKc>:
     46c:	26 2f       	mov	r18, r22
     46e:	30 e0       	ldi	r19, 0x00	; 0
     470:	22 0f       	add	r18, r18
     472:	33 1f       	adc	r19, r19
     474:	82 0f       	add	r24, r18
     476:	93 1f       	adc	r25, r19
     478:	dc 01       	movw	r26, r24
     47a:	8d 91       	ld	r24, X+
     47c:	9c 91       	ld	r25, X
     47e:	00 97       	sbiw	r24, 0x00	; 0
     480:	41 f0       	breq	.+16     	; 0x492 <_ZN11Dev_Manager6WritesE8Dev_typePKc+0x26>
     482:	ba 01       	movw	r22, r20
     484:	dc 01       	movw	r26, r24
     486:	ed 91       	ld	r30, X+
     488:	fc 91       	ld	r31, X
     48a:	04 80       	ldd	r0, Z+4	; 0x04
     48c:	f5 81       	ldd	r31, Z+5	; 0x05
     48e:	e0 2d       	mov	r30, r0
     490:	09 95       	icall
     492:	08 95       	ret

00000494 <_ZN11Dev_Manager11Device_InitE8Dev_type>:
     494:	70 e0       	ldi	r23, 0x00	; 0
     496:	66 0f       	add	r22, r22
     498:	77 1f       	adc	r23, r23
     49a:	86 0f       	add	r24, r22
     49c:	97 1f       	adc	r25, r23
     49e:	dc 01       	movw	r26, r24
     4a0:	8d 91       	ld	r24, X+
     4a2:	9c 91       	ld	r25, X
     4a4:	00 97       	sbiw	r24, 0x00	; 0
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <_ZN11Dev_Manager11Device_InitE8Dev_type+0x22>
     4a8:	dc 01       	movw	r26, r24
     4aa:	ed 91       	ld	r30, X+
     4ac:	fc 91       	ld	r31, X
     4ae:	01 90       	ld	r0, Z+
     4b0:	f0 81       	ld	r31, Z
     4b2:	e0 2d       	mov	r30, r0
     4b4:	09 95       	icall
     4b6:	08 95       	ret

000004b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>:
     4b8:	e6 2f       	mov	r30, r22
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ee 0f       	add	r30, r30
     4be:	ff 1f       	adc	r31, r31
     4c0:	e8 0f       	add	r30, r24
     4c2:	f9 1f       	adc	r31, r25
     4c4:	80 81       	ld	r24, Z
     4c6:	91 81       	ldd	r25, Z+1	; 0x01
     4c8:	89 2b       	or	r24, r25
     4ca:	11 f0       	breq	.+4      	; 0x4d0 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE+0x18>
     4cc:	57 83       	std	Z+7, r21	; 0x07
     4ce:	46 83       	std	Z+6, r20	; 0x06
     4d0:	08 95       	ret

000004d2 <_ZN11Dev_Manager12Driver_CheckE8Dev_type>:
     4d2:	70 e0       	ldi	r23, 0x00	; 0
     4d4:	66 0f       	add	r22, r22
     4d6:	77 1f       	adc	r23, r23
     4d8:	fc 01       	movw	r30, r24
     4da:	e6 0f       	add	r30, r22
     4dc:	f7 1f       	adc	r31, r23
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	20 81       	ld	r18, Z
     4e2:	31 81       	ldd	r19, Z+1	; 0x01
     4e4:	23 2b       	or	r18, r19
     4e6:	09 f4       	brne	.+2      	; 0x4ea <_ZN11Dev_Manager12Driver_CheckE8Dev_type+0x18>
     4e8:	80 e0       	ldi	r24, 0x00	; 0
     4ea:	08 95       	ret

000004ec <_ZNK11Dev_Manager16getInterfaceAddrE8Dev_type>:
	}
}
const DeviceDriveInterFace* Dev_Manager::getInterfaceAddr(Dev_type Device) const
{
	if(interface[Device])
     4ec:	70 e0       	ldi	r23, 0x00	; 0
     4ee:	66 0f       	add	r22, r22
     4f0:	77 1f       	adc	r23, r23
     4f2:	86 0f       	add	r24, r22
     4f4:	97 1f       	adc	r25, r23
	{
		return interface[Device];
	}
	else
		return nullptr;
}
     4f6:	fc 01       	movw	r30, r24
     4f8:	80 81       	ld	r24, Z
     4fa:	91 81       	ldd	r25, Z+1	; 0x01
     4fc:	08 95       	ret

000004fe <__vector_18>:
ISR(USART0_RX_vect)
{
     4fe:	1f 92       	push	r1
     500:	0f 92       	push	r0
     502:	0f b6       	in	r0, 0x3f	; 63
     504:	0f 92       	push	r0
     506:	11 24       	eor	r1, r1
     508:	0b b6       	in	r0, 0x3b	; 59
     50a:	0f 92       	push	r0
     50c:	2f 93       	push	r18
     50e:	3f 93       	push	r19
     510:	4f 93       	push	r20
     512:	5f 93       	push	r21
     514:	6f 93       	push	r22
     516:	7f 93       	push	r23
     518:	8f 93       	push	r24
     51a:	9f 93       	push	r25
     51c:	af 93       	push	r26
     51e:	bf 93       	push	r27
     520:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[UART0](UART0,UDR0);
     522:	ff 93       	push	r31
     524:	6a df       	rcall	.-300    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     526:	6c b1       	in	r22, 0x0c	; 12
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	dc 01       	movw	r26, r24
     52c:	16 96       	adiw	r26, 0x06	; 6
     52e:	ed 91       	ld	r30, X+
     530:	fc 91       	ld	r31, X
     532:	17 97       	sbiw	r26, 0x07	; 7
     534:	80 e0       	ldi	r24, 0x00	; 0
}
     536:	09 95       	icall
     538:	ff 91       	pop	r31
     53a:	ef 91       	pop	r30
     53c:	bf 91       	pop	r27
     53e:	af 91       	pop	r26
     540:	9f 91       	pop	r25
     542:	8f 91       	pop	r24
     544:	7f 91       	pop	r23
     546:	6f 91       	pop	r22
     548:	5f 91       	pop	r21
     54a:	4f 91       	pop	r20
     54c:	3f 91       	pop	r19
     54e:	2f 91       	pop	r18
     550:	0f 90       	pop	r0
     552:	0b be       	out	0x3b, r0	; 59
     554:	0f 90       	pop	r0
     556:	0f be       	out	0x3f, r0	; 63
     558:	0f 90       	pop	r0
     55a:	1f 90       	pop	r1
     55c:	18 95       	reti

0000055e <__vector_30>:
ISR(USART1_RX_vect)
{
     55e:	1f 92       	push	r1
     560:	0f 92       	push	r0
     562:	0f b6       	in	r0, 0x3f	; 63
     564:	0f 92       	push	r0
     566:	11 24       	eor	r1, r1
     568:	0b b6       	in	r0, 0x3b	; 59
     56a:	0f 92       	push	r0
     56c:	2f 93       	push	r18
     56e:	3f 93       	push	r19
     570:	4f 93       	push	r20
     572:	5f 93       	push	r21
     574:	6f 93       	push	r22
     576:	7f 93       	push	r23
     578:	8f 93       	push	r24
     57a:	9f 93       	push	r25
     57c:	af 93       	push	r26
     57e:	bf 93       	push	r27
     580:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[RS485](RS485,UDR1);
     582:	ff 93       	push	r31
     584:	3a df       	rcall	.-396    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     586:	60 91 9c 00 	lds	r22, 0x009C	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
     58a:	70 e0       	ldi	r23, 0x00	; 0
     58c:	dc 01       	movw	r26, r24
     58e:	18 96       	adiw	r26, 0x08	; 8
     590:	ed 91       	ld	r30, X+
     592:	fc 91       	ld	r31, X
     594:	19 97       	sbiw	r26, 0x09	; 9
     596:	81 e0       	ldi	r24, 0x01	; 1
}
     598:	09 95       	icall
     59a:	ff 91       	pop	r31
     59c:	ef 91       	pop	r30
     59e:	bf 91       	pop	r27
     5a0:	af 91       	pop	r26
     5a2:	9f 91       	pop	r25
     5a4:	8f 91       	pop	r24
     5a6:	7f 91       	pop	r23
     5a8:	6f 91       	pop	r22
     5aa:	5f 91       	pop	r21
     5ac:	4f 91       	pop	r20
     5ae:	3f 91       	pop	r19
     5b0:	2f 91       	pop	r18
     5b2:	0f 90       	pop	r0
     5b4:	0b be       	out	0x3b, r0	; 59
     5b6:	0f 90       	pop	r0
     5b8:	0f be       	out	0x3f, r0	; 63
     5ba:	0f 90       	pop	r0
     5bc:	1f 90       	pop	r1
     5be:	18 95       	reti

000005c0 <__vector_28>:
ISR(TIMER3_COMPC_vect)
{
     5c0:	1f 92       	push	r1
     5c2:	0f 92       	push	r0
     5c4:	0f b6       	in	r0, 0x3f	; 63
     5c6:	0f 92       	push	r0
     5c8:	11 24       	eor	r1, r1
     5ca:	0b b6       	in	r0, 0x3b	; 59
     5cc:	0f 92       	push	r0
     5ce:	2f 93       	push	r18
     5d0:	3f 93       	push	r19
     5d2:	4f 93       	push	r20
     5d4:	5f 93       	push	r21
     5d6:	6f 93       	push	r22
     5d8:	7f 93       	push	r23
     5da:	8f 93       	push	r24
     5dc:	9f 93       	push	r25
     5de:	af 93       	push	r26
     5e0:	bf 93       	push	r27
     5e2:	ef 93       	push	r30
	Dev_Manager::getInstance()->isr_handle[SEC_TIMER](SEC_TIMER,0);
     5e4:	ff 93       	push	r31
     5e6:	09 df       	rcall	.-494    	; 0x3fa <_ZN11Dev_Manager11getInstanceEv>
     5e8:	dc 01       	movw	r26, r24
     5ea:	1a 96       	adiw	r26, 0x0a	; 10
     5ec:	ed 91       	ld	r30, X+
     5ee:	fc 91       	ld	r31, X
     5f0:	1b 97       	sbiw	r26, 0x0b	; 11
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	70 e0       	ldi	r23, 0x00	; 0
     5f6:	82 e0       	ldi	r24, 0x02	; 2
     5f8:	09 95       	icall
     5fa:	ff 91       	pop	r31
     5fc:	ef 91       	pop	r30
     5fe:	bf 91       	pop	r27
     600:	af 91       	pop	r26
     602:	9f 91       	pop	r25
     604:	8f 91       	pop	r24
     606:	7f 91       	pop	r23
     608:	6f 91       	pop	r22
     60a:	5f 91       	pop	r21
     60c:	4f 91       	pop	r20
     60e:	3f 91       	pop	r19
     610:	2f 91       	pop	r18
     612:	0f 90       	pop	r0
     614:	0b be       	out	0x3b, r0	; 59
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0
     61c:	1f 90       	pop	r1
     61e:	18 95       	reti

00000620 <_ZNK20DeviceDriveInterFace11Device_ReadEv>:
{
	return malloc(size);
}
void Timer::operator delete(void* ptr)
{
	free(ptr);
     620:	80 e0       	ldi	r24, 0x00	; 0
     622:	08 95       	ret

00000624 <_ZN20DeviceDriveInterFace13Device_WritesEPKc>:
     624:	08 95       	ret

00000626 <_ZN20DeviceDriveInterFace12Device_WriteEc>:
     626:	08 95       	ret

00000628 <_ZN5Timer11Device_InitEv>:
     628:	80 e4       	ldi	r24, 0x40	; 64
     62a:	80 93 8b 00 	sts	0x008B, r24	; 0x80008b <__TEXT_REGION_LENGTH__+0x7e008b>
     62e:	84 e0       	ldi	r24, 0x04	; 4
     630:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x7e008a>
     634:	88 e0       	ldi	r24, 0x08	; 8
     636:	9d e3       	ldi	r25, 0x3D	; 61
     638:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     63c:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>
     640:	82 e0       	ldi	r24, 0x02	; 2
     642:	80 93 7d 00 	sts	0x007D, r24	; 0x80007d <__TEXT_REGION_LENGTH__+0x7e007d>
     646:	08 95       	ret

00000648 <_ZN5TimerC1Ev>:
     648:	2b e0       	ldi	r18, 0x0B	; 11
     64a:	31 e0       	ldi	r19, 0x01	; 1
     64c:	fc 01       	movw	r30, r24
     64e:	31 83       	std	Z+1, r19	; 0x01
     650:	20 83       	st	Z, r18
     652:	08 95       	ret

00000654 <_ZN5TimernwEj>:
     654:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <pvPortMalloc>
     658:	08 95       	ret

0000065a <_GLOBAL__sub_I_dev1>:
 *
 * Created: 2017-07-25 오후 3:18:57
 *  Author: bluebiz
 */ 
#include "per_sec_timer.h"
Dev_Manager dev1;
     65a:	82 e9       	ldi	r24, 0x92	; 146
     65c:	91 e0       	ldi	r25, 0x01	; 1
     65e:	b7 ce       	rjmp	.-658    	; 0x3ce <_ZN11Dev_ManagerC1Ev>
     660:	08 95       	ret

00000662 <_GLOBAL__sub_D_dev1>:
     662:	82 e9       	ldi	r24, 0x92	; 146
     664:	91 e0       	ldi	r25, 0x01	; 1
     666:	c4 ce       	rjmp	.-632    	; 0x3f0 <_ZN11Dev_ManagerD1Ev>
     668:	08 95       	ret

0000066a <_ZN11RS485Driver11Device_InitEv>:
{
	this->Uart_baudrate = _Uart_baudrate;
}
void RS485Driver::operator delete(void* ptr)
{
	free(ptr);
     66a:	cf 93       	push	r28
     66c:	df 93       	push	r29
     66e:	ec 01       	movw	r28, r24
     670:	10 92 9b 00 	sts	0x009B, r1	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
     674:	88 e9       	ldi	r24, 0x98	; 152
     676:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
     67a:	86 e0       	ldi	r24, 0x06	; 6
     67c:	80 93 9d 00 	sts	0x009D, r24	; 0x80009d <__TEXT_REGION_LENGTH__+0x7e009d>
     680:	be 01       	movw	r22, r28
     682:	6e 5f       	subi	r22, 0xFE	; 254
     684:	7f 4f       	sbci	r23, 0xFF	; 255
     686:	ce 01       	movw	r24, r28
     688:	fc d0       	rcall	.+504    	; 0x882 <_ZN4Ubbr10Ubbr_ValueERKj>
     68a:	10 92 98 00 	sts	0x0098, r1	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
     68e:	90 93 99 00 	sts	0x0099, r25	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
     692:	81 e0       	ldi	r24, 0x01	; 1
     694:	0e 94 15 10 	call	0x202a	; 0x202a <xQueueCreateMutex>
     698:	9f 83       	std	Y+7, r25	; 0x07
     69a:	8e 83       	std	Y+6, r24	; 0x06
     69c:	81 e0       	ldi	r24, 0x01	; 1
     69e:	0e 94 15 10 	call	0x202a	; 0x202a <xQueueCreateMutex>
     6a2:	9d 83       	std	Y+5, r25	; 0x05
     6a4:	8c 83       	std	Y+4, r24	; 0x04
     6a6:	df 91       	pop	r29
     6a8:	cf 91       	pop	r28
     6aa:	08 95       	ret

000006ac <_ZN11RS485DriverC1Ev>:
     6ac:	27 e1       	ldi	r18, 0x17	; 23
     6ae:	31 e0       	ldi	r19, 0x01	; 1
     6b0:	fc 01       	movw	r30, r24
     6b2:	31 83       	std	Z+1, r19	; 0x01
     6b4:	20 83       	st	Z, r18
     6b6:	20 e8       	ldi	r18, 0x80	; 128
     6b8:	35 e2       	ldi	r19, 0x25	; 37
     6ba:	33 83       	std	Z+3, r19	; 0x03
     6bc:	22 83       	std	Z+2, r18	; 0x02
     6be:	20 91 9e 01 	lds	r18, 0x019E	; 0x80019e <_ZN11RS485Driver4instE>
     6c2:	30 91 9f 01 	lds	r19, 0x019F	; 0x80019f <_ZN11RS485Driver4instE+0x1>
     6c6:	23 2b       	or	r18, r19
     6c8:	21 f4       	brne	.+8      	; 0x6d2 <_ZN11RS485DriverC1Ev+0x26>
     6ca:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <_ZN11RS485Driver4instE+0x1>
     6ce:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <_ZN11RS485Driver4instE>
     6d2:	08 95       	ret

000006d4 <_ZN11RS485DrivernwEj>:
}
void* RS485Driver::operator new(size_t size)
{
	return malloc(size);
     6d4:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <pvPortMalloc>
}
     6d8:	08 95       	ret

000006da <_ZN11RS485Driver12UART_PutcharEc>:
void RS485Driver::UART_Putchar(const char data)
{
     6da:	1f 93       	push	r17
     6dc:	cf 93       	push	r28
     6de:	df 93       	push	r29
     6e0:	ec 01       	movw	r28, r24
     6e2:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     6e4:	20 e0       	ldi	r18, 0x00	; 0
     6e6:	44 e6       	ldi	r20, 0x64	; 100
     6e8:	50 e0       	ldi	r21, 0x00	; 0
     6ea:	60 e0       	ldi	r22, 0x00	; 0
     6ec:	70 e0       	ldi	r23, 0x00	; 0
     6ee:	8c 81       	ldd	r24, Y+4	; 0x04
     6f0:	9d 81       	ldd	r25, Y+5	; 0x05
     6f2:	0e 94 2d 10 	call	0x205a	; 0x205a <xQueueGenericReceive>
     6f6:	81 30       	cpi	r24, 0x01	; 1
     6f8:	81 f4       	brne	.+32     	; 0x71a <_ZN11RS485Driver12UART_PutcharEc+0x40>
	{
		while((UCSR1A & (1 << UDRE1)) == 0);
     6fa:	eb e9       	ldi	r30, 0x9B	; 155
     6fc:	f0 e0       	ldi	r31, 0x00	; 0
     6fe:	80 81       	ld	r24, Z
     700:	85 ff       	sbrs	r24, 5
     702:	fd cf       	rjmp	.-6      	; 0x6fe <_ZN11RS485Driver12UART_PutcharEc+0x24>
		UDR1 = data;
     704:	10 93 9c 00 	sts	0x009C, r17	; 0x80009c <__TEXT_REGION_LENGTH__+0x7e009c>
		xSemaphoreGive(char_Mutex);
     708:	20 e0       	ldi	r18, 0x00	; 0
     70a:	40 e0       	ldi	r20, 0x00	; 0
     70c:	50 e0       	ldi	r21, 0x00	; 0
     70e:	60 e0       	ldi	r22, 0x00	; 0
     710:	70 e0       	ldi	r23, 0x00	; 0
     712:	8c 81       	ldd	r24, Y+4	; 0x04
     714:	9d 81       	ldd	r25, Y+5	; 0x05
     716:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <xQueueGenericSend>
	}
}
     71a:	df 91       	pop	r29
     71c:	cf 91       	pop	r28
     71e:	1f 91       	pop	r17
     720:	08 95       	ret

00000722 <_ZN11RS485Driver12Device_WriteEc>:
		}
		xSemaphoreGive(Uart_Mutex);
	}
}
void RS485Driver::Device_Write(char data)
{
     722:	db cf       	rjmp	.-74     	; 0x6da <_ZN11RS485Driver12UART_PutcharEc>
     724:	08 95       	ret

00000726 <_ZN11RS485Driver14UART_PutStringEPKc>:
     726:	0f 93       	push	r16
     728:	1f 93       	push	r17
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	8c 01       	movw	r16, r24
     730:	eb 01       	movw	r28, r22
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	44 e6       	ldi	r20, 0x64	; 100
     736:	50 e0       	ldi	r21, 0x00	; 0
     738:	60 e0       	ldi	r22, 0x00	; 0
     73a:	70 e0       	ldi	r23, 0x00	; 0
     73c:	fc 01       	movw	r30, r24
     73e:	86 81       	ldd	r24, Z+6	; 0x06
     740:	97 81       	ldd	r25, Z+7	; 0x07
     742:	0e 94 2d 10 	call	0x205a	; 0x205a <xQueueGenericReceive>
     746:	81 30       	cpi	r24, 0x01	; 1
     748:	99 f4       	brne	.+38     	; 0x770 <_ZN11RS485Driver14UART_PutStringEPKc+0x4a>
     74a:	68 81       	ld	r22, Y
     74c:	66 23       	and	r22, r22
     74e:	31 f0       	breq	.+12     	; 0x75c <_ZN11RS485Driver14UART_PutStringEPKc+0x36>
     750:	21 96       	adiw	r28, 0x01	; 1
     752:	c8 01       	movw	r24, r16
     754:	c2 df       	rcall	.-124    	; 0x6da <_ZN11RS485Driver12UART_PutcharEc>
     756:	69 91       	ld	r22, Y+
     758:	61 11       	cpse	r22, r1
     75a:	fb cf       	rjmp	.-10     	; 0x752 <_ZN11RS485Driver14UART_PutStringEPKc+0x2c>
     75c:	20 e0       	ldi	r18, 0x00	; 0
     75e:	40 e0       	ldi	r20, 0x00	; 0
     760:	50 e0       	ldi	r21, 0x00	; 0
     762:	60 e0       	ldi	r22, 0x00	; 0
     764:	70 e0       	ldi	r23, 0x00	; 0
     766:	f8 01       	movw	r30, r16
     768:	86 81       	ldd	r24, Z+6	; 0x06
     76a:	97 81       	ldd	r25, Z+7	; 0x07
     76c:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <xQueueGenericSend>
     770:	df 91       	pop	r29
     772:	cf 91       	pop	r28
     774:	1f 91       	pop	r17
     776:	0f 91       	pop	r16
     778:	08 95       	ret

0000077a <_ZN11RS485Driver13Device_WritesEPKc>:
     77a:	d5 cf       	rjmp	.-86     	; 0x726 <_ZN11RS485Driver14UART_PutStringEPKc>
     77c:	08 95       	ret

0000077e <_ZN10UartDriver11Device_InitEv>:
{
	return Ubbr::Ubbr_Value(_Uart_baudrate);
}
void UartDriver::operator delete(void* ptr)
{
	free(ptr);
     77e:	cf 93       	push	r28
     780:	df 93       	push	r29
     782:	ec 01       	movw	r28, r24
     784:	88 e9       	ldi	r24, 0x98	; 152
     786:	8a b9       	out	0x0a, r24	; 10
     788:	86 e0       	ldi	r24, 0x06	; 6
     78a:	80 93 95 00 	sts	0x0095, r24	; 0x800095 <__TEXT_REGION_LENGTH__+0x7e0095>
     78e:	be 01       	movw	r22, r28
     790:	6e 5f       	subi	r22, 0xFE	; 254
     792:	7f 4f       	sbci	r23, 0xFF	; 255
     794:	ce 01       	movw	r24, r28
     796:	75 d0       	rcall	.+234    	; 0x882 <_ZN4Ubbr10Ubbr_ValueERKj>
     798:	10 92 90 00 	sts	0x0090, r1	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
     79c:	99 b9       	out	0x09, r25	; 9
     79e:	81 e0       	ldi	r24, 0x01	; 1
     7a0:	0e 94 15 10 	call	0x202a	; 0x202a <xQueueCreateMutex>
     7a4:	9f 83       	std	Y+7, r25	; 0x07
     7a6:	8e 83       	std	Y+6, r24	; 0x06
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	0e 94 15 10 	call	0x202a	; 0x202a <xQueueCreateMutex>
     7ae:	9d 83       	std	Y+5, r25	; 0x05
     7b0:	8c 83       	std	Y+4, r24	; 0x04
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	08 95       	ret

000007b8 <_ZN10UartDriverC1Ev>:
     7b8:	23 e2       	ldi	r18, 0x23	; 35
     7ba:	31 e0       	ldi	r19, 0x01	; 1
     7bc:	fc 01       	movw	r30, r24
     7be:	31 83       	std	Z+1, r19	; 0x01
     7c0:	20 83       	st	Z, r18
     7c2:	20 ec       	ldi	r18, 0xC0	; 192
     7c4:	32 e1       	ldi	r19, 0x12	; 18
     7c6:	33 83       	std	Z+3, r19	; 0x03
     7c8:	22 83       	std	Z+2, r18	; 0x02
     7ca:	20 91 a0 01 	lds	r18, 0x01A0	; 0x8001a0 <_ZN10UartDriver4instE>
     7ce:	30 91 a1 01 	lds	r19, 0x01A1	; 0x8001a1 <_ZN10UartDriver4instE+0x1>
     7d2:	23 2b       	or	r18, r19
     7d4:	21 f4       	brne	.+8      	; 0x7de <_ZN10UartDriverC1Ev+0x26>
     7d6:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <_ZN10UartDriver4instE+0x1>
     7da:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <_ZN10UartDriver4instE>
     7de:	08 95       	ret

000007e0 <_ZN10UartDrivernwEj>:
}
void* UartDriver::operator new(size_t size)
{
	return malloc(size);
     7e0:	0c 94 4c 0c 	jmp	0x1898	; 0x1898 <pvPortMalloc>
}
     7e4:	08 95       	ret

000007e6 <_ZN10UartDriver12UART_PutcharEc>:
void UartDriver::UART_Putchar(const char data)
{
     7e6:	1f 93       	push	r17
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ec 01       	movw	r28, r24
     7ee:	16 2f       	mov	r17, r22
	if(xSemaphoreTake(char_Mutex,100) == pdPASS)
     7f0:	20 e0       	ldi	r18, 0x00	; 0
     7f2:	44 e6       	ldi	r20, 0x64	; 100
     7f4:	50 e0       	ldi	r21, 0x00	; 0
     7f6:	60 e0       	ldi	r22, 0x00	; 0
     7f8:	70 e0       	ldi	r23, 0x00	; 0
     7fa:	8c 81       	ldd	r24, Y+4	; 0x04
     7fc:	9d 81       	ldd	r25, Y+5	; 0x05
     7fe:	0e 94 2d 10 	call	0x205a	; 0x205a <xQueueGenericReceive>
     802:	81 30       	cpi	r24, 0x01	; 1
     804:	61 f4       	brne	.+24     	; 0x81e <_ZN10UartDriver12UART_PutcharEc+0x38>
	{
		while((UCSR0A & (1 << UDRE0)) == 0);
     806:	5d 9b       	sbis	0x0b, 5	; 11
     808:	fe cf       	rjmp	.-4      	; 0x806 <_ZN10UartDriver12UART_PutcharEc+0x20>
		UDR0 = data;
     80a:	1c b9       	out	0x0c, r17	; 12
		xSemaphoreGive(char_Mutex);
     80c:	20 e0       	ldi	r18, 0x00	; 0
     80e:	40 e0       	ldi	r20, 0x00	; 0
     810:	50 e0       	ldi	r21, 0x00	; 0
     812:	60 e0       	ldi	r22, 0x00	; 0
     814:	70 e0       	ldi	r23, 0x00	; 0
     816:	8c 81       	ldd	r24, Y+4	; 0x04
     818:	9d 81       	ldd	r25, Y+5	; 0x05
     81a:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <xQueueGenericSend>
	}
}
     81e:	df 91       	pop	r29
     820:	cf 91       	pop	r28
     822:	1f 91       	pop	r17
     824:	08 95       	ret

00000826 <_ZN10UartDriver12Device_WriteEc>:
     826:	df cf       	rjmp	.-66     	; 0x7e6 <_ZN10UartDriver12UART_PutcharEc>
     828:	08 95       	ret

0000082a <_ZN10UartDriver14UART_PutStringEPKc>:
     82a:	0f 93       	push	r16
     82c:	1f 93       	push	r17
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
     832:	8c 01       	movw	r16, r24
     834:	eb 01       	movw	r28, r22
     836:	20 e0       	ldi	r18, 0x00	; 0
     838:	44 e6       	ldi	r20, 0x64	; 100
     83a:	50 e0       	ldi	r21, 0x00	; 0
     83c:	60 e0       	ldi	r22, 0x00	; 0
     83e:	70 e0       	ldi	r23, 0x00	; 0
     840:	fc 01       	movw	r30, r24
     842:	86 81       	ldd	r24, Z+6	; 0x06
     844:	97 81       	ldd	r25, Z+7	; 0x07
     846:	0e 94 2d 10 	call	0x205a	; 0x205a <xQueueGenericReceive>
     84a:	81 30       	cpi	r24, 0x01	; 1
     84c:	99 f4       	brne	.+38     	; 0x874 <_ZN10UartDriver14UART_PutStringEPKc+0x4a>
     84e:	68 81       	ld	r22, Y
     850:	66 23       	and	r22, r22
     852:	31 f0       	breq	.+12     	; 0x860 <_ZN10UartDriver14UART_PutStringEPKc+0x36>
     854:	21 96       	adiw	r28, 0x01	; 1
     856:	c8 01       	movw	r24, r16
     858:	c6 df       	rcall	.-116    	; 0x7e6 <_ZN10UartDriver12UART_PutcharEc>
     85a:	69 91       	ld	r22, Y+
     85c:	61 11       	cpse	r22, r1
     85e:	fb cf       	rjmp	.-10     	; 0x856 <_ZN10UartDriver14UART_PutStringEPKc+0x2c>
     860:	20 e0       	ldi	r18, 0x00	; 0
     862:	40 e0       	ldi	r20, 0x00	; 0
     864:	50 e0       	ldi	r21, 0x00	; 0
     866:	60 e0       	ldi	r22, 0x00	; 0
     868:	70 e0       	ldi	r23, 0x00	; 0
     86a:	f8 01       	movw	r30, r16
     86c:	86 81       	ldd	r24, Z+6	; 0x06
     86e:	97 81       	ldd	r25, Z+7	; 0x07
     870:	0e 94 83 0f 	call	0x1f06	; 0x1f06 <xQueueGenericSend>
     874:	df 91       	pop	r29
     876:	cf 91       	pop	r28
     878:	1f 91       	pop	r17
     87a:	0f 91       	pop	r16
     87c:	08 95       	ret

0000087e <_ZN10UartDriver13Device_WritesEPKc>:
     87e:	d5 cf       	rjmp	.-86     	; 0x82a <_ZN10UartDriver14UART_PutStringEPKc>
     880:	08 95       	ret

00000882 <_ZN4Ubbr10Ubbr_ValueERKj>:
 *  Author: bluebiz
 */ 
#include "Ubbr_Calculate.h"

uint16_t Ubbr::Ubbr_Value(const uint16_t &Uart_baudrate)
{
     882:	cf 92       	push	r12
     884:	df 92       	push	r13
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
	float temp =  (((F_cpu / (Uart_baudrate * 16UL))) - 1);
	float ubbr_h = (uint16_t)(temp + 0.5);
     88e:	fb 01       	movw	r30, r22
     890:	20 81       	ld	r18, Z
     892:	31 81       	ldd	r19, Z+1	; 0x01
     894:	c9 01       	movw	r24, r18
     896:	a0 e0       	ldi	r26, 0x00	; 0
     898:	b0 e0       	ldi	r27, 0x00	; 0
     89a:	88 0f       	add	r24, r24
     89c:	99 1f       	adc	r25, r25
     89e:	aa 1f       	adc	r26, r26
     8a0:	bb 1f       	adc	r27, r27
     8a2:	88 0f       	add	r24, r24
     8a4:	99 1f       	adc	r25, r25
     8a6:	aa 1f       	adc	r26, r26
     8a8:	bb 1f       	adc	r27, r27
     8aa:	9c 01       	movw	r18, r24
     8ac:	ad 01       	movw	r20, r26
     8ae:	22 0f       	add	r18, r18
     8b0:	33 1f       	adc	r19, r19
     8b2:	44 1f       	adc	r20, r20
     8b4:	55 1f       	adc	r21, r21
     8b6:	22 0f       	add	r18, r18
     8b8:	33 1f       	adc	r19, r19
     8ba:	44 1f       	adc	r20, r20
     8bc:	55 1f       	adc	r21, r21
     8be:	60 e0       	ldi	r22, 0x00	; 0
     8c0:	74 e2       	ldi	r23, 0x24	; 36
     8c2:	84 ef       	ldi	r24, 0xF4	; 244
     8c4:	90 e0       	ldi	r25, 0x00	; 0
     8c6:	0e 94 ed 16 	call	0x2dda	; 0x2dda <__udivmodsi4>
     8ca:	ca 01       	movw	r24, r20
     8cc:	b9 01       	movw	r22, r18
     8ce:	61 50       	subi	r22, 0x01	; 1
     8d0:	71 09       	sbc	r23, r1
     8d2:	81 09       	sbc	r24, r1
     8d4:	91 09       	sbc	r25, r1
     8d6:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <__floatunsisf>
     8da:	20 e0       	ldi	r18, 0x00	; 0
     8dc:	30 e0       	ldi	r19, 0x00	; 0
     8de:	40 e0       	ldi	r20, 0x00	; 0
     8e0:	5f e3       	ldi	r21, 0x3F	; 63
     8e2:	0e 94 cf 15 	call	0x2b9e	; 0x2b9e <__addsf3>
     8e6:	6b 01       	movw	r12, r22
     8e8:	7c 01       	movw	r14, r24
	float ubbr_l = (uint8_t)(temp + 0.5);
	uint16_t result = (0xff00 & ((uint16_t)ubbr_h << 8)) | (0x00ff & (uint8_t)ubbr_l);
	return result;
     8ea:	0e 94 33 16 	call	0x2c66	; 0x2c66 <__fixunssfsi>
     8ee:	d6 2f       	mov	r29, r22
     8f0:	f0 e0       	ldi	r31, 0x00	; 0
     8f2:	cf 2f       	mov	r28, r31
     8f4:	c7 01       	movw	r24, r14
     8f6:	b6 01       	movw	r22, r12
     8f8:	0e 94 33 16 	call	0x2c66	; 0x2c66 <__fixunssfsi>
}
     8fc:	ce 01       	movw	r24, r28
     8fe:	86 2b       	or	r24, r22
     900:	df 91       	pop	r29
     902:	cf 91       	pop	r28
     904:	ff 90       	pop	r15
     906:	ef 90       	pop	r14
     908:	df 90       	pop	r13
     90a:	cf 90       	pop	r12
     90c:	08 95       	ret

0000090e <_Z14enc28j60ReadOphh>:
// link status
uint8_t enc28j60linkup(void)
{
        // bit 10 (= bit 3 in upper reg)
	return(enc28j60PhyReadH(PHSTAT2) && 4);
}
     90e:	c0 98       	cbi	0x18, 0	; 24
     910:	96 2f       	mov	r25, r22
     912:	6f 71       	andi	r22, 0x1F	; 31
     914:	86 2b       	or	r24, r22
     916:	8f b9       	out	0x0f, r24	; 15
     918:	77 9b       	sbis	0x0e, 7	; 14
     91a:	fe cf       	rjmp	.-4      	; 0x918 <_Z14enc28j60ReadOphh+0xa>
     91c:	1f b8       	out	0x0f, r1	; 15
     91e:	77 9b       	sbis	0x0e, 7	; 14
     920:	fe cf       	rjmp	.-4      	; 0x91e <_Z14enc28j60ReadOphh+0x10>
     922:	99 23       	and	r25, r25
     924:	1c f4       	brge	.+6      	; 0x92c <_Z14enc28j60ReadOphh+0x1e>
     926:	1f b8       	out	0x0f, r1	; 15
     928:	77 9b       	sbis	0x0e, 7	; 14
     92a:	fe cf       	rjmp	.-4      	; 0x928 <_Z14enc28j60ReadOphh+0x1a>
     92c:	c0 9a       	sbi	0x18, 0	; 24
     92e:	8f b1       	in	r24, 0x0f	; 15
     930:	08 95       	ret

00000932 <_Z15enc28j60WriteOphhh>:
     932:	c0 98       	cbi	0x18, 0	; 24
     934:	6f 71       	andi	r22, 0x1F	; 31
     936:	86 2b       	or	r24, r22
     938:	8f b9       	out	0x0f, r24	; 15
     93a:	77 9b       	sbis	0x0e, 7	; 14
     93c:	fe cf       	rjmp	.-4      	; 0x93a <_Z15enc28j60WriteOphhh+0x8>
     93e:	4f b9       	out	0x0f, r20	; 15
     940:	77 9b       	sbis	0x0e, 7	; 14
     942:	fe cf       	rjmp	.-4      	; 0x940 <_Z15enc28j60WriteOphhh+0xe>
     944:	c0 9a       	sbi	0x18, 0	; 24
     946:	08 95       	ret

00000948 <_Z18enc28j60ReadBufferjPh>:
     948:	fb 01       	movw	r30, r22
     94a:	c0 98       	cbi	0x18, 0	; 24
     94c:	2a e3       	ldi	r18, 0x3A	; 58
     94e:	2f b9       	out	0x0f, r18	; 15
     950:	77 9b       	sbis	0x0e, 7	; 14
     952:	fe cf       	rjmp	.-4      	; 0x950 <_Z18enc28j60ReadBufferjPh+0x8>
     954:	00 97       	sbiw	r24, 0x00	; 0
     956:	61 f0       	breq	.+24     	; 0x970 <_Z18enc28j60ReadBufferjPh+0x28>
     958:	df 01       	movw	r26, r30
     95a:	a8 0f       	add	r26, r24
     95c:	b9 1f       	adc	r27, r25
     95e:	1f b8       	out	0x0f, r1	; 15
     960:	77 9b       	sbis	0x0e, 7	; 14
     962:	fe cf       	rjmp	.-4      	; 0x960 <_Z18enc28j60ReadBufferjPh+0x18>
     964:	9f b1       	in	r25, 0x0f	; 15
     966:	91 93       	st	Z+, r25
     968:	ae 17       	cp	r26, r30
     96a:	bf 07       	cpc	r27, r31
     96c:	c1 f7       	brne	.-16     	; 0x95e <_Z18enc28j60ReadBufferjPh+0x16>
     96e:	01 c0       	rjmp	.+2      	; 0x972 <_Z18enc28j60ReadBufferjPh+0x2a>
     970:	df 01       	movw	r26, r30
     972:	1c 92       	st	X, r1
     974:	c0 9a       	sbi	0x18, 0	; 24
     976:	08 95       	ret

00000978 <_Z19enc28j60WriteBufferjPh>:
     978:	fb 01       	movw	r30, r22
     97a:	c0 98       	cbi	0x18, 0	; 24
     97c:	2a e7       	ldi	r18, 0x7A	; 122
     97e:	2f b9       	out	0x0f, r18	; 15
     980:	77 9b       	sbis	0x0e, 7	; 14
     982:	fe cf       	rjmp	.-4      	; 0x980 <_Z19enc28j60WriteBufferjPh+0x8>
     984:	00 97       	sbiw	r24, 0x00	; 0
     986:	61 f0       	breq	.+24     	; 0x9a0 <_Z19enc28j60WriteBufferjPh+0x28>
     988:	9f 01       	movw	r18, r30
     98a:	28 0f       	add	r18, r24
     98c:	39 1f       	adc	r19, r25
     98e:	03 c0       	rjmp	.+6      	; 0x996 <_Z19enc28j60WriteBufferjPh+0x1e>
     990:	2e 17       	cp	r18, r30
     992:	3f 07       	cpc	r19, r31
     994:	29 f0       	breq	.+10     	; 0x9a0 <_Z19enc28j60WriteBufferjPh+0x28>
     996:	91 91       	ld	r25, Z+
     998:	9f b9       	out	0x0f, r25	; 15
     99a:	77 9b       	sbis	0x0e, 7	; 14
     99c:	fe cf       	rjmp	.-4      	; 0x99a <_Z19enc28j60WriteBufferjPh+0x22>
     99e:	f8 cf       	rjmp	.-16     	; 0x990 <_Z19enc28j60WriteBufferjPh+0x18>
     9a0:	c0 9a       	sbi	0x18, 0	; 24
     9a2:	08 95       	ret

000009a4 <_Z15enc28j60SetBankh>:
     9a4:	1f 93       	push	r17
     9a6:	cf 93       	push	r28
     9a8:	df 93       	push	r29
     9aa:	18 2f       	mov	r17, r24
     9ac:	10 76       	andi	r17, 0x60	; 96
     9ae:	c1 2f       	mov	r28, r17
     9b0:	d0 e0       	ldi	r29, 0x00	; 0
     9b2:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <_ZL12Enc28j60Bank>
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	c8 17       	cp	r28, r24
     9ba:	d9 07       	cpc	r29, r25
     9bc:	a1 f0       	breq	.+40     	; 0x9e6 <_Z15enc28j60SetBankh+0x42>
     9be:	43 e0       	ldi	r20, 0x03	; 3
     9c0:	6f e1       	ldi	r22, 0x1F	; 31
     9c2:	80 ea       	ldi	r24, 0xA0	; 160
     9c4:	b6 df       	rcall	.-148    	; 0x932 <_Z15enc28j60WriteOphhh>
     9c6:	ae 01       	movw	r20, r28
     9c8:	55 95       	asr	r21
     9ca:	47 95       	ror	r20
     9cc:	55 95       	asr	r21
     9ce:	47 95       	ror	r20
     9d0:	55 95       	asr	r21
     9d2:	47 95       	ror	r20
     9d4:	55 95       	asr	r21
     9d6:	47 95       	ror	r20
     9d8:	55 95       	asr	r21
     9da:	47 95       	ror	r20
     9dc:	6f e1       	ldi	r22, 0x1F	; 31
     9de:	80 e8       	ldi	r24, 0x80	; 128
     9e0:	a8 df       	rcall	.-176    	; 0x932 <_Z15enc28j60WriteOphhh>
     9e2:	10 93 a4 01 	sts	0x01A4, r17	; 0x8001a4 <_ZL12Enc28j60Bank>
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	1f 91       	pop	r17
     9ec:	08 95       	ret

000009ee <_Z12enc28j60Readh>:
     9ee:	cf 93       	push	r28
     9f0:	c8 2f       	mov	r28, r24
     9f2:	d8 df       	rcall	.-80     	; 0x9a4 <_Z15enc28j60SetBankh>
     9f4:	6c 2f       	mov	r22, r28
     9f6:	80 e0       	ldi	r24, 0x00	; 0
     9f8:	8a df       	rcall	.-236    	; 0x90e <_Z14enc28j60ReadOphh>
     9fa:	cf 91       	pop	r28
     9fc:	08 95       	ret

000009fe <_Z13enc28j60Writehh>:
     9fe:	cf 93       	push	r28
     a00:	df 93       	push	r29
     a02:	c8 2f       	mov	r28, r24
     a04:	d6 2f       	mov	r29, r22
     a06:	ce df       	rcall	.-100    	; 0x9a4 <_Z15enc28j60SetBankh>
     a08:	4d 2f       	mov	r20, r29
     a0a:	6c 2f       	mov	r22, r28
     a0c:	80 e4       	ldi	r24, 0x40	; 64
     a0e:	91 df       	rcall	.-222    	; 0x932 <_Z15enc28j60WriteOphhh>
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	08 95       	ret

00000a16 <_Z16enc28j60PhyWritehj>:
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	d6 2f       	mov	r29, r22
     a1c:	c7 2f       	mov	r28, r23
     a1e:	68 2f       	mov	r22, r24
     a20:	84 ed       	ldi	r24, 0xD4	; 212
     a22:	ed df       	rcall	.-38     	; 0x9fe <_Z13enc28j60Writehh>
     a24:	6d 2f       	mov	r22, r29
     a26:	86 ed       	ldi	r24, 0xD6	; 214
     a28:	ea df       	rcall	.-44     	; 0x9fe <_Z13enc28j60Writehh>
     a2a:	6c 2f       	mov	r22, r28
     a2c:	87 ed       	ldi	r24, 0xD7	; 215
     a2e:	e7 df       	rcall	.-50     	; 0x9fe <_Z13enc28j60Writehh>
     a30:	8a ee       	ldi	r24, 0xEA	; 234
     a32:	dd df       	rcall	.-70     	; 0x9ee <_Z12enc28j60Readh>
     a34:	80 ff       	sbrs	r24, 0
     a36:	04 c0       	rjmp	.+8      	; 0xa40 <_Z16enc28j60PhyWritehj+0x2a>
     a38:	85 e0       	ldi	r24, 0x05	; 5
     a3a:	8a 95       	dec	r24
     a3c:	f1 f7       	brne	.-4      	; 0xa3a <_Z16enc28j60PhyWritehj+0x24>
     a3e:	f8 cf       	rjmp	.-16     	; 0xa30 <_Z16enc28j60PhyWritehj+0x1a>
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <_Z14enc28j60clkouth>:
     a46:	68 2f       	mov	r22, r24
     a48:	67 70       	andi	r22, 0x07	; 7
     a4a:	85 e7       	ldi	r24, 0x75	; 117
     a4c:	d8 cf       	rjmp	.-80     	; 0x9fe <_Z13enc28j60Writehh>
     a4e:	08 95       	ret

00000a50 <_Z12enc28j60InitPh>:
     a50:	cf 93       	push	r28
     a52:	df 93       	push	r29
     a54:	ec 01       	movw	r28, r24
     a56:	b8 9a       	sbi	0x17, 0	; 23
     a58:	c0 9a       	sbi	0x18, 0	; 24
     a5a:	a6 d2       	rcall	.+1356   	; 0xfa8 <_Z8spi_initv>
     a5c:	4f ef       	ldi	r20, 0xFF	; 255
     a5e:	60 e0       	ldi	r22, 0x00	; 0
     a60:	8f ef       	ldi	r24, 0xFF	; 255
     a62:	67 df       	rcall	.-306    	; 0x932 <_Z15enc28j60WriteOphhh>
     a64:	82 e3       	ldi	r24, 0x32	; 50
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	a9 d2       	rcall	.+1362   	; 0xfbc <_Z8delay_msj>
     a6a:	10 92 a3 01 	sts	0x01A3, r1	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
     a6e:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <_ZL13NextPacketPtr>
     a72:	60 e0       	ldi	r22, 0x00	; 0
     a74:	88 e0       	ldi	r24, 0x08	; 8
     a76:	c3 df       	rcall	.-122    	; 0x9fe <_Z13enc28j60Writehh>
     a78:	60 e0       	ldi	r22, 0x00	; 0
     a7a:	89 e0       	ldi	r24, 0x09	; 9
     a7c:	c0 df       	rcall	.-128    	; 0x9fe <_Z13enc28j60Writehh>
     a7e:	60 e0       	ldi	r22, 0x00	; 0
     a80:	8c e0       	ldi	r24, 0x0C	; 12
     a82:	bd df       	rcall	.-134    	; 0x9fe <_Z13enc28j60Writehh>
     a84:	60 e0       	ldi	r22, 0x00	; 0
     a86:	8d e0       	ldi	r24, 0x0D	; 13
     a88:	ba df       	rcall	.-140    	; 0x9fe <_Z13enc28j60Writehh>
     a8a:	6e ef       	ldi	r22, 0xFE	; 254
     a8c:	8a e0       	ldi	r24, 0x0A	; 10
     a8e:	b7 df       	rcall	.-146    	; 0x9fe <_Z13enc28j60Writehh>
     a90:	69 e1       	ldi	r22, 0x19	; 25
     a92:	8b e0       	ldi	r24, 0x0B	; 11
     a94:	b4 df       	rcall	.-152    	; 0x9fe <_Z13enc28j60Writehh>
     a96:	6f ef       	ldi	r22, 0xFF	; 255
     a98:	84 e0       	ldi	r24, 0x04	; 4
     a9a:	b1 df       	rcall	.-158    	; 0x9fe <_Z13enc28j60Writehh>
     a9c:	69 e1       	ldi	r22, 0x19	; 25
     a9e:	85 e0       	ldi	r24, 0x05	; 5
     aa0:	ae df       	rcall	.-164    	; 0x9fe <_Z13enc28j60Writehh>
     aa2:	6f ef       	ldi	r22, 0xFF	; 255
     aa4:	86 e0       	ldi	r24, 0x06	; 6
     aa6:	ab df       	rcall	.-170    	; 0x9fe <_Z13enc28j60Writehh>
     aa8:	6f e1       	ldi	r22, 0x1F	; 31
     aaa:	87 e0       	ldi	r24, 0x07	; 7
     aac:	a8 df       	rcall	.-176    	; 0x9fe <_Z13enc28j60Writehh>
     aae:	60 eb       	ldi	r22, 0xB0	; 176
     ab0:	88 e3       	ldi	r24, 0x38	; 56
     ab2:	a5 df       	rcall	.-182    	; 0x9fe <_Z13enc28j60Writehh>
     ab4:	6f e3       	ldi	r22, 0x3F	; 63
     ab6:	88 e2       	ldi	r24, 0x28	; 40
     ab8:	a2 df       	rcall	.-188    	; 0x9fe <_Z13enc28j60Writehh>
     aba:	60 e3       	ldi	r22, 0x30	; 48
     abc:	89 e2       	ldi	r24, 0x29	; 41
     abe:	9f df       	rcall	.-194    	; 0x9fe <_Z13enc28j60Writehh>
     ac0:	69 ef       	ldi	r22, 0xF9	; 249
     ac2:	80 e3       	ldi	r24, 0x30	; 48
     ac4:	9c df       	rcall	.-200    	; 0x9fe <_Z13enc28j60Writehh>
     ac6:	67 ef       	ldi	r22, 0xF7	; 247
     ac8:	81 e3       	ldi	r24, 0x31	; 49
     aca:	99 df       	rcall	.-206    	; 0x9fe <_Z13enc28j60Writehh>
     acc:	6d e0       	ldi	r22, 0x0D	; 13
     ace:	80 ec       	ldi	r24, 0xC0	; 192
     ad0:	96 df       	rcall	.-212    	; 0x9fe <_Z13enc28j60Writehh>
     ad2:	60 e0       	ldi	r22, 0x00	; 0
     ad4:	81 ec       	ldi	r24, 0xC1	; 193
     ad6:	93 df       	rcall	.-218    	; 0x9fe <_Z13enc28j60Writehh>
     ad8:	42 e3       	ldi	r20, 0x32	; 50
     ada:	62 ec       	ldi	r22, 0xC2	; 194
     adc:	80 e8       	ldi	r24, 0x80	; 128
     ade:	29 df       	rcall	.-430    	; 0x932 <_Z15enc28j60WriteOphhh>
     ae0:	62 e1       	ldi	r22, 0x12	; 18
     ae2:	86 ec       	ldi	r24, 0xC6	; 198
     ae4:	8c df       	rcall	.-232    	; 0x9fe <_Z13enc28j60Writehh>
     ae6:	6c e0       	ldi	r22, 0x0C	; 12
     ae8:	87 ec       	ldi	r24, 0xC7	; 199
     aea:	89 df       	rcall	.-238    	; 0x9fe <_Z13enc28j60Writehh>
     aec:	62 e1       	ldi	r22, 0x12	; 18
     aee:	84 ec       	ldi	r24, 0xC4	; 196
     af0:	86 df       	rcall	.-244    	; 0x9fe <_Z13enc28j60Writehh>
     af2:	6c ed       	ldi	r22, 0xDC	; 220
     af4:	8a ec       	ldi	r24, 0xCA	; 202
     af6:	83 df       	rcall	.-250    	; 0x9fe <_Z13enc28j60Writehh>
     af8:	65 e0       	ldi	r22, 0x05	; 5
     afa:	8b ec       	ldi	r24, 0xCB	; 203
     afc:	80 df       	rcall	.-256    	; 0x9fe <_Z13enc28j60Writehh>
     afe:	68 81       	ld	r22, Y
     b00:	84 ee       	ldi	r24, 0xE4	; 228
     b02:	7d df       	rcall	.-262    	; 0x9fe <_Z13enc28j60Writehh>
     b04:	69 81       	ldd	r22, Y+1	; 0x01
     b06:	85 ee       	ldi	r24, 0xE5	; 229
     b08:	7a df       	rcall	.-268    	; 0x9fe <_Z13enc28j60Writehh>
     b0a:	6a 81       	ldd	r22, Y+2	; 0x02
     b0c:	82 ee       	ldi	r24, 0xE2	; 226
     b0e:	77 df       	rcall	.-274    	; 0x9fe <_Z13enc28j60Writehh>
     b10:	6b 81       	ldd	r22, Y+3	; 0x03
     b12:	83 ee       	ldi	r24, 0xE3	; 227
     b14:	74 df       	rcall	.-280    	; 0x9fe <_Z13enc28j60Writehh>
     b16:	6c 81       	ldd	r22, Y+4	; 0x04
     b18:	80 ee       	ldi	r24, 0xE0	; 224
     b1a:	71 df       	rcall	.-286    	; 0x9fe <_Z13enc28j60Writehh>
     b1c:	6d 81       	ldd	r22, Y+5	; 0x05
     b1e:	81 ee       	ldi	r24, 0xE1	; 225
     b20:	6e df       	rcall	.-292    	; 0x9fe <_Z13enc28j60Writehh>
     b22:	60 e0       	ldi	r22, 0x00	; 0
     b24:	71 e0       	ldi	r23, 0x01	; 1
     b26:	80 e1       	ldi	r24, 0x10	; 16
     b28:	76 df       	rcall	.-276    	; 0xa16 <_Z16enc28j60PhyWritehj>
     b2a:	8f e1       	ldi	r24, 0x1F	; 31
     b2c:	3b df       	rcall	.-394    	; 0x9a4 <_Z15enc28j60SetBankh>
     b2e:	40 ec       	ldi	r20, 0xC0	; 192
     b30:	6b e1       	ldi	r22, 0x1B	; 27
     b32:	80 e8       	ldi	r24, 0x80	; 128
     b34:	fe de       	rcall	.-516    	; 0x932 <_Z15enc28j60WriteOphhh>
     b36:	44 e0       	ldi	r20, 0x04	; 4
     b38:	6f e1       	ldi	r22, 0x1F	; 31
     b3a:	80 e8       	ldi	r24, 0x80	; 128
     b3c:	fa de       	rcall	.-524    	; 0x932 <_Z15enc28j60WriteOphhh>
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_Z18enc28j60PacketSendjPh>:

void enc28j60PacketSend(uint16_t len, uint8_t* packet)
{
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	ec 01       	movw	r28, r24
     b4e:	8b 01       	movw	r16, r22
	// Set the write pointer to start of transmit buffer area
	enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
     b50:	6f ef       	ldi	r22, 0xFF	; 255
     b52:	82 e0       	ldi	r24, 0x02	; 2
     b54:	54 df       	rcall	.-344    	; 0x9fe <_Z13enc28j60Writehh>
	enc28j60Write(EWRPTH, TXSTART_INIT>>8);
     b56:	69 e1       	ldi	r22, 0x19	; 25
     b58:	83 e0       	ldi	r24, 0x03	; 3
     b5a:	51 df       	rcall	.-350    	; 0x9fe <_Z13enc28j60Writehh>
	// Set the TXND pointer to correspond to the packet size given
	enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
     b5c:	6c 2f       	mov	r22, r28
     b5e:	61 50       	subi	r22, 0x01	; 1
     b60:	86 e0       	ldi	r24, 0x06	; 6
     b62:	4d df       	rcall	.-358    	; 0x9fe <_Z13enc28j60Writehh>
	enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
     b64:	ce 01       	movw	r24, r28
     b66:	81 50       	subi	r24, 0x01	; 1
     b68:	96 4e       	sbci	r25, 0xE6	; 230
     b6a:	69 2f       	mov	r22, r25
     b6c:	87 e0       	ldi	r24, 0x07	; 7
	// write per-packet control byte (0x00 means use macon3 settings)
	enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
     b6e:	47 df       	rcall	.-370    	; 0x9fe <_Z13enc28j60Writehh>
     b70:	40 e0       	ldi	r20, 0x00	; 0
     b72:	60 e0       	ldi	r22, 0x00	; 0
     b74:	8a e7       	ldi	r24, 0x7A	; 122
	// copy the packet into the transmit buffer
	enc28j60WriteBuffer(len, packet);
     b76:	dd de       	rcall	.-582    	; 0x932 <_Z15enc28j60WriteOphhh>
     b78:	b8 01       	movw	r22, r16
	// send the contents of the transmit buffer onto the network
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
     b7a:	ce 01       	movw	r24, r28
     b7c:	fd de       	rcall	.-518    	; 0x978 <_Z19enc28j60WriteBufferjPh>
     b7e:	48 e0       	ldi	r20, 0x08	; 8
     b80:	6f e1       	ldi	r22, 0x1F	; 31
        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
	if( (enc28j60Read(EIR) & EIR_TXERIF) ){
     b82:	80 e8       	ldi	r24, 0x80	; 128
     b84:	d6 de       	rcall	.-596    	; 0x932 <_Z15enc28j60WriteOphhh>
     b86:	8c e1       	ldi	r24, 0x1C	; 28
     b88:	32 df       	rcall	.-412    	; 0x9ee <_Z12enc28j60Readh>
                enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
     b8a:	81 ff       	sbrs	r24, 1
     b8c:	04 c0       	rjmp	.+8      	; 0xb96 <_Z18enc28j60PacketSendjPh+0x52>
     b8e:	48 e0       	ldi	r20, 0x08	; 8
     b90:	6f e1       	ldi	r22, 0x1F	; 31
     b92:	80 ea       	ldi	r24, 0xA0	; 160
        }
}
     b94:	ce de       	rcall	.-612    	; 0x932 <_Z15enc28j60WriteOphhh>
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	08 95       	ret

00000ba0 <_Z21enc28j60PacketReceivejPh>:
// The packet will by headed by an ethernet header.
//      maxlen  The maximum acceptable length of a retrieved packet.
//      packet  Pointer where packet data should be stored.
// Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
uint16_t enc28j60PacketReceive(uint16_t maxlen, uint8_t* packet)
{
     ba0:	9f 92       	push	r9
     ba2:	af 92       	push	r10
     ba4:	bf 92       	push	r11
     ba6:	cf 92       	push	r12
     ba8:	df 92       	push	r13
     baa:	ef 92       	push	r14
     bac:	ff 92       	push	r15
     bae:	0f 93       	push	r16
     bb0:	1f 93       	push	r17
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	5c 01       	movw	r10, r24
     bb8:	7b 01       	movw	r14, r22
	uint16_t rxstat;
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
     bba:	89 e3       	ldi	r24, 0x39	; 57
     bbc:	18 df       	rcall	.-464    	; 0x9ee <_Z12enc28j60Readh>
     bbe:	88 23       	and	r24, r24
     bc0:	09 f4       	brne	.+2      	; 0xbc4 <_Z21enc28j60PacketReceivejPh+0x24>
     bc2:	45 c0       	rjmp	.+138    	; 0xc4e <_Z21enc28j60PacketReceivejPh+0xae>
		return(0);
        }

	// Set the read pointer to the start of the received packet
	enc28j60Write(ERDPTL, (NextPacketPtr));
     bc4:	60 91 a2 01 	lds	r22, 0x01A2	; 0x8001a2 <_ZL13NextPacketPtr>
     bc8:	c0 91 a3 01 	lds	r28, 0x01A3	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
     bcc:	80 e0       	ldi	r24, 0x00	; 0
	enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
     bce:	17 df       	rcall	.-466    	; 0x9fe <_Z13enc28j60Writehh>
     bd0:	6c 2f       	mov	r22, r28
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	14 df       	rcall	.-472    	; 0x9fe <_Z13enc28j60Writehh>
     bd6:	60 e0       	ldi	r22, 0x00	; 0
     bd8:	8a e3       	ldi	r24, 0x3A	; 58
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     bda:	99 de       	rcall	.-718    	; 0x90e <_Z14enc28j60ReadOphh>
     bdc:	c8 2f       	mov	r28, r24
     bde:	60 e0       	ldi	r22, 0x00	; 0
     be0:	8a e3       	ldi	r24, 0x3A	; 58
     be2:	95 de       	rcall	.-726    	; 0x90e <_Z14enc28j60ReadOphh>
     be4:	d0 e0       	ldi	r29, 0x00	; 0
     be6:	d8 2b       	or	r29, r24
     be8:	d0 93 a3 01 	sts	0x01A3, r29	; 0x8001a3 <_ZL13NextPacketPtr+0x1>
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     bec:	c0 93 a2 01 	sts	0x01A2, r28	; 0x8001a2 <_ZL13NextPacketPtr>
     bf0:	60 e0       	ldi	r22, 0x00	; 0
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     bf2:	8a e3       	ldi	r24, 0x3A	; 58
     bf4:	8c de       	rcall	.-744    	; 0x90e <_Z14enc28j60ReadOphh>
     bf6:	08 2f       	mov	r16, r24
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
     bf8:	60 e0       	ldi	r22, 0x00	; 0
     bfa:	8a e3       	ldi	r24, 0x3A	; 58
     bfc:	88 de       	rcall	.-752    	; 0x90e <_Z14enc28j60ReadOphh>
     bfe:	98 2e       	mov	r9, r24
     c00:	60 e0       	ldi	r22, 0x00	; 0
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
     c02:	8a e3       	ldi	r24, 0x3A	; 58
     c04:	84 de       	rcall	.-760    	; 0x90e <_Z14enc28j60ReadOphh>
     c06:	c8 2e       	mov	r12, r24
     c08:	60 e0       	ldi	r22, 0x00	; 0
                len=maxlen-1;
        }
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
     c0a:	8a e3       	ldi	r24, 0x3A	; 58
     c0c:	80 de       	rcall	.-768    	; 0x90e <_Z14enc28j60ReadOphh>
        len-=4; //remove the CRC count
	// read the receive status (see datasheet page 43)
	rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	rxstat |= ((uint16_t)enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0))<<8;
	// limit retrieve length
        if (len>maxlen-1){
     c0e:	c7 fe       	sbrs	r12, 7
     c10:	0f c0       	rjmp	.+30     	; 0xc30 <_Z21enc28j60PacketReceivejPh+0x90>
     c12:	81 e0       	ldi	r24, 0x01	; 1
	// read the next packet pointer
	NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
	// read the packet length (see datasheet page 43)
	len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
	len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
     c14:	a8 1a       	sub	r10, r24
     c16:	b1 08       	sbc	r11, r1
     c18:	10 e0       	ldi	r17, 0x00	; 0
     c1a:	19 29       	or	r17, r9
     c1c:	04 50       	subi	r16, 0x04	; 4
     c1e:	11 09       	sbc	r17, r1
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
        }else{
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
     c20:	a0 16       	cp	r10, r16
     c22:	b1 06       	cpc	r11, r17
     c24:	08 f4       	brcc	.+2      	; 0xc28 <_Z21enc28j60PacketReceivejPh+0x88>
     c26:	85 01       	movw	r16, r10
        // check CRC and symbol errors (see datasheet page 44, table 7-3):
        // The ERXFCON.CRCEN is set by default. Normally we should not
        // need to check this.
        if ((rxstat & 0x80)==0){
                // invalid
                len=0;
     c28:	b7 01       	movw	r22, r14
                // copy the packet from the receive buffer
                enc28j60ReadBuffer(len, packet);
        }
	// Move the RX read pointer to the start of the next received packet
	// This frees the memory we just read out
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
     c2a:	c8 01       	movw	r24, r16
     c2c:	8d de       	rcall	.-742    	; 0x948 <_Z18enc28j60ReadBufferjPh>
     c2e:	02 c0       	rjmp	.+4      	; 0xc34 <_Z21enc28j60PacketReceivejPh+0x94>
     c30:	00 e0       	ldi	r16, 0x00	; 0
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
     c32:	10 e0       	ldi	r17, 0x00	; 0
     c34:	6c 2f       	mov	r22, r28
     c36:	8c e0       	ldi	r24, 0x0C	; 12
     c38:	e2 de       	rcall	.-572    	; 0x9fe <_Z13enc28j60Writehh>
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
     c3a:	6d 2f       	mov	r22, r29
     c3c:	8d e0       	ldi	r24, 0x0D	; 13
     c3e:	df de       	rcall	.-578    	; 0x9fe <_Z13enc28j60Writehh>
     c40:	40 e4       	ldi	r20, 0x40	; 64
     c42:	6e e1       	ldi	r22, 0x1E	; 30
	return(len);
     c44:	80 e8       	ldi	r24, 0x80	; 128
     c46:	75 de       	rcall	.-790    	; 0x932 <_Z15enc28j60WriteOphhh>
     c48:	80 2f       	mov	r24, r16
	uint16_t len;
	// check if a packet has been received and buffered
	//if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
        // The above does not work. See Rev. B4 Silicon Errata point 6.
	if( enc28j60Read(EPKTCNT) ==0 ){
		return(0);
     c4a:	91 2f       	mov	r25, r17
     c4c:	02 c0       	rjmp	.+4      	; 0xc52 <_Z21enc28j60PacketReceivejPh+0xb2>
	enc28j60Write(ERXRDPTL, (NextPacketPtr));
	enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
	// decrement the packet counter indicate we are done with this packet
	enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
	return(len);
}
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	df 91       	pop	r29
     c54:	cf 91       	pop	r28
     c56:	1f 91       	pop	r17
     c58:	0f 91       	pop	r16
     c5a:	ff 90       	pop	r15
     c5c:	ef 90       	pop	r14
     c5e:	df 90       	pop	r13
     c60:	cf 90       	pop	r12
     c62:	bf 90       	pop	r11
     c64:	af 90       	pop	r10
     c66:	9f 90       	pop	r9
     c68:	08 95       	ret

00000c6a <_Z8checksumPhjh>:
        }else{
                // no options:
                // 20 bytes:
                buf[TCP_HEADER_LEN_P]=0x50;
        }
}
     c6a:	cf 92       	push	r12
     c6c:	df 92       	push	r13
     c6e:	ef 92       	push	r14
     c70:	ff 92       	push	r15
     c72:	cf 93       	push	r28
     c74:	df 93       	push	r29
     c76:	ec 01       	movw	r28, r24
     c78:	db 01       	movw	r26, r22
     c7a:	41 30       	cpi	r20, 0x01	; 1
     c7c:	61 f4       	brne	.+24     	; 0xc96 <_Z8checksumPhjh+0x2c>
     c7e:	6b 01       	movw	r12, r22
     c80:	88 e0       	ldi	r24, 0x08	; 8
     c82:	c8 1a       	sub	r12, r24
     c84:	d1 08       	sbc	r13, r1
     c86:	e1 2c       	mov	r14, r1
     c88:	f1 2c       	mov	r15, r1
     c8a:	81 e1       	ldi	r24, 0x11	; 17
     c8c:	c8 0e       	add	r12, r24
     c8e:	d1 1c       	adc	r13, r1
     c90:	e1 1c       	adc	r14, r1
     c92:	f1 1c       	adc	r15, r1
     c94:	11 c0       	rjmp	.+34     	; 0xcb8 <_Z8checksumPhjh+0x4e>
     c96:	42 30       	cpi	r20, 0x02	; 2
     c98:	61 f4       	brne	.+24     	; 0xcb2 <_Z8checksumPhjh+0x48>
     c9a:	6b 01       	movw	r12, r22
     c9c:	88 e0       	ldi	r24, 0x08	; 8
     c9e:	c8 1a       	sub	r12, r24
     ca0:	d1 08       	sbc	r13, r1
     ca2:	e1 2c       	mov	r14, r1
     ca4:	f1 2c       	mov	r15, r1
     ca6:	86 e0       	ldi	r24, 0x06	; 6
     ca8:	c8 0e       	add	r12, r24
     caa:	d1 1c       	adc	r13, r1
     cac:	e1 1c       	adc	r14, r1
     cae:	f1 1c       	adc	r15, r1
     cb0:	03 c0       	rjmp	.+6      	; 0xcb8 <_Z8checksumPhjh+0x4e>
     cb2:	c1 2c       	mov	r12, r1
     cb4:	d1 2c       	mov	r13, r1
     cb6:	76 01       	movw	r14, r12
     cb8:	a2 30       	cpi	r26, 0x02	; 2
     cba:	b1 05       	cpc	r27, r1
     cbc:	f0 f0       	brcs	.+60     	; 0xcfa <_Z8checksumPhjh+0x90>
     cbe:	9d 01       	movw	r18, r26
     cc0:	fe 01       	movw	r30, r28
     cc2:	40 81       	ld	r20, Z
     cc4:	50 e0       	ldi	r21, 0x00	; 0
     cc6:	60 e0       	ldi	r22, 0x00	; 0
     cc8:	70 e0       	ldi	r23, 0x00	; 0
     cca:	76 2f       	mov	r23, r22
     ccc:	65 2f       	mov	r22, r21
     cce:	54 2f       	mov	r21, r20
     cd0:	44 27       	eor	r20, r20
     cd2:	81 81       	ldd	r24, Z+1	; 0x01
     cd4:	48 2b       	or	r20, r24
     cd6:	c4 0e       	add	r12, r20
     cd8:	d5 1e       	adc	r13, r21
     cda:	e6 1e       	adc	r14, r22
     cdc:	f7 1e       	adc	r15, r23
     cde:	32 96       	adiw	r30, 0x02	; 2
     ce0:	22 50       	subi	r18, 0x02	; 2
     ce2:	31 09       	sbc	r19, r1
     ce4:	22 30       	cpi	r18, 0x02	; 2
     ce6:	31 05       	cpc	r19, r1
     ce8:	60 f7       	brcc	.-40     	; 0xcc2 <_Z8checksumPhjh+0x58>
     cea:	cd 01       	movw	r24, r26
     cec:	02 97       	sbiw	r24, 0x02	; 2
     cee:	8e 7f       	andi	r24, 0xFE	; 254
     cf0:	02 96       	adiw	r24, 0x02	; 2
     cf2:	c8 0f       	add	r28, r24
     cf4:	d9 1f       	adc	r29, r25
     cf6:	a1 70       	andi	r26, 0x01	; 1
     cf8:	bb 27       	eor	r27, r27
     cfa:	ab 2b       	or	r26, r27
     cfc:	61 f0       	breq	.+24     	; 0xd16 <_Z8checksumPhjh+0xac>
     cfe:	88 81       	ld	r24, Y
     d00:	90 e0       	ldi	r25, 0x00	; 0
     d02:	a0 e0       	ldi	r26, 0x00	; 0
     d04:	b0 e0       	ldi	r27, 0x00	; 0
     d06:	ba 2f       	mov	r27, r26
     d08:	a9 2f       	mov	r26, r25
     d0a:	98 2f       	mov	r25, r24
     d0c:	88 27       	eor	r24, r24
     d0e:	c8 0e       	add	r12, r24
     d10:	d9 1e       	adc	r13, r25
     d12:	ea 1e       	adc	r14, r26
     d14:	fb 1e       	adc	r15, r27
     d16:	a7 01       	movw	r20, r14
     d18:	66 27       	eor	r22, r22
     d1a:	77 27       	eor	r23, r23
     d1c:	41 15       	cp	r20, r1
     d1e:	51 05       	cpc	r21, r1
     d20:	61 05       	cpc	r22, r1
     d22:	71 05       	cpc	r23, r1
     d24:	71 f0       	breq	.+28     	; 0xd42 <_Z8checksumPhjh+0xd8>
     d26:	ee 24       	eor	r14, r14
     d28:	ff 24       	eor	r15, r15
     d2a:	c4 0e       	add	r12, r20
     d2c:	d5 1e       	adc	r13, r21
     d2e:	e6 1e       	adc	r14, r22
     d30:	f7 1e       	adc	r15, r23
     d32:	a7 01       	movw	r20, r14
     d34:	66 27       	eor	r22, r22
     d36:	77 27       	eor	r23, r23
     d38:	41 15       	cp	r20, r1
     d3a:	51 05       	cpc	r21, r1
     d3c:	61 05       	cpc	r22, r1
     d3e:	71 05       	cpc	r23, r1
     d40:	91 f7       	brne	.-28     	; 0xd26 <_Z8checksumPhjh+0xbc>
     d42:	c6 01       	movw	r24, r12
     d44:	80 95       	com	r24
     d46:	90 95       	com	r25
     d48:	df 91       	pop	r29
     d4a:	cf 91       	pop	r28
     d4c:	ff 90       	pop	r15
     d4e:	ef 90       	pop	r14
     d50:	df 90       	pop	r13
     d52:	cf 90       	pop	r12
     d54:	08 95       	ret

00000d56 <_Z19init_ip_arp_udp_tcpPhS_h>:
     d56:	40 93 00 01 	sts	0x0100, r20	; 0x800100 <__data_start>
     d5a:	a6 2f       	mov	r26, r22
     d5c:	b7 2f       	mov	r27, r23
     d5e:	e5 ea       	ldi	r30, 0xA5	; 165
     d60:	f1 e0       	ldi	r31, 0x01	; 1
     d62:	49 ea       	ldi	r20, 0xA9	; 169
     d64:	51 e0       	ldi	r21, 0x01	; 1
     d66:	2d 91       	ld	r18, X+
     d68:	21 93       	st	Z+, r18
     d6a:	e4 17       	cp	r30, r20
     d6c:	f5 07       	cpc	r31, r21
     d6e:	d9 f7       	brne	.-10     	; 0xd66 <_Z19init_ip_arp_udp_tcpPhS_h+0x10>
     d70:	a8 2f       	mov	r26, r24
     d72:	b9 2f       	mov	r27, r25
     d74:	e9 ea       	ldi	r30, 0xA9	; 169
     d76:	f1 e0       	ldi	r31, 0x01	; 1
     d78:	2f ea       	ldi	r18, 0xAF	; 175
     d7a:	31 e0       	ldi	r19, 0x01	; 1
     d7c:	8d 91       	ld	r24, X+
     d7e:	81 93       	st	Z+, r24
     d80:	e2 17       	cp	r30, r18
     d82:	f3 07       	cpc	r31, r19
     d84:	d9 f7       	brne	.-10     	; 0xd7c <_Z19init_ip_arp_udp_tcpPhS_h+0x26>
     d86:	08 95       	ret

00000d88 <_Z25eth_type_is_arp_and_my_ipPhj>:
     d88:	69 32       	cpi	r22, 0x29	; 41
     d8a:	71 05       	cpc	r23, r1
     d8c:	c8 f0       	brcs	.+50     	; 0xdc0 <_Z25eth_type_is_arp_and_my_ipPhj+0x38>
     d8e:	fc 01       	movw	r30, r24
     d90:	24 85       	ldd	r18, Z+12	; 0x0c
     d92:	28 30       	cpi	r18, 0x08	; 8
     d94:	b9 f4       	brne	.+46     	; 0xdc4 <_Z25eth_type_is_arp_and_my_ipPhj+0x3c>
     d96:	25 85       	ldd	r18, Z+13	; 0x0d
     d98:	26 30       	cpi	r18, 0x06	; 6
     d9a:	b1 f4       	brne	.+44     	; 0xdc8 <_Z25eth_type_is_arp_and_my_ipPhj+0x40>
     d9c:	36 a1       	ldd	r19, Z+38	; 0x26
     d9e:	20 91 a5 01 	lds	r18, 0x01A5	; 0x8001a5 <_ZL6ipaddr>
     da2:	32 13       	cpse	r19, r18
     da4:	13 c0       	rjmp	.+38     	; 0xdcc <_Z25eth_type_is_arp_and_my_ipPhj+0x44>
     da6:	b7 96       	adiw	r30, 0x27	; 39
     da8:	a6 ea       	ldi	r26, 0xA6	; 166
     daa:	b1 e0       	ldi	r27, 0x01	; 1
     dac:	8a 96       	adiw	r24, 0x2a	; 42
     dae:	31 91       	ld	r19, Z+
     db0:	2d 91       	ld	r18, X+
     db2:	32 13       	cpse	r19, r18
     db4:	0d c0       	rjmp	.+26     	; 0xdd0 <_Z25eth_type_is_arp_and_my_ipPhj+0x48>
     db6:	e8 17       	cp	r30, r24
     db8:	f9 07       	cpc	r31, r25
     dba:	c9 f7       	brne	.-14     	; 0xdae <_Z25eth_type_is_arp_and_my_ipPhj+0x26>
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	08 95       	ret
     dc0:	80 e0       	ldi	r24, 0x00	; 0
     dc2:	08 95       	ret
     dc4:	80 e0       	ldi	r24, 0x00	; 0
     dc6:	08 95       	ret
     dc8:	80 e0       	ldi	r24, 0x00	; 0
     dca:	08 95       	ret
     dcc:	80 e0       	ldi	r24, 0x00	; 0
     dce:	08 95       	ret
     dd0:	80 e0       	ldi	r24, 0x00	; 0
     dd2:	08 95       	ret

00000dd4 <_Z24eth_type_is_ip_and_my_ipPhj>:
     dd4:	cf 93       	push	r28
     dd6:	df 93       	push	r29
     dd8:	fc 01       	movw	r30, r24
     dda:	6a 32       	cpi	r22, 0x2A	; 42
     ddc:	71 05       	cpc	r23, r1
     dde:	e0 f0       	brcs	.+56     	; 0xe18 <_Z24eth_type_is_ip_and_my_ipPhj+0x44>
     de0:	84 85       	ldd	r24, Z+12	; 0x0c
     de2:	88 30       	cpi	r24, 0x08	; 8
     de4:	d9 f4       	brne	.+54     	; 0xe1c <_Z24eth_type_is_ip_and_my_ipPhj+0x48>
     de6:	85 85       	ldd	r24, Z+13	; 0x0d
     de8:	81 11       	cpse	r24, r1
     dea:	1a c0       	rjmp	.+52     	; 0xe20 <_Z24eth_type_is_ip_and_my_ipPhj+0x4c>
     dec:	96 85       	ldd	r25, Z+14	; 0x0e
     dee:	95 34       	cpi	r25, 0x45	; 69
     df0:	c1 f4       	brne	.+48     	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     df2:	26 8d       	ldd	r18, Z+30	; 0x1e
     df4:	90 91 a5 01 	lds	r25, 0x01A5	; 0x8001a5 <_ZL6ipaddr>
     df8:	29 13       	cpse	r18, r25
     dfa:	13 c0       	rjmp	.+38     	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     dfc:	df 01       	movw	r26, r30
     dfe:	5f 96       	adiw	r26, 0x1f	; 31
     e00:	c6 ea       	ldi	r28, 0xA6	; 166
     e02:	d1 e0       	ldi	r29, 0x01	; 1
     e04:	b2 96       	adiw	r30, 0x22	; 34
     e06:	2d 91       	ld	r18, X+
     e08:	99 91       	ld	r25, Y+
     e0a:	29 13       	cpse	r18, r25
     e0c:	0a c0       	rjmp	.+20     	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     e0e:	ae 17       	cp	r26, r30
     e10:	bf 07       	cpc	r27, r31
     e12:	c9 f7       	brne	.-14     	; 0xe06 <_Z24eth_type_is_ip_and_my_ipPhj+0x32>
     e14:	81 e0       	ldi	r24, 0x01	; 1
     e16:	05 c0       	rjmp	.+10     	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     e18:	80 e0       	ldi	r24, 0x00	; 0
     e1a:	03 c0       	rjmp	.+6      	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     e1c:	80 e0       	ldi	r24, 0x00	; 0
     e1e:	01 c0       	rjmp	.+2      	; 0xe22 <_Z24eth_type_is_ip_and_my_ipPhj+0x4e>
     e20:	80 e0       	ldi	r24, 0x00	; 0
     e22:	df 91       	pop	r29
     e24:	cf 91       	pop	r28
     e26:	08 95       	ret

00000e28 <_Z8make_ethPh>:
     e28:	fc 01       	movw	r30, r24
     e2a:	a9 ea       	ldi	r26, 0xA9	; 169
     e2c:	b1 e0       	ldi	r27, 0x01	; 1
     e2e:	9c 01       	movw	r18, r24
     e30:	2a 5f       	subi	r18, 0xFA	; 250
     e32:	3f 4f       	sbci	r19, 0xFF	; 255
     e34:	86 81       	ldd	r24, Z+6	; 0x06
     e36:	81 93       	st	Z+, r24
     e38:	8d 91       	ld	r24, X+
     e3a:	85 83       	std	Z+5, r24	; 0x05
     e3c:	e2 17       	cp	r30, r18
     e3e:	f3 07       	cpc	r31, r19
     e40:	c9 f7       	brne	.-14     	; 0xe34 <_Z8make_ethPh+0xc>
     e42:	08 95       	ret

00000e44 <_Z20fill_ip_hdr_checksumPh>:
     e44:	cf 93       	push	r28
     e46:	df 93       	push	r29
     e48:	ec 01       	movw	r28, r24
     e4a:	18 8e       	std	Y+24, r1	; 0x18
     e4c:	19 8e       	std	Y+25, r1	; 0x19
     e4e:	80 e4       	ldi	r24, 0x40	; 64
     e50:	8c 8b       	std	Y+20, r24	; 0x14
     e52:	1d 8a       	std	Y+21, r1	; 0x15
     e54:	8e 8b       	std	Y+22, r24	; 0x16
     e56:	40 e0       	ldi	r20, 0x00	; 0
     e58:	64 e1       	ldi	r22, 0x14	; 20
     e5a:	70 e0       	ldi	r23, 0x00	; 0
     e5c:	ce 01       	movw	r24, r28
     e5e:	0e 96       	adiw	r24, 0x0e	; 14
     e60:	04 df       	rcall	.-504    	; 0xc6a <_Z8checksumPhjh>
     e62:	98 8f       	std	Y+24, r25	; 0x18
     e64:	89 8f       	std	Y+25, r24	; 0x19
     e66:	df 91       	pop	r29
     e68:	cf 91       	pop	r28
     e6a:	08 95       	ret

00000e6c <_Z7make_ipPh>:
     e6c:	ac 01       	movw	r20, r24
     e6e:	a5 ea       	ldi	r26, 0xA5	; 165
     e70:	b1 e0       	ldi	r27, 0x01	; 1
     e72:	fc 01       	movw	r30, r24
     e74:	7a 96       	adiw	r30, 0x1a	; 26
     e76:	29 ea       	ldi	r18, 0xA9	; 169
     e78:	31 e0       	ldi	r19, 0x01	; 1
     e7a:	90 81       	ld	r25, Z
     e7c:	94 83       	std	Z+4, r25	; 0x04
     e7e:	9d 91       	ld	r25, X+
     e80:	91 93       	st	Z+, r25
     e82:	a2 17       	cp	r26, r18
     e84:	b3 07       	cpc	r27, r19
     e86:	c9 f7       	brne	.-14     	; 0xe7a <_Z7make_ipPh+0xe>
     e88:	ca 01       	movw	r24, r20
     e8a:	dc cf       	rjmp	.-72     	; 0xe44 <_Z20fill_ip_hdr_checksumPh>
     e8c:	08 95       	ret

00000e8e <_Z28make_arp_answer_from_requestPh>:

void make_arp_answer_from_request(uint8_t *buf)
{
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
        uint8_t i=0;
        //
        make_eth(buf);
     e92:	ec 01       	movw	r28, r24
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
     e94:	c9 df       	rcall	.-110    	; 0xe28 <_Z8make_ethPh>
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
     e96:	1c 8a       	std	Y+20, r1	; 0x14
     e98:	82 e0       	ldi	r24, 0x02	; 2
     e9a:	8d 8b       	std	Y+21, r24	; 0x15
     e9c:	a9 ea       	ldi	r26, 0xA9	; 169
     e9e:	b1 e0       	ldi	r27, 0x01	; 1
     ea0:	fe 01       	movw	r30, r28
     ea2:	76 96       	adiw	r30, 0x16	; 22
     ea4:	2f ea       	ldi	r18, 0xAF	; 175
        // fill the mac addresses:
        while(i<6){
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
     ea6:	31 e0       	ldi	r19, 0x01	; 1
     ea8:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
     eaa:	82 87       	std	Z+10, r24	; 0x0a
     eac:	8d 91       	ld	r24, X+
        //
        make_eth(buf);
        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;
        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
        // fill the mac addresses:
        while(i<6){
     eae:	81 93       	st	Z+, r24
     eb0:	a2 17       	cp	r26, r18
     eb2:	b3 07       	cpc	r27, r19
     eb4:	c9 f7       	brne	.-14     	; 0xea8 <_Z28make_arp_answer_from_requestPh+0x1a>
     eb6:	a5 ea       	ldi	r26, 0xA5	; 165
     eb8:	b1 e0       	ldi	r27, 0x01	; 1
     eba:	fe 01       	movw	r30, r28
     ebc:	7c 96       	adiw	r30, 0x1c	; 28
     ebe:	29 ea       	ldi	r18, 0xA9	; 169
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
     ec0:	31 e0       	ldi	r19, 0x01	; 1
     ec2:	80 81       	ld	r24, Z
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
     ec4:	82 87       	std	Z+10, r24	; 0x0a
     ec6:	8d 91       	ld	r24, X+
                buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
                buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
                i++;
        }
        i=0;
        while(i<4){
     ec8:	81 93       	st	Z+, r24
     eca:	a2 17       	cp	r26, r18
     ecc:	b3 07       	cpc	r27, r19
                buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
                buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
                i++;
        }
        // eth+arp is 42 bytes:
        enc28j60PacketSend(42,buf); 
     ece:	c9 f7       	brne	.-14     	; 0xec2 <_Z28make_arp_answer_from_requestPh+0x34>
     ed0:	be 01       	movw	r22, r28
     ed2:	8a e2       	ldi	r24, 0x2A	; 42
     ed4:	90 e0       	ldi	r25, 0x00	; 0
}
     ed6:	36 de       	rcall	.-916    	; 0xb44 <_Z18enc28j60PacketSendjPh>
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	08 95       	ret

00000ede <_Z28make_echo_reply_from_requestPhj>:

void make_echo_reply_from_request(uint8_t *buf,uint16_t len)
{
     ede:	0f 93       	push	r16
     ee0:	1f 93       	push	r17
     ee2:	cf 93       	push	r28
     ee4:	df 93       	push	r29
     ee6:	ec 01       	movw	r28, r24
        make_eth(buf);
        make_ip(buf);
     ee8:	8b 01       	movw	r16, r22
     eea:	9e df       	rcall	.-196    	; 0xe28 <_Z8make_ethPh>
        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;
     eec:	ce 01       	movw	r24, r28
        // we changed only the icmp.type field from request(=8) to reply(=0).
        // we can therefore easily correct the checksum:
        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08)){
     eee:	be df       	rcall	.-132    	; 0xe6c <_Z7make_ipPh>
     ef0:	1a a2       	std	Y+34, r1	; 0x22
     ef2:	8c a1       	ldd	r24, Y+36	; 0x24
                buf[ICMP_CHECKSUM_P+1]++;
     ef4:	88 3f       	cpi	r24, 0xF8	; 248
     ef6:	18 f0       	brcs	.+6      	; 0xefe <_Z28make_echo_reply_from_requestPhj+0x20>
     ef8:	9d a1       	ldd	r25, Y+37	; 0x25
        }
        buf[ICMP_CHECKSUM_P]+=0x08;
     efa:	9f 5f       	subi	r25, 0xFF	; 255
        //
        enc28j60PacketSend(len,buf);
     efc:	9d a3       	std	Y+37, r25	; 0x25
     efe:	88 5f       	subi	r24, 0xF8	; 248
     f00:	8c a3       	std	Y+36, r24	; 0x24
}
     f02:	be 01       	movw	r22, r28
     f04:	c8 01       	movw	r24, r16
     f06:	1e de       	rcall	.-964    	; 0xb44 <_Z18enc28j60PacketSendjPh>
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	1f 91       	pop	r17
     f0e:	0f 91       	pop	r16
     f10:	08 95       	ret

00000f12 <_Z27make_udp_reply_from_requestPhPchj>:

// you can send a max of 220 bytes of data
void make_udp_reply_from_request(uint8_t *buf,char *data,uint8_t datalen,uint16_t port)
{
     f12:	df 92       	push	r13
     f14:	ef 92       	push	r14
     f16:	ff 92       	push	r15
     f18:	0f 93       	push	r16
     f1a:	1f 93       	push	r17
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	ec 01       	movw	r28, r24
     f22:	d6 2e       	mov	r13, r22
     f24:	e7 2e       	mov	r14, r23
     f26:	04 2f       	mov	r16, r20
     f28:	12 2f       	mov	r17, r18
        uint8_t i=0;
        uint16_t ck;
        make_eth(buf);
     f2a:	f3 2e       	mov	r15, r19
     f2c:	7d df       	rcall	.-262    	; 0xe28 <_Z8make_ethPh>
     f2e:	0d 3d       	cpi	r16, 0xDD	; 221
     f30:	08 f0       	brcs	.+2      	; 0xf34 <_Z27make_udp_reply_from_requestPhPchj+0x22>
        if (datalen>220){
                datalen=220;
        }
        // total length field in the IP header must be set:
        buf[IP_TOTLEN_H_P]=0;
     f32:	0c ed       	ldi	r16, 0xDC	; 220
        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
     f34:	18 8a       	std	Y+16, r1	; 0x10
     f36:	8c e1       	ldi	r24, 0x1C	; 28
        make_ip(buf);
     f38:	80 0f       	add	r24, r16
     f3a:	89 8b       	std	Y+17, r24	; 0x11
        // send to port:
        //buf[UDP_DST_PORT_H_P]=port>>8;
        //buf[UDP_DST_PORT_L_P]=port & 0xff;
        // sent to port of sender and use "port" as own source:
        buf[UDP_DST_PORT_H_P]=buf[UDP_SRC_PORT_H_P];
     f3c:	ce 01       	movw	r24, r28
     f3e:	96 df       	rcall	.-212    	; 0xe6c <_Z7make_ipPh>
        buf[UDP_DST_PORT_L_P]= buf[UDP_SRC_PORT_L_P];
     f40:	8a a1       	ldd	r24, Y+34	; 0x22
     f42:	8c a3       	std	Y+36, r24	; 0x24
        buf[UDP_SRC_PORT_H_P]=port>>8;
     f44:	8b a1       	ldd	r24, Y+35	; 0x23
        buf[UDP_SRC_PORT_L_P]=port & 0xff;
     f46:	8d a3       	std	Y+37, r24	; 0x25
        // calculte the udp length:
        buf[UDP_LEN_H_P]=0;
     f48:	fa a2       	std	Y+34, r15	; 0x22
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
     f4a:	1b a3       	std	Y+35, r17	; 0x23
     f4c:	1e a2       	std	Y+38, r1	; 0x26
     f4e:	88 e0       	ldi	r24, 0x08	; 8
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
     f50:	80 0f       	add	r24, r16
        buf[UDP_CHECKSUM_L_P]=0;
     f52:	8f a3       	std	Y+39, r24	; 0x27
        // copy the data:
        while(i<datalen){
     f54:	18 a6       	std	Y+40, r1	; 0x28
     f56:	19 a6       	std	Y+41, r1	; 0x29
     f58:	00 23       	and	r16, r16
     f5a:	81 f0       	breq	.+32     	; 0xf7c <_Z27make_udp_reply_from_requestPhPchj+0x6a>
     f5c:	ad 2d       	mov	r26, r13
     f5e:	be 2d       	mov	r27, r14
     f60:	fe 01       	movw	r30, r28
     f62:	ba 96       	adiw	r30, 0x2a	; 42
     f64:	2f ef       	ldi	r18, 0xFF	; 255
     f66:	20 0f       	add	r18, r16
     f68:	30 e0       	ldi	r19, 0x00	; 0
     f6a:	25 5d       	subi	r18, 0xD5	; 213
     f6c:	3f 4f       	sbci	r19, 0xFF	; 255
                buf[UDP_DATA_P+i]=data[i];
     f6e:	2c 0f       	add	r18, r28
     f70:	3d 1f       	adc	r19, r29
        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
        // zero the checksum
        buf[UDP_CHECKSUM_H_P]=0;
        buf[UDP_CHECKSUM_L_P]=0;
        // copy the data:
        while(i<datalen){
     f72:	9d 91       	ld	r25, X+
     f74:	91 93       	st	Z+, r25
     f76:	e2 17       	cp	r30, r18
                buf[UDP_DATA_P+i]=data[i];
                i++;
        }
        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
     f78:	f3 07       	cpc	r31, r19
     f7a:	d9 f7       	brne	.-10     	; 0xf72 <_Z27make_udp_reply_from_requestPhPchj+0x60>
     f7c:	10 e0       	ldi	r17, 0x00	; 0
     f7e:	b8 01       	movw	r22, r16
     f80:	60 5f       	subi	r22, 0xF0	; 240
     f82:	7f 4f       	sbci	r23, 0xFF	; 255
     f84:	41 e0       	ldi	r20, 0x01	; 1
     f86:	ce 01       	movw	r24, r28
        buf[UDP_CHECKSUM_H_P]=ck>>8;
     f88:	4a 96       	adiw	r24, 0x1a	; 26
        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
     f8a:	6f de       	rcall	.-802    	; 0xc6a <_Z8checksumPhjh>
     f8c:	98 a7       	std	Y+40, r25	; 0x28
     f8e:	89 a7       	std	Y+41, r24	; 0x29
     f90:	be 01       	movw	r22, r28
}
     f92:	c8 01       	movw	r24, r16
     f94:	8a 96       	adiw	r24, 0x2a	; 42
     f96:	d6 dd       	rcall	.-1108   	; 0xb44 <_Z18enc28j60PacketSendjPh>
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	1f 91       	pop	r17
     f9e:	0f 91       	pop	r16
     fa0:	ff 90       	pop	r15
     fa2:	ef 90       	pop	r14
     fa4:	df 90       	pop	r13
     fa6:	08 95       	ret

00000fa8 <_Z8spi_initv>:
#include "spi.h"

void spi_init(void)
{
    //DDRB  |= 1<<PB5 | 1<<PB7; // mosi, sck output
	DDRB  |= 1<<SPI_MOSI | 1<<SPI_SCK; // mosi, sck output
     fa8:	87 b3       	in	r24, 0x17	; 23
     faa:	86 60       	ori	r24, 0x06	; 6
     fac:	87 bb       	out	0x17, r24	; 23
	cbi(SPI_DDR,SPI_MISO); // MISO is input
     fae:	bb 98       	cbi	0x17, 3	; 23
        
           //    CSPASSIVE; ###############################
    cbi(SPI_PORT,SPI_MOSI); // MOSI low
     fb0:	c2 98       	cbi	0x18, 2	; 24
    cbi(SPI_PORT,SPI_SCK); // SCK low
     fb2:	c1 98       	cbi	0x18, 1	; 24
    //CPHA = 0;
  //  SPCR &= 0xF3;

	// initialize SPI interface
	// master mode and Fosc/2 clock:
    SPCR = (1<<SPE)|(1<<MSTR);  
     fb4:	80 e5       	ldi	r24, 0x50	; 80
     fb6:	8d b9       	out	0x0d, r24	; 13
     //SPCR &= 0x7B;
   // master mode and Fosc/128 clock:
   //SPCR &= 0xFB;
  
	//SPSR = 0x00;
    SPSR |= (1<<SPI2X); 
     fb8:	70 9a       	sbi	0x0e, 0	; 14
     fba:	08 95       	ret

00000fbc <_Z8delay_msj>:
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     fbc:	00 97       	sbiw	r24, 0x00	; 0
     fbe:	41 f0       	breq	.+16     	; 0xfd0 <_Z8delay_msj+0x14>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     fc0:	ef eb       	ldi	r30, 0xBF	; 191
     fc2:	f0 e0       	ldi	r31, 0x00	; 0
     fc4:	31 97       	sbiw	r30, 0x01	; 1
     fc6:	f1 f7       	brne	.-4      	; 0xfc4 <_Z8delay_msj+0x8>
     fc8:	00 c0       	rjmp	.+0      	; 0xfca <_Z8delay_msj+0xe>
     fca:	00 00       	nop
                _delay_ms(0.96);
                ms--;
     fcc:	01 97       	sbiw	r24, 0x01	; 1
/* delay for a minimum of <ms> */
{
        // we use a calibrated macro. This is more
        // accurate and not so much compiler dependent
        // as self made code.
        while(ms){
     fce:	c1 f7       	brne	.-16     	; 0xfc0 <_Z8delay_msj+0x4>
     fd0:	08 95       	ret

00000fd2 <_Z9Timer_ISR8Dev_typej>:
	sb->Serialstore(data);
	sbi(PORTB,6);
}
void Timer_ISR(Dev_type Device,uint16_t Arg)
{
	mem4[SEC]++;
     fd2:	e8 ec       	ldi	r30, 0xC8	; 200
     fd4:	f3 e0       	ldi	r31, 0x03	; 3
     fd6:	84 85       	ldd	r24, Z+12	; 0x0c
     fd8:	95 85       	ldd	r25, Z+13	; 0x0d
     fda:	01 96       	adiw	r24, 0x01	; 1
     fdc:	95 87       	std	Z+13, r25	; 0x0d
     fde:	84 87       	std	Z+12, r24	; 0x0c
	cbi(PORTB,5);
     fe0:	c5 98       	cbi	0x18, 5	; 24
	cbi(PORTB,6);
     fe2:	c6 98       	cbi	0x18, 6	; 24
     fe4:	08 95       	ret

00000fe6 <_ZL5proc2Pv>:
	}
}

#if USE_ETH
static void proc2(void* pvParam)
{
     fe6:	cf 93       	push	r28
     fe8:	df 93       	push	r29
     fea:	cd b7       	in	r28, 0x3d	; 61
     fec:	de b7       	in	r29, 0x3e	; 62
     fee:	a2 97       	sbiw	r28, 0x22	; 34
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	f8 94       	cli
     ff4:	de bf       	out	0x3e, r29	; 62
     ff6:	0f be       	out	0x3f, r0	; 63
     ff8:	cd bf       	out	0x3d, r28	; 61
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
     ffa:	04 ec       	ldi	r16, 0xC4	; 196
     ffc:	13 e0       	ldi	r17, 0x03	; 3
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
     ffe:	0f 2e       	mov	r0, r31
    1000:	f8 e0       	ldi	r31, 0x08	; 8
    1002:	4f 2e       	mov	r4, r31
    1004:	f4 e0       	ldi	r31, 0x04	; 4
    1006:	5f 2e       	mov	r5, r31
    1008:	f0 2d       	mov	r31, r0
    100a:	0f 2e       	mov	r0, r31
    100c:	fa e0       	ldi	r31, 0x0A	; 10
    100e:	cf 2e       	mov	r12, r31
    1010:	f4 e0       	ldi	r31, 0x04	; 4
    1012:	df 2e       	mov	r13, r31
    1014:	f0 2d       	mov	r31, r0
    1016:	0f 2e       	mov	r0, r31
    1018:	fc e0       	ldi	r31, 0x0C	; 12
    101a:	ef 2e       	mov	r14, r31
    101c:	f4 e0       	ldi	r31, 0x04	; 4
    101e:	ff 2e       	mov	r15, r31
    1020:	f0 2d       	mov	r31, r0
			make_echo_reply_from_request(buf,plen);
			continue;
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
		 {
			 char temp[29] = {0};
    1022:	ce 01       	movw	r24, r28
    1024:	01 96       	adiw	r24, 0x01	; 1
    1026:	9f 8f       	std	Y+31, r25	; 0x1f
    1028:	8e 8f       	std	Y+30, r24	; 0x1e
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    102a:	33 24       	eor	r3, r3
    102c:	33 94       	inc	r3
{
RESET_ETH:
    char led_flag = 0;
	static uint8_t mymac[6] = {0x54,0x55,0x58,0x10,0x00,0x24};
	static uint8_t myip[4] = {0,0,0,0};
	memcpy(myip,cmp_mem,sizeof(cmp_mem));		
    102e:	f8 01       	movw	r30, r16
    1030:	80 81       	ld	r24, Z
    1032:	91 81       	ldd	r25, Z+1	; 0x01
    1034:	a2 81       	ldd	r26, Z+2	; 0x02
    1036:	b3 81       	ldd	r27, Z+3	; 0x03
    1038:	80 93 c0 03 	sts	0x03C0, r24	; 0x8003c0 <_ZZL5proc2PvE4myip>
    103c:	90 93 c1 03 	sts	0x03C1, r25	; 0x8003c1 <_ZZL5proc2PvE4myip+0x1>
    1040:	a0 93 c2 03 	sts	0x03C2, r26	; 0x8003c2 <_ZZL5proc2PvE4myip+0x2>
    1044:	b0 93 c3 03 	sts	0x03C3, r27	; 0x8003c3 <_ZZL5proc2PvE4myip+0x3>
	static uint8_t buf[BUFFER_SIZE+1];
	uint16_t plen;
	DDRB = 0xff;
    1048:	8f ef       	ldi	r24, 0xFF	; 255
    104a:	87 bb       	out	0x17, r24	; 23
	PORTB = 0xff;
    104c:	88 bb       	out	0x18, r24	; 24
	 enc28j60Init(mymac);
    104e:	81 e0       	ldi	r24, 0x01	; 1
    1050:	91 e0       	ldi	r25, 0x01	; 1
	 enc28j60clkout(2); // change clkout from 6.25MHz to 12.5MHz
    1052:	fe dc       	rcall	.-1540   	; 0xa50 <_Z12enc28j60InitPh>
    1054:	82 e0       	ldi	r24, 0x02	; 2
	 vTaskDelay(10);
    1056:	f7 dc       	rcall	.-1554   	; 0xa46 <_Z14enc28j60clkouth>
    1058:	8a e0       	ldi	r24, 0x0A	; 10
    105a:	90 e0       	ldi	r25, 0x00	; 0
    105c:	0e 94 b6 13 	call	0x276c	; 0x276c <vTaskDelay>
	 enc28j60PhyWrite(PHLCON,0x476);
    1060:	66 e7       	ldi	r22, 0x76	; 118
    1062:	74 e0       	ldi	r23, 0x04	; 4
    1064:	84 e1       	ldi	r24, 0x14	; 20
	 vTaskDelay(20);
    1066:	d7 dc       	rcall	.-1618   	; 0xa16 <_Z16enc28j60PhyWritehj>
    1068:	84 e1       	ldi	r24, 0x14	; 20
    106a:	90 e0       	ldi	r25, 0x00	; 0
    106c:	0e 94 b6 13 	call	0x276c	; 0x276c <vTaskDelay>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);
    1070:	40 e5       	ldi	r20, 0x50	; 80
    1072:	60 ec       	ldi	r22, 0xC0	; 192
    1074:	73 e0       	ldi	r23, 0x03	; 3
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	91 e0       	ldi	r25, 0x01	; 1

#if USE_ETH
static void proc2(void* pvParam)
{
RESET_ETH:
    char led_flag = 0;
    107a:	6d de       	rcall	.-806    	; 0xd56 <_Z19init_ip_arp_udp_tcpPhS_h>
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    107c:	18 a2       	std	Y+32, r1	; 0x20
    107e:	21 2c       	mov	r2, r1
    1080:	0f 2e       	mov	r0, r31
    1082:	fe e0       	ldi	r31, 0x0E	; 14
    1084:	af 2e       	mov	r10, r31
    1086:	f4 e0       	ldi	r31, 0x04	; 4
    1088:	bf 2e       	mov	r11, r31
			 else
			 {
				 PORTB = cbi(PORTB,4); 
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    108a:	f0 2d       	mov	r31, r0
    108c:	0f 2e       	mov	r0, r31
    108e:	ff ea       	ldi	r31, 0xAF	; 175
    1090:	6f 2e       	mov	r6, r31
    1092:	f1 e0       	ldi	r31, 0x01	; 1
    1094:	7f 2e       	mov	r7, r31
    1096:	f0 2d       	mov	r31, r0
    1098:	0f 2e       	mov	r0, r31
    109a:	f8 ec       	ldi	r31, 0xC8	; 200
    109c:	8f 2e       	mov	r8, r31
    109e:	f3 e0       	ldi	r31, 0x03	; 3
    10a0:	9f 2e       	mov	r9, r31
	 //init the ethernet/ip layer:
	 init_ip_arp_udp_tcp(mymac,myip,MYWWWPORT);

	 while(1)
	 {
		 if((cmp_mem[0] != mem4[IPV4_0]) | (cmp_mem[1] != mem4[IPV4_1]) | (cmp_mem[2] != mem4[IPV4_2]) | (cmp_mem[3] != mem4[IPV4_3]))
    10a2:	f0 2d       	mov	r31, r0
    10a4:	d8 01       	movw	r26, r16
    10a6:	8c 91       	ld	r24, X
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	f2 01       	movw	r30, r4
    10ac:	60 81       	ld	r22, Z
    10ae:	71 81       	ldd	r23, Z+1	; 0x01
    10b0:	11 96       	adiw	r26, 0x01	; 1
    10b2:	4c 91       	ld	r20, X
    10b4:	50 e0       	ldi	r21, 0x00	; 0
    10b6:	33 2d       	mov	r19, r3
    10b8:	f6 01       	movw	r30, r12
    10ba:	a0 81       	ld	r26, Z
    10bc:	b1 81       	ldd	r27, Z+1	; 0x01
    10be:	4a 17       	cp	r20, r26
    10c0:	5b 07       	cpc	r21, r27
    10c2:	09 f4       	brne	.+2      	; 0x10c6 <_ZL5proc2Pv+0xe0>
    10c4:	32 2d       	mov	r19, r2
    10c6:	23 2d       	mov	r18, r3
    10c8:	86 17       	cp	r24, r22
    10ca:	97 07       	cpc	r25, r23
    10cc:	09 f4       	brne	.+2      	; 0x10d0 <_ZL5proc2Pv+0xea>
    10ce:	22 2d       	mov	r18, r2
    10d0:	f3 2f       	mov	r31, r19
    10d2:	f2 2b       	or	r31, r18
    10d4:	d8 01       	movw	r26, r16
    10d6:	12 96       	adiw	r26, 0x02	; 2
    10d8:	2c 91       	ld	r18, X
    10da:	30 e0       	ldi	r19, 0x00	; 0
    10dc:	e3 2d       	mov	r30, r3
    10de:	d7 01       	movw	r26, r14
    10e0:	4d 91       	ld	r20, X+
    10e2:	5c 91       	ld	r21, X
    10e4:	24 17       	cp	r18, r20
    10e6:	35 07       	cpc	r19, r21
    10e8:	09 f4       	brne	.+2      	; 0x10ec <_ZL5proc2Pv+0x106>
    10ea:	e2 2d       	mov	r30, r2
    10ec:	ef 2b       	or	r30, r31
    10ee:	71 f4       	brne	.+28     	; 0x110c <__stack+0xd>
    10f0:	f8 01       	movw	r30, r16
    10f2:	23 81       	ldd	r18, Z+3	; 0x03
    10f4:	30 e0       	ldi	r19, 0x00	; 0
    10f6:	e3 2d       	mov	r30, r3
    10f8:	d5 01       	movw	r26, r10
    10fa:	4d 91       	ld	r20, X+
    10fc:	5c 91       	ld	r21, X
    10fe:	24 17       	cp	r18, r20
    1100:	35 07       	cpc	r19, r21
    1102:	09 f4       	brne	.+2      	; 0x1106 <__stack+0x7>
    1104:	e2 2d       	mov	r30, r2
    1106:	ee 23       	and	r30, r30
    1108:	09 f4       	brne	.+2      	; 0x110c <__stack+0xd>
		 {
			 if(cmp_mem[0] != mem4[IPV4_0])
    110a:	46 c0       	rjmp	.+140    	; 0x1198 <__stack+0x99>
    110c:	86 17       	cp	r24, r22
    110e:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)0,mem4[IPV4_0]);
    1110:	41 f0       	breq	.+16     	; 0x1122 <__stack+0x23>
    1112:	80 e0       	ldi	r24, 0x00	; 0
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	0e 94 29 17 	call	0x2e52	; 0x2e52 <eeprom_update_byte>
				  cmp_mem[0] = mem4[IPV4_0];
    111a:	f2 01       	movw	r30, r4
    111c:	80 81       	ld	r24, Z
    111e:	d8 01       	movw	r26, r16
			 }
			 if(cmp_mem[1] != mem4[IPV4_1])
    1120:	8c 93       	st	X, r24
    1122:	f6 01       	movw	r30, r12
    1124:	60 81       	ld	r22, Z
    1126:	71 81       	ldd	r23, Z+1	; 0x01
    1128:	d8 01       	movw	r26, r16
    112a:	11 96       	adiw	r26, 0x01	; 1
    112c:	8c 91       	ld	r24, X
    112e:	90 e0       	ldi	r25, 0x00	; 0
    1130:	86 17       	cp	r24, r22
    1132:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)1,mem4[IPV4_1]);
    1134:	49 f0       	breq	.+18     	; 0x1148 <__stack+0x49>
    1136:	81 e0       	ldi	r24, 0x01	; 1
    1138:	90 e0       	ldi	r25, 0x00	; 0
    113a:	0e 94 29 17 	call	0x2e52	; 0x2e52 <eeprom_update_byte>
				  cmp_mem[1] = mem4[IPV4_1];
    113e:	f6 01       	movw	r30, r12
    1140:	80 81       	ld	r24, Z
    1142:	d8 01       	movw	r26, r16
    1144:	11 96       	adiw	r26, 0x01	; 1
			 }
			 if(cmp_mem[2] != mem4[IPV4_2])
    1146:	8c 93       	st	X, r24
    1148:	f7 01       	movw	r30, r14
    114a:	60 81       	ld	r22, Z
    114c:	71 81       	ldd	r23, Z+1	; 0x01
    114e:	d8 01       	movw	r26, r16
    1150:	12 96       	adiw	r26, 0x02	; 2
    1152:	8c 91       	ld	r24, X
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	86 17       	cp	r24, r22
    1158:	97 07       	cpc	r25, r23
			 {
				  eeprom_update_byte((uint8_t*)2,mem4[IPV4_2]);
    115a:	49 f0       	breq	.+18     	; 0x116e <__stack+0x6f>
    115c:	82 e0       	ldi	r24, 0x02	; 2
    115e:	90 e0       	ldi	r25, 0x00	; 0
    1160:	0e 94 29 17 	call	0x2e52	; 0x2e52 <eeprom_update_byte>
				  cmp_mem[2] = mem4[IPV4_2];
    1164:	f7 01       	movw	r30, r14
    1166:	80 81       	ld	r24, Z
    1168:	d8 01       	movw	r26, r16
    116a:	12 96       	adiw	r26, 0x02	; 2
			 }
			 if(cmp_mem[3] != mem4[IPV4_3])
    116c:	8c 93       	st	X, r24
    116e:	60 91 0e 04 	lds	r22, 0x040E	; 0x80040e <mem4+0x46>
    1172:	70 91 0f 04 	lds	r23, 0x040F	; 0x80040f <mem4+0x47>
    1176:	f8 01       	movw	r30, r16
    1178:	83 81       	ldd	r24, Z+3	; 0x03
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	86 17       	cp	r24, r22
    117e:	97 07       	cpc	r25, r23
    1180:	09 f4       	brne	.+2      	; 0x1184 <__stack+0x85>
			 {
				  eeprom_update_byte((uint8_t*)3,mem4[IPV4_3]);
    1182:	55 cf       	rjmp	.-342    	; 0x102e <_ZL5proc2Pv+0x48>
    1184:	83 e0       	ldi	r24, 0x03	; 3
    1186:	90 e0       	ldi	r25, 0x00	; 0
    1188:	0e 94 29 17 	call	0x2e52	; 0x2e52 <eeprom_update_byte>
				  cmp_mem[3] = mem4[IPV4_3];
    118c:	80 91 0e 04 	lds	r24, 0x040E	; 0x80040e <mem4+0x46>
    1190:	d8 01       	movw	r26, r16
    1192:	13 96       	adiw	r26, 0x03	; 3
			 }
			 goto RESET_ETH;
		 }
		 plen = enc28j60PacketReceive(BUFFER_SIZE, buf);
    1194:	8c 93       	st	X, r24
    1196:	49 cf       	rjmp	.-366    	; 0x102a <_ZL5proc2Pv+0x44>
    1198:	6f eb       	ldi	r22, 0xBF	; 191
    119a:	71 e0       	ldi	r23, 0x01	; 1
    119c:	80 e0       	ldi	r24, 0x00	; 0
    119e:	92 e0       	ldi	r25, 0x02	; 2
    11a0:	ff dc       	rcall	.-1538   	; 0xba0 <_Z21enc28j60PacketReceivejPh>
		 if(plen==0)
    11a2:	9a a3       	std	Y+34, r25	; 0x22
    11a4:	89 a3       	std	Y+33, r24	; 0x21
		 {
			 goto UDP_SEND;
		 }
		 if(eth_type_is_arp_and_my_ip(buf,plen))
    11a6:	00 97       	sbiw	r24, 0x00	; 0
    11a8:	09 f4       	brne	.+2      	; 0x11ac <__stack+0xad>
    11aa:	70 c0       	rjmp	.+224    	; 0x128c <__stack+0x18d>
    11ac:	bc 01       	movw	r22, r24
    11ae:	8f eb       	ldi	r24, 0xBF	; 191
    11b0:	91 e0       	ldi	r25, 0x01	; 1
		 {
			 make_arp_answer_from_request(buf);
    11b2:	ea dd       	rcall	.-1068   	; 0xd88 <_Z25eth_type_is_arp_and_my_ipPhj>
    11b4:	88 23       	and	r24, r24
    11b6:	21 f0       	breq	.+8      	; 0x11c0 <__stack+0xc1>
			 continue;
    11b8:	8f eb       	ldi	r24, 0xBF	; 191
		 }
		 if(eth_type_is_ip_and_my_ip(buf,plen)==0)
    11ba:	91 e0       	ldi	r25, 0x01	; 1
    11bc:	68 de       	rcall	.-816    	; 0xe8e <_Z28make_arp_answer_from_requestPh>
    11be:	72 cf       	rjmp	.-284    	; 0x10a4 <_ZL5proc2Pv+0xbe>
    11c0:	69 a1       	ldd	r22, Y+33	; 0x21
    11c2:	7a a1       	ldd	r23, Y+34	; 0x22
    11c4:	8f eb       	ldi	r24, 0xBF	; 191
    11c6:	91 e0       	ldi	r25, 0x01	; 1
    11c8:	05 de       	rcall	.-1014   	; 0xdd4 <_Z24eth_type_is_ip_and_my_ipPhj>
    11ca:	88 23       	and	r24, r24
		 {
			 continue;
		 }
		 if(buf[IP_PROTO_P]==IP_PROTO_ICMP_V && buf[ICMP_TYPE_P]==ICMP_TYPE_ECHOREQUEST_V)
    11cc:	09 f4       	brne	.+2      	; 0x11d0 <__stack+0xd1>
    11ce:	6a cf       	rjmp	.-300    	; 0x10a4 <_ZL5proc2Pv+0xbe>
    11d0:	80 91 d6 01 	lds	r24, 0x01D6	; 0x8001d6 <_ZZL5proc2PvE3buf+0x17>
    11d4:	81 30       	cpi	r24, 0x01	; 1
    11d6:	51 f4       	brne	.+20     	; 0x11ec <__stack+0xed>
		 {
			make_echo_reply_from_request(buf,plen);
    11d8:	80 91 e1 01 	lds	r24, 0x01E1	; 0x8001e1 <_ZZL5proc2PvE3buf+0x22>
    11dc:	88 30       	cpi	r24, 0x08	; 8
    11de:	31 f4       	brne	.+12     	; 0x11ec <__stack+0xed>
    11e0:	69 a1       	ldd	r22, Y+33	; 0x21
    11e2:	7a a1       	ldd	r23, Y+34	; 0x22
			continue;
    11e4:	8f eb       	ldi	r24, 0xBF	; 191
		 }
		 if(buf[UDP_DATA_P] == 0x01 + '0')
    11e6:	91 e0       	ldi	r25, 0x01	; 1
    11e8:	7a de       	rcall	.-780    	; 0xede <_Z28make_echo_reply_from_requestPhj>
    11ea:	5c cf       	rjmp	.-328    	; 0x10a4 <_ZL5proc2Pv+0xbe>
    11ec:	80 91 e9 01 	lds	r24, 0x01E9	; 0x8001e9 <_ZZL5proc2PvE3buf+0x2a>
		 {
			 char temp[29] = {0};
    11f0:	81 33       	cpi	r24, 0x31	; 49
    11f2:	09 f0       	breq	.+2      	; 0x11f6 <__stack+0xf7>
    11f4:	4b c0       	rjmp	.+150    	; 0x128c <__stack+0x18d>
    11f6:	ee 8d       	ldd	r30, Y+30	; 0x1e
    11f8:	ff 8d       	ldd	r31, Y+31	; 0x1f
    11fa:	8d e1       	ldi	r24, 0x1D	; 29
			 char loop = buf[UDP_DATA_P + 1];
    11fc:	11 92       	st	Z+, r1
    11fe:	8a 95       	dec	r24
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    1200:	e9 f7       	brne	.-6      	; 0x11fc <__stack+0xfd>
    1202:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <_ZZL5proc2PvE3buf+0x2b>
    1206:	80 53       	subi	r24, 0x30	; 48
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	01 96       	adiw	r24, 0x01	; 1
    120c:	82 30       	cpi	r24, 0x02	; 2
    120e:	91 05       	cpc	r25, r1
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    1210:	0c f0       	brlt	.+2      	; 0x1214 <__stack+0x115>
    1212:	87 c0       	rjmp	.+270    	; 0x1322 <__stack+0x223>
    1214:	22 c0       	rjmp	.+68     	; 0x125a <__stack+0x15b>
    1216:	f9 01       	movw	r30, r18
    1218:	e1 54       	subi	r30, 0x41	; 65
    121a:	fe 4f       	sbci	r31, 0xFE	; 254
    121c:	63 a5       	ldd	r22, Z+43	; 0x2b
    121e:	fe 01       	movw	r30, r28
				 if(i % 2 == 0)
    1220:	e2 0f       	add	r30, r18
    1222:	f3 1f       	adc	r31, r19
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
    1224:	60 83       	st	Z, r22
    1226:	40 fd       	sbrc	r20, 0
    1228:	12 c0       	rjmp	.+36     	; 0x124e <__stack+0x14f>
    122a:	e5 2f       	mov	r30, r21
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	ee 0f       	add	r30, r30
    1230:	ff 1f       	adc	r31, r31
    1232:	e4 52       	subi	r30, 0x24	; 36
    1234:	fc 4f       	sbci	r31, 0xFC	; 252
    1236:	af ef       	ldi	r26, 0xFF	; 255
    1238:	bf ef       	ldi	r27, 0xFF	; 255
    123a:	ac 0f       	add	r26, r28
    123c:	bd 1f       	adc	r27, r29
    123e:	a2 0f       	add	r26, r18
    1240:	b3 1f       	adc	r27, r19
    1242:	2c 91       	ld	r18, X
    1244:	30 e0       	ldi	r19, 0x00	; 0
					num++;
    1246:	36 2b       	or	r19, r22
			 char temp[29] = {0};
			 char loop = buf[UDP_DATA_P + 1];
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
    1248:	31 83       	std	Z+1, r19	; 0x01
    124a:	20 83       	st	Z, r18
    124c:	5f 5f       	subi	r21, 0xFF	; 255
    124e:	4f 5f       	subi	r20, 0xFF	; 255
    1250:	24 2f       	mov	r18, r20
    1252:	30 e0       	ldi	r19, 0x00	; 0
				 {
					mem4[UDP_DATA0 + num] =  (( 0xff00 & temp[i-1] << 8)) | (0x00ff & temp[i-2]);
					num++;
				 }
			 }
			 mem4[GOAL_CNT] = mem4[UDP_DATA14];
    1254:	28 17       	cp	r18, r24
    1256:	39 07       	cpc	r19, r25
    1258:	f4 f2       	brlt	.-68     	; 0x1216 <__stack+0x117>
    125a:	d4 01       	movw	r26, r8
    125c:	d0 96       	adiw	r26, 0x30	; 48
    125e:	8d 91       	ld	r24, X+
    1260:	9c 91       	ld	r25, X
    1262:	d1 97       	sbiw	r26, 0x31	; 49
    1264:	51 96       	adiw	r26, 0x11	; 17
			 mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1266:	9c 93       	st	X, r25
    1268:	8e 93       	st	-X, r24
    126a:	50 97       	sbiw	r26, 0x10	; 16
    126c:	dd 96       	adiw	r26, 0x3d	; 61
			 mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    126e:	9c 93       	st	X, r25
    1270:	8e 93       	st	-X, r24
    1272:	dc 97       	sbiw	r26, 0x3c	; 60
    1274:	d9 96       	adiw	r26, 0x39	; 57
			 mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    1276:	9c 93       	st	X, r25
    1278:	8e 93       	st	-X, r24
    127a:	d8 97       	sbiw	r26, 0x38	; 56
    127c:	d7 96       	adiw	r26, 0x37	; 55
			 mem4[TARGET_CMP] = mem4[GOAL_CNT];
    127e:	9c 93       	st	X, r25
    1280:	8e 93       	st	-X, r24
    1282:	d6 97       	sbiw	r26, 0x36	; 54
    1284:	df 96       	adiw	r26, 0x3f	; 63
			 goto UDP_SEND;
		 }
		 UDP_SEND:
			 led_flag = ~led_flag;
    1286:	9c 93       	st	X, r25
    1288:	8e 93       	st	-X, r24
    128a:	de 97       	sbiw	r26, 0x3e	; 62
			 if(led_flag)
    128c:	b8 a1       	ldd	r27, Y+32	; 0x20
    128e:	b0 95       	com	r27
			 {
				 PORTB = sbi(PORTB,4);
    1290:	b8 a3       	std	Y+32, r27	; 0x20
    1292:	bb 23       	and	r27, r27
    1294:	29 f0       	breq	.+10     	; 0x12a0 <__stack+0x1a1>
    1296:	88 b3       	in	r24, 0x18	; 24
    1298:	80 61       	ori	r24, 0x10	; 16
			 }
			 else
			 {
				 PORTB = cbi(PORTB,4); 
    129a:	88 bb       	out	0x18, r24	; 24
    129c:	88 bb       	out	0x18, r24	; 24
    129e:	04 c0       	rjmp	.+8      	; 0x12a8 <__stack+0x1a9>
    12a0:	88 b3       	in	r24, 0x18	; 24
			 }
			 static int data[8] = {0};
			 data[0] = mem4[TEMP];
    12a2:	8f 7e       	andi	r24, 0xEF	; 239
    12a4:	88 bb       	out	0x18, r24	; 24
    12a6:	88 bb       	out	0x18, r24	; 24
    12a8:	f4 01       	movw	r30, r8
    12aa:	82 81       	ldd	r24, Z+2	; 0x02
    12ac:	93 81       	ldd	r25, Z+3	; 0x03
    12ae:	d3 01       	movw	r26, r6
			 data[1] = mem4[COUNT];
    12b0:	11 96       	adiw	r26, 0x01	; 1
    12b2:	9c 93       	st	X, r25
    12b4:	8e 93       	st	-X, r24
    12b6:	86 81       	ldd	r24, Z+6	; 0x06
    12b8:	97 81       	ldd	r25, Z+7	; 0x07
    12ba:	13 96       	adiw	r26, 0x03	; 3
			 data[2] = mem4[PRESSURE];
    12bc:	9c 93       	st	X, r25
    12be:	8e 93       	st	-X, r24
    12c0:	12 97       	sbiw	r26, 0x02	; 2
    12c2:	84 81       	ldd	r24, Z+4	; 0x04
    12c4:	95 81       	ldd	r25, Z+5	; 0x05
    12c6:	15 96       	adiw	r26, 0x05	; 5
			 data[3] = mem4[GOAL_CNT];
    12c8:	9c 93       	st	X, r25
    12ca:	8e 93       	st	-X, r24
    12cc:	14 97       	sbiw	r26, 0x04	; 4
    12ce:	80 89       	ldd	r24, Z+16	; 0x10
    12d0:	91 89       	ldd	r25, Z+17	; 0x11
    12d2:	17 96       	adiw	r26, 0x07	; 7
			 data[4] = mem4[MACHINE_STATES];
    12d4:	9c 93       	st	X, r25
    12d6:	8e 93       	st	-X, r24
    12d8:	16 97       	sbiw	r26, 0x06	; 6
    12da:	82 89       	ldd	r24, Z+18	; 0x12
    12dc:	93 89       	ldd	r25, Z+19	; 0x13
    12de:	19 96       	adiw	r26, 0x09	; 9
			 data[5] = mem4[SEC];
    12e0:	9c 93       	st	X, r25
    12e2:	8e 93       	st	-X, r24
    12e4:	18 97       	sbiw	r26, 0x08	; 8
    12e6:	84 85       	ldd	r24, Z+12	; 0x0c
    12e8:	95 85       	ldd	r25, Z+13	; 0x0d
    12ea:	1b 96       	adiw	r26, 0x0b	; 11
			 data[6] = mem4[MIN];
    12ec:	9c 93       	st	X, r25
    12ee:	8e 93       	st	-X, r24
    12f0:	1a 97       	sbiw	r26, 0x0a	; 10
    12f2:	82 85       	ldd	r24, Z+10	; 0x0a
    12f4:	93 85       	ldd	r25, Z+11	; 0x0b
    12f6:	1d 96       	adiw	r26, 0x0d	; 13
			 data[7] = mem4[HOUR];
    12f8:	9c 93       	st	X, r25
    12fa:	8e 93       	st	-X, r24
    12fc:	1c 97       	sbiw	r26, 0x0c	; 12
    12fe:	80 85       	ldd	r24, Z+8	; 0x08
    1300:	91 85       	ldd	r25, Z+9	; 0x09
			 make_udp_reply_from_request(buf,(char*)&data,sizeof(data),MYUDPPORT);
    1302:	1f 96       	adiw	r26, 0x0f	; 15
    1304:	9c 93       	st	X, r25
    1306:	8e 93       	st	-X, r24
    1308:	1e 97       	sbiw	r26, 0x0e	; 14
    130a:	2f e0       	ldi	r18, 0x0F	; 15
    130c:	37 e2       	ldi	r19, 0x27	; 39
    130e:	40 e1       	ldi	r20, 0x10	; 16
    1310:	b3 01       	movw	r22, r6
			 vTaskDelay(100);
    1312:	8f eb       	ldi	r24, 0xBF	; 191
    1314:	91 e0       	ldi	r25, 0x01	; 1
    1316:	fd dd       	rcall	.-1030   	; 0xf12 <_Z27make_udp_reply_from_requestPhPchj>
    1318:	84 e6       	ldi	r24, 0x64	; 100
    131a:	90 e0       	ldi	r25, 0x00	; 0
			 loop = loop - '0';
			 char start = 2;
			 char num = 0;
			 for(char i=1;i<loop+1;i++)
			 {
				 temp[i-1] = buf[UDP_DATA_P + (start + (i-1))];
    131c:	0e 94 b6 13 	call	0x276c	; 0x276c <vTaskDelay>
    1320:	c1 ce       	rjmp	.-638    	; 0x10a4 <_ZL5proc2Pv+0xbe>
    1322:	20 91 eb 01 	lds	r18, 0x01EB	; 0x8001eb <_ZZL5proc2PvE3buf+0x2c>
    1326:	29 83       	std	Y+1, r18	; 0x01
    1328:	41 e0       	ldi	r20, 0x01	; 1
    132a:	50 e0       	ldi	r21, 0x00	; 0
    132c:	90 cf       	rjmp	.-224    	; 0x124e <__stack+0x14f>

0000132e <_ZL5proc1Pv>:
			/////////////////////////////////			
		}
	}
}
static void proc1(void* pvParam) 
{
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	cd b7       	in	r28, 0x3d	; 61
    1334:	de b7       	in	r29, 0x3e	; 62
    1336:	2f 97       	sbiw	r28, 0x0f	; 15
    1338:	0f b6       	in	r0, 0x3f	; 63
    133a:	f8 94       	cli
    133c:	de bf       	out	0x3e, r29	; 62
    133e:	0f be       	out	0x3f, r0	; 63
    1340:	cd bf       	out	0x3d, r28	; 61
    1342:	6c 01       	movw	r12, r24
	//UART1 
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	//SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
    1344:	fe 01       	movw	r30, r28
    1346:	31 96       	adiw	r30, 0x01	; 1
    1348:	8f e0       	ldi	r24, 0x0F	; 15
    134a:	df 01       	movw	r26, r30
    134c:	1d 92       	st	X+, r1
    134e:	8a 95       	dec	r24
    1350:	e9 f7       	brne	.-6      	; 0x134c <_ZL5proc1Pv+0x1e>
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1352:	08 ec       	ldi	r16, 0xC8	; 200
    1354:	13 e0       	ldi	r17, 0x03	; 3
    1356:	5e 01       	movw	r10, r28
    1358:	b0 e1       	ldi	r27, 0x10	; 16
    135a:	ab 0e       	add	r10, r27
    135c:	b1 1c       	adc	r11, r1
			else
			{
				cbi(PORTB,7);
				GetExceptionCode(&exception,0x01,0x06);
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
				cbi(UCSR1B,RXCIE0);
    135e:	0f 2e       	mov	r0, r31
    1360:	fa e9       	ldi	r31, 0x9A	; 154
    1362:	8f 2e       	mov	r8, r31
    1364:	91 2c       	mov	r9, r1
    1366:	f0 2d       	mov	r31, r0
				mem4[TEMP] = current_temp;
				mem4[COUNT] = count_number;
				mem4[PRESSURE] = current_pressure;
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1368:	0f 2e       	mov	r0, r31
    136a:	f3 e0       	ldi	r31, 0x03	; 3
    136c:	6f 2e       	mov	r6, r31
    136e:	71 2c       	mov	r7, r1
    1370:	f0 2d       	mov	r31, r0
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	//SerialBuffer *sb1 = (SerialBuffer*)DataStruct[UART0];
	uint8_t proc1_buff[15] = {0};
	while(1)
	{
	   if(mem4[TARGET_CMP] != mem4[GOAL_CNT])
    1372:	f8 01       	movw	r30, r16
    1374:	80 89       	ldd	r24, Z+16	; 0x10
    1376:	91 89       	ldd	r25, Z+17	; 0x11
    1378:	26 ad       	ldd	r18, Z+62	; 0x3e
    137a:	37 ad       	ldd	r19, Z+63	; 0x3f
    137c:	28 17       	cp	r18, r24
    137e:	39 07       	cpc	r19, r25
    1380:	41 f0       	breq	.+16     	; 0x1392 <_ZL5proc1Pv+0x64>
	   {
		   mem4[TARGET_MAX] = mem4[GOAL_CNT];
    1382:	95 af       	std	Z+61, r25	; 0x3d
    1384:	84 af       	std	Z+60, r24	; 0x3c
		   mem4[TARGET_GOAL_CNT] = mem4[GOAL_CNT];
    1386:	91 af       	std	Z+57, r25	; 0x39
    1388:	80 af       	std	Z+56, r24	; 0x38
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
    138a:	97 ab       	std	Z+55, r25	; 0x37
    138c:	86 ab       	std	Z+54, r24	; 0x36
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
    138e:	97 af       	std	Z+63, r25	; 0x3f
    1390:	86 af       	std	Z+62, r24	; 0x3e
		}
		if(sb->SerialAvailable() >= 15)
    1392:	c6 01       	movw	r24, r12
    1394:	06 d8       	rcall	.-4084   	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1396:	8f 30       	cpi	r24, 0x0F	; 15
    1398:	60 f3       	brcs	.-40     	; 0x1372 <_ZL5proc1Pv+0x44>
    139a:	ce 01       	movw	r24, r28
    139c:	01 96       	adiw	r24, 0x01	; 1
    139e:	7c 01       	movw	r14, r24
		{
			for(uint8_t i=0;i<15;i++)
			{
				proc1_buff[i] = sb->SerialRead();
    13a0:	c6 01       	movw	r24, r12
    13a2:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    13a6:	d7 01       	movw	r26, r14
    13a8:	8d 93       	st	X+, r24
    13aa:	7d 01       	movw	r14, r26
		   mem4[WARNING_HIGH] = mem4[GOAL_CNT];
		   mem4[TARGET_CMP] = mem4[GOAL_CNT];
		}
		if(sb->SerialAvailable() >= 15)
		{
			for(uint8_t i=0;i<15;i++)
    13ac:	aa 15       	cp	r26, r10
    13ae:	bb 05       	cpc	r27, r11
    13b0:	b9 f7       	brne	.-18     	; 0x13a0 <_ZL5proc1Pv+0x72>
			{
				proc1_buff[i] = sb->SerialRead();
			}
			if(proc1_buff[0] == 0x02)
    13b2:	89 81       	ldd	r24, Y+1	; 0x01
    13b4:	82 30       	cpi	r24, 0x02	; 2
    13b6:	99 f5       	brne	.+102    	; 0x141e <_ZL5proc1Pv+0xf0>
			{
	
				count_number = ((0xff & proc1_buff[7]) << 8) | (0xff & proc1_buff[8]);
    13b8:	88 85       	ldd	r24, Y+8	; 0x08
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	98 2f       	mov	r25, r24
    13be:	88 27       	eor	r24, r24
    13c0:	29 85       	ldd	r18, Y+9	; 0x09
    13c2:	82 2b       	or	r24, r18
    13c4:	90 93 17 04 	sts	0x0417, r25	; 0x800417 <count_number+0x1>
    13c8:	80 93 16 04 	sts	0x0416, r24	; 0x800416 <count_number>
				current_temp = ((0xff & proc1_buff[9]) << 8) | (0xff & proc1_buff[10]);
    13cc:	4a 85       	ldd	r20, Y+10	; 0x0a
    13ce:	50 e0       	ldi	r21, 0x00	; 0
    13d0:	54 2f       	mov	r21, r20
    13d2:	44 27       	eor	r20, r20
    13d4:	2b 85       	ldd	r18, Y+11	; 0x0b
    13d6:	42 2b       	or	r20, r18
    13d8:	50 93 15 04 	sts	0x0415, r21	; 0x800415 <current_temp+0x1>
    13dc:	40 93 14 04 	sts	0x0414, r20	; 0x800414 <current_temp>
				current_pressure = ((0xff & proc1_buff[11]) << 8) | (0xff & proc1_buff[12]);
    13e0:	2c 85       	ldd	r18, Y+12	; 0x0c
    13e2:	30 e0       	ldi	r19, 0x00	; 0
    13e4:	32 2f       	mov	r19, r18
    13e6:	22 27       	eor	r18, r18
    13e8:	6d 85       	ldd	r22, Y+13	; 0x0d
    13ea:	26 2b       	or	r18, r22
    13ec:	30 93 13 04 	sts	0x0413, r19	; 0x800413 <current_pressure+0x1>
    13f0:	20 93 12 04 	sts	0x0412, r18	; 0x800412 <current_pressure>
				mem4[TEMP] = current_temp;
    13f4:	f8 01       	movw	r30, r16
    13f6:	53 83       	std	Z+3, r21	; 0x03
    13f8:	42 83       	std	Z+2, r20	; 0x02
				mem4[COUNT] = count_number;
    13fa:	97 83       	std	Z+7, r25	; 0x07
    13fc:	86 83       	std	Z+6, r24	; 0x06
				mem4[PRESSURE] = current_pressure;
    13fe:	35 83       	std	Z+5, r19	; 0x05
    1400:	24 83       	std	Z+4, r18	; 0x04
				if((mem4[GOAL_CNT] == mem4[COUNT])&& mem4[MACHINE_STATES] == NORMAL)
    1402:	20 89       	ldd	r18, Z+16	; 0x10
    1404:	31 89       	ldd	r19, Z+17	; 0x11
    1406:	82 17       	cp	r24, r18
    1408:	93 07       	cpc	r25, r19
    140a:	09 f0       	breq	.+2      	; 0x140e <_ZL5proc1Pv+0xe0>
    140c:	b2 cf       	rjmp	.-156    	; 0x1372 <_ZL5proc1Pv+0x44>
    140e:	82 89       	ldd	r24, Z+18	; 0x12
    1410:	93 89       	ldd	r25, Z+19	; 0x13
    1412:	89 2b       	or	r24, r25
    1414:	09 f0       	breq	.+2      	; 0x1418 <_ZL5proc1Pv+0xea>
    1416:	ad cf       	rjmp	.-166    	; 0x1372 <_ZL5proc1Pv+0x44>
				{
					mem4[MACHINE_STATES] = COMPLETE_PRODUCTS;
    1418:	73 8a       	std	Z+19, r7	; 0x13
    141a:	62 8a       	std	Z+18, r6	; 0x12
    141c:	aa cf       	rjmp	.-172    	; 0x1372 <_ZL5proc1Pv+0x44>
				}
			}
			else
			{
				cbi(PORTB,7);
    141e:	c7 98       	cbi	0x18, 7	; 24
				GetExceptionCode(&exception,0x01,0x06);
    1420:	46 e0       	ldi	r20, 0x06	; 6
    1422:	61 e0       	ldi	r22, 0x01	; 1
    1424:	80 e2       	ldi	r24, 0x20	; 32
    1426:	94 e0       	ldi	r25, 0x04	; 4
    1428:	0e 94 0c 01 	call	0x218	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
				sb->SerialWrite((char*)&exception,sizeof(exception)); //리스폰스 데이터 쓰기.
    142c:	45 e0       	ldi	r20, 0x05	; 5
    142e:	50 e0       	ldi	r21, 0x00	; 0
    1430:	60 e2       	ldi	r22, 0x20	; 32
    1432:	74 e0       	ldi	r23, 0x04	; 4
    1434:	c6 01       	movw	r24, r12
    1436:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
				cbi(UCSR1B,RXCIE0);
    143a:	d4 01       	movw	r26, r8
    143c:	8c 91       	ld	r24, X
    143e:	8f 77       	andi	r24, 0x7F	; 127
    1440:	8c 93       	st	X, r24
				sb->SerialFlush();
    1442:	c6 01       	movw	r24, r12
    1444:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
				sbi(UCSR1B,RXCIE0);
    1448:	f4 01       	movw	r30, r8
    144a:	80 81       	ld	r24, Z
    144c:	80 68       	ori	r24, 0x80	; 128
    144e:	80 83       	st	Z, r24
				sbi(PORTB,7);
    1450:	c7 9a       	sbi	0x18, 7	; 24
    1452:	8f cf       	rjmp	.-226    	; 0x1372 <_ZL5proc1Pv+0x44>

00001454 <_ZL4procPv>:
	#if USE_SYSTEM_SEC
		mem4[SYSTEM_SEC_CLOCK]++;
	#endif
}
static void proc(void* pvParam) //터치패널 HMI RS232 쓰레드
{
    1454:	cf 93       	push	r28
    1456:	df 93       	push	r29
    1458:	cd b7       	in	r28, 0x3d	; 61
    145a:	de b7       	in	r29, 0x3e	; 62
    145c:	2a 97       	sbiw	r28, 0x0a	; 10
    145e:	0f b6       	in	r0, 0x3f	; 63
    1460:	f8 94       	cli
    1462:	de bf       	out	0x3e, r29	; 62
    1464:	0f be       	out	0x3f, r0	; 63
    1466:	cd bf       	out	0x3d, r28	; 61
    1468:	7c 01       	movw	r14, r24
	char read_Flag = 0;
    146a:	d1 2c       	mov	r13, r1
	char buf1[10];
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	while(1)
	{
		if(mem4[SEC] >= 60)
    146c:	08 ec       	ldi	r16, 0xC8	; 200
    146e:	13 e0       	ldi	r17, 0x03	; 3
    1470:	4e 01       	movw	r8, r28
    1472:	8c e0       	ldi	r24, 0x0C	; 12
    1474:	88 0e       	add	r8, r24
    1476:	91 1c       	adc	r9, r1
    1478:	68 94       	set
    147a:	33 24       	eor	r3, r3
    147c:	34 f8       	bld	r3, 4
						buf1[i] = sb->SerialRead();
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
					read_Flag = 0;
    147e:	61 2c       	mov	r6, r1
    1480:	77 24       	eor	r7, r7
    1482:	73 94       	inc	r7
    1484:	5e 01       	movw	r10, r28
    1486:	e9 e0       	ldi	r30, 0x09	; 9
    1488:	ae 0e       	add	r10, r30
    148a:	b1 1c       	adc	r11, r1
    148c:	0f 2e       	mov	r0, r31
    148e:	f5 e0       	ldi	r31, 0x05	; 5
    1490:	4f 2e       	mov	r4, r31
    1492:	f0 2d       	mov	r31, r0
    1494:	68 94       	set
    1496:	55 24       	eor	r5, r5
    1498:	52 f8       	bld	r5, 2
    149a:	0e c0       	rjmp	.+28     	; 0x14b8 <_ZL4procPv+0x64>
    149c:	c7 2c       	mov	r12, r7
    149e:	d7 2c       	mov	r13, r7
    14a0:	0b c0       	rjmp	.+22     	; 0x14b8 <_ZL4procPv+0x64>
    14a2:	c7 2c       	mov	r12, r7
    14a4:	d7 2c       	mov	r13, r7
    14a6:	08 c0       	rjmp	.+16     	; 0x14b8 <_ZL4procPv+0x64>
    14a8:	c5 2c       	mov	r12, r5
    14aa:	d7 2c       	mov	r13, r7
    14ac:	05 c0       	rjmp	.+10     	; 0x14b8 <_ZL4procPv+0x64>
    14ae:	c4 2c       	mov	r12, r4
    14b0:	d7 2c       	mov	r13, r7
    14b2:	02 c0       	rjmp	.+4      	; 0x14b8 <_ZL4procPv+0x64>
    14b4:	c3 2c       	mov	r12, r3
    14b6:	d7 2c       	mov	r13, r7
	char buf1[10];
	//SerialBuffer *sb = (SerialBuffer*)pvParam;
	SerialBuffer *sb = static_cast<SerialBuffer*>(pvParam);	
	while(1)
	{
		if(mem4[SEC] >= 60)
    14b8:	f8 01       	movw	r30, r16
    14ba:	84 85       	ldd	r24, Z+12	; 0x0c
    14bc:	95 85       	ldd	r25, Z+13	; 0x0d
    14be:	cc 97       	sbiw	r24, 0x3c	; 60
    14c0:	9c f0       	brlt	.+38     	; 0x14e8 <_ZL4procPv+0x94>
		{
			mem4[SEC] = 0;
    14c2:	15 86       	std	Z+13, r1	; 0x0d
    14c4:	14 86       	std	Z+12, r1	; 0x0c
			mem4[MIN]++;
    14c6:	82 85       	ldd	r24, Z+10	; 0x0a
    14c8:	93 85       	ldd	r25, Z+11	; 0x0b
    14ca:	01 96       	adiw	r24, 0x01	; 1
			if(mem4[MIN] >= 60)
    14cc:	8c 33       	cpi	r24, 0x3C	; 60
    14ce:	91 05       	cpc	r25, r1
    14d0:	1c f4       	brge	.+6      	; 0x14d8 <_ZL4procPv+0x84>
	while(1)
	{
		if(mem4[SEC] >= 60)
		{
			mem4[SEC] = 0;
			mem4[MIN]++;
    14d2:	93 87       	std	Z+11, r25	; 0x0b
    14d4:	82 87       	std	Z+10, r24	; 0x0a
    14d6:	08 c0       	rjmp	.+16     	; 0x14e8 <_ZL4procPv+0x94>
			if(mem4[MIN] >= 60)
			{
				mem4[MIN] = 0;
    14d8:	f8 01       	movw	r30, r16
    14da:	13 86       	std	Z+11, r1	; 0x0b
    14dc:	12 86       	std	Z+10, r1	; 0x0a
				mem4[HOUR]++;
    14de:	80 85       	ldd	r24, Z+8	; 0x08
    14e0:	91 85       	ldd	r25, Z+9	; 0x09
    14e2:	01 96       	adiw	r24, 0x01	; 1
    14e4:	91 87       	std	Z+9, r25	; 0x09
    14e6:	80 87       	std	Z+8, r24	; 0x08
			}
		}
		if(read_Flag == 0)
    14e8:	d1 10       	cpse	r13, r1
    14ea:	2c c0       	rjmp	.+88     	; 0x1544 <_ZL4procPv+0xf0>
		{
			if(sb->SerialAvailable() >= 2)
    14ec:	c7 01       	movw	r24, r14
    14ee:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    14f2:	82 30       	cpi	r24, 0x02	; 2
    14f4:	08 f3       	brcs	.-62     	; 0x14b8 <_ZL4procPv+0x64>
			{
				for(int i=0;i<2;i++)
				{
					buf1[i] = sb->SerialRead();
    14f6:	c7 01       	movw	r24, r14
    14f8:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    14fc:	89 83       	std	Y+1, r24	; 0x01
    14fe:	c7 01       	movw	r24, r14
    1500:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1504:	8a 83       	std	Y+2, r24	; 0x02
				}
				if(buf1[0] != 0x01)
				{
					read_Flag = 0;
				}
				if(buf1[1] == 0x01)
    1506:	81 30       	cpi	r24, 0x01	; 1
    1508:	11 f1       	breq	.+68     	; 0x154e <_ZL4procPv+0xfa>
				{
					function_code = 0x01;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x04)
    150a:	84 30       	cpi	r24, 0x04	; 4
    150c:	b9 f1       	breq	.+110    	; 0x157c <_ZL4procPv+0x128>
				{
					function_code = 0x04;
					read_Flag = 1;
				}
				else if(buf1[1] == 0x05)
    150e:	85 30       	cpi	r24, 0x05	; 5
    1510:	09 f4       	brne	.+2      	; 0x1514 <_ZL4procPv+0xc0>
    1512:	5b c0       	rjmp	.+182    	; 0x15ca <_ZL4procPv+0x176>
				{
					function_code = 0x05;                              
					read_Flag = 1;
				}
				else if(buf1[1] == 0x10)
    1514:	80 31       	cpi	r24, 0x10	; 16
    1516:	09 f4       	brne	.+2      	; 0x151a <_ZL4procPv+0xc6>
    1518:	7e c0       	rjmp	.+252    	; 0x1616 <_ZL4procPv+0x1c2>
				else
				{
					#if CHECK_ERROR
						mem4[ERROR_CNT]++;
					#endif
					GetExceptionCode(&exception,0x01,0x01);  
    151a:	47 2d       	mov	r20, r7
    151c:	67 2d       	mov	r22, r7
    151e:	80 e2       	ldi	r24, 0x20	; 32
    1520:	94 e0       	ldi	r25, 0x04	; 4
    1522:	0e 94 0c 01 	call	0x218	; 0x218 <_Z16GetExceptionCodeP16RspExceptionCodecc>
					//dev->Close_Handle(UART0);
					//PORTB = 0x00;
					cbi(PORTB,7);
    1526:	c7 98       	cbi	0x18, 7	; 24
					cbi(UCSR0B,RXCIE0);                                                                                                                                                                                                                
    1528:	57 98       	cbi	0x0a, 7	; 10
					sb->SerialFlush();
    152a:	c7 01       	movw	r24, r14
    152c:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <_ZN12SerialBuffer11SerialFlushEv>
					sbi(UCSR0B,RXCIE0);
    1530:	57 9a       	sbi	0x0a, 7	; 10
					//dev->Open_Handle(UART0,Uart_ISR);
					sb->SerialWrite((char*)&exception,sizeof(exception));
    1532:	45 e0       	ldi	r20, 0x05	; 5
    1534:	50 e0       	ldi	r21, 0x00	; 0
    1536:	60 e2       	ldi	r22, 0x20	; 32
    1538:	74 e0       	ldi	r23, 0x04	; 4
    153a:	c7 01       	movw	r24, r14
    153c:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
					sbi(PORTB,7);
    1540:	c7 9a       	sbi	0x18, 7	; 24
    1542:	ba cf       	rjmp	.-140    	; 0x14b8 <_ZL4procPv+0x64>
					read_Flag = 0;	
				}
			}
			
		}
		if(read_Flag == 1)
    1544:	f1 e0       	ldi	r31, 0x01	; 1
    1546:	df 12       	cpse	r13, r31
    1548:	b7 cf       	rjmp	.-146    	; 0x14b8 <_ZL4procPv+0x64>
		{
			if(function_code == 0x01)  
    154a:	cf 12       	cpse	r12, r31
    154c:	14 c0       	rjmp	.+40     	; 0x1576 <_ZL4procPv+0x122>
			{
				if(sb->SerialAvailable() >= 6)
    154e:	c7 01       	movw	r24, r14
    1550:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1554:	86 30       	cpi	r24, 0x06	; 6
    1556:	08 f4       	brcc	.+2      	; 0x155a <_ZL4procPv+0x106>
    1558:	a1 cf       	rjmp	.-190    	; 0x149c <_ZL4procPv+0x48>
    155a:	6e 01       	movw	r12, r28
    155c:	83 e0       	ldi	r24, 0x03	; 3
    155e:	c8 0e       	add	r12, r24
    1560:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1562:	c7 01       	movw	r24, r14
    1564:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1568:	f6 01       	movw	r30, r12
    156a:	81 93       	st	Z+, r24
    156c:	6f 01       	movw	r12, r30
		{
			if(function_code == 0x01)  
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    156e:	ae 16       	cp	r10, r30
    1570:	bf 06       	cpc	r11, r31
    1572:	b9 f7       	brne	.-18     	; 0x1562 <_ZL4procPv+0x10e>
    1574:	96 cf       	rjmp	.-212    	; 0x14a2 <_ZL4procPv+0x4e>
						buf1[i] = sb->SerialRead();
					}

				}
			}
			else if(function_code == 0x04) //Max1W 값 읽기
    1576:	f4 e0       	ldi	r31, 0x04	; 4
    1578:	cf 12       	cpse	r12, r31
    157a:	24 c0       	rjmp	.+72     	; 0x15c4 <_ZL4procPv+0x170>
			{
				if(sb->SerialAvailable() >= 6)
    157c:	c7 01       	movw	r24, r14
    157e:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    1582:	86 30       	cpi	r24, 0x06	; 6
    1584:	08 f4       	brcc	.+2      	; 0x1588 <_ZL4procPv+0x134>
    1586:	90 cf       	rjmp	.-224    	; 0x14a8 <_ZL4procPv+0x54>
    1588:	6e 01       	movw	r12, r28
    158a:	83 e0       	ldi	r24, 0x03	; 3
    158c:	c8 0e       	add	r12, r24
    158e:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    1590:	c7 01       	movw	r24, r14
    1592:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1596:	f6 01       	movw	r30, r12
    1598:	81 93       	st	Z+, r24
    159a:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x04) //Max1W 값 읽기
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    159c:	ae 16       	cp	r10, r30
    159e:	bf 06       	cpc	r11, r31
    15a0:	b9 f7       	brne	.-18     	; 0x1590 <_ZL4procPv+0x13c>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc04Data(buf1,&func04,mem4);
    15a2:	a8 01       	movw	r20, r16
    15a4:	60 e3       	ldi	r22, 0x30	; 48
    15a6:	74 e0       	ldi	r23, 0x04	; 4
    15a8:	ce 01       	movw	r24, r28
    15aa:	01 96       	adiw	r24, 0x01	; 1
    15ac:	0e 94 8f 00 	call	0x11e	; 0x11e <_Z13GetFunc04DataPcP17GetFunctionCode04Pi>
					sb->SerialWrite((char*)&func04,sizeof(func04));
    15b0:	47 e0       	ldi	r20, 0x07	; 7
    15b2:	50 e0       	ldi	r21, 0x00	; 0
    15b4:	60 e3       	ldi	r22, 0x30	; 48
    15b6:	74 e0       	ldi	r23, 0x04	; 4
    15b8:	c7 01       	movw	r24, r14
    15ba:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    15be:	c5 2c       	mov	r12, r5
					read_Flag = 0;
    15c0:	d6 2c       	mov	r13, r6
    15c2:	7a cf       	rjmp	.-268    	; 0x14b8 <_ZL4procPv+0x64>
				}
			}
			else if(function_code == 0x05) //터치 버튼 
    15c4:	f5 e0       	ldi	r31, 0x05	; 5
    15c6:	cf 12       	cpse	r12, r31
    15c8:	23 c0       	rjmp	.+70     	; 0x1610 <_ZL4procPv+0x1bc>
			{
				if(sb->SerialAvailable() >= 6)
    15ca:	c7 01       	movw	r24, r14
    15cc:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    15d0:	86 30       	cpi	r24, 0x06	; 6
    15d2:	08 f4       	brcc	.+2      	; 0x15d6 <_ZL4procPv+0x182>
    15d4:	6c cf       	rjmp	.-296    	; 0x14ae <_ZL4procPv+0x5a>
    15d6:	6e 01       	movw	r12, r28
    15d8:	83 e0       	ldi	r24, 0x03	; 3
    15da:	c8 0e       	add	r12, r24
    15dc:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<8;i++)
					{
						buf1[i] = sb->SerialRead();
    15de:	c7 01       	movw	r24, r14
    15e0:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    15e4:	f6 01       	movw	r30, r12
    15e6:	81 93       	st	Z+, r24
    15e8:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x05) //터치 버튼 
			{
				if(sb->SerialAvailable() >= 6)
				{
					for(int i=2;i<8;i++)
    15ea:	ae 16       	cp	r10, r30
    15ec:	bf 06       	cpc	r11, r31
    15ee:	b9 f7       	brne	.-18     	; 0x15de <_ZL4procPv+0x18a>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFunc05Data(buf1,&func05);
    15f0:	67 e3       	ldi	r22, 0x37	; 55
    15f2:	74 e0       	ldi	r23, 0x04	; 4
    15f4:	ce 01       	movw	r24, r28
    15f6:	01 96       	adiw	r24, 0x01	; 1
    15f8:	0e 94 b0 00 	call	0x160	; 0x160 <_Z13GetFunc05DataPcP17GetFunctionCode05>
					sb->SerialWrite((char*)&func05,sizeof(func05));
    15fc:	48 e0       	ldi	r20, 0x08	; 8
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	67 e3       	ldi	r22, 0x37	; 55
    1602:	74 e0       	ldi	r23, 0x04	; 4
    1604:	c7 01       	movw	r24, r14
    1606:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    160a:	c4 2c       	mov	r12, r4
					read_Flag = 0;
    160c:	d6 2c       	mov	r13, r6
    160e:	54 cf       	rjmp	.-344    	; 0x14b8 <_ZL4procPv+0x64>
				}
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
    1610:	f0 e1       	ldi	r31, 0x10	; 16
    1612:	cf 12       	cpse	r12, r31
    1614:	51 cf       	rjmp	.-350    	; 0x14b8 <_ZL4procPv+0x64>
			{
				if(sb->SerialAvailable() >= 9)
    1616:	c7 01       	movw	r24, r14
    1618:	0e 94 d1 01 	call	0x3a2	; 0x3a2 <_ZN12SerialBuffer15SerialAvailableEv>
    161c:	89 30       	cpi	r24, 0x09	; 9
    161e:	08 f4       	brcc	.+2      	; 0x1622 <_ZL4procPv+0x1ce>
    1620:	49 cf       	rjmp	.-366    	; 0x14b4 <_ZL4procPv+0x60>
    1622:	6e 01       	movw	r12, r28
    1624:	83 e0       	ldi	r24, 0x03	; 3
    1626:	c8 0e       	add	r12, r24
    1628:	d1 1c       	adc	r13, r1
				{
					for(int i=2;i<11;i++)
					{
						buf1[i] = sb->SerialRead();
    162a:	c7 01       	movw	r24, r14
    162c:	0e 94 a5 01 	call	0x34a	; 0x34a <_ZN12SerialBuffer10SerialReadEv>
    1630:	f6 01       	movw	r30, r12
    1632:	81 93       	st	Z+, r24
    1634:	6f 01       	movw	r12, r30
			}
			else if(function_code == 0x10)  //3_MAX1W 입력 
			{
				if(sb->SerialAvailable() >= 9)
				{
					for(int i=2;i<11;i++)
    1636:	8e 16       	cp	r8, r30
    1638:	9f 06       	cpc	r9, r31
    163a:	b9 f7       	brne	.-18     	; 0x162a <_ZL4procPv+0x1d6>
					{
						buf1[i] = sb->SerialRead();
					}
					GetFucc10Data(buf1,&func10,mem4); //데이터 파싱
    163c:	a8 01       	movw	r20, r16
    163e:	65 e2       	ldi	r22, 0x25	; 37
    1640:	74 e0       	ldi	r23, 0x04	; 4
    1642:	ce 01       	movw	r24, r28
    1644:	01 96       	adiw	r24, 0x01	; 1
    1646:	0e 94 c9 00 	call	0x192	; 0x192 <_Z13GetFucc10DataPcP17GetFunctionCode10Pi>
					ResponseFucc10Data(buf1,&rsp10); //리스폰스 데이터를 만듬.
    164a:	68 e1       	ldi	r22, 0x18	; 24
    164c:	74 e0       	ldi	r23, 0x04	; 4
    164e:	ce 01       	movw	r24, r28
    1650:	01 96       	adiw	r24, 0x01	; 1
    1652:	0e 94 f3 00 	call	0x1e6	; 0x1e6 <_Z18ResponseFucc10DataPcP22ResponseFunctionCode10>
					sb->SerialWrite((char*)&rsp10,sizeof(rsp10)); //리스폰스 데이터 쓰기.
    1656:	48 e0       	ldi	r20, 0x08	; 8
    1658:	50 e0       	ldi	r21, 0x00	; 0
    165a:	68 e1       	ldi	r22, 0x18	; 24
    165c:	74 e0       	ldi	r23, 0x04	; 4
    165e:	c7 01       	movw	r24, r14
    1660:	0e 94 69 01 	call	0x2d2	; 0x2d2 <_ZN12SerialBuffer11SerialWriteEPKci>
    1664:	c3 2c       	mov	r12, r3
					read_Flag = 0;
    1666:	d6 2c       	mov	r13, r6
    1668:	27 cf       	rjmp	.-434    	; 0x14b8 <_ZL4procPv+0x64>

0000166a <_Z8Uart_ISR8Dev_typej>:

void Uart_ISR(Dev_type Device,uint16_t Arg)
{ 
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[UART0];
	sb->Serialstore(data);
    166a:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <DataStruct>
    166e:	90 91 40 04 	lds	r25, 0x0440	; 0x800440 <DataStruct+0x1>
    1672:	0e 94 44 01 	call	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,5);
    1676:	c5 9a       	sbi	0x18, 5	; 24
    1678:	08 95       	ret

0000167a <_Z9RS485_ISR8Dev_typej>:
}
void RS485_ISR(Dev_type Device,uint16_t Arg)
{
	uint8_t data = Arg;
	SerialBuffer *sb = (SerialBuffer*)DataStruct[RS485];
	sb->Serialstore(data);
    167a:	80 91 41 04 	lds	r24, 0x0441	; 0x800441 <DataStruct+0x2>
    167e:	90 91 42 04 	lds	r25, 0x0442	; 0x800442 <DataStruct+0x3>
    1682:	0e 94 44 01 	call	0x288	; 0x288 <_ZN12SerialBuffer11SerialstoreEc>
	sbi(PORTB,6);
    1686:	c6 9a       	sbi	0x18, 6	; 24
    1688:	08 95       	ret

0000168a <_Z8Init_Devv>:
	cmp_mem[2] = mem4[IPV4_2];
	cmp_mem[3] = mem4[IPV4_3];
	
}
void Init_Dev()
{
    168a:	cf 93       	push	r28
    168c:	df 93       	push	r29
	dev = new Dev_Manager();
    168e:	8c e0       	ldi	r24, 0x0C	; 12
    1690:	90 e0       	ldi	r25, 0x00	; 0
    1692:	0e 94 1f 02 	call	0x43e	; 0x43e <_ZN11Dev_ManagernwEj>
    1696:	ec 01       	movw	r28, r24
    1698:	0e 94 e7 01 	call	0x3ce	; 0x3ce <_ZN11Dev_ManagerC1Ev>
    169c:	d0 93 46 04 	sts	0x0446, r29	; 0x800446 <dev+0x1>
    16a0:	c0 93 45 04 	sts	0x0445, r28	; 0x800445 <dev>
	dev->Register_Dev(new UartDriver,UART0);
    16a4:	88 e0       	ldi	r24, 0x08	; 8
    16a6:	90 e0       	ldi	r25, 0x00	; 0
    16a8:	9b d8       	rcall	.-3786   	; 0x7e0 <_ZN10UartDrivernwEj>
    16aa:	ec 01       	movw	r28, r24
    16ac:	85 d8       	rcall	.-3830   	; 0x7b8 <_ZN10UartDriverC1Ev>
    16ae:	40 e0       	ldi	r20, 0x00	; 0
    16b0:	be 01       	movw	r22, r28
    16b2:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    16b6:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    16ba:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new RS485Driver,RS485);
    16be:	88 e0       	ldi	r24, 0x08	; 8
    16c0:	90 e0       	ldi	r25, 0x00	; 0
    16c2:	08 d8       	rcall	.-4080   	; 0x6d4 <_ZN11RS485DrivernwEj>
    16c4:	ec 01       	movw	r28, r24
    16c6:	0e 94 56 03 	call	0x6ac	; 0x6ac <_ZN11RS485DriverC1Ev>
    16ca:	41 e0       	ldi	r20, 0x01	; 1
    16cc:	be 01       	movw	r22, r28
    16ce:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    16d2:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    16d6:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Register_Dev(new Timer,SEC_TIMER);
    16da:	82 e0       	ldi	r24, 0x02	; 2
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	0e 94 2a 03 	call	0x654	; 0x654 <_ZN5TimernwEj>
    16e2:	ec 01       	movw	r28, r24
    16e4:	0e 94 24 03 	call	0x648	; 0x648 <_ZN5TimerC1Ev>
    16e8:	42 e0       	ldi	r20, 0x02	; 2
    16ea:	be 01       	movw	r22, r28
    16ec:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    16f0:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    16f4:	0e 94 16 02 	call	0x42c	; 0x42c <_ZN11Dev_Manager12Register_DevEP20DeviceDriveInterFace8Dev_type>
	dev->Device_Init(UART0);
    16f8:	60 e0       	ldi	r22, 0x00	; 0
    16fa:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    16fe:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1702:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(RS485);
    1706:	61 e0       	ldi	r22, 0x01	; 1
    1708:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    170c:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1710:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Device_Init(SEC_TIMER);
    1714:	62 e0       	ldi	r22, 0x02	; 2
    1716:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    171a:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    171e:	0e 94 4a 02 	call	0x494	; 0x494 <_ZN11Dev_Manager11Device_InitE8Dev_type>
	dev->Writes(UART0,"Uart Init SUCCESS boadrate 9600bps \r\n");
    1722:	4b e2       	ldi	r20, 0x2B	; 43
    1724:	51 e0       	ldi	r21, 0x01	; 1
    1726:	60 e0       	ldi	r22, 0x00	; 0
    1728:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    172c:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1730:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePKc>
	dev->Writes(RS485,"RS485 Init SUCCESS boadrate 9600bps \r\n");
    1734:	41 e5       	ldi	r20, 0x51	; 81
    1736:	51 e0       	ldi	r21, 0x01	; 1
    1738:	61 e0       	ldi	r22, 0x01	; 1
    173a:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    173e:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    1742:	0e 94 36 02 	call	0x46c	; 0x46c <_ZN11Dev_Manager6WritesE8Dev_typePKc>
}
    1746:	df 91       	pop	r29
    1748:	cf 91       	pop	r28
    174a:	08 95       	ret

0000174c <main>:
int current_pressure = 0;

int mem4[MAX_ENUM] = {0};
char cmp_mem[4] = {0};
int main( void )
{
    174c:	cf 92       	push	r12
    174e:	df 92       	push	r13
    1750:	ef 92       	push	r14
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	cf 93       	push	r28
    1758:	df 93       	push	r29
	vTaskStartScheduler();//스케줄러 실행 
	return 0;
}
static void System_Init()
{
	mem4[IPV4_0] = eeprom_read_byte((const uint8_t*)0);  //read ip address
    175a:	80 e0       	ldi	r24, 0x00	; 0
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	0e 94 21 17 	call	0x2e42	; 0x2e42 <eeprom_read_byte>
    1762:	d8 2e       	mov	r13, r24
    1764:	90 e0       	ldi	r25, 0x00	; 0
    1766:	90 93 09 04 	sts	0x0409, r25	; 0x800409 <mem4+0x41>
    176a:	80 93 08 04 	sts	0x0408, r24	; 0x800408 <mem4+0x40>
	mem4[IPV4_1] = eeprom_read_byte((const uint8_t*)1);
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	0e 94 21 17 	call	0x2e42	; 0x2e42 <eeprom_read_byte>
    1776:	d8 2f       	mov	r29, r24
    1778:	90 e0       	ldi	r25, 0x00	; 0
    177a:	90 93 0b 04 	sts	0x040B, r25	; 0x80040b <mem4+0x43>
    177e:	80 93 0a 04 	sts	0x040A, r24	; 0x80040a <mem4+0x42>
	mem4[IPV4_2] = eeprom_read_byte((const uint8_t*)2);
    1782:	82 e0       	ldi	r24, 0x02	; 2
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	0e 94 21 17 	call	0x2e42	; 0x2e42 <eeprom_read_byte>
    178a:	c8 2f       	mov	r28, r24
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	90 93 0d 04 	sts	0x040D, r25	; 0x80040d <mem4+0x45>
    1792:	80 93 0c 04 	sts	0x040C, r24	; 0x80040c <mem4+0x44>
	mem4[IPV4_3] = eeprom_read_byte((const uint8_t*)3);
    1796:	83 e0       	ldi	r24, 0x03	; 3
    1798:	90 e0       	ldi	r25, 0x00	; 0
    179a:	0e 94 21 17 	call	0x2e42	; 0x2e42 <eeprom_read_byte>
    179e:	28 2f       	mov	r18, r24
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	30 93 0f 04 	sts	0x040F, r19	; 0x80040f <mem4+0x47>
    17a6:	20 93 0e 04 	sts	0x040E, r18	; 0x80040e <mem4+0x46>
	cmp_mem[0] = mem4[IPV4_0];
    17aa:	e4 ec       	ldi	r30, 0xC4	; 196
    17ac:	f3 e0       	ldi	r31, 0x03	; 3
    17ae:	d0 82       	st	Z, r13
	cmp_mem[1] = mem4[IPV4_1];
    17b0:	d1 83       	std	Z+1, r29	; 0x01
	cmp_mem[2] = mem4[IPV4_2];
    17b2:	c2 83       	std	Z+2, r28	; 0x02
	cmp_mem[3] = mem4[IPV4_3];
    17b4:	83 83       	std	Z+3, r24	; 0x03
char cmp_mem[4] = {0};
int main( void )
{
	System_Init();
	cli();  //인터럽트 금지 
	Init_Dev(); //dev 매니저 초기화
    17b6:	f8 94       	cli
	
	
	dev->Open_Handle(UART0,Uart_ISR);  //드라이버 매니져에 인터럽트 루틴 등록
    17b8:	68 df       	rcall	.-304    	; 0x168a <_Z8Init_Devv>
    17ba:	45 e3       	ldi	r20, 0x35	; 53
    17bc:	5b e0       	ldi	r21, 0x0B	; 11
    17be:	60 e0       	ldi	r22, 0x00	; 0
    17c0:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    17c4:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    17c8:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(RS485,RS485_ISR); //드라이버 매니져에 인터럽트 루틴 등록
    17cc:	4d e3       	ldi	r20, 0x3D	; 61
    17ce:	5b e0       	ldi	r21, 0x0B	; 11
    17d0:	61 e0       	ldi	r22, 0x01	; 1
    17d2:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    17d6:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    17da:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	dev->Open_Handle(SEC_TIMER,Timer_ISR);
    17de:	49 ee       	ldi	r20, 0xE9	; 233
    17e0:	57 e0       	ldi	r21, 0x07	; 7
    17e2:	62 e0       	ldi	r22, 0x02	; 2
    17e4:	80 91 45 04 	lds	r24, 0x0445	; 0x800445 <dev>
    17e8:	90 91 46 04 	lds	r25, 0x0446	; 0x800446 <dev+0x1>
    17ec:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <_ZN11Dev_Manager11Open_HandleE8Dev_typePFvS0_jE>
	SerialBuffer *sb = new SerialBuffer(dev,UART0); //링 버퍼 
    17f0:	88 e8       	ldi	r24, 0x88	; 136
    17f2:	90 e0       	ldi	r25, 0x00	; 0
    17f4:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    17f8:	6c 01       	movw	r12, r24
    17fa:	60 91 45 04 	lds	r22, 0x0445	; 0x800445 <dev>
    17fe:	70 91 46 04 	lds	r23, 0x0446	; 0x800446 <dev+0x1>
    1802:	40 e0       	ldi	r20, 0x00	; 0
    1804:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb == nullptr)
    1808:	c1 14       	cp	r12, r1
    180a:	d1 04       	cpc	r13, r1
	{
		#if DEBUG 
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    180c:	21 f4       	brne	.+8      	; 0x1816 <main+0xca>
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	90 e0       	ldi	r25, 0x00	; 0
    1812:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART0 SUCCESS\r\n");
		#endif
	}
	SerialBuffer *sb1 = new SerialBuffer(dev,RS485); //링 버퍼 
    1816:	88 e8       	ldi	r24, 0x88	; 136
    1818:	90 e0       	ldi	r25, 0x00	; 0
    181a:	0e 94 41 01 	call	0x282	; 0x282 <_ZN12SerialBuffernwEj>
    181e:	ec 01       	movw	r28, r24
    1820:	60 91 45 04 	lds	r22, 0x0445	; 0x800445 <dev>
    1824:	70 91 46 04 	lds	r23, 0x0446	; 0x800446 <dev+0x1>
    1828:	41 e0       	ldi	r20, 0x01	; 1
    182a:	0e 94 1c 01 	call	0x238	; 0x238 <_ZN12SerialBufferC1EP11Dev_Manager8Dev_type>
	if(sb1 == nullptr)
    182e:	20 97       	sbiw	r28, 0x00	; 0
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer Error\r\n");
		#endif
		exit(1);
    1830:	21 f4       	brne	.+8      	; 0x183a <main+0xee>
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	0e 94 3a 17 	call	0x2e74	; 0x2e74 <__do_global_dtors>
	{
		#if DEBUG
			dev->Writes(UART0,"RingBuffer UART1 SUCCESS\r\n");
		#endif
	}
	DataStruct[UART0] = sb;
    183a:	ef e3       	ldi	r30, 0x3F	; 63
    183c:	f4 e0       	ldi	r31, 0x04	; 4
    183e:	d1 82       	std	Z+1, r13	; 0x01
	DataStruct[RS485] = sb1;
    1840:	c0 82       	st	Z, r12
    1842:	d3 83       	std	Z+3, r29	; 0x03
					dev->Writes(UART0,"DataStruct UART1 Address SUCCESS\r\n");
			#endif
		}
	}

	sei(); //인터럽트 사용 
    1844:	c2 83       	std	Z+2, r28	; 0x02
	"Task1",      //테스크 이름
	350,                   //스택의 크기
	sb,       // 테스크 매개 변수
	2,                     //테스크 우선 순위
	NULL                   //태스크 핸들
	);
    1846:	78 94       	sei
    1848:	e1 2c       	mov	r14, r1
    184a:	f1 2c       	mov	r15, r1
    184c:	02 e0       	ldi	r16, 0x02	; 2
    184e:	96 01       	movw	r18, r12
    1850:	4e e5       	ldi	r20, 0x5E	; 94
    1852:	51 e0       	ldi	r21, 0x01	; 1
    1854:	68 e7       	ldi	r22, 0x78	; 120
    1856:	71 e0       	ldi	r23, 0x01	; 1
    1858:	8a e2       	ldi	r24, 0x2A	; 42
    185a:	9a e0       	ldi	r25, 0x0A	; 10
		"Task2",      //테스크 이름
		350,                   //스택의 크기
		sb1,       // 테스크 매개 변수
		2,                     //테스크 우선 순위
		NULL                   //태스크 핸들
		);
    185c:	2b d5       	rcall	.+2646   	; 0x22b4 <xTaskCreate>
    185e:	9e 01       	movw	r18, r28
    1860:	4e e5       	ldi	r20, 0x5E	; 94
    1862:	51 e0       	ldi	r21, 0x01	; 1
    1864:	6e e7       	ldi	r22, 0x7E	; 126
    1866:	71 e0       	ldi	r23, 0x01	; 1
    1868:	87 e9       	ldi	r24, 0x97	; 151
    186a:	99 e0       	ldi	r25, 0x09	; 9
				"Task3",      //테스크 이름
				240,                   //스택의 크기
				NULL,       // 테스크 매개 변수
				2,                     //테스크 우선 순위
				NULL                   //태스크 핸들
				);
    186c:	23 d5       	rcall	.+2630   	; 0x22b4 <xTaskCreate>
    186e:	20 e0       	ldi	r18, 0x00	; 0
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	40 ef       	ldi	r20, 0xF0	; 240
    1874:	50 e0       	ldi	r21, 0x00	; 0
    1876:	64 e8       	ldi	r22, 0x84	; 132
    1878:	71 e0       	ldi	r23, 0x01	; 1
    187a:	83 ef       	ldi	r24, 0xF3	; 243
		#endif
			
		
	
	vTaskStartScheduler();//스케줄러 실행 
    187c:	97 e0       	ldi	r25, 0x07	; 7
    187e:	1a d5       	rcall	.+2612   	; 0x22b4 <xTaskCreate>
	return 0;
}
    1880:	17 d6       	rcall	.+3118   	; 0x24b0 <vTaskStartScheduler>
    1882:	80 e0       	ldi	r24, 0x00	; 0
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	0f 91       	pop	r16
    188c:	ff 90       	pop	r15
    188e:	ef 90       	pop	r14
    1890:	df 90       	pop	r13
    1892:	cf 90       	pop	r12
    1894:	08 95       	ret

00001896 <vApplicationStackOverflowHook>:
}
#endif


void vApplicationStackOverflowHook( TaskHandle_t xTask, signed char *pcTaskName )
{
    1896:	08 95       	ret

00001898 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    189c:	ec 01       	movw	r28, r24
	{
		if( pucAlignedHeap == NULL )
    189e:	30 d6       	rcall	.+3168   	; 0x2500 <vTaskSuspendAll>
    18a0:	80 91 47 04 	lds	r24, 0x0447	; 0x800447 <pucAlignedHeap.2069>
    18a4:	90 91 48 04 	lds	r25, 0x0448	; 0x800448 <pucAlignedHeap.2069+0x1>
    18a8:	89 2b       	or	r24, r25
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    18aa:	31 f4       	brne	.+12     	; 0x18b8 <pvPortMalloc+0x20>
    18ac:	8c e4       	ldi	r24, 0x4C	; 76
    18ae:	94 e0       	ldi	r25, 0x04	; 4
    18b0:	90 93 48 04 	sts	0x0448, r25	; 0x800448 <pucAlignedHeap.2069+0x1>
    18b4:	80 93 47 04 	sts	0x0447, r24	; 0x800447 <pucAlignedHeap.2069>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    18b8:	20 91 49 04 	lds	r18, 0x0449	; 0x800449 <xNextFreeByte>
    18bc:	30 91 4a 04 	lds	r19, 0x044A	; 0x80044a <xNextFreeByte+0x1>
    18c0:	c9 01       	movw	r24, r18
    18c2:	8c 0f       	add	r24, r28
    18c4:	9d 1f       	adc	r25, r29
    18c6:	8b 3f       	cpi	r24, 0xFB	; 251
    18c8:	48 e0       	ldi	r20, 0x08	; 8
    18ca:	94 07       	cpc	r25, r20
    18cc:	70 f4       	brcc	.+28     	; 0x18ea <pvPortMalloc+0x52>
    18ce:	28 17       	cp	r18, r24
    18d0:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    18d2:	70 f4       	brcc	.+28     	; 0x18f0 <pvPortMalloc+0x58>
    18d4:	c0 91 47 04 	lds	r28, 0x0447	; 0x800447 <pucAlignedHeap.2069>
    18d8:	d0 91 48 04 	lds	r29, 0x0448	; 0x800448 <pucAlignedHeap.2069+0x1>
    18dc:	c2 0f       	add	r28, r18
			xNextFreeByte += xWantedSize;
    18de:	d3 1f       	adc	r29, r19
    18e0:	90 93 4a 04 	sts	0x044A, r25	; 0x80044a <xNextFreeByte+0x1>
    18e4:	80 93 49 04 	sts	0x0449, r24	; 0x800449 <xNextFreeByte>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    18e8:	05 c0       	rjmp	.+10     	; 0x18f4 <pvPortMalloc+0x5c>
    18ea:	c0 e0       	ldi	r28, 0x00	; 0
    18ec:	d0 e0       	ldi	r29, 0x00	; 0
    18ee:	02 c0       	rjmp	.+4      	; 0x18f4 <pvPortMalloc+0x5c>
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    18f0:	c0 e0       	ldi	r28, 0x00	; 0
    18f2:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif

	return pvReturn;
}
    18f4:	c2 d6       	rcall	.+3460   	; 0x267a <xTaskResumeAll>
    18f6:	ce 01       	movw	r24, r28
    18f8:	df 91       	pop	r29
    18fa:	cf 91       	pop	r28
    18fc:	08 95       	ret

000018fe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    18fe:	08 95       	ret

00001900 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1900:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1902:	03 96       	adiw	r24, 0x03	; 3
    1904:	92 83       	std	Z+2, r25	; 0x02
    1906:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1908:	2f ef       	ldi	r18, 0xFF	; 255
    190a:	3f ef       	ldi	r19, 0xFF	; 255
    190c:	34 83       	std	Z+4, r19	; 0x04
    190e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1910:	96 83       	std	Z+6, r25	; 0x06
    1912:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1914:	90 87       	std	Z+8, r25	; 0x08
    1916:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1918:	10 82       	st	Z, r1
    191a:	08 95       	ret

0000191c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    191c:	fc 01       	movw	r30, r24
    191e:	11 86       	std	Z+9, r1	; 0x09
    1920:	10 86       	std	Z+8, r1	; 0x08
    1922:	08 95       	ret

00001924 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	9c 01       	movw	r18, r24
    192a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    192c:	dc 01       	movw	r26, r24
    192e:	11 96       	adiw	r26, 0x01	; 1
    1930:	cd 91       	ld	r28, X+
    1932:	dc 91       	ld	r29, X
    1934:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1936:	d3 83       	std	Z+3, r29	; 0x03
    1938:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    193a:	8c 81       	ldd	r24, Y+4	; 0x04
    193c:	9d 81       	ldd	r25, Y+5	; 0x05
    193e:	95 83       	std	Z+5, r25	; 0x05
    1940:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1942:	8c 81       	ldd	r24, Y+4	; 0x04
    1944:	9d 81       	ldd	r25, Y+5	; 0x05
    1946:	dc 01       	movw	r26, r24
    1948:	13 96       	adiw	r26, 0x03	; 3
    194a:	7c 93       	st	X, r23
    194c:	6e 93       	st	-X, r22
    194e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1950:	7d 83       	std	Y+5, r23	; 0x05
    1952:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1954:	31 87       	std	Z+9, r19	; 0x09
    1956:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1958:	f9 01       	movw	r30, r18
    195a:	80 81       	ld	r24, Z
    195c:	8f 5f       	subi	r24, 0xFF	; 255
    195e:	80 83       	st	Z, r24
}
    1960:	df 91       	pop	r29
    1962:	cf 91       	pop	r28
    1964:	08 95       	ret

00001966 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1966:	cf 93       	push	r28
    1968:	df 93       	push	r29
    196a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    196c:	48 81       	ld	r20, Y
    196e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1970:	4f 3f       	cpi	r20, 0xFF	; 255
    1972:	2f ef       	ldi	r18, 0xFF	; 255
    1974:	52 07       	cpc	r21, r18
    1976:	21 f4       	brne	.+8      	; 0x1980 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1978:	fc 01       	movw	r30, r24
    197a:	a7 81       	ldd	r26, Z+7	; 0x07
    197c:	b0 85       	ldd	r27, Z+8	; 0x08
    197e:	0d c0       	rjmp	.+26     	; 0x199a <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1980:	dc 01       	movw	r26, r24
    1982:	13 96       	adiw	r26, 0x03	; 3
    1984:	01 c0       	rjmp	.+2      	; 0x1988 <vListInsert+0x22>
    1986:	df 01       	movw	r26, r30
    1988:	12 96       	adiw	r26, 0x02	; 2
    198a:	ed 91       	ld	r30, X+
    198c:	fc 91       	ld	r31, X
    198e:	13 97       	sbiw	r26, 0x03	; 3
    1990:	20 81       	ld	r18, Z
    1992:	31 81       	ldd	r19, Z+1	; 0x01
    1994:	42 17       	cp	r20, r18
    1996:	53 07       	cpc	r21, r19
    1998:	b0 f7       	brcc	.-20     	; 0x1986 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    199a:	12 96       	adiw	r26, 0x02	; 2
    199c:	ed 91       	ld	r30, X+
    199e:	fc 91       	ld	r31, X
    19a0:	13 97       	sbiw	r26, 0x03	; 3
    19a2:	fb 83       	std	Y+3, r31	; 0x03
    19a4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    19a6:	d5 83       	std	Z+5, r29	; 0x05
    19a8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    19aa:	bd 83       	std	Y+5, r27	; 0x05
    19ac:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    19ae:	13 96       	adiw	r26, 0x03	; 3
    19b0:	dc 93       	st	X, r29
    19b2:	ce 93       	st	-X, r28
    19b4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19b6:	99 87       	std	Y+9, r25	; 0x09
    19b8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    19ba:	fc 01       	movw	r30, r24
    19bc:	20 81       	ld	r18, Z
    19be:	2f 5f       	subi	r18, 0xFF	; 255
    19c0:	20 83       	st	Z, r18
}
    19c2:	df 91       	pop	r29
    19c4:	cf 91       	pop	r28
    19c6:	08 95       	ret

000019c8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    19c8:	cf 93       	push	r28
    19ca:	df 93       	push	r29
    19cc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    19ce:	a0 85       	ldd	r26, Z+8	; 0x08
    19d0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19d2:	c2 81       	ldd	r28, Z+2	; 0x02
    19d4:	d3 81       	ldd	r29, Z+3	; 0x03
    19d6:	84 81       	ldd	r24, Z+4	; 0x04
    19d8:	95 81       	ldd	r25, Z+5	; 0x05
    19da:	9d 83       	std	Y+5, r25	; 0x05
    19dc:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    19de:	c4 81       	ldd	r28, Z+4	; 0x04
    19e0:	d5 81       	ldd	r29, Z+5	; 0x05
    19e2:	82 81       	ldd	r24, Z+2	; 0x02
    19e4:	93 81       	ldd	r25, Z+3	; 0x03
    19e6:	9b 83       	std	Y+3, r25	; 0x03
    19e8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    19ea:	11 96       	adiw	r26, 0x01	; 1
    19ec:	8d 91       	ld	r24, X+
    19ee:	9c 91       	ld	r25, X
    19f0:	12 97       	sbiw	r26, 0x02	; 2
    19f2:	e8 17       	cp	r30, r24
    19f4:	f9 07       	cpc	r31, r25
    19f6:	31 f4       	brne	.+12     	; 0x1a04 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    19f8:	84 81       	ldd	r24, Z+4	; 0x04
    19fa:	95 81       	ldd	r25, Z+5	; 0x05
    19fc:	12 96       	adiw	r26, 0x02	; 2
    19fe:	9c 93       	st	X, r25
    1a00:	8e 93       	st	-X, r24
    1a02:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1a04:	11 86       	std	Z+9, r1	; 0x09
    1a06:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a08:	8c 91       	ld	r24, X
    1a0a:	81 50       	subi	r24, 0x01	; 1
    1a0c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1a0e:	df 91       	pop	r29
    1a10:	cf 91       	pop	r28
    1a12:	08 95       	ret

00001a14 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a14:	31 e1       	ldi	r19, 0x11	; 17
    1a16:	fc 01       	movw	r30, r24
    1a18:	30 83       	st	Z, r19
    1a1a:	31 97       	sbiw	r30, 0x01	; 1
    1a1c:	22 e2       	ldi	r18, 0x22	; 34
    1a1e:	20 83       	st	Z, r18
    1a20:	31 97       	sbiw	r30, 0x01	; 1
    1a22:	a3 e3       	ldi	r26, 0x33	; 51
    1a24:	a0 83       	st	Z, r26
    1a26:	31 97       	sbiw	r30, 0x01	; 1
    1a28:	60 83       	st	Z, r22
    1a2a:	31 97       	sbiw	r30, 0x01	; 1
    1a2c:	70 83       	st	Z, r23
    1a2e:	31 97       	sbiw	r30, 0x01	; 1
    1a30:	10 82       	st	Z, r1
    1a32:	31 97       	sbiw	r30, 0x01	; 1
    1a34:	60 e8       	ldi	r22, 0x80	; 128
    1a36:	60 83       	st	Z, r22
    1a38:	31 97       	sbiw	r30, 0x01	; 1
    1a3a:	10 82       	st	Z, r1
    1a3c:	31 97       	sbiw	r30, 0x01	; 1
    1a3e:	62 e0       	ldi	r22, 0x02	; 2
    1a40:	60 83       	st	Z, r22
    1a42:	31 97       	sbiw	r30, 0x01	; 1
    1a44:	63 e0       	ldi	r22, 0x03	; 3
    1a46:	60 83       	st	Z, r22
    1a48:	31 97       	sbiw	r30, 0x01	; 1
    1a4a:	64 e0       	ldi	r22, 0x04	; 4
    1a4c:	60 83       	st	Z, r22
    1a4e:	31 97       	sbiw	r30, 0x01	; 1
    1a50:	65 e0       	ldi	r22, 0x05	; 5
    1a52:	60 83       	st	Z, r22
    1a54:	31 97       	sbiw	r30, 0x01	; 1
    1a56:	66 e0       	ldi	r22, 0x06	; 6
    1a58:	60 83       	st	Z, r22
    1a5a:	31 97       	sbiw	r30, 0x01	; 1
    1a5c:	67 e0       	ldi	r22, 0x07	; 7
    1a5e:	60 83       	st	Z, r22
    1a60:	31 97       	sbiw	r30, 0x01	; 1
    1a62:	68 e0       	ldi	r22, 0x08	; 8
    1a64:	60 83       	st	Z, r22
    1a66:	31 97       	sbiw	r30, 0x01	; 1
    1a68:	69 e0       	ldi	r22, 0x09	; 9
    1a6a:	60 83       	st	Z, r22
    1a6c:	31 97       	sbiw	r30, 0x01	; 1
    1a6e:	60 e1       	ldi	r22, 0x10	; 16
    1a70:	60 83       	st	Z, r22
    1a72:	31 97       	sbiw	r30, 0x01	; 1
    1a74:	30 83       	st	Z, r19
    1a76:	31 97       	sbiw	r30, 0x01	; 1
    1a78:	32 e1       	ldi	r19, 0x12	; 18
    1a7a:	30 83       	st	Z, r19
    1a7c:	31 97       	sbiw	r30, 0x01	; 1
    1a7e:	33 e1       	ldi	r19, 0x13	; 19
    1a80:	30 83       	st	Z, r19
    1a82:	31 97       	sbiw	r30, 0x01	; 1
    1a84:	34 e1       	ldi	r19, 0x14	; 20
    1a86:	30 83       	st	Z, r19
    1a88:	31 97       	sbiw	r30, 0x01	; 1
    1a8a:	35 e1       	ldi	r19, 0x15	; 21
    1a8c:	30 83       	st	Z, r19
    1a8e:	31 97       	sbiw	r30, 0x01	; 1
    1a90:	36 e1       	ldi	r19, 0x16	; 22
    1a92:	30 83       	st	Z, r19
    1a94:	31 97       	sbiw	r30, 0x01	; 1
    1a96:	37 e1       	ldi	r19, 0x17	; 23
    1a98:	30 83       	st	Z, r19
    1a9a:	31 97       	sbiw	r30, 0x01	; 1
    1a9c:	38 e1       	ldi	r19, 0x18	; 24
    1a9e:	30 83       	st	Z, r19
    1aa0:	31 97       	sbiw	r30, 0x01	; 1
    1aa2:	39 e1       	ldi	r19, 0x19	; 25
    1aa4:	30 83       	st	Z, r19
    1aa6:	31 97       	sbiw	r30, 0x01	; 1
    1aa8:	30 e2       	ldi	r19, 0x20	; 32
    1aaa:	30 83       	st	Z, r19
    1aac:	31 97       	sbiw	r30, 0x01	; 1
    1aae:	31 e2       	ldi	r19, 0x21	; 33
    1ab0:	30 83       	st	Z, r19
    1ab2:	31 97       	sbiw	r30, 0x01	; 1
    1ab4:	20 83       	st	Z, r18
    1ab6:	31 97       	sbiw	r30, 0x01	; 1
    1ab8:	23 e2       	ldi	r18, 0x23	; 35
    1aba:	20 83       	st	Z, r18
    1abc:	31 97       	sbiw	r30, 0x01	; 1
    1abe:	40 83       	st	Z, r20
    1ac0:	31 97       	sbiw	r30, 0x01	; 1
    1ac2:	50 83       	st	Z, r21
    1ac4:	31 97       	sbiw	r30, 0x01	; 1
    1ac6:	26 e2       	ldi	r18, 0x26	; 38
    1ac8:	20 83       	st	Z, r18
    1aca:	31 97       	sbiw	r30, 0x01	; 1
    1acc:	27 e2       	ldi	r18, 0x27	; 39
    1ace:	20 83       	st	Z, r18
    1ad0:	31 97       	sbiw	r30, 0x01	; 1
    1ad2:	28 e2       	ldi	r18, 0x28	; 40
    1ad4:	20 83       	st	Z, r18
    1ad6:	31 97       	sbiw	r30, 0x01	; 1
    1ad8:	29 e2       	ldi	r18, 0x29	; 41
    1ada:	20 83       	st	Z, r18
    1adc:	31 97       	sbiw	r30, 0x01	; 1
    1ade:	20 e3       	ldi	r18, 0x30	; 48
    1ae0:	20 83       	st	Z, r18
    1ae2:	31 97       	sbiw	r30, 0x01	; 1
    1ae4:	21 e3       	ldi	r18, 0x31	; 49
    1ae6:	20 83       	st	Z, r18
    1ae8:	86 97       	sbiw	r24, 0x26	; 38
    1aea:	08 95       	ret

00001aec <xPortStartScheduler>:
    1aec:	1b bc       	out	0x2b, r1	; 43
    1aee:	89 ef       	ldi	r24, 0xF9	; 249
    1af0:	8a bd       	out	0x2a, r24	; 42
    1af2:	8b e0       	ldi	r24, 0x0B	; 11
    1af4:	8e bd       	out	0x2e, r24	; 46
    1af6:	87 b7       	in	r24, 0x37	; 55
    1af8:	80 61       	ori	r24, 0x10	; 16
    1afa:	87 bf       	out	0x37, r24	; 55
    1afc:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1b00:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1b04:	cd 91       	ld	r28, X+
    1b06:	cd bf       	out	0x3d, r28	; 61
    1b08:	dd 91       	ld	r29, X+
    1b0a:	de bf       	out	0x3e, r29	; 62
    1b0c:	ff 91       	pop	r31
    1b0e:	ef 91       	pop	r30
    1b10:	df 91       	pop	r29
    1b12:	cf 91       	pop	r28
    1b14:	bf 91       	pop	r27
    1b16:	af 91       	pop	r26
    1b18:	9f 91       	pop	r25
    1b1a:	8f 91       	pop	r24
    1b1c:	7f 91       	pop	r23
    1b1e:	6f 91       	pop	r22
    1b20:	5f 91       	pop	r21
    1b22:	4f 91       	pop	r20
    1b24:	3f 91       	pop	r19
    1b26:	2f 91       	pop	r18
    1b28:	1f 91       	pop	r17
    1b2a:	0f 91       	pop	r16
    1b2c:	ff 90       	pop	r15
    1b2e:	ef 90       	pop	r14
    1b30:	df 90       	pop	r13
    1b32:	cf 90       	pop	r12
    1b34:	bf 90       	pop	r11
    1b36:	af 90       	pop	r10
    1b38:	9f 90       	pop	r9
    1b3a:	8f 90       	pop	r8
    1b3c:	7f 90       	pop	r7
    1b3e:	6f 90       	pop	r6
    1b40:	5f 90       	pop	r5
    1b42:	4f 90       	pop	r4
    1b44:	3f 90       	pop	r3
    1b46:	2f 90       	pop	r2
    1b48:	1f 90       	pop	r1
    1b4a:	0f 90       	pop	r0
    1b4c:	0f be       	out	0x3f, r0	; 63
    1b4e:	0f 90       	pop	r0
    1b50:	08 95       	ret
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	08 95       	ret

00001b56 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1b56:	0f 92       	push	r0
    1b58:	0f b6       	in	r0, 0x3f	; 63
    1b5a:	f8 94       	cli
    1b5c:	0f 92       	push	r0
    1b5e:	1f 92       	push	r1
    1b60:	11 24       	eor	r1, r1
    1b62:	2f 92       	push	r2
    1b64:	3f 92       	push	r3
    1b66:	4f 92       	push	r4
    1b68:	5f 92       	push	r5
    1b6a:	6f 92       	push	r6
    1b6c:	7f 92       	push	r7
    1b6e:	8f 92       	push	r8
    1b70:	9f 92       	push	r9
    1b72:	af 92       	push	r10
    1b74:	bf 92       	push	r11
    1b76:	cf 92       	push	r12
    1b78:	df 92       	push	r13
    1b7a:	ef 92       	push	r14
    1b7c:	ff 92       	push	r15
    1b7e:	0f 93       	push	r16
    1b80:	1f 93       	push	r17
    1b82:	2f 93       	push	r18
    1b84:	3f 93       	push	r19
    1b86:	4f 93       	push	r20
    1b88:	5f 93       	push	r21
    1b8a:	6f 93       	push	r22
    1b8c:	7f 93       	push	r23
    1b8e:	8f 93       	push	r24
    1b90:	9f 93       	push	r25
    1b92:	af 93       	push	r26
    1b94:	bf 93       	push	r27
    1b96:	cf 93       	push	r28
    1b98:	df 93       	push	r29
    1b9a:	ef 93       	push	r30
    1b9c:	ff 93       	push	r31
    1b9e:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1ba2:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1ba6:	0d b6       	in	r0, 0x3d	; 61
    1ba8:	0d 92       	st	X+, r0
    1baa:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
    1bac:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
    1bae:	25 d6       	rcall	.+3146   	; 0x27fa <vTaskSwitchContext>
    1bb0:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1bb4:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1bb8:	cd 91       	ld	r28, X+
    1bba:	cd bf       	out	0x3d, r28	; 61
    1bbc:	dd 91       	ld	r29, X+
    1bbe:	de bf       	out	0x3e, r29	; 62
    1bc0:	ff 91       	pop	r31
    1bc2:	ef 91       	pop	r30
    1bc4:	df 91       	pop	r29
    1bc6:	cf 91       	pop	r28
    1bc8:	bf 91       	pop	r27
    1bca:	af 91       	pop	r26
    1bcc:	9f 91       	pop	r25
    1bce:	8f 91       	pop	r24
    1bd0:	7f 91       	pop	r23
    1bd2:	6f 91       	pop	r22
    1bd4:	5f 91       	pop	r21
    1bd6:	4f 91       	pop	r20
    1bd8:	3f 91       	pop	r19
    1bda:	2f 91       	pop	r18
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	ff 90       	pop	r15
    1be2:	ef 90       	pop	r14
    1be4:	df 90       	pop	r13
    1be6:	cf 90       	pop	r12
    1be8:	bf 90       	pop	r11
    1bea:	af 90       	pop	r10
    1bec:	9f 90       	pop	r9
    1bee:	8f 90       	pop	r8
    1bf0:	7f 90       	pop	r7
    1bf2:	6f 90       	pop	r6
    1bf4:	5f 90       	pop	r5
    1bf6:	4f 90       	pop	r4
    1bf8:	3f 90       	pop	r3
    1bfa:	2f 90       	pop	r2
    1bfc:	1f 90       	pop	r1
    1bfe:	0f 90       	pop	r0
    1c00:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1c02:	0f 90       	pop	r0
    1c04:	08 95       	ret

00001c06 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1c06:	0f 92       	push	r0
    1c08:	0f b6       	in	r0, 0x3f	; 63
    1c0a:	f8 94       	cli
    1c0c:	0f 92       	push	r0
    1c0e:	1f 92       	push	r1
    1c10:	11 24       	eor	r1, r1
    1c12:	2f 92       	push	r2
    1c14:	3f 92       	push	r3
    1c16:	4f 92       	push	r4
    1c18:	5f 92       	push	r5
    1c1a:	6f 92       	push	r6
    1c1c:	7f 92       	push	r7
    1c1e:	8f 92       	push	r8
    1c20:	9f 92       	push	r9
    1c22:	af 92       	push	r10
    1c24:	bf 92       	push	r11
    1c26:	cf 92       	push	r12
    1c28:	df 92       	push	r13
    1c2a:	ef 92       	push	r14
    1c2c:	ff 92       	push	r15
    1c2e:	0f 93       	push	r16
    1c30:	1f 93       	push	r17
    1c32:	2f 93       	push	r18
    1c34:	3f 93       	push	r19
    1c36:	4f 93       	push	r20
    1c38:	5f 93       	push	r21
    1c3a:	6f 93       	push	r22
    1c3c:	7f 93       	push	r23
    1c3e:	8f 93       	push	r24
    1c40:	9f 93       	push	r25
    1c42:	af 93       	push	r26
    1c44:	bf 93       	push	r27
    1c46:	cf 93       	push	r28
    1c48:	df 93       	push	r29
    1c4a:	ef 93       	push	r30
    1c4c:	ff 93       	push	r31
    1c4e:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1c52:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1c56:	0d b6       	in	r0, 0x3d	; 61
    1c58:	0d 92       	st	X+, r0
    1c5a:	0e b6       	in	r0, 0x3e	; 62
	if( xTaskIncrementTick() != pdFALSE )
    1c5c:	0d 92       	st	X+, r0
	{
		vTaskSwitchContext();
    1c5e:	56 d4       	rcall	.+2220   	; 0x250c <xTaskIncrementTick>
    1c60:	81 11       	cpse	r24, r1
	}
	portRESTORE_CONTEXT();
    1c62:	cb d5       	rcall	.+2966   	; 0x27fa <vTaskSwitchContext>
    1c64:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    1c68:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    1c6c:	cd 91       	ld	r28, X+
    1c6e:	cd bf       	out	0x3d, r28	; 61
    1c70:	dd 91       	ld	r29, X+
    1c72:	de bf       	out	0x3e, r29	; 62
    1c74:	ff 91       	pop	r31
    1c76:	ef 91       	pop	r30
    1c78:	df 91       	pop	r29
    1c7a:	cf 91       	pop	r28
    1c7c:	bf 91       	pop	r27
    1c7e:	af 91       	pop	r26
    1c80:	9f 91       	pop	r25
    1c82:	8f 91       	pop	r24
    1c84:	7f 91       	pop	r23
    1c86:	6f 91       	pop	r22
    1c88:	5f 91       	pop	r21
    1c8a:	4f 91       	pop	r20
    1c8c:	3f 91       	pop	r19
    1c8e:	2f 91       	pop	r18
    1c90:	1f 91       	pop	r17
    1c92:	0f 91       	pop	r16
    1c94:	ff 90       	pop	r15
    1c96:	ef 90       	pop	r14
    1c98:	df 90       	pop	r13
    1c9a:	cf 90       	pop	r12
    1c9c:	bf 90       	pop	r11
    1c9e:	af 90       	pop	r10
    1ca0:	9f 90       	pop	r9
    1ca2:	8f 90       	pop	r8
    1ca4:	7f 90       	pop	r7
    1ca6:	6f 90       	pop	r6
    1ca8:	5f 90       	pop	r5
    1caa:	4f 90       	pop	r4
    1cac:	3f 90       	pop	r3
    1cae:	2f 90       	pop	r2
    1cb0:	1f 90       	pop	r1
    1cb2:	0f 90       	pop	r0
    1cb4:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
    1cb6:	0f 90       	pop	r0
    1cb8:	08 95       	ret

00001cba <__vector_12>:
    1cba:	a5 df       	rcall	.-182    	; 0x1c06 <vPortYieldFromTick>
    1cbc:	18 95       	reti

00001cbe <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1cbe:	0f 93       	push	r16
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	ec 01       	movw	r28, r24
    1cc8:	04 2f       	mov	r16, r20
    1cca:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1ccc:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1cce:	41 11       	cpse	r20, r1
    1cd0:	0b c0       	rjmp	.+22     	; 0x1ce8 <prvCopyDataToQueue+0x2a>
    1cd2:	88 81       	ld	r24, Y
    1cd4:	99 81       	ldd	r25, Y+1	; 0x01
    1cd6:	89 2b       	or	r24, r25
    1cd8:	09 f0       	breq	.+2      	; 0x1cdc <prvCopyDataToQueue+0x1e>
    1cda:	41 c0       	rjmp	.+130    	; 0x1d5e <prvCopyDataToQueue+0xa0>
    1cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    1cde:	9b 81       	ldd	r25, Y+3	; 0x03
    1ce0:	0b d7       	rcall	.+3606   	; 0x2af8 <xTaskPriorityDisinherit>
    1ce2:	1b 82       	std	Y+3, r1	; 0x03
    1ce4:	1a 82       	std	Y+2, r1	; 0x02
    1ce6:	42 c0       	rjmp	.+132    	; 0x1d6c <prvCopyDataToQueue+0xae>
    1ce8:	01 11       	cpse	r16, r1
    1cea:	17 c0       	rjmp	.+46     	; 0x1d1a <prvCopyDataToQueue+0x5c>
    1cec:	50 e0       	ldi	r21, 0x00	; 0
    1cee:	8c 81       	ldd	r24, Y+4	; 0x04
    1cf0:	9d 81       	ldd	r25, Y+5	; 0x05
    1cf2:	0e 94 18 17 	call	0x2e30	; 0x2e30 <memcpy>
    1cf6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1cf8:	8c 81       	ldd	r24, Y+4	; 0x04
    1cfa:	9d 81       	ldd	r25, Y+5	; 0x05
    1cfc:	82 0f       	add	r24, r18
    1cfe:	91 1d       	adc	r25, r1
    1d00:	9d 83       	std	Y+5, r25	; 0x05
    1d02:	8c 83       	std	Y+4, r24	; 0x04
    1d04:	2a 81       	ldd	r18, Y+2	; 0x02
    1d06:	3b 81       	ldd	r19, Y+3	; 0x03
    1d08:	82 17       	cp	r24, r18
    1d0a:	93 07       	cpc	r25, r19
    1d0c:	50 f1       	brcs	.+84     	; 0x1d62 <prvCopyDataToQueue+0xa4>
    1d0e:	88 81       	ld	r24, Y
    1d10:	99 81       	ldd	r25, Y+1	; 0x01
    1d12:	9d 83       	std	Y+5, r25	; 0x05
    1d14:	8c 83       	std	Y+4, r24	; 0x04
    1d16:	80 e0       	ldi	r24, 0x00	; 0
    1d18:	29 c0       	rjmp	.+82     	; 0x1d6c <prvCopyDataToQueue+0xae>
    1d1a:	50 e0       	ldi	r21, 0x00	; 0
    1d1c:	8e 81       	ldd	r24, Y+6	; 0x06
    1d1e:	9f 81       	ldd	r25, Y+7	; 0x07
    1d20:	0e 94 18 17 	call	0x2e30	; 0x2e30 <memcpy>
    1d24:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1d26:	90 e0       	ldi	r25, 0x00	; 0
    1d28:	91 95       	neg	r25
    1d2a:	81 95       	neg	r24
    1d2c:	91 09       	sbc	r25, r1
    1d2e:	2e 81       	ldd	r18, Y+6	; 0x06
    1d30:	3f 81       	ldd	r19, Y+7	; 0x07
    1d32:	28 0f       	add	r18, r24
    1d34:	39 1f       	adc	r19, r25
    1d36:	3f 83       	std	Y+7, r19	; 0x07
    1d38:	2e 83       	std	Y+6, r18	; 0x06
    1d3a:	48 81       	ld	r20, Y
    1d3c:	59 81       	ldd	r21, Y+1	; 0x01
    1d3e:	24 17       	cp	r18, r20
    1d40:	35 07       	cpc	r19, r21
    1d42:	30 f4       	brcc	.+12     	; 0x1d50 <prvCopyDataToQueue+0x92>
    1d44:	2a 81       	ldd	r18, Y+2	; 0x02
    1d46:	3b 81       	ldd	r19, Y+3	; 0x03
    1d48:	82 0f       	add	r24, r18
    1d4a:	93 1f       	adc	r25, r19
    1d4c:	9f 83       	std	Y+7, r25	; 0x07
    1d4e:	8e 83       	std	Y+6, r24	; 0x06
    1d50:	02 30       	cpi	r16, 0x02	; 2
    1d52:	49 f4       	brne	.+18     	; 0x1d66 <prvCopyDataToQueue+0xa8>
    1d54:	11 23       	and	r17, r17
    1d56:	49 f0       	breq	.+18     	; 0x1d6a <prvCopyDataToQueue+0xac>
    1d58:	11 50       	subi	r17, 0x01	; 1
    1d5a:	80 e0       	ldi	r24, 0x00	; 0
    1d5c:	07 c0       	rjmp	.+14     	; 0x1d6c <prvCopyDataToQueue+0xae>
    1d5e:	80 e0       	ldi	r24, 0x00	; 0
    1d60:	05 c0       	rjmp	.+10     	; 0x1d6c <prvCopyDataToQueue+0xae>
    1d62:	80 e0       	ldi	r24, 0x00	; 0
    1d64:	03 c0       	rjmp	.+6      	; 0x1d6c <prvCopyDataToQueue+0xae>
    1d66:	80 e0       	ldi	r24, 0x00	; 0
    1d68:	01 c0       	rjmp	.+2      	; 0x1d6c <prvCopyDataToQueue+0xae>
    1d6a:	80 e0       	ldi	r24, 0x00	; 0
    1d6c:	1f 5f       	subi	r17, 0xFF	; 255
    1d6e:	1a 8f       	std	Y+26, r17	; 0x1a
    1d70:	df 91       	pop	r29
    1d72:	cf 91       	pop	r28
    1d74:	1f 91       	pop	r17
    1d76:	0f 91       	pop	r16
    1d78:	08 95       	ret

00001d7a <prvCopyDataFromQueue>:
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	44 8d       	ldd	r20, Z+28	; 0x1c
    1d7e:	44 23       	and	r20, r20
    1d80:	a9 f0       	breq	.+42     	; 0x1dac <prvCopyDataFromQueue+0x32>
    1d82:	50 e0       	ldi	r21, 0x00	; 0
    1d84:	26 81       	ldd	r18, Z+6	; 0x06
    1d86:	37 81       	ldd	r19, Z+7	; 0x07
    1d88:	24 0f       	add	r18, r20
    1d8a:	35 1f       	adc	r19, r21
    1d8c:	37 83       	std	Z+7, r19	; 0x07
    1d8e:	26 83       	std	Z+6, r18	; 0x06
    1d90:	82 81       	ldd	r24, Z+2	; 0x02
    1d92:	93 81       	ldd	r25, Z+3	; 0x03
    1d94:	28 17       	cp	r18, r24
    1d96:	39 07       	cpc	r19, r25
    1d98:	20 f0       	brcs	.+8      	; 0x1da2 <prvCopyDataFromQueue+0x28>
    1d9a:	80 81       	ld	r24, Z
    1d9c:	91 81       	ldd	r25, Z+1	; 0x01
    1d9e:	97 83       	std	Z+7, r25	; 0x07
    1da0:	86 83       	std	Z+6, r24	; 0x06
    1da2:	cb 01       	movw	r24, r22
    1da4:	66 81       	ldd	r22, Z+6	; 0x06
    1da6:	77 81       	ldd	r23, Z+7	; 0x07
    1da8:	0c 94 18 17 	jmp	0x2e30	; 0x2e30 <memcpy>
    1dac:	08 95       	ret

00001dae <prvUnlockQueue>:
    1dae:	ef 92       	push	r14
    1db0:	ff 92       	push	r15
    1db2:	0f 93       	push	r16
    1db4:	1f 93       	push	r17
    1db6:	cf 93       	push	r28
    1db8:	8c 01       	movw	r16, r24
    1dba:	0f b6       	in	r0, 0x3f	; 63
    1dbc:	f8 94       	cli
    1dbe:	0f 92       	push	r0
    1dc0:	fc 01       	movw	r30, r24
    1dc2:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1dc4:	1c 16       	cp	r1, r28
    1dc6:	9c f4       	brge	.+38     	; 0x1dee <prvUnlockQueue+0x40>
    1dc8:	81 89       	ldd	r24, Z+17	; 0x11
    1dca:	81 11       	cpse	r24, r1
    1dcc:	06 c0       	rjmp	.+12     	; 0x1dda <prvUnlockQueue+0x2c>
    1dce:	0f c0       	rjmp	.+30     	; 0x1dee <prvUnlockQueue+0x40>
    1dd0:	f8 01       	movw	r30, r16
    1dd2:	81 89       	ldd	r24, Z+17	; 0x11
    1dd4:	81 11       	cpse	r24, r1
    1dd6:	05 c0       	rjmp	.+10     	; 0x1de2 <prvUnlockQueue+0x34>
    1dd8:	0a c0       	rjmp	.+20     	; 0x1dee <prvUnlockQueue+0x40>
    1dda:	78 01       	movw	r14, r16
    1ddc:	f1 e1       	ldi	r31, 0x11	; 17
    1dde:	ef 0e       	add	r14, r31
    1de0:	f1 1c       	adc	r15, r1
    1de2:	c7 01       	movw	r24, r14
    1de4:	9a d5       	rcall	.+2868   	; 0x291a <xTaskRemoveFromEventList>
    1de6:	81 11       	cpse	r24, r1
    1de8:	21 d6       	rcall	.+3138   	; 0x2a2c <vTaskMissedYield>
    1dea:	c1 50       	subi	r28, 0x01	; 1
    1dec:	89 f7       	brne	.-30     	; 0x1dd0 <prvUnlockQueue+0x22>
    1dee:	8f ef       	ldi	r24, 0xFF	; 255
    1df0:	f8 01       	movw	r30, r16
    1df2:	86 8f       	std	Z+30, r24	; 0x1e
    1df4:	0f 90       	pop	r0
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	0f b6       	in	r0, 0x3f	; 63
    1dfa:	f8 94       	cli
    1dfc:	0f 92       	push	r0
    1dfe:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1e00:	1c 16       	cp	r1, r28
    1e02:	9c f4       	brge	.+38     	; 0x1e2a <prvUnlockQueue+0x7c>
    1e04:	80 85       	ldd	r24, Z+8	; 0x08
    1e06:	81 11       	cpse	r24, r1
    1e08:	06 c0       	rjmp	.+12     	; 0x1e16 <prvUnlockQueue+0x68>
    1e0a:	0f c0       	rjmp	.+30     	; 0x1e2a <prvUnlockQueue+0x7c>
    1e0c:	f8 01       	movw	r30, r16
    1e0e:	80 85       	ldd	r24, Z+8	; 0x08
    1e10:	81 11       	cpse	r24, r1
    1e12:	05 c0       	rjmp	.+10     	; 0x1e1e <prvUnlockQueue+0x70>
    1e14:	0a c0       	rjmp	.+20     	; 0x1e2a <prvUnlockQueue+0x7c>
    1e16:	78 01       	movw	r14, r16
    1e18:	f8 e0       	ldi	r31, 0x08	; 8
    1e1a:	ef 0e       	add	r14, r31
    1e1c:	f1 1c       	adc	r15, r1
    1e1e:	c7 01       	movw	r24, r14
    1e20:	7c d5       	rcall	.+2808   	; 0x291a <xTaskRemoveFromEventList>
    1e22:	81 11       	cpse	r24, r1
    1e24:	03 d6       	rcall	.+3078   	; 0x2a2c <vTaskMissedYield>
    1e26:	c1 50       	subi	r28, 0x01	; 1
    1e28:	89 f7       	brne	.-30     	; 0x1e0c <prvUnlockQueue+0x5e>
    1e2a:	8f ef       	ldi	r24, 0xFF	; 255
    1e2c:	f8 01       	movw	r30, r16
    1e2e:	85 8f       	std	Z+29, r24	; 0x1d
    1e30:	0f 90       	pop	r0
    1e32:	0f be       	out	0x3f, r0	; 63
    1e34:	cf 91       	pop	r28
    1e36:	1f 91       	pop	r17
    1e38:	0f 91       	pop	r16
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	08 95       	ret

00001e40 <xQueueGenericReset>:
    1e40:	cf 93       	push	r28
    1e42:	df 93       	push	r29
    1e44:	ec 01       	movw	r28, r24
    1e46:	0f b6       	in	r0, 0x3f	; 63
    1e48:	f8 94       	cli
    1e4a:	0f 92       	push	r0
    1e4c:	48 81       	ld	r20, Y
    1e4e:	59 81       	ldd	r21, Y+1	; 0x01
    1e50:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1e52:	30 e0       	ldi	r19, 0x00	; 0
    1e54:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1e56:	72 9f       	mul	r23, r18
    1e58:	c0 01       	movw	r24, r0
    1e5a:	73 9f       	mul	r23, r19
    1e5c:	90 0d       	add	r25, r0
    1e5e:	11 24       	eor	r1, r1
    1e60:	fa 01       	movw	r30, r20
    1e62:	e8 0f       	add	r30, r24
    1e64:	f9 1f       	adc	r31, r25
    1e66:	fb 83       	std	Y+3, r31	; 0x03
    1e68:	ea 83       	std	Y+2, r30	; 0x02
    1e6a:	1a 8e       	std	Y+26, r1	; 0x1a
    1e6c:	5d 83       	std	Y+5, r21	; 0x05
    1e6e:	4c 83       	std	Y+4, r20	; 0x04
    1e70:	82 1b       	sub	r24, r18
    1e72:	93 0b       	sbc	r25, r19
    1e74:	84 0f       	add	r24, r20
    1e76:	95 1f       	adc	r25, r21
    1e78:	9f 83       	std	Y+7, r25	; 0x07
    1e7a:	8e 83       	std	Y+6, r24	; 0x06
    1e7c:	8f ef       	ldi	r24, 0xFF	; 255
    1e7e:	8d 8f       	std	Y+29, r24	; 0x1d
    1e80:	8e 8f       	std	Y+30, r24	; 0x1e
    1e82:	61 11       	cpse	r22, r1
    1e84:	0a c0       	rjmp	.+20     	; 0x1e9a <xQueueGenericReset+0x5a>
    1e86:	88 85       	ldd	r24, Y+8	; 0x08
    1e88:	88 23       	and	r24, r24
    1e8a:	69 f0       	breq	.+26     	; 0x1ea6 <xQueueGenericReset+0x66>
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	08 96       	adiw	r24, 0x08	; 8
    1e90:	44 d5       	rcall	.+2696   	; 0x291a <xTaskRemoveFromEventList>
    1e92:	88 23       	and	r24, r24
    1e94:	41 f0       	breq	.+16     	; 0x1ea6 <xQueueGenericReset+0x66>
    1e96:	5f de       	rcall	.-834    	; 0x1b56 <vPortYield>
    1e98:	06 c0       	rjmp	.+12     	; 0x1ea6 <xQueueGenericReset+0x66>
    1e9a:	ce 01       	movw	r24, r28
    1e9c:	08 96       	adiw	r24, 0x08	; 8
    1e9e:	30 dd       	rcall	.-1440   	; 0x1900 <vListInitialise>
    1ea0:	ce 01       	movw	r24, r28
    1ea2:	41 96       	adiw	r24, 0x11	; 17
    1ea4:	2d dd       	rcall	.-1446   	; 0x1900 <vListInitialise>
    1ea6:	0f 90       	pop	r0
    1ea8:	0f be       	out	0x3f, r0	; 63
    1eaa:	81 e0       	ldi	r24, 0x01	; 1
    1eac:	df 91       	pop	r29
    1eae:	cf 91       	pop	r28
    1eb0:	08 95       	ret

00001eb2 <xQueueGenericCreate>:
    1eb2:	0f 93       	push	r16
    1eb4:	1f 93       	push	r17
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	08 2f       	mov	r16, r24
    1ebc:	16 2f       	mov	r17, r22
    1ebe:	66 23       	and	r22, r22
    1ec0:	b1 f0       	breq	.+44     	; 0x1eee <xQueueGenericCreate+0x3c>
    1ec2:	86 9f       	mul	r24, r22
    1ec4:	c0 01       	movw	r24, r0
    1ec6:	11 24       	eor	r1, r1
    1ec8:	4f 96       	adiw	r24, 0x1f	; 31
    1eca:	e6 dc       	rcall	.-1588   	; 0x1898 <pvPortMalloc>
    1ecc:	ec 01       	movw	r28, r24
    1ece:	00 97       	sbiw	r24, 0x00	; 0
    1ed0:	39 f4       	brne	.+14     	; 0x1ee0 <xQueueGenericCreate+0x2e>
    1ed2:	13 c0       	rjmp	.+38     	; 0x1efa <xQueueGenericCreate+0x48>
    1ed4:	0b 8f       	std	Y+27, r16	; 0x1b
    1ed6:	1c 8f       	std	Y+28, r17	; 0x1c
    1ed8:	61 e0       	ldi	r22, 0x01	; 1
    1eda:	ce 01       	movw	r24, r28
    1edc:	b1 df       	rcall	.-158    	; 0x1e40 <xQueueGenericReset>
    1ede:	0d c0       	rjmp	.+26     	; 0x1efa <xQueueGenericCreate+0x48>
    1ee0:	4f 96       	adiw	r24, 0x1f	; 31
    1ee2:	99 83       	std	Y+1, r25	; 0x01
    1ee4:	88 83       	st	Y, r24
    1ee6:	f6 cf       	rjmp	.-20     	; 0x1ed4 <xQueueGenericCreate+0x22>
    1ee8:	d9 83       	std	Y+1, r29	; 0x01
    1eea:	c8 83       	st	Y, r28
    1eec:	f3 cf       	rjmp	.-26     	; 0x1ed4 <xQueueGenericCreate+0x22>
    1eee:	8f e1       	ldi	r24, 0x1F	; 31
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	d2 dc       	rcall	.-1628   	; 0x1898 <pvPortMalloc>
    1ef4:	ec 01       	movw	r28, r24
    1ef6:	89 2b       	or	r24, r25
    1ef8:	b9 f7       	brne	.-18     	; 0x1ee8 <xQueueGenericCreate+0x36>
    1efa:	ce 01       	movw	r24, r28
    1efc:	df 91       	pop	r29
    1efe:	cf 91       	pop	r28
    1f00:	1f 91       	pop	r17
    1f02:	0f 91       	pop	r16
    1f04:	08 95       	ret

00001f06 <xQueueGenericSend>:
    1f06:	9f 92       	push	r9
    1f08:	af 92       	push	r10
    1f0a:	bf 92       	push	r11
    1f0c:	cf 92       	push	r12
    1f0e:	df 92       	push	r13
    1f10:	ef 92       	push	r14
    1f12:	ff 92       	push	r15
    1f14:	0f 93       	push	r16
    1f16:	1f 93       	push	r17
    1f18:	cf 93       	push	r28
    1f1a:	df 93       	push	r29
    1f1c:	00 d0       	rcall	.+0      	; 0x1f1e <xQueueGenericSend+0x18>
    1f1e:	00 d0       	rcall	.+0      	; 0x1f20 <xQueueGenericSend+0x1a>
    1f20:	1f 92       	push	r1
    1f22:	cd b7       	in	r28, 0x3d	; 61
    1f24:	de b7       	in	r29, 0x3e	; 62
    1f26:	8c 01       	movw	r16, r24
    1f28:	6b 01       	movw	r12, r22
    1f2a:	5d 83       	std	Y+5, r21	; 0x05
    1f2c:	4c 83       	std	Y+4, r20	; 0x04
    1f2e:	a2 2e       	mov	r10, r18
    1f30:	b1 2c       	mov	r11, r1
    1f32:	99 24       	eor	r9, r9
    1f34:	93 94       	inc	r9
    1f36:	7c 01       	movw	r14, r24
    1f38:	88 e0       	ldi	r24, 0x08	; 8
    1f3a:	e8 0e       	add	r14, r24
    1f3c:	f1 1c       	adc	r15, r1
    1f3e:	0f b6       	in	r0, 0x3f	; 63
    1f40:	f8 94       	cli
    1f42:	0f 92       	push	r0
    1f44:	f8 01       	movw	r30, r16
    1f46:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f48:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f4a:	98 17       	cp	r25, r24
    1f4c:	18 f0       	brcs	.+6      	; 0x1f54 <xQueueGenericSend+0x4e>
    1f4e:	f2 e0       	ldi	r31, 0x02	; 2
    1f50:	af 12       	cpse	r10, r31
    1f52:	15 c0       	rjmp	.+42     	; 0x1f7e <xQueueGenericSend+0x78>
    1f54:	4a 2d       	mov	r20, r10
    1f56:	b6 01       	movw	r22, r12
    1f58:	c8 01       	movw	r24, r16
    1f5a:	b1 de       	rcall	.-670    	; 0x1cbe <prvCopyDataToQueue>
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	91 89       	ldd	r25, Z+17	; 0x11
    1f60:	99 23       	and	r25, r25
    1f62:	39 f0       	breq	.+14     	; 0x1f72 <xQueueGenericSend+0x6c>
    1f64:	c8 01       	movw	r24, r16
    1f66:	41 96       	adiw	r24, 0x11	; 17
    1f68:	d8 d4       	rcall	.+2480   	; 0x291a <xTaskRemoveFromEventList>
    1f6a:	88 23       	and	r24, r24
    1f6c:	21 f0       	breq	.+8      	; 0x1f76 <xQueueGenericSend+0x70>
    1f6e:	f3 dd       	rcall	.-1050   	; 0x1b56 <vPortYield>
    1f70:	02 c0       	rjmp	.+4      	; 0x1f76 <xQueueGenericSend+0x70>
    1f72:	81 11       	cpse	r24, r1
    1f74:	f0 dd       	rcall	.-1056   	; 0x1b56 <vPortYield>
    1f76:	0f 90       	pop	r0
    1f78:	0f be       	out	0x3f, r0	; 63
    1f7a:	81 e0       	ldi	r24, 0x01	; 1
    1f7c:	45 c0       	rjmp	.+138    	; 0x2008 <xQueueGenericSend+0x102>
    1f7e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f80:	9d 81       	ldd	r25, Y+5	; 0x05
    1f82:	89 2b       	or	r24, r25
    1f84:	21 f4       	brne	.+8      	; 0x1f8e <xQueueGenericSend+0x88>
    1f86:	0f 90       	pop	r0
    1f88:	0f be       	out	0x3f, r0	; 63
    1f8a:	80 e0       	ldi	r24, 0x00	; 0
    1f8c:	3d c0       	rjmp	.+122    	; 0x2008 <xQueueGenericSend+0x102>
    1f8e:	b1 10       	cpse	r11, r1
    1f90:	04 c0       	rjmp	.+8      	; 0x1f9a <xQueueGenericSend+0x94>
    1f92:	ce 01       	movw	r24, r28
    1f94:	01 96       	adiw	r24, 0x01	; 1
    1f96:	07 d5       	rcall	.+2574   	; 0x29a6 <vTaskSetTimeOutState>
    1f98:	b9 2c       	mov	r11, r9
    1f9a:	0f 90       	pop	r0
    1f9c:	0f be       	out	0x3f, r0	; 63
    1f9e:	b0 d2       	rcall	.+1376   	; 0x2500 <vTaskSuspendAll>
    1fa0:	0f b6       	in	r0, 0x3f	; 63
    1fa2:	f8 94       	cli
    1fa4:	0f 92       	push	r0
    1fa6:	f8 01       	movw	r30, r16
    1fa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1faa:	8f 3f       	cpi	r24, 0xFF	; 255
    1fac:	09 f4       	brne	.+2      	; 0x1fb0 <xQueueGenericSend+0xaa>
    1fae:	15 8e       	std	Z+29, r1	; 0x1d
    1fb0:	f8 01       	movw	r30, r16
    1fb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fb4:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb6:	09 f4       	brne	.+2      	; 0x1fba <xQueueGenericSend+0xb4>
    1fb8:	16 8e       	std	Z+30, r1	; 0x1e
    1fba:	0f 90       	pop	r0
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	be 01       	movw	r22, r28
    1fc0:	6c 5f       	subi	r22, 0xFC	; 252
    1fc2:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc4:	ce 01       	movw	r24, r28
    1fc6:	01 96       	adiw	r24, 0x01	; 1
    1fc8:	f9 d4       	rcall	.+2546   	; 0x29bc <xTaskCheckForTimeOut>
    1fca:	81 11       	cpse	r24, r1
    1fcc:	19 c0       	rjmp	.+50     	; 0x2000 <xQueueGenericSend+0xfa>
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	92 8d       	ldd	r25, Z+26	; 0x1a
    1fd8:	0f 90       	pop	r0
    1fda:	0f be       	out	0x3f, r0	; 63
    1fdc:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fde:	98 13       	cpse	r25, r24
    1fe0:	0b c0       	rjmp	.+22     	; 0x1ff8 <xQueueGenericSend+0xf2>
    1fe2:	6c 81       	ldd	r22, Y+4	; 0x04
    1fe4:	7d 81       	ldd	r23, Y+5	; 0x05
    1fe6:	c7 01       	movw	r24, r14
    1fe8:	88 d4       	rcall	.+2320   	; 0x28fa <vTaskPlaceOnEventList>
    1fea:	c8 01       	movw	r24, r16
    1fec:	e0 de       	rcall	.-576    	; 0x1dae <prvUnlockQueue>
    1fee:	45 d3       	rcall	.+1674   	; 0x267a <xTaskResumeAll>
    1ff0:	81 11       	cpse	r24, r1
    1ff2:	a5 cf       	rjmp	.-182    	; 0x1f3e <xQueueGenericSend+0x38>
    1ff4:	b0 dd       	rcall	.-1184   	; 0x1b56 <vPortYield>
    1ff6:	a3 cf       	rjmp	.-186    	; 0x1f3e <xQueueGenericSend+0x38>
    1ff8:	c8 01       	movw	r24, r16
    1ffa:	d9 de       	rcall	.-590    	; 0x1dae <prvUnlockQueue>
    1ffc:	3e d3       	rcall	.+1660   	; 0x267a <xTaskResumeAll>
    1ffe:	9f cf       	rjmp	.-194    	; 0x1f3e <xQueueGenericSend+0x38>
    2000:	c8 01       	movw	r24, r16
    2002:	d5 de       	rcall	.-598    	; 0x1dae <prvUnlockQueue>
    2004:	3a d3       	rcall	.+1652   	; 0x267a <xTaskResumeAll>
    2006:	80 e0       	ldi	r24, 0x00	; 0
    2008:	0f 90       	pop	r0
    200a:	0f 90       	pop	r0
    200c:	0f 90       	pop	r0
    200e:	0f 90       	pop	r0
    2010:	0f 90       	pop	r0
    2012:	df 91       	pop	r29
    2014:	cf 91       	pop	r28
    2016:	1f 91       	pop	r17
    2018:	0f 91       	pop	r16
    201a:	ff 90       	pop	r15
    201c:	ef 90       	pop	r14
    201e:	df 90       	pop	r13
    2020:	cf 90       	pop	r12
    2022:	bf 90       	pop	r11
    2024:	af 90       	pop	r10
    2026:	9f 90       	pop	r9
    2028:	08 95       	ret

0000202a <xQueueCreateMutex>:
    202a:	cf 93       	push	r28
    202c:	df 93       	push	r29
    202e:	48 2f       	mov	r20, r24
    2030:	60 e0       	ldi	r22, 0x00	; 0
    2032:	81 e0       	ldi	r24, 0x01	; 1
    2034:	3e df       	rcall	.-388    	; 0x1eb2 <xQueueGenericCreate>
    2036:	ec 01       	movw	r28, r24
    2038:	00 97       	sbiw	r24, 0x00	; 0
    203a:	59 f0       	breq	.+22     	; 0x2052 <xQueueCreateMutex+0x28>
    203c:	1b 82       	std	Y+3, r1	; 0x03
    203e:	1a 82       	std	Y+2, r1	; 0x02
    2040:	19 82       	std	Y+1, r1	; 0x01
    2042:	18 82       	st	Y, r1
    2044:	1e 82       	std	Y+6, r1	; 0x06
    2046:	20 e0       	ldi	r18, 0x00	; 0
    2048:	40 e0       	ldi	r20, 0x00	; 0
    204a:	50 e0       	ldi	r21, 0x00	; 0
    204c:	60 e0       	ldi	r22, 0x00	; 0
    204e:	70 e0       	ldi	r23, 0x00	; 0
    2050:	5a df       	rcall	.-332    	; 0x1f06 <xQueueGenericSend>
    2052:	ce 01       	movw	r24, r28
    2054:	df 91       	pop	r29
    2056:	cf 91       	pop	r28
    2058:	08 95       	ret

0000205a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    205a:	8f 92       	push	r8
    205c:	9f 92       	push	r9
    205e:	af 92       	push	r10
    2060:	bf 92       	push	r11
    2062:	cf 92       	push	r12
    2064:	df 92       	push	r13
    2066:	ef 92       	push	r14
    2068:	ff 92       	push	r15
    206a:	0f 93       	push	r16
    206c:	1f 93       	push	r17
    206e:	cf 93       	push	r28
    2070:	df 93       	push	r29
    2072:	00 d0       	rcall	.+0      	; 0x2074 <xQueueGenericReceive+0x1a>
    2074:	00 d0       	rcall	.+0      	; 0x2076 <xQueueGenericReceive+0x1c>
    2076:	1f 92       	push	r1
    2078:	cd b7       	in	r28, 0x3d	; 61
    207a:	de b7       	in	r29, 0x3e	; 62
    207c:	8c 01       	movw	r16, r24
    207e:	5b 01       	movw	r10, r22
    2080:	5d 83       	std	Y+5, r21	; 0x05
    2082:	4c 83       	std	Y+4, r20	; 0x04
    2084:	82 2e       	mov	r8, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2086:	e1 2c       	mov	r14, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2088:	99 24       	eor	r9, r9
    208a:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    208c:	6c 01       	movw	r12, r24
    208e:	81 e1       	ldi	r24, 0x11	; 17
    2090:	c8 0e       	add	r12, r24
    2092:	d1 1c       	adc	r13, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2094:	0f b6       	in	r0, 0x3f	; 63
    2096:	f8 94       	cli
    2098:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    209a:	f8 01       	movw	r30, r16
    209c:	f2 8c       	ldd	r15, Z+26	; 0x1a

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    209e:	ff 20       	and	r15, r15
    20a0:	61 f1       	breq	.+88     	; 0x20fa <xQueueGenericReceive+0xa0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    20a2:	c6 80       	ldd	r12, Z+6	; 0x06
    20a4:	d7 80       	ldd	r13, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    20a6:	b5 01       	movw	r22, r10
    20a8:	c8 01       	movw	r24, r16
    20aa:	67 de       	rcall	.-818    	; 0x1d7a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    20ac:	81 10       	cpse	r8, r1
    20ae:	16 c0       	rjmp	.+44     	; 0x20dc <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
    20b0:	fa 94       	dec	r15
    20b2:	f8 01       	movw	r30, r16
    20b4:	f2 8e       	std	Z+26, r15	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    20b6:	80 81       	ld	r24, Z
    20b8:	91 81       	ldd	r25, Z+1	; 0x01
    20ba:	89 2b       	or	r24, r25
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    20bc:	21 f4       	brne	.+8      	; 0x20c6 <xQueueGenericReceive+0x6c>
    20be:	5c d5       	rcall	.+2744   	; 0x2b78 <pvTaskIncrementMutexHeldCount>
    20c0:	f8 01       	movw	r30, r16
    20c2:	93 83       	std	Z+3, r25	; 0x03
    20c4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20c6:	f8 01       	movw	r30, r16
    20c8:	80 85       	ldd	r24, Z+8	; 0x08
    20ca:	88 23       	and	r24, r24
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20cc:	91 f0       	breq	.+36     	; 0x20f2 <xQueueGenericReceive+0x98>
    20ce:	c8 01       	movw	r24, r16
    20d0:	08 96       	adiw	r24, 0x08	; 8
    20d2:	23 d4       	rcall	.+2118   	; 0x291a <xTaskRemoveFromEventList>
						{
							queueYIELD_IF_USING_PREEMPTION();
    20d4:	88 23       	and	r24, r24
    20d6:	69 f0       	breq	.+26     	; 0x20f2 <xQueueGenericReceive+0x98>
    20d8:	3e dd       	rcall	.-1412   	; 0x1b56 <vPortYield>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    20da:	0b c0       	rjmp	.+22     	; 0x20f2 <xQueueGenericReceive+0x98>
    20dc:	f8 01       	movw	r30, r16
    20de:	d7 82       	std	Z+7, r13	; 0x07

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20e0:	c6 82       	std	Z+6, r12	; 0x06
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20e2:	81 89       	ldd	r24, Z+17	; 0x11
    20e4:	88 23       	and	r24, r24
    20e6:	29 f0       	breq	.+10     	; 0x20f2 <xQueueGenericReceive+0x98>
    20e8:	c8 01       	movw	r24, r16
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    20ea:	41 96       	adiw	r24, 0x11	; 17
    20ec:	16 d4       	rcall	.+2092   	; 0x291a <xTaskRemoveFromEventList>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    20ee:	81 11       	cpse	r24, r1
    20f0:	32 dd       	rcall	.-1436   	; 0x1b56 <vPortYield>
				return pdPASS;
    20f2:	0f 90       	pop	r0
    20f4:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    20f6:	81 e0       	ldi	r24, 0x01	; 1
    20f8:	58 c0       	rjmp	.+176    	; 0x21aa <xQueueGenericReceive+0x150>
    20fa:	8c 81       	ldd	r24, Y+4	; 0x04
    20fc:	9d 81       	ldd	r25, Y+5	; 0x05
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    20fe:	89 2b       	or	r24, r25
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2100:	21 f4       	brne	.+8      	; 0x210a <xQueueGenericReceive+0xb0>
				}
				else if( xEntryTimeSet == pdFALSE )
    2102:	0f 90       	pop	r0
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2104:	0f be       	out	0x3f, r0	; 63
    2106:	80 e0       	ldi	r24, 0x00	; 0
    2108:	50 c0       	rjmp	.+160    	; 0x21aa <xQueueGenericReceive+0x150>
					xEntryTimeSet = pdTRUE;
    210a:	e1 10       	cpse	r14, r1
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    210c:	04 c0       	rjmp	.+8      	; 0x2116 <xQueueGenericReceive+0xbc>
    210e:	ce 01       	movw	r24, r28

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2110:	01 96       	adiw	r24, 0x01	; 1
    2112:	49 d4       	rcall	.+2194   	; 0x29a6 <vTaskSetTimeOutState>
		prvLockQueue( pxQueue );
    2114:	e9 2c       	mov	r14, r9
    2116:	0f 90       	pop	r0
    2118:	0f be       	out	0x3f, r0	; 63
    211a:	f2 d1       	rcall	.+996    	; 0x2500 <vTaskSuspendAll>
    211c:	0f b6       	in	r0, 0x3f	; 63
    211e:	f8 94       	cli
    2120:	0f 92       	push	r0
    2122:	f8 01       	movw	r30, r16
    2124:	85 8d       	ldd	r24, Z+29	; 0x1d
    2126:	8f 3f       	cpi	r24, 0xFF	; 255
    2128:	09 f4       	brne	.+2      	; 0x212c <xQueueGenericReceive+0xd2>
    212a:	15 8e       	std	Z+29, r1	; 0x1d
    212c:	f8 01       	movw	r30, r16

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    212e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2130:	8f 3f       	cpi	r24, 0xFF	; 255
    2132:	09 f4       	brne	.+2      	; 0x2136 <xQueueGenericReceive+0xdc>
    2134:	16 8e       	std	Z+30, r1	; 0x1e
    2136:	0f 90       	pop	r0
    2138:	0f be       	out	0x3f, r0	; 63
    213a:	be 01       	movw	r22, r28
    213c:	6c 5f       	subi	r22, 0xFC	; 252
    213e:	7f 4f       	sbci	r23, 0xFF	; 255

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2140:	ce 01       	movw	r24, r28
    2142:	01 96       	adiw	r24, 0x01	; 1
    2144:	3b d4       	rcall	.+2166   	; 0x29bc <xTaskCheckForTimeOut>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2146:	81 11       	cpse	r24, r1
    2148:	24 c0       	rjmp	.+72     	; 0x2192 <xQueueGenericReceive+0x138>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    214a:	0f b6       	in	r0, 0x3f	; 63
    214c:	f8 94       	cli
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    214e:	0f 92       	push	r0
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2150:	f8 01       	movw	r30, r16
    2152:	82 8d       	ldd	r24, Z+26	; 0x1a
    2154:	0f 90       	pop	r0
					{
						taskENTER_CRITICAL();
    2156:	0f be       	out	0x3f, r0	; 63
    2158:	81 11       	cpse	r24, r1
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    215a:	17 c0       	rjmp	.+46     	; 0x218a <xQueueGenericReceive+0x130>
    215c:	80 81       	ld	r24, Z
						}
						taskEXIT_CRITICAL();
    215e:	91 81       	ldd	r25, Z+1	; 0x01
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2160:	89 2b       	or	r24, r25
    2162:	41 f4       	brne	.+16     	; 0x2174 <xQueueGenericReceive+0x11a>
    2164:	0f b6       	in	r0, 0x3f	; 63
				prvUnlockQueue( pxQueue );
    2166:	f8 94       	cli
				if( xTaskResumeAll() == pdFALSE )
    2168:	0f 92       	push	r0
    216a:	82 81       	ldd	r24, Z+2	; 0x02
    216c:	93 81       	ldd	r25, Z+3	; 0x03
    216e:	62 d4       	rcall	.+2244   	; 0x2a34 <vTaskPriorityInherit>
				{
					portYIELD_WITHIN_API();
    2170:	0f 90       	pop	r0
    2172:	0f be       	out	0x3f, r0	; 63
    2174:	6c 81       	ldd	r22, Y+4	; 0x04
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2176:	7d 81       	ldd	r23, Y+5	; 0x05
    2178:	c6 01       	movw	r24, r12
    217a:	bf d3       	rcall	.+1918   	; 0x28fa <vTaskPlaceOnEventList>
				( void ) xTaskResumeAll();
    217c:	c8 01       	movw	r24, r16
    217e:	17 de       	rcall	.-978    	; 0x1dae <prvUnlockQueue>
    2180:	7c d2       	rcall	.+1272   	; 0x267a <xTaskResumeAll>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    2182:	81 11       	cpse	r24, r1
    2184:	87 cf       	rjmp	.-242    	; 0x2094 <xQueueGenericReceive+0x3a>
    2186:	e7 dc       	rcall	.-1586   	; 0x1b56 <vPortYield>
			( void ) xTaskResumeAll();
    2188:	85 cf       	rjmp	.-246    	; 0x2094 <xQueueGenericReceive+0x3a>
    218a:	c8 01       	movw	r24, r16

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    218c:	10 de       	rcall	.-992    	; 0x1dae <prvUnlockQueue>
    218e:	75 d2       	rcall	.+1258   	; 0x267a <xTaskResumeAll>
    2190:	81 cf       	rjmp	.-254    	; 0x2094 <xQueueGenericReceive+0x3a>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2192:	c8 01       	movw	r24, r16
    2194:	0c de       	rcall	.-1000   	; 0x1dae <prvUnlockQueue>
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2196:	71 d2       	rcall	.+1250   	; 0x267a <xTaskResumeAll>
    2198:	0f b6       	in	r0, 0x3f	; 63
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    219a:	f8 94       	cli
    219c:	0f 92       	push	r0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
}
    219e:	f8 01       	movw	r30, r16
    21a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    21a2:	0f 90       	pop	r0
    21a4:	0f be       	out	0x3f, r0	; 63
    21a6:	81 11       	cpse	r24, r1
    21a8:	75 cf       	rjmp	.-278    	; 0x2094 <xQueueGenericReceive+0x3a>
    21aa:	0f 90       	pop	r0
    21ac:	0f 90       	pop	r0
    21ae:	0f 90       	pop	r0
    21b0:	0f 90       	pop	r0
    21b2:	0f 90       	pop	r0
    21b4:	df 91       	pop	r29
    21b6:	cf 91       	pop	r28
    21b8:	1f 91       	pop	r17
    21ba:	0f 91       	pop	r16
    21bc:	ff 90       	pop	r15
    21be:	ef 90       	pop	r14
    21c0:	df 90       	pop	r13
    21c2:	cf 90       	pop	r12
    21c4:	bf 90       	pop	r11
    21c6:	af 90       	pop	r10
    21c8:	9f 90       	pop	r9
    21ca:	8f 90       	pop	r8
    21cc:	08 95       	ret

000021ce <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    21ce:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    21d2:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    21d6:	80 81       	ld	r24, Z
    21d8:	81 11       	cpse	r24, r1
    21da:	07 c0       	rjmp	.+14     	; 0x21ea <prvResetNextTaskUnblockTime+0x1c>
    21dc:	8f ef       	ldi	r24, 0xFF	; 255
    21de:	9f ef       	ldi	r25, 0xFF	; 255
    21e0:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    21e4:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    21e8:	08 95       	ret
    21ea:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    21ee:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    21f2:	05 80       	ldd	r0, Z+5	; 0x05
    21f4:	f6 81       	ldd	r31, Z+6	; 0x06
    21f6:	e0 2d       	mov	r30, r0
    21f8:	06 80       	ldd	r0, Z+6	; 0x06
    21fa:	f7 81       	ldd	r31, Z+7	; 0x07
    21fc:	e0 2d       	mov	r30, r0
    21fe:	82 81       	ldd	r24, Z+2	; 0x02
    2200:	93 81       	ldd	r25, Z+3	; 0x03
    2202:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    2206:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    220a:	08 95       	ret

0000220c <prvAddCurrentTaskToDelayedList>:
    220c:	ff 92       	push	r15
    220e:	0f 93       	push	r16
    2210:	1f 93       	push	r17
    2212:	cf 93       	push	r28
    2214:	df 93       	push	r29
    2216:	ec 01       	movw	r28, r24
    2218:	f6 2e       	mov	r15, r22
    221a:	00 91 52 0d 	lds	r16, 0x0D52	; 0x800d52 <xTickCount>
    221e:	10 91 53 0d 	lds	r17, 0x0D53	; 0x800d53 <xTickCount+0x1>
    2222:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2226:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    222a:	02 96       	adiw	r24, 0x02	; 2
    222c:	cd db       	rcall	.-2150   	; 0x19c8 <uxListRemove>
    222e:	cf 3f       	cpi	r28, 0xFF	; 255
    2230:	8f ef       	ldi	r24, 0xFF	; 255
    2232:	d8 07       	cpc	r29, r24
    2234:	61 f4       	brne	.+24     	; 0x224e <prvAddCurrentTaskToDelayedList+0x42>
    2236:	ff 20       	and	r15, r15
    2238:	51 f0       	breq	.+20     	; 0x224e <prvAddCurrentTaskToDelayedList+0x42>
    223a:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    223e:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2242:	6e 5f       	subi	r22, 0xFE	; 254
    2244:	7f 4f       	sbci	r23, 0xFF	; 255
    2246:	85 e5       	ldi	r24, 0x55	; 85
    2248:	9d e0       	ldi	r25, 0x0D	; 13
    224a:	6c db       	rcall	.-2344   	; 0x1924 <vListInsertEnd>
    224c:	2d c0       	rjmp	.+90     	; 0x22a8 <prvAddCurrentTaskToDelayedList+0x9c>
    224e:	c0 0f       	add	r28, r16
    2250:	d1 1f       	adc	r29, r17
    2252:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2256:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    225a:	d3 83       	std	Z+3, r29	; 0x03
    225c:	c2 83       	std	Z+2, r28	; 0x02
    225e:	c0 17       	cp	r28, r16
    2260:	d1 07       	cpc	r29, r17
    2262:	60 f4       	brcc	.+24     	; 0x227c <prvAddCurrentTaskToDelayedList+0x70>
    2264:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2268:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    226c:	80 91 71 0d 	lds	r24, 0x0D71	; 0x800d71 <pxOverflowDelayedTaskList>
    2270:	90 91 72 0d 	lds	r25, 0x0D72	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    2274:	6e 5f       	subi	r22, 0xFE	; 254
    2276:	7f 4f       	sbci	r23, 0xFF	; 255
    2278:	76 db       	rcall	.-2324   	; 0x1966 <vListInsert>
    227a:	16 c0       	rjmp	.+44     	; 0x22a8 <prvAddCurrentTaskToDelayedList+0x9c>
    227c:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2280:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2284:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    2288:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    228c:	6e 5f       	subi	r22, 0xFE	; 254
    228e:	7f 4f       	sbci	r23, 0xFF	; 255
    2290:	6a db       	rcall	.-2348   	; 0x1966 <vListInsert>
    2292:	80 91 4a 0d 	lds	r24, 0x0D4A	; 0x800d4a <xNextTaskUnblockTime>
    2296:	90 91 4b 0d 	lds	r25, 0x0D4B	; 0x800d4b <xNextTaskUnblockTime+0x1>
    229a:	c8 17       	cp	r28, r24
    229c:	d9 07       	cpc	r29, r25
    229e:	20 f4       	brcc	.+8      	; 0x22a8 <prvAddCurrentTaskToDelayedList+0x9c>
    22a0:	d0 93 4b 0d 	sts	0x0D4B, r29	; 0x800d4b <xNextTaskUnblockTime+0x1>
    22a4:	c0 93 4a 0d 	sts	0x0D4A, r28	; 0x800d4a <xNextTaskUnblockTime>
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	0f 91       	pop	r16
    22b0:	ff 90       	pop	r15
    22b2:	08 95       	ret

000022b4 <xTaskCreate>:
    22b4:	4f 92       	push	r4
    22b6:	5f 92       	push	r5
    22b8:	6f 92       	push	r6
    22ba:	7f 92       	push	r7
    22bc:	8f 92       	push	r8
    22be:	9f 92       	push	r9
    22c0:	af 92       	push	r10
    22c2:	bf 92       	push	r11
    22c4:	cf 92       	push	r12
    22c6:	df 92       	push	r13
    22c8:	ef 92       	push	r14
    22ca:	ff 92       	push	r15
    22cc:	0f 93       	push	r16
    22ce:	cf 93       	push	r28
    22d0:	df 93       	push	r29
    22d2:	4c 01       	movw	r8, r24
    22d4:	6b 01       	movw	r12, r22
    22d6:	5a 01       	movw	r10, r20
    22d8:	29 01       	movw	r4, r18
    22da:	ca 01       	movw	r24, r20
    22dc:	dd da       	rcall	.-2630   	; 0x1898 <pvPortMalloc>
    22de:	3c 01       	movw	r6, r24
    22e0:	89 2b       	or	r24, r25
    22e2:	09 f4       	brne	.+2      	; 0x22e6 <xTaskCreate+0x32>
    22e4:	d4 c0       	rjmp	.+424    	; 0x248e <xTaskCreate+0x1da>
    22e6:	88 e2       	ldi	r24, 0x28	; 40
    22e8:	90 e0       	ldi	r25, 0x00	; 0
    22ea:	d6 da       	rcall	.-2644   	; 0x1898 <pvPortMalloc>
    22ec:	ec 01       	movw	r28, r24
    22ee:	89 2b       	or	r24, r25
    22f0:	71 f0       	breq	.+28     	; 0x230e <xTaskCreate+0x5a>
    22f2:	78 8e       	std	Y+24, r7	; 0x18
    22f4:	6f 8a       	std	Y+23, r6	; 0x17
    22f6:	81 e0       	ldi	r24, 0x01	; 1
    22f8:	a8 1a       	sub	r10, r24
    22fa:	b1 08       	sbc	r11, r1
    22fc:	6a 0c       	add	r6, r10
    22fe:	7b 1c       	adc	r7, r11
    2300:	d6 01       	movw	r26, r12
    2302:	8c 91       	ld	r24, X
    2304:	89 8f       	std	Y+25, r24	; 0x19
    2306:	8c 91       	ld	r24, X
    2308:	81 11       	cpse	r24, r1
    230a:	04 c0       	rjmp	.+8      	; 0x2314 <xTaskCreate+0x60>
    230c:	17 c0       	rjmp	.+46     	; 0x233c <xTaskCreate+0x88>
    230e:	c3 01       	movw	r24, r6
    2310:	f6 da       	rcall	.-2580   	; 0x18fe <vPortFree>
    2312:	bd c0       	rjmp	.+378    	; 0x248e <xTaskCreate+0x1da>
    2314:	ae 01       	movw	r20, r28
    2316:	46 5e       	subi	r20, 0xE6	; 230
    2318:	5f 4f       	sbci	r21, 0xFF	; 255
    231a:	f6 01       	movw	r30, r12
    231c:	31 96       	adiw	r30, 0x01	; 1
    231e:	b8 e0       	ldi	r27, 0x08	; 8
    2320:	cb 0e       	add	r12, r27
    2322:	d1 1c       	adc	r13, r1
    2324:	cf 01       	movw	r24, r30
    2326:	21 91       	ld	r18, Z+
    2328:	da 01       	movw	r26, r20
    232a:	2d 93       	st	X+, r18
    232c:	ad 01       	movw	r20, r26
    232e:	dc 01       	movw	r26, r24
    2330:	8c 91       	ld	r24, X
    2332:	88 23       	and	r24, r24
    2334:	19 f0       	breq	.+6      	; 0x233c <xTaskCreate+0x88>
    2336:	ec 15       	cp	r30, r12
    2338:	fd 05       	cpc	r31, r13
    233a:	a1 f7       	brne	.-24     	; 0x2324 <xTaskCreate+0x70>
    233c:	18 a2       	std	Y+32, r1	; 0x20
    233e:	04 30       	cpi	r16, 0x04	; 4
    2340:	08 f0       	brcs	.+2      	; 0x2344 <xTaskCreate+0x90>
    2342:	03 e0       	ldi	r16, 0x03	; 3
    2344:	0e 8b       	std	Y+22, r16	; 0x16
    2346:	09 a3       	std	Y+33, r16	; 0x21
    2348:	1a a2       	std	Y+34, r1	; 0x22
    234a:	6e 01       	movw	r12, r28
    234c:	b2 e0       	ldi	r27, 0x02	; 2
    234e:	cb 0e       	add	r12, r27
    2350:	d1 1c       	adc	r13, r1
    2352:	c6 01       	movw	r24, r12
    2354:	e3 da       	rcall	.-2618   	; 0x191c <vListInitialiseItem>
    2356:	ce 01       	movw	r24, r28
    2358:	0c 96       	adiw	r24, 0x0c	; 12
    235a:	e0 da       	rcall	.-2624   	; 0x191c <vListInitialiseItem>
    235c:	d9 87       	std	Y+9, r29	; 0x09
    235e:	c8 87       	std	Y+8, r28	; 0x08
    2360:	84 e0       	ldi	r24, 0x04	; 4
    2362:	90 e0       	ldi	r25, 0x00	; 0
    2364:	80 1b       	sub	r24, r16
    2366:	91 09       	sbc	r25, r1
    2368:	9d 87       	std	Y+13, r25	; 0x0d
    236a:	8c 87       	std	Y+12, r24	; 0x0c
    236c:	db 8b       	std	Y+19, r29	; 0x13
    236e:	ca 8b       	std	Y+18, r28	; 0x12
    2370:	1b a2       	std	Y+35, r1	; 0x23
    2372:	1c a2       	std	Y+36, r1	; 0x24
    2374:	1d a2       	std	Y+37, r1	; 0x25
    2376:	1e a2       	std	Y+38, r1	; 0x26
    2378:	1f a2       	std	Y+39, r1	; 0x27
    237a:	a2 01       	movw	r20, r4
    237c:	b4 01       	movw	r22, r8
    237e:	c3 01       	movw	r24, r6
    2380:	49 db       	rcall	.-2414   	; 0x1a14 <pxPortInitialiseStack>
    2382:	99 83       	std	Y+1, r25	; 0x01
    2384:	88 83       	st	Y, r24
    2386:	e1 14       	cp	r14, r1
    2388:	f1 04       	cpc	r15, r1
    238a:	19 f0       	breq	.+6      	; 0x2392 <xTaskCreate+0xde>
    238c:	f7 01       	movw	r30, r14
    238e:	d1 83       	std	Z+1, r29	; 0x01
    2390:	c0 83       	st	Z, r28
    2392:	0f b6       	in	r0, 0x3f	; 63
    2394:	f8 94       	cli
    2396:	0f 92       	push	r0
    2398:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    239c:	8f 5f       	subi	r24, 0xFF	; 255
    239e:	80 93 54 0d 	sts	0x0D54, r24	; 0x800d54 <uxCurrentNumberOfTasks>
    23a2:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    23a6:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    23aa:	89 2b       	or	r24, r25
    23ac:	89 f5       	brne	.+98     	; 0x2410 <xTaskCreate+0x15c>
    23ae:	d0 93 ac 0d 	sts	0x0DAC, r29	; 0x800dac <pxCurrentTCB+0x1>
    23b2:	c0 93 ab 0d 	sts	0x0DAB, r28	; 0x800dab <pxCurrentTCB>
    23b6:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    23ba:	81 30       	cpi	r24, 0x01	; 1
    23bc:	09 f0       	breq	.+2      	; 0x23c0 <xTaskCreate+0x10c>
    23be:	38 c0       	rjmp	.+112    	; 0x2430 <xTaskCreate+0x17c>
    23c0:	87 e8       	ldi	r24, 0x87	; 135
    23c2:	9d e0       	ldi	r25, 0x0D	; 13
    23c4:	9d da       	rcall	.-2758   	; 0x1900 <vListInitialise>
    23c6:	80 e9       	ldi	r24, 0x90	; 144
    23c8:	9d e0       	ldi	r25, 0x0D	; 13
    23ca:	9a da       	rcall	.-2764   	; 0x1900 <vListInitialise>
    23cc:	89 e9       	ldi	r24, 0x99	; 153
    23ce:	9d e0       	ldi	r25, 0x0D	; 13
    23d0:	97 da       	rcall	.-2770   	; 0x1900 <vListInitialise>
    23d2:	82 ea       	ldi	r24, 0xA2	; 162
    23d4:	9d e0       	ldi	r25, 0x0D	; 13
    23d6:	94 da       	rcall	.-2776   	; 0x1900 <vListInitialise>
    23d8:	8e e7       	ldi	r24, 0x7E	; 126
    23da:	9d e0       	ldi	r25, 0x0D	; 13
    23dc:	91 da       	rcall	.-2782   	; 0x1900 <vListInitialise>
    23de:	85 e7       	ldi	r24, 0x75	; 117
    23e0:	9d e0       	ldi	r25, 0x0D	; 13
    23e2:	8e da       	rcall	.-2788   	; 0x1900 <vListInitialise>
    23e4:	88 e6       	ldi	r24, 0x68	; 104
    23e6:	9d e0       	ldi	r25, 0x0D	; 13
    23e8:	8b da       	rcall	.-2794   	; 0x1900 <vListInitialise>
    23ea:	8f e5       	ldi	r24, 0x5F	; 95
    23ec:	9d e0       	ldi	r25, 0x0D	; 13
    23ee:	88 da       	rcall	.-2800   	; 0x1900 <vListInitialise>
    23f0:	85 e5       	ldi	r24, 0x55	; 85
    23f2:	9d e0       	ldi	r25, 0x0D	; 13
    23f4:	85 da       	rcall	.-2806   	; 0x1900 <vListInitialise>
    23f6:	8e e7       	ldi	r24, 0x7E	; 126
    23f8:	9d e0       	ldi	r25, 0x0D	; 13
    23fa:	90 93 74 0d 	sts	0x0D74, r25	; 0x800d74 <pxDelayedTaskList+0x1>
    23fe:	80 93 73 0d 	sts	0x0D73, r24	; 0x800d73 <pxDelayedTaskList>
    2402:	85 e7       	ldi	r24, 0x75	; 117
    2404:	9d e0       	ldi	r25, 0x0D	; 13
    2406:	90 93 72 0d 	sts	0x0D72, r25	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    240a:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <pxOverflowDelayedTaskList>
    240e:	10 c0       	rjmp	.+32     	; 0x2430 <xTaskCreate+0x17c>
    2410:	80 91 50 0d 	lds	r24, 0x0D50	; 0x800d50 <xSchedulerRunning>
    2414:	81 11       	cpse	r24, r1
    2416:	0c c0       	rjmp	.+24     	; 0x2430 <xTaskCreate+0x17c>
    2418:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    241c:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2420:	96 89       	ldd	r25, Z+22	; 0x16
    2422:	8e 89       	ldd	r24, Y+22	; 0x16
    2424:	89 17       	cp	r24, r25
    2426:	20 f0       	brcs	.+8      	; 0x2430 <xTaskCreate+0x17c>
    2428:	d0 93 ac 0d 	sts	0x0DAC, r29	; 0x800dac <pxCurrentTCB+0x1>
    242c:	c0 93 ab 0d 	sts	0x0DAB, r28	; 0x800dab <pxCurrentTCB>
    2430:	80 91 4c 0d 	lds	r24, 0x0D4C	; 0x800d4c <uxTaskNumber>
    2434:	8f 5f       	subi	r24, 0xFF	; 255
    2436:	80 93 4c 0d 	sts	0x0D4C, r24	; 0x800d4c <uxTaskNumber>
    243a:	8e 89       	ldd	r24, Y+22	; 0x16
    243c:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2440:	98 17       	cp	r25, r24
    2442:	10 f4       	brcc	.+4      	; 0x2448 <xTaskCreate+0x194>
    2444:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2448:	90 e0       	ldi	r25, 0x00	; 0
    244a:	9c 01       	movw	r18, r24
    244c:	22 0f       	add	r18, r18
    244e:	33 1f       	adc	r19, r19
    2450:	22 0f       	add	r18, r18
    2452:	33 1f       	adc	r19, r19
    2454:	22 0f       	add	r18, r18
    2456:	33 1f       	adc	r19, r19
    2458:	82 0f       	add	r24, r18
    245a:	93 1f       	adc	r25, r19
    245c:	b6 01       	movw	r22, r12
    245e:	89 57       	subi	r24, 0x79	; 121
    2460:	92 4f       	sbci	r25, 0xF2	; 242
    2462:	60 da       	rcall	.-2880   	; 0x1924 <vListInsertEnd>
    2464:	0f 90       	pop	r0
    2466:	0f be       	out	0x3f, r0	; 63
    2468:	80 91 50 0d 	lds	r24, 0x0D50	; 0x800d50 <xSchedulerRunning>
    246c:	88 23       	and	r24, r24
    246e:	59 f0       	breq	.+22     	; 0x2486 <xTaskCreate+0x1d2>
    2470:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2474:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2478:	96 89       	ldd	r25, Z+22	; 0x16
    247a:	8e 89       	ldd	r24, Y+22	; 0x16
    247c:	98 17       	cp	r25, r24
    247e:	28 f4       	brcc	.+10     	; 0x248a <xTaskCreate+0x1d6>
    2480:	6a db       	rcall	.-2348   	; 0x1b56 <vPortYield>
    2482:	81 e0       	ldi	r24, 0x01	; 1
    2484:	05 c0       	rjmp	.+10     	; 0x2490 <xTaskCreate+0x1dc>
    2486:	81 e0       	ldi	r24, 0x01	; 1
    2488:	03 c0       	rjmp	.+6      	; 0x2490 <xTaskCreate+0x1dc>
    248a:	81 e0       	ldi	r24, 0x01	; 1
    248c:	01 c0       	rjmp	.+2      	; 0x2490 <xTaskCreate+0x1dc>
    248e:	8f ef       	ldi	r24, 0xFF	; 255
    2490:	df 91       	pop	r29
    2492:	cf 91       	pop	r28
    2494:	0f 91       	pop	r16
    2496:	ff 90       	pop	r15
    2498:	ef 90       	pop	r14
    249a:	df 90       	pop	r13
    249c:	cf 90       	pop	r12
    249e:	bf 90       	pop	r11
    24a0:	af 90       	pop	r10
    24a2:	9f 90       	pop	r9
    24a4:	8f 90       	pop	r8
    24a6:	7f 90       	pop	r7
    24a8:	6f 90       	pop	r6
    24aa:	5f 90       	pop	r5
    24ac:	4f 90       	pop	r4
    24ae:	08 95       	ret

000024b0 <vTaskStartScheduler>:
    24b0:	ef 92       	push	r14
    24b2:	ff 92       	push	r15
    24b4:	0f 93       	push	r16
    24b6:	0f 2e       	mov	r0, r31
    24b8:	f8 e4       	ldi	r31, 0x48	; 72
    24ba:	ef 2e       	mov	r14, r31
    24bc:	fd e0       	ldi	r31, 0x0D	; 13
    24be:	ff 2e       	mov	r15, r31
    24c0:	f0 2d       	mov	r31, r0
    24c2:	00 e0       	ldi	r16, 0x00	; 0
    24c4:	20 e0       	ldi	r18, 0x00	; 0
    24c6:	30 e0       	ldi	r19, 0x00	; 0
    24c8:	45 e5       	ldi	r20, 0x55	; 85
    24ca:	50 e0       	ldi	r21, 0x00	; 0
    24cc:	6a e8       	ldi	r22, 0x8A	; 138
    24ce:	71 e0       	ldi	r23, 0x01	; 1
    24d0:	86 ec       	ldi	r24, 0xC6	; 198
    24d2:	93 e1       	ldi	r25, 0x13	; 19
    24d4:	ef de       	rcall	.-546    	; 0x22b4 <xTaskCreate>
    24d6:	81 30       	cpi	r24, 0x01	; 1
    24d8:	79 f4       	brne	.+30     	; 0x24f8 <vTaskStartScheduler+0x48>
    24da:	f8 94       	cli
    24dc:	8f ef       	ldi	r24, 0xFF	; 255
    24de:	9f ef       	ldi	r25, 0xFF	; 255
    24e0:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    24e4:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    24e8:	81 e0       	ldi	r24, 0x01	; 1
    24ea:	80 93 50 0d 	sts	0x0D50, r24	; 0x800d50 <xSchedulerRunning>
    24ee:	10 92 53 0d 	sts	0x0D53, r1	; 0x800d53 <xTickCount+0x1>
    24f2:	10 92 52 0d 	sts	0x0D52, r1	; 0x800d52 <xTickCount>
    24f6:	fa da       	rcall	.-2572   	; 0x1aec <xPortStartScheduler>
    24f8:	0f 91       	pop	r16
    24fa:	ff 90       	pop	r15
    24fc:	ef 90       	pop	r14
    24fe:	08 95       	ret

00002500 <vTaskSuspendAll>:
    2500:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2504:	8f 5f       	subi	r24, 0xFF	; 255
    2506:	80 93 47 0d 	sts	0x0D47, r24	; 0x800d47 <uxSchedulerSuspended>
    250a:	08 95       	ret

0000250c <xTaskIncrementTick>:
    250c:	cf 92       	push	r12
    250e:	df 92       	push	r13
    2510:	ef 92       	push	r14
    2512:	ff 92       	push	r15
    2514:	0f 93       	push	r16
    2516:	1f 93       	push	r17
    2518:	cf 93       	push	r28
    251a:	df 93       	push	r29
    251c:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2520:	81 11       	cpse	r24, r1
    2522:	95 c0       	rjmp	.+298    	; 0x264e <xTaskIncrementTick+0x142>
    2524:	e0 90 52 0d 	lds	r14, 0x0D52	; 0x800d52 <xTickCount>
    2528:	f0 90 53 0d 	lds	r15, 0x0D53	; 0x800d53 <xTickCount+0x1>
    252c:	8f ef       	ldi	r24, 0xFF	; 255
    252e:	e8 1a       	sub	r14, r24
    2530:	f8 0a       	sbc	r15, r24
    2532:	f0 92 53 0d 	sts	0x0D53, r15	; 0x800d53 <xTickCount+0x1>
    2536:	e0 92 52 0d 	sts	0x0D52, r14	; 0x800d52 <xTickCount>
    253a:	e1 14       	cp	r14, r1
    253c:	f1 04       	cpc	r15, r1
    253e:	b1 f4       	brne	.+44     	; 0x256c <xTaskIncrementTick+0x60>
    2540:	80 91 73 0d 	lds	r24, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    2544:	90 91 74 0d 	lds	r25, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    2548:	20 91 71 0d 	lds	r18, 0x0D71	; 0x800d71 <pxOverflowDelayedTaskList>
    254c:	30 91 72 0d 	lds	r19, 0x0D72	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    2550:	30 93 74 0d 	sts	0x0D74, r19	; 0x800d74 <pxDelayedTaskList+0x1>
    2554:	20 93 73 0d 	sts	0x0D73, r18	; 0x800d73 <pxDelayedTaskList>
    2558:	90 93 72 0d 	sts	0x0D72, r25	; 0x800d72 <pxOverflowDelayedTaskList+0x1>
    255c:	80 93 71 0d 	sts	0x0D71, r24	; 0x800d71 <pxOverflowDelayedTaskList>
    2560:	80 91 4d 0d 	lds	r24, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    2564:	8f 5f       	subi	r24, 0xFF	; 255
    2566:	80 93 4d 0d 	sts	0x0D4D, r24	; 0x800d4d <xNumOfOverflows>
    256a:	31 de       	rcall	.-926    	; 0x21ce <prvResetNextTaskUnblockTime>
    256c:	80 91 4a 0d 	lds	r24, 0x0D4A	; 0x800d4a <xNextTaskUnblockTime>
    2570:	90 91 4b 0d 	lds	r25, 0x0D4B	; 0x800d4b <xNextTaskUnblockTime+0x1>
    2574:	e8 16       	cp	r14, r24
    2576:	f9 06       	cpc	r15, r25
    2578:	10 f4       	brcc	.+4      	; 0x257e <xTaskIncrementTick+0x72>
    257a:	d1 2c       	mov	r13, r1
    257c:	50 c0       	rjmp	.+160    	; 0x261e <xTaskIncrementTick+0x112>
    257e:	d1 2c       	mov	r13, r1
    2580:	cc 24       	eor	r12, r12
    2582:	c3 94       	inc	r12
    2584:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    2588:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    258c:	80 81       	ld	r24, Z
    258e:	81 11       	cpse	r24, r1
    2590:	07 c0       	rjmp	.+14     	; 0x25a0 <xTaskIncrementTick+0x94>
    2592:	8f ef       	ldi	r24, 0xFF	; 255
    2594:	9f ef       	ldi	r25, 0xFF	; 255
    2596:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    259a:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    259e:	3f c0       	rjmp	.+126    	; 0x261e <xTaskIncrementTick+0x112>
    25a0:	e0 91 73 0d 	lds	r30, 0x0D73	; 0x800d73 <pxDelayedTaskList>
    25a4:	f0 91 74 0d 	lds	r31, 0x0D74	; 0x800d74 <pxDelayedTaskList+0x1>
    25a8:	05 80       	ldd	r0, Z+5	; 0x05
    25aa:	f6 81       	ldd	r31, Z+6	; 0x06
    25ac:	e0 2d       	mov	r30, r0
    25ae:	c6 81       	ldd	r28, Z+6	; 0x06
    25b0:	d7 81       	ldd	r29, Z+7	; 0x07
    25b2:	8a 81       	ldd	r24, Y+2	; 0x02
    25b4:	9b 81       	ldd	r25, Y+3	; 0x03
    25b6:	e8 16       	cp	r14, r24
    25b8:	f9 06       	cpc	r15, r25
    25ba:	28 f4       	brcc	.+10     	; 0x25c6 <xTaskIncrementTick+0xba>
    25bc:	90 93 4b 0d 	sts	0x0D4B, r25	; 0x800d4b <xNextTaskUnblockTime+0x1>
    25c0:	80 93 4a 0d 	sts	0x0D4A, r24	; 0x800d4a <xNextTaskUnblockTime>
    25c4:	2c c0       	rjmp	.+88     	; 0x261e <xTaskIncrementTick+0x112>
    25c6:	8e 01       	movw	r16, r28
    25c8:	0e 5f       	subi	r16, 0xFE	; 254
    25ca:	1f 4f       	sbci	r17, 0xFF	; 255
    25cc:	c8 01       	movw	r24, r16
    25ce:	fc d9       	rcall	.-3080   	; 0x19c8 <uxListRemove>
    25d0:	8c 89       	ldd	r24, Y+20	; 0x14
    25d2:	9d 89       	ldd	r25, Y+21	; 0x15
    25d4:	89 2b       	or	r24, r25
    25d6:	19 f0       	breq	.+6      	; 0x25de <xTaskIncrementTick+0xd2>
    25d8:	ce 01       	movw	r24, r28
    25da:	0c 96       	adiw	r24, 0x0c	; 12
    25dc:	f5 d9       	rcall	.-3094   	; 0x19c8 <uxListRemove>
    25de:	8e 89       	ldd	r24, Y+22	; 0x16
    25e0:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    25e4:	98 17       	cp	r25, r24
    25e6:	10 f4       	brcc	.+4      	; 0x25ec <xTaskIncrementTick+0xe0>
    25e8:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    25ec:	90 e0       	ldi	r25, 0x00	; 0
    25ee:	9c 01       	movw	r18, r24
    25f0:	22 0f       	add	r18, r18
    25f2:	33 1f       	adc	r19, r19
    25f4:	22 0f       	add	r18, r18
    25f6:	33 1f       	adc	r19, r19
    25f8:	22 0f       	add	r18, r18
    25fa:	33 1f       	adc	r19, r19
    25fc:	82 0f       	add	r24, r18
    25fe:	93 1f       	adc	r25, r19
    2600:	b8 01       	movw	r22, r16
    2602:	89 57       	subi	r24, 0x79	; 121
    2604:	92 4f       	sbci	r25, 0xF2	; 242
    2606:	8e d9       	rcall	.-3300   	; 0x1924 <vListInsertEnd>
    2608:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    260c:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2610:	9e 89       	ldd	r25, Y+22	; 0x16
    2612:	86 89       	ldd	r24, Z+22	; 0x16
    2614:	98 17       	cp	r25, r24
    2616:	08 f4       	brcc	.+2      	; 0x261a <xTaskIncrementTick+0x10e>
    2618:	b5 cf       	rjmp	.-150    	; 0x2584 <xTaskIncrementTick+0x78>
    261a:	dc 2c       	mov	r13, r12
    261c:	b3 cf       	rjmp	.-154    	; 0x2584 <xTaskIncrementTick+0x78>
    261e:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2622:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2626:	86 89       	ldd	r24, Z+22	; 0x16
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	fc 01       	movw	r30, r24
    262c:	ee 0f       	add	r30, r30
    262e:	ff 1f       	adc	r31, r31
    2630:	ee 0f       	add	r30, r30
    2632:	ff 1f       	adc	r31, r31
    2634:	ee 0f       	add	r30, r30
    2636:	ff 1f       	adc	r31, r31
    2638:	8e 0f       	add	r24, r30
    263a:	9f 1f       	adc	r25, r31
    263c:	fc 01       	movw	r30, r24
    263e:	e9 57       	subi	r30, 0x79	; 121
    2640:	f2 4f       	sbci	r31, 0xF2	; 242
    2642:	80 81       	ld	r24, Z
    2644:	82 30       	cpi	r24, 0x02	; 2
    2646:	48 f0       	brcs	.+18     	; 0x265a <xTaskIncrementTick+0x14e>
    2648:	dd 24       	eor	r13, r13
    264a:	d3 94       	inc	r13
    264c:	06 c0       	rjmp	.+12     	; 0x265a <xTaskIncrementTick+0x14e>
    264e:	80 91 4f 0d 	lds	r24, 0x0D4F	; 0x800d4f <uxPendedTicks>
    2652:	8f 5f       	subi	r24, 0xFF	; 255
    2654:	80 93 4f 0d 	sts	0x0D4F, r24	; 0x800d4f <uxPendedTicks>
    2658:	d1 2c       	mov	r13, r1
    265a:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <xYieldPending>
    265e:	88 23       	and	r24, r24
    2660:	11 f0       	breq	.+4      	; 0x2666 <xTaskIncrementTick+0x15a>
    2662:	dd 24       	eor	r13, r13
    2664:	d3 94       	inc	r13
    2666:	8d 2d       	mov	r24, r13
    2668:	df 91       	pop	r29
    266a:	cf 91       	pop	r28
    266c:	1f 91       	pop	r17
    266e:	0f 91       	pop	r16
    2670:	ff 90       	pop	r15
    2672:	ef 90       	pop	r14
    2674:	df 90       	pop	r13
    2676:	cf 90       	pop	r12
    2678:	08 95       	ret

0000267a <xTaskResumeAll>:
    267a:	df 92       	push	r13
    267c:	ef 92       	push	r14
    267e:	ff 92       	push	r15
    2680:	0f 93       	push	r16
    2682:	1f 93       	push	r17
    2684:	cf 93       	push	r28
    2686:	df 93       	push	r29
    2688:	0f b6       	in	r0, 0x3f	; 63
    268a:	f8 94       	cli
    268c:	0f 92       	push	r0
    268e:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    2692:	81 50       	subi	r24, 0x01	; 1
    2694:	80 93 47 0d 	sts	0x0D47, r24	; 0x800d47 <uxSchedulerSuspended>
    2698:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    269c:	81 11       	cpse	r24, r1
    269e:	59 c0       	rjmp	.+178    	; 0x2752 <xTaskResumeAll+0xd8>
    26a0:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    26a4:	81 11       	cpse	r24, r1
    26a6:	30 c0       	rjmp	.+96     	; 0x2708 <xTaskResumeAll+0x8e>
    26a8:	57 c0       	rjmp	.+174    	; 0x2758 <xTaskResumeAll+0xde>
    26aa:	d7 01       	movw	r26, r14
    26ac:	15 96       	adiw	r26, 0x05	; 5
    26ae:	ed 91       	ld	r30, X+
    26b0:	fc 91       	ld	r31, X
    26b2:	16 97       	sbiw	r26, 0x06	; 6
    26b4:	c6 81       	ldd	r28, Z+6	; 0x06
    26b6:	d7 81       	ldd	r29, Z+7	; 0x07
    26b8:	ce 01       	movw	r24, r28
    26ba:	0c 96       	adiw	r24, 0x0c	; 12
    26bc:	85 d9       	rcall	.-3318   	; 0x19c8 <uxListRemove>
    26be:	8e 01       	movw	r16, r28
    26c0:	0e 5f       	subi	r16, 0xFE	; 254
    26c2:	1f 4f       	sbci	r17, 0xFF	; 255
    26c4:	c8 01       	movw	r24, r16
    26c6:	80 d9       	rcall	.-3328   	; 0x19c8 <uxListRemove>
    26c8:	8e 89       	ldd	r24, Y+22	; 0x16
    26ca:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    26ce:	98 17       	cp	r25, r24
    26d0:	10 f4       	brcc	.+4      	; 0x26d6 <xTaskResumeAll+0x5c>
    26d2:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	9c 01       	movw	r18, r24
    26da:	22 0f       	add	r18, r18
    26dc:	33 1f       	adc	r19, r19
    26de:	22 0f       	add	r18, r18
    26e0:	33 1f       	adc	r19, r19
    26e2:	22 0f       	add	r18, r18
    26e4:	33 1f       	adc	r19, r19
    26e6:	82 0f       	add	r24, r18
    26e8:	93 1f       	adc	r25, r19
    26ea:	b8 01       	movw	r22, r16
    26ec:	89 57       	subi	r24, 0x79	; 121
    26ee:	92 4f       	sbci	r25, 0xF2	; 242
    26f0:	19 d9       	rcall	.-3534   	; 0x1924 <vListInsertEnd>
    26f2:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    26f6:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    26fa:	9e 89       	ldd	r25, Y+22	; 0x16
    26fc:	86 89       	ldd	r24, Z+22	; 0x16
    26fe:	98 17       	cp	r25, r24
    2700:	68 f0       	brcs	.+26     	; 0x271c <xTaskResumeAll+0xa2>
    2702:	d0 92 4e 0d 	sts	0x0D4E, r13	; 0x800d4e <xYieldPending>
    2706:	0a c0       	rjmp	.+20     	; 0x271c <xTaskResumeAll+0xa2>
    2708:	c0 e0       	ldi	r28, 0x00	; 0
    270a:	d0 e0       	ldi	r29, 0x00	; 0
    270c:	0f 2e       	mov	r0, r31
    270e:	f8 e6       	ldi	r31, 0x68	; 104
    2710:	ef 2e       	mov	r14, r31
    2712:	fd e0       	ldi	r31, 0x0D	; 13
    2714:	ff 2e       	mov	r15, r31
    2716:	f0 2d       	mov	r31, r0
    2718:	dd 24       	eor	r13, r13
    271a:	d3 94       	inc	r13
    271c:	f7 01       	movw	r30, r14
    271e:	80 81       	ld	r24, Z
    2720:	81 11       	cpse	r24, r1
    2722:	c3 cf       	rjmp	.-122    	; 0x26aa <xTaskResumeAll+0x30>
    2724:	cd 2b       	or	r28, r29
    2726:	09 f0       	breq	.+2      	; 0x272a <xTaskResumeAll+0xb0>
    2728:	52 dd       	rcall	.-1372   	; 0x21ce <prvResetNextTaskUnblockTime>
    272a:	c0 91 4f 0d 	lds	r28, 0x0D4F	; 0x800d4f <uxPendedTicks>
    272e:	cc 23       	and	r28, r28
    2730:	49 f0       	breq	.+18     	; 0x2744 <xTaskResumeAll+0xca>
    2732:	d1 e0       	ldi	r29, 0x01	; 1
    2734:	eb de       	rcall	.-554    	; 0x250c <xTaskIncrementTick>
    2736:	81 11       	cpse	r24, r1
    2738:	d0 93 4e 0d 	sts	0x0D4E, r29	; 0x800d4e <xYieldPending>
    273c:	c1 50       	subi	r28, 0x01	; 1
    273e:	d1 f7       	brne	.-12     	; 0x2734 <xTaskResumeAll+0xba>
    2740:	10 92 4f 0d 	sts	0x0D4F, r1	; 0x800d4f <uxPendedTicks>
    2744:	80 91 4e 0d 	lds	r24, 0x0D4E	; 0x800d4e <xYieldPending>
    2748:	88 23       	and	r24, r24
    274a:	29 f0       	breq	.+10     	; 0x2756 <xTaskResumeAll+0xdc>
    274c:	04 da       	rcall	.-3064   	; 0x1b56 <vPortYield>
    274e:	81 e0       	ldi	r24, 0x01	; 1
    2750:	03 c0       	rjmp	.+6      	; 0x2758 <xTaskResumeAll+0xde>
    2752:	80 e0       	ldi	r24, 0x00	; 0
    2754:	01 c0       	rjmp	.+2      	; 0x2758 <xTaskResumeAll+0xde>
    2756:	80 e0       	ldi	r24, 0x00	; 0
    2758:	0f 90       	pop	r0
    275a:	0f be       	out	0x3f, r0	; 63
    275c:	df 91       	pop	r29
    275e:	cf 91       	pop	r28
    2760:	1f 91       	pop	r17
    2762:	0f 91       	pop	r16
    2764:	ff 90       	pop	r15
    2766:	ef 90       	pop	r14
    2768:	df 90       	pop	r13
    276a:	08 95       	ret

0000276c <vTaskDelay>:
    276c:	cf 93       	push	r28
    276e:	df 93       	push	r29
    2770:	ec 01       	movw	r28, r24
    2772:	89 2b       	or	r24, r25
    2774:	39 f0       	breq	.+14     	; 0x2784 <vTaskDelay+0x18>
    2776:	c4 de       	rcall	.-632    	; 0x2500 <vTaskSuspendAll>
    2778:	60 e0       	ldi	r22, 0x00	; 0
    277a:	ce 01       	movw	r24, r28
    277c:	47 dd       	rcall	.-1394   	; 0x220c <prvAddCurrentTaskToDelayedList>
    277e:	7d df       	rcall	.-262    	; 0x267a <xTaskResumeAll>
    2780:	81 11       	cpse	r24, r1
    2782:	01 c0       	rjmp	.+2      	; 0x2786 <vTaskDelay+0x1a>
    2784:	e8 d9       	rcall	.-3120   	; 0x1b56 <vPortYield>
    2786:	df 91       	pop	r29
    2788:	cf 91       	pop	r28
    278a:	08 95       	ret

0000278c <prvIdleTask>:
    278c:	0f e5       	ldi	r16, 0x5F	; 95
    278e:	1d e0       	ldi	r17, 0x0D	; 13
    2790:	0f 2e       	mov	r0, r31
    2792:	f7 e8       	ldi	r31, 0x87	; 135
    2794:	ef 2e       	mov	r14, r31
    2796:	fd e0       	ldi	r31, 0x0D	; 13
    2798:	ff 2e       	mov	r15, r31
    279a:	f0 2d       	mov	r31, r0
    279c:	24 c0       	rjmp	.+72     	; 0x27e6 <prvIdleTask+0x5a>
    279e:	b0 de       	rcall	.-672    	; 0x2500 <vTaskSuspendAll>
    27a0:	d8 01       	movw	r26, r16
    27a2:	cc 91       	ld	r28, X
    27a4:	6a df       	rcall	.-300    	; 0x267a <xTaskResumeAll>
    27a6:	cc 23       	and	r28, r28
    27a8:	f1 f0       	breq	.+60     	; 0x27e6 <prvIdleTask+0x5a>
    27aa:	0f b6       	in	r0, 0x3f	; 63
    27ac:	f8 94       	cli
    27ae:	0f 92       	push	r0
    27b0:	d8 01       	movw	r26, r16
    27b2:	15 96       	adiw	r26, 0x05	; 5
    27b4:	ed 91       	ld	r30, X+
    27b6:	fc 91       	ld	r31, X
    27b8:	16 97       	sbiw	r26, 0x06	; 6
    27ba:	c6 81       	ldd	r28, Z+6	; 0x06
    27bc:	d7 81       	ldd	r29, Z+7	; 0x07
    27be:	ce 01       	movw	r24, r28
    27c0:	02 96       	adiw	r24, 0x02	; 2
    27c2:	02 d9       	rcall	.-3580   	; 0x19c8 <uxListRemove>
    27c4:	80 91 54 0d 	lds	r24, 0x0D54	; 0x800d54 <uxCurrentNumberOfTasks>
    27c8:	81 50       	subi	r24, 0x01	; 1
    27ca:	80 93 54 0d 	sts	0x0D54, r24	; 0x800d54 <uxCurrentNumberOfTasks>
    27ce:	80 91 5e 0d 	lds	r24, 0x0D5E	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    27d2:	81 50       	subi	r24, 0x01	; 1
    27d4:	80 93 5e 0d 	sts	0x0D5E, r24	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    27d8:	0f 90       	pop	r0
    27da:	0f be       	out	0x3f, r0	; 63
    27dc:	8f 89       	ldd	r24, Y+23	; 0x17
    27de:	98 8d       	ldd	r25, Y+24	; 0x18
    27e0:	8e d8       	rcall	.-3812   	; 0x18fe <vPortFree>
    27e2:	ce 01       	movw	r24, r28
    27e4:	8c d8       	rcall	.-3816   	; 0x18fe <vPortFree>
    27e6:	80 91 5e 0d 	lds	r24, 0x0D5E	; 0x800d5e <uxDeletedTasksWaitingCleanUp>
    27ea:	81 11       	cpse	r24, r1
    27ec:	d8 cf       	rjmp	.-80     	; 0x279e <prvIdleTask+0x12>
    27ee:	f7 01       	movw	r30, r14
    27f0:	80 81       	ld	r24, Z
    27f2:	82 30       	cpi	r24, 0x02	; 2
    27f4:	c0 f3       	brcs	.-16     	; 0x27e6 <prvIdleTask+0x5a>
    27f6:	af d9       	rcall	.-3234   	; 0x1b56 <vPortYield>
    27f8:	f6 cf       	rjmp	.-20     	; 0x27e6 <prvIdleTask+0x5a>

000027fa <vTaskSwitchContext>:
    27fa:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    27fe:	88 23       	and	r24, r24
    2800:	21 f0       	breq	.+8      	; 0x280a <vTaskSwitchContext+0x10>
    2802:	81 e0       	ldi	r24, 0x01	; 1
    2804:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    2808:	08 95       	ret
    280a:	10 92 4e 0d 	sts	0x0D4E, r1	; 0x800d4e <xYieldPending>
    280e:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2812:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2816:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    281a:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    281e:	2d 91       	ld	r18, X+
    2820:	3c 91       	ld	r19, X
    2822:	87 89       	ldd	r24, Z+23	; 0x17
    2824:	90 8d       	ldd	r25, Z+24	; 0x18
    2826:	82 17       	cp	r24, r18
    2828:	93 07       	cpc	r25, r19
    282a:	58 f0       	brcs	.+22     	; 0x2842 <vTaskSwitchContext+0x48>
    282c:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2830:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2834:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2838:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    283c:	67 5e       	subi	r22, 0xE7	; 231
    283e:	7f 4f       	sbci	r23, 0xFF	; 255
    2840:	2a d8       	rcall	.-4012   	; 0x1896 <vApplicationStackOverflowHook>
    2842:	20 91 51 0d 	lds	r18, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2846:	82 2f       	mov	r24, r18
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	fc 01       	movw	r30, r24
    284c:	ee 0f       	add	r30, r30
    284e:	ff 1f       	adc	r31, r31
    2850:	ee 0f       	add	r30, r30
    2852:	ff 1f       	adc	r31, r31
    2854:	ee 0f       	add	r30, r30
    2856:	ff 1f       	adc	r31, r31
    2858:	e8 0f       	add	r30, r24
    285a:	f9 1f       	adc	r31, r25
    285c:	e9 57       	subi	r30, 0x79	; 121
    285e:	f2 4f       	sbci	r31, 0xF2	; 242
    2860:	30 81       	ld	r19, Z
    2862:	31 11       	cpse	r19, r1
    2864:	11 c0       	rjmp	.+34     	; 0x2888 <vTaskSwitchContext+0x8e>
    2866:	21 50       	subi	r18, 0x01	; 1
    2868:	82 2f       	mov	r24, r18
    286a:	90 e0       	ldi	r25, 0x00	; 0
    286c:	fc 01       	movw	r30, r24
    286e:	ee 0f       	add	r30, r30
    2870:	ff 1f       	adc	r31, r31
    2872:	ee 0f       	add	r30, r30
    2874:	ff 1f       	adc	r31, r31
    2876:	ee 0f       	add	r30, r30
    2878:	ff 1f       	adc	r31, r31
    287a:	e8 0f       	add	r30, r24
    287c:	f9 1f       	adc	r31, r25
    287e:	e9 57       	subi	r30, 0x79	; 121
    2880:	f2 4f       	sbci	r31, 0xF2	; 242
    2882:	30 81       	ld	r19, Z
    2884:	33 23       	and	r19, r19
    2886:	79 f3       	breq	.-34     	; 0x2866 <vTaskSwitchContext+0x6c>
    2888:	ac 01       	movw	r20, r24
    288a:	44 0f       	add	r20, r20
    288c:	55 1f       	adc	r21, r21
    288e:	44 0f       	add	r20, r20
    2890:	55 1f       	adc	r21, r21
    2892:	44 0f       	add	r20, r20
    2894:	55 1f       	adc	r21, r21
    2896:	48 0f       	add	r20, r24
    2898:	59 1f       	adc	r21, r25
    289a:	da 01       	movw	r26, r20
    289c:	a9 57       	subi	r26, 0x79	; 121
    289e:	b2 4f       	sbci	r27, 0xF2	; 242
    28a0:	11 96       	adiw	r26, 0x01	; 1
    28a2:	ed 91       	ld	r30, X+
    28a4:	fc 91       	ld	r31, X
    28a6:	12 97       	sbiw	r26, 0x02	; 2
    28a8:	02 80       	ldd	r0, Z+2	; 0x02
    28aa:	f3 81       	ldd	r31, Z+3	; 0x03
    28ac:	e0 2d       	mov	r30, r0
    28ae:	12 96       	adiw	r26, 0x02	; 2
    28b0:	fc 93       	st	X, r31
    28b2:	ee 93       	st	-X, r30
    28b4:	11 97       	sbiw	r26, 0x01	; 1
    28b6:	46 57       	subi	r20, 0x76	; 118
    28b8:	52 4f       	sbci	r21, 0xF2	; 242
    28ba:	e4 17       	cp	r30, r20
    28bc:	f5 07       	cpc	r31, r21
    28be:	29 f4       	brne	.+10     	; 0x28ca <vTaskSwitchContext+0xd0>
    28c0:	42 81       	ldd	r20, Z+2	; 0x02
    28c2:	53 81       	ldd	r21, Z+3	; 0x03
    28c4:	fd 01       	movw	r30, r26
    28c6:	52 83       	std	Z+2, r21	; 0x02
    28c8:	41 83       	std	Z+1, r20	; 0x01
    28ca:	fc 01       	movw	r30, r24
    28cc:	ee 0f       	add	r30, r30
    28ce:	ff 1f       	adc	r31, r31
    28d0:	ee 0f       	add	r30, r30
    28d2:	ff 1f       	adc	r31, r31
    28d4:	ee 0f       	add	r30, r30
    28d6:	ff 1f       	adc	r31, r31
    28d8:	8e 0f       	add	r24, r30
    28da:	9f 1f       	adc	r25, r31
    28dc:	fc 01       	movw	r30, r24
    28de:	e9 57       	subi	r30, 0x79	; 121
    28e0:	f2 4f       	sbci	r31, 0xF2	; 242
    28e2:	01 80       	ldd	r0, Z+1	; 0x01
    28e4:	f2 81       	ldd	r31, Z+2	; 0x02
    28e6:	e0 2d       	mov	r30, r0
    28e8:	86 81       	ldd	r24, Z+6	; 0x06
    28ea:	97 81       	ldd	r25, Z+7	; 0x07
    28ec:	90 93 ac 0d 	sts	0x0DAC, r25	; 0x800dac <pxCurrentTCB+0x1>
    28f0:	80 93 ab 0d 	sts	0x0DAB, r24	; 0x800dab <pxCurrentTCB>
    28f4:	20 93 51 0d 	sts	0x0D51, r18	; 0x800d51 <uxTopReadyPriority>
    28f8:	08 95       	ret

000028fa <vTaskPlaceOnEventList>:
    28fa:	cf 93       	push	r28
    28fc:	df 93       	push	r29
    28fe:	eb 01       	movw	r28, r22
    2900:	60 91 ab 0d 	lds	r22, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2904:	70 91 ac 0d 	lds	r23, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2908:	64 5f       	subi	r22, 0xF4	; 244
    290a:	7f 4f       	sbci	r23, 0xFF	; 255
    290c:	2c d8       	rcall	.-4008   	; 0x1966 <vListInsert>
    290e:	61 e0       	ldi	r22, 0x01	; 1
    2910:	ce 01       	movw	r24, r28
    2912:	7c dc       	rcall	.-1800   	; 0x220c <prvAddCurrentTaskToDelayedList>
    2914:	df 91       	pop	r29
    2916:	cf 91       	pop	r28
    2918:	08 95       	ret

0000291a <xTaskRemoveFromEventList>:
    291a:	0f 93       	push	r16
    291c:	1f 93       	push	r17
    291e:	cf 93       	push	r28
    2920:	df 93       	push	r29
    2922:	dc 01       	movw	r26, r24
    2924:	15 96       	adiw	r26, 0x05	; 5
    2926:	ed 91       	ld	r30, X+
    2928:	fc 91       	ld	r31, X
    292a:	16 97       	sbiw	r26, 0x06	; 6
    292c:	c6 81       	ldd	r28, Z+6	; 0x06
    292e:	d7 81       	ldd	r29, Z+7	; 0x07
    2930:	8e 01       	movw	r16, r28
    2932:	04 5f       	subi	r16, 0xF4	; 244
    2934:	1f 4f       	sbci	r17, 0xFF	; 255
    2936:	c8 01       	movw	r24, r16
    2938:	47 d8       	rcall	.-3954   	; 0x19c8 <uxListRemove>
    293a:	80 91 47 0d 	lds	r24, 0x0D47	; 0x800d47 <uxSchedulerSuspended>
    293e:	81 11       	cpse	r24, r1
    2940:	1b c0       	rjmp	.+54     	; 0x2978 <xTaskRemoveFromEventList+0x5e>
    2942:	0a 50       	subi	r16, 0x0A	; 10
    2944:	11 09       	sbc	r17, r1
    2946:	c8 01       	movw	r24, r16
    2948:	3f d8       	rcall	.-3970   	; 0x19c8 <uxListRemove>
    294a:	8e 89       	ldd	r24, Y+22	; 0x16
    294c:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2950:	98 17       	cp	r25, r24
    2952:	10 f4       	brcc	.+4      	; 0x2958 <xTaskRemoveFromEventList+0x3e>
    2954:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2958:	90 e0       	ldi	r25, 0x00	; 0
    295a:	9c 01       	movw	r18, r24
    295c:	22 0f       	add	r18, r18
    295e:	33 1f       	adc	r19, r19
    2960:	22 0f       	add	r18, r18
    2962:	33 1f       	adc	r19, r19
    2964:	22 0f       	add	r18, r18
    2966:	33 1f       	adc	r19, r19
    2968:	82 0f       	add	r24, r18
    296a:	93 1f       	adc	r25, r19
    296c:	b8 01       	movw	r22, r16
    296e:	89 57       	subi	r24, 0x79	; 121
    2970:	92 4f       	sbci	r25, 0xF2	; 242
    2972:	0e 94 92 0c 	call	0x1924	; 0x1924 <vListInsertEnd>
    2976:	05 c0       	rjmp	.+10     	; 0x2982 <xTaskRemoveFromEventList+0x68>
    2978:	b8 01       	movw	r22, r16
    297a:	88 e6       	ldi	r24, 0x68	; 104
    297c:	9d e0       	ldi	r25, 0x0D	; 13
    297e:	0e 94 92 0c 	call	0x1924	; 0x1924 <vListInsertEnd>
    2982:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2986:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    298a:	9e 89       	ldd	r25, Y+22	; 0x16
    298c:	86 89       	ldd	r24, Z+22	; 0x16
    298e:	89 17       	cp	r24, r25
    2990:	20 f4       	brcc	.+8      	; 0x299a <xTaskRemoveFromEventList+0x80>
    2992:	81 e0       	ldi	r24, 0x01	; 1
    2994:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    2998:	01 c0       	rjmp	.+2      	; 0x299c <xTaskRemoveFromEventList+0x82>
    299a:	80 e0       	ldi	r24, 0x00	; 0
    299c:	df 91       	pop	r29
    299e:	cf 91       	pop	r28
    29a0:	1f 91       	pop	r17
    29a2:	0f 91       	pop	r16
    29a4:	08 95       	ret

000029a6 <vTaskSetTimeOutState>:
    29a6:	20 91 4d 0d 	lds	r18, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    29aa:	fc 01       	movw	r30, r24
    29ac:	20 83       	st	Z, r18
    29ae:	20 91 52 0d 	lds	r18, 0x0D52	; 0x800d52 <xTickCount>
    29b2:	30 91 53 0d 	lds	r19, 0x0D53	; 0x800d53 <xTickCount+0x1>
    29b6:	32 83       	std	Z+2, r19	; 0x02
    29b8:	21 83       	std	Z+1, r18	; 0x01
    29ba:	08 95       	ret

000029bc <xTaskCheckForTimeOut>:
    29bc:	0f b6       	in	r0, 0x3f	; 63
    29be:	f8 94       	cli
    29c0:	0f 92       	push	r0
    29c2:	40 91 52 0d 	lds	r20, 0x0D52	; 0x800d52 <xTickCount>
    29c6:	50 91 53 0d 	lds	r21, 0x0D53	; 0x800d53 <xTickCount+0x1>
    29ca:	db 01       	movw	r26, r22
    29cc:	2d 91       	ld	r18, X+
    29ce:	3c 91       	ld	r19, X
    29d0:	2f 3f       	cpi	r18, 0xFF	; 255
    29d2:	bf ef       	ldi	r27, 0xFF	; 255
    29d4:	3b 07       	cpc	r19, r27
    29d6:	11 f1       	breq	.+68     	; 0x2a1c <xTaskCheckForTimeOut+0x60>
    29d8:	e0 91 4d 0d 	lds	r30, 0x0D4D	; 0x800d4d <xNumOfOverflows>
    29dc:	dc 01       	movw	r26, r24
    29de:	fc 91       	ld	r31, X
    29e0:	fe 17       	cp	r31, r30
    29e2:	39 f0       	breq	.+14     	; 0x29f2 <xTaskCheckForTimeOut+0x36>
    29e4:	11 96       	adiw	r26, 0x01	; 1
    29e6:	ed 91       	ld	r30, X+
    29e8:	fc 91       	ld	r31, X
    29ea:	12 97       	sbiw	r26, 0x02	; 2
    29ec:	4e 17       	cp	r20, r30
    29ee:	5f 07       	cpc	r21, r31
    29f0:	b8 f4       	brcc	.+46     	; 0x2a20 <xTaskCheckForTimeOut+0x64>
    29f2:	dc 01       	movw	r26, r24
    29f4:	11 96       	adiw	r26, 0x01	; 1
    29f6:	ed 91       	ld	r30, X+
    29f8:	fc 91       	ld	r31, X
    29fa:	12 97       	sbiw	r26, 0x02	; 2
    29fc:	da 01       	movw	r26, r20
    29fe:	ae 1b       	sub	r26, r30
    2a00:	bf 0b       	sbc	r27, r31
    2a02:	a2 17       	cp	r26, r18
    2a04:	b3 07       	cpc	r27, r19
    2a06:	70 f4       	brcc	.+28     	; 0x2a24 <xTaskCheckForTimeOut+0x68>
    2a08:	db 01       	movw	r26, r22
    2a0a:	e4 1b       	sub	r30, r20
    2a0c:	f5 0b       	sbc	r31, r21
    2a0e:	2e 0f       	add	r18, r30
    2a10:	3f 1f       	adc	r19, r31
    2a12:	2d 93       	st	X+, r18
    2a14:	3c 93       	st	X, r19
    2a16:	c7 df       	rcall	.-114    	; 0x29a6 <vTaskSetTimeOutState>
    2a18:	80 e0       	ldi	r24, 0x00	; 0
    2a1a:	05 c0       	rjmp	.+10     	; 0x2a26 <xTaskCheckForTimeOut+0x6a>
    2a1c:	80 e0       	ldi	r24, 0x00	; 0
    2a1e:	03 c0       	rjmp	.+6      	; 0x2a26 <xTaskCheckForTimeOut+0x6a>
    2a20:	81 e0       	ldi	r24, 0x01	; 1
    2a22:	01 c0       	rjmp	.+2      	; 0x2a26 <xTaskCheckForTimeOut+0x6a>
    2a24:	81 e0       	ldi	r24, 0x01	; 1
    2a26:	0f 90       	pop	r0
    2a28:	0f be       	out	0x3f, r0	; 63
    2a2a:	08 95       	ret

00002a2c <vTaskMissedYield>:
    2a2c:	81 e0       	ldi	r24, 0x01	; 1
    2a2e:	80 93 4e 0d 	sts	0x0D4E, r24	; 0x800d4e <xYieldPending>
    2a32:	08 95       	ret

00002a34 <vTaskPriorityInherit>:
    2a34:	0f 93       	push	r16
    2a36:	1f 93       	push	r17
    2a38:	cf 93       	push	r28
    2a3a:	df 93       	push	r29
    2a3c:	fc 01       	movw	r30, r24
    2a3e:	89 2b       	or	r24, r25
    2a40:	09 f4       	brne	.+2      	; 0x2a44 <vTaskPriorityInherit+0x10>
    2a42:	55 c0       	rjmp	.+170    	; 0x2aee <vTaskPriorityInherit+0xba>
    2a44:	26 89       	ldd	r18, Z+22	; 0x16
    2a46:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2a4a:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2a4e:	56 96       	adiw	r26, 0x16	; 22
    2a50:	8c 91       	ld	r24, X
    2a52:	28 17       	cp	r18, r24
    2a54:	08 f0       	brcs	.+2      	; 0x2a58 <vTaskPriorityInherit+0x24>
    2a56:	4b c0       	rjmp	.+150    	; 0x2aee <vTaskPriorityInherit+0xba>
    2a58:	84 85       	ldd	r24, Z+12	; 0x0c
    2a5a:	95 85       	ldd	r25, Z+13	; 0x0d
    2a5c:	99 23       	and	r25, r25
    2a5e:	64 f0       	brlt	.+24     	; 0x2a78 <vTaskPriorityInherit+0x44>
    2a60:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2a64:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2a68:	56 96       	adiw	r26, 0x16	; 22
    2a6a:	3c 91       	ld	r19, X
    2a6c:	84 e0       	ldi	r24, 0x04	; 4
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	83 1b       	sub	r24, r19
    2a72:	91 09       	sbc	r25, r1
    2a74:	95 87       	std	Z+13, r25	; 0x0d
    2a76:	84 87       	std	Z+12, r24	; 0x0c
    2a78:	30 e0       	ldi	r19, 0x00	; 0
    2a7a:	c9 01       	movw	r24, r18
    2a7c:	88 0f       	add	r24, r24
    2a7e:	99 1f       	adc	r25, r25
    2a80:	88 0f       	add	r24, r24
    2a82:	99 1f       	adc	r25, r25
    2a84:	88 0f       	add	r24, r24
    2a86:	99 1f       	adc	r25, r25
    2a88:	28 0f       	add	r18, r24
    2a8a:	39 1f       	adc	r19, r25
    2a8c:	29 57       	subi	r18, 0x79	; 121
    2a8e:	32 4f       	sbci	r19, 0xF2	; 242
    2a90:	82 85       	ldd	r24, Z+10	; 0x0a
    2a92:	93 85       	ldd	r25, Z+11	; 0x0b
    2a94:	82 17       	cp	r24, r18
    2a96:	93 07       	cpc	r25, r19
    2a98:	19 f5       	brne	.+70     	; 0x2ae0 <vTaskPriorityInherit+0xac>
    2a9a:	8f 01       	movw	r16, r30
    2a9c:	ef 01       	movw	r28, r30
    2a9e:	22 96       	adiw	r28, 0x02	; 2
    2aa0:	ce 01       	movw	r24, r28
    2aa2:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <uxListRemove>
    2aa6:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2aaa:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2aae:	86 89       	ldd	r24, Z+22	; 0x16
    2ab0:	f8 01       	movw	r30, r16
    2ab2:	86 8b       	std	Z+22, r24	; 0x16
    2ab4:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2ab8:	98 17       	cp	r25, r24
    2aba:	10 f4       	brcc	.+4      	; 0x2ac0 <vTaskPriorityInherit+0x8c>
    2abc:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	9c 01       	movw	r18, r24
    2ac4:	22 0f       	add	r18, r18
    2ac6:	33 1f       	adc	r19, r19
    2ac8:	22 0f       	add	r18, r18
    2aca:	33 1f       	adc	r19, r19
    2acc:	22 0f       	add	r18, r18
    2ace:	33 1f       	adc	r19, r19
    2ad0:	82 0f       	add	r24, r18
    2ad2:	93 1f       	adc	r25, r19
    2ad4:	be 01       	movw	r22, r28
    2ad6:	89 57       	subi	r24, 0x79	; 121
    2ad8:	92 4f       	sbci	r25, 0xF2	; 242
    2ada:	0e 94 92 0c 	call	0x1924	; 0x1924 <vListInsertEnd>
    2ade:	07 c0       	rjmp	.+14     	; 0x2aee <vTaskPriorityInherit+0xba>
    2ae0:	a0 91 ab 0d 	lds	r26, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2ae4:	b0 91 ac 0d 	lds	r27, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2ae8:	56 96       	adiw	r26, 0x16	; 22
    2aea:	8c 91       	ld	r24, X
    2aec:	86 8b       	std	Z+22, r24	; 0x16
    2aee:	df 91       	pop	r29
    2af0:	cf 91       	pop	r28
    2af2:	1f 91       	pop	r17
    2af4:	0f 91       	pop	r16
    2af6:	08 95       	ret

00002af8 <xTaskPriorityDisinherit>:
    2af8:	0f 93       	push	r16
    2afa:	1f 93       	push	r17
    2afc:	cf 93       	push	r28
    2afe:	df 93       	push	r29
    2b00:	fc 01       	movw	r30, r24
    2b02:	89 2b       	or	r24, r25
    2b04:	79 f1       	breq	.+94     	; 0x2b64 <xTaskPriorityDisinherit+0x6c>
    2b06:	82 a1       	ldd	r24, Z+34	; 0x22
    2b08:	81 50       	subi	r24, 0x01	; 1
    2b0a:	82 a3       	std	Z+34, r24	; 0x22
    2b0c:	26 89       	ldd	r18, Z+22	; 0x16
    2b0e:	91 a1       	ldd	r25, Z+33	; 0x21
    2b10:	29 17       	cp	r18, r25
    2b12:	51 f1       	breq	.+84     	; 0x2b68 <xTaskPriorityDisinherit+0x70>
    2b14:	81 11       	cpse	r24, r1
    2b16:	2a c0       	rjmp	.+84     	; 0x2b6c <xTaskPriorityDisinherit+0x74>
    2b18:	ef 01       	movw	r28, r30
    2b1a:	8f 01       	movw	r16, r30
    2b1c:	0e 5f       	subi	r16, 0xFE	; 254
    2b1e:	1f 4f       	sbci	r17, 0xFF	; 255
    2b20:	c8 01       	movw	r24, r16
    2b22:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <uxListRemove>
    2b26:	89 a1       	ldd	r24, Y+33	; 0x21
    2b28:	8e 8b       	std	Y+22, r24	; 0x16
    2b2a:	24 e0       	ldi	r18, 0x04	; 4
    2b2c:	30 e0       	ldi	r19, 0x00	; 0
    2b2e:	28 1b       	sub	r18, r24
    2b30:	31 09       	sbc	r19, r1
    2b32:	3d 87       	std	Y+13, r19	; 0x0d
    2b34:	2c 87       	std	Y+12, r18	; 0x0c
    2b36:	90 91 51 0d 	lds	r25, 0x0D51	; 0x800d51 <uxTopReadyPriority>
    2b3a:	98 17       	cp	r25, r24
    2b3c:	10 f4       	brcc	.+4      	; 0x2b42 <xTaskPriorityDisinherit+0x4a>
    2b3e:	80 93 51 0d 	sts	0x0D51, r24	; 0x800d51 <uxTopReadyPriority>
    2b42:	90 e0       	ldi	r25, 0x00	; 0
    2b44:	9c 01       	movw	r18, r24
    2b46:	22 0f       	add	r18, r18
    2b48:	33 1f       	adc	r19, r19
    2b4a:	22 0f       	add	r18, r18
    2b4c:	33 1f       	adc	r19, r19
    2b4e:	22 0f       	add	r18, r18
    2b50:	33 1f       	adc	r19, r19
    2b52:	82 0f       	add	r24, r18
    2b54:	93 1f       	adc	r25, r19
    2b56:	b8 01       	movw	r22, r16
    2b58:	89 57       	subi	r24, 0x79	; 121
    2b5a:	92 4f       	sbci	r25, 0xF2	; 242
    2b5c:	0e 94 92 0c 	call	0x1924	; 0x1924 <vListInsertEnd>
    2b60:	81 e0       	ldi	r24, 0x01	; 1
    2b62:	05 c0       	rjmp	.+10     	; 0x2b6e <xTaskPriorityDisinherit+0x76>
    2b64:	80 e0       	ldi	r24, 0x00	; 0
    2b66:	03 c0       	rjmp	.+6      	; 0x2b6e <xTaskPriorityDisinherit+0x76>
    2b68:	80 e0       	ldi	r24, 0x00	; 0
    2b6a:	01 c0       	rjmp	.+2      	; 0x2b6e <xTaskPriorityDisinherit+0x76>
    2b6c:	80 e0       	ldi	r24, 0x00	; 0
    2b6e:	df 91       	pop	r29
    2b70:	cf 91       	pop	r28
    2b72:	1f 91       	pop	r17
    2b74:	0f 91       	pop	r16
    2b76:	08 95       	ret

00002b78 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2b78:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2b7c:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2b80:	89 2b       	or	r24, r25
    2b82:	39 f0       	breq	.+14     	; 0x2b92 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2b84:	e0 91 ab 0d 	lds	r30, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2b88:	f0 91 ac 0d 	lds	r31, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
    2b8c:	82 a1       	ldd	r24, Z+34	; 0x22
    2b8e:	8f 5f       	subi	r24, 0xFF	; 255
    2b90:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2b92:	80 91 ab 0d 	lds	r24, 0x0DAB	; 0x800dab <pxCurrentTCB>
    2b96:	90 91 ac 0d 	lds	r25, 0x0DAC	; 0x800dac <pxCurrentTCB+0x1>
	}
    2b9a:	08 95       	ret

00002b9c <__subsf3>:
    2b9c:	50 58       	subi	r21, 0x80	; 128

00002b9e <__addsf3>:
    2b9e:	bb 27       	eor	r27, r27
    2ba0:	aa 27       	eor	r26, r26
    2ba2:	0e d0       	rcall	.+28     	; 0x2bc0 <__addsf3x>
    2ba4:	e0 c0       	rjmp	.+448    	; 0x2d66 <__fp_round>
    2ba6:	d1 d0       	rcall	.+418    	; 0x2d4a <__fp_pscA>
    2ba8:	30 f0       	brcs	.+12     	; 0x2bb6 <__addsf3+0x18>
    2baa:	d6 d0       	rcall	.+428    	; 0x2d58 <__fp_pscB>
    2bac:	20 f0       	brcs	.+8      	; 0x2bb6 <__addsf3+0x18>
    2bae:	31 f4       	brne	.+12     	; 0x2bbc <__addsf3+0x1e>
    2bb0:	9f 3f       	cpi	r25, 0xFF	; 255
    2bb2:	11 f4       	brne	.+4      	; 0x2bb8 <__addsf3+0x1a>
    2bb4:	1e f4       	brtc	.+6      	; 0x2bbc <__addsf3+0x1e>
    2bb6:	c6 c0       	rjmp	.+396    	; 0x2d44 <__fp_nan>
    2bb8:	0e f4       	brtc	.+2      	; 0x2bbc <__addsf3+0x1e>
    2bba:	e0 95       	com	r30
    2bbc:	e7 fb       	bst	r30, 7
    2bbe:	bc c0       	rjmp	.+376    	; 0x2d38 <__fp_inf>

00002bc0 <__addsf3x>:
    2bc0:	e9 2f       	mov	r30, r25
    2bc2:	e2 d0       	rcall	.+452    	; 0x2d88 <__fp_split3>
    2bc4:	80 f3       	brcs	.-32     	; 0x2ba6 <__addsf3+0x8>
    2bc6:	ba 17       	cp	r27, r26
    2bc8:	62 07       	cpc	r22, r18
    2bca:	73 07       	cpc	r23, r19
    2bcc:	84 07       	cpc	r24, r20
    2bce:	95 07       	cpc	r25, r21
    2bd0:	18 f0       	brcs	.+6      	; 0x2bd8 <__addsf3x+0x18>
    2bd2:	71 f4       	brne	.+28     	; 0x2bf0 <__addsf3x+0x30>
    2bd4:	9e f5       	brtc	.+102    	; 0x2c3c <__addsf3x+0x7c>
    2bd6:	fa c0       	rjmp	.+500    	; 0x2dcc <__fp_zero>
    2bd8:	0e f4       	brtc	.+2      	; 0x2bdc <__addsf3x+0x1c>
    2bda:	e0 95       	com	r30
    2bdc:	0b 2e       	mov	r0, r27
    2bde:	ba 2f       	mov	r27, r26
    2be0:	a0 2d       	mov	r26, r0
    2be2:	0b 01       	movw	r0, r22
    2be4:	b9 01       	movw	r22, r18
    2be6:	90 01       	movw	r18, r0
    2be8:	0c 01       	movw	r0, r24
    2bea:	ca 01       	movw	r24, r20
    2bec:	a0 01       	movw	r20, r0
    2bee:	11 24       	eor	r1, r1
    2bf0:	ff 27       	eor	r31, r31
    2bf2:	59 1b       	sub	r21, r25
    2bf4:	99 f0       	breq	.+38     	; 0x2c1c <__addsf3x+0x5c>
    2bf6:	59 3f       	cpi	r21, 0xF9	; 249
    2bf8:	50 f4       	brcc	.+20     	; 0x2c0e <__addsf3x+0x4e>
    2bfa:	50 3e       	cpi	r21, 0xE0	; 224
    2bfc:	68 f1       	brcs	.+90     	; 0x2c58 <__addsf3x+0x98>
    2bfe:	1a 16       	cp	r1, r26
    2c00:	f0 40       	sbci	r31, 0x00	; 0
    2c02:	a2 2f       	mov	r26, r18
    2c04:	23 2f       	mov	r18, r19
    2c06:	34 2f       	mov	r19, r20
    2c08:	44 27       	eor	r20, r20
    2c0a:	58 5f       	subi	r21, 0xF8	; 248
    2c0c:	f3 cf       	rjmp	.-26     	; 0x2bf4 <__addsf3x+0x34>
    2c0e:	46 95       	lsr	r20
    2c10:	37 95       	ror	r19
    2c12:	27 95       	ror	r18
    2c14:	a7 95       	ror	r26
    2c16:	f0 40       	sbci	r31, 0x00	; 0
    2c18:	53 95       	inc	r21
    2c1a:	c9 f7       	brne	.-14     	; 0x2c0e <__addsf3x+0x4e>
    2c1c:	7e f4       	brtc	.+30     	; 0x2c3c <__addsf3x+0x7c>
    2c1e:	1f 16       	cp	r1, r31
    2c20:	ba 0b       	sbc	r27, r26
    2c22:	62 0b       	sbc	r22, r18
    2c24:	73 0b       	sbc	r23, r19
    2c26:	84 0b       	sbc	r24, r20
    2c28:	ba f0       	brmi	.+46     	; 0x2c58 <__addsf3x+0x98>
    2c2a:	91 50       	subi	r25, 0x01	; 1
    2c2c:	a1 f0       	breq	.+40     	; 0x2c56 <__addsf3x+0x96>
    2c2e:	ff 0f       	add	r31, r31
    2c30:	bb 1f       	adc	r27, r27
    2c32:	66 1f       	adc	r22, r22
    2c34:	77 1f       	adc	r23, r23
    2c36:	88 1f       	adc	r24, r24
    2c38:	c2 f7       	brpl	.-16     	; 0x2c2a <__addsf3x+0x6a>
    2c3a:	0e c0       	rjmp	.+28     	; 0x2c58 <__addsf3x+0x98>
    2c3c:	ba 0f       	add	r27, r26
    2c3e:	62 1f       	adc	r22, r18
    2c40:	73 1f       	adc	r23, r19
    2c42:	84 1f       	adc	r24, r20
    2c44:	48 f4       	brcc	.+18     	; 0x2c58 <__addsf3x+0x98>
    2c46:	87 95       	ror	r24
    2c48:	77 95       	ror	r23
    2c4a:	67 95       	ror	r22
    2c4c:	b7 95       	ror	r27
    2c4e:	f7 95       	ror	r31
    2c50:	9e 3f       	cpi	r25, 0xFE	; 254
    2c52:	08 f0       	brcs	.+2      	; 0x2c56 <__addsf3x+0x96>
    2c54:	b3 cf       	rjmp	.-154    	; 0x2bbc <__addsf3+0x1e>
    2c56:	93 95       	inc	r25
    2c58:	88 0f       	add	r24, r24
    2c5a:	08 f0       	brcs	.+2      	; 0x2c5e <__addsf3x+0x9e>
    2c5c:	99 27       	eor	r25, r25
    2c5e:	ee 0f       	add	r30, r30
    2c60:	97 95       	ror	r25
    2c62:	87 95       	ror	r24
    2c64:	08 95       	ret

00002c66 <__fixunssfsi>:
    2c66:	98 d0       	rcall	.+304    	; 0x2d98 <__fp_splitA>
    2c68:	88 f0       	brcs	.+34     	; 0x2c8c <__fixunssfsi+0x26>
    2c6a:	9f 57       	subi	r25, 0x7F	; 127
    2c6c:	90 f0       	brcs	.+36     	; 0x2c92 <__fixunssfsi+0x2c>
    2c6e:	b9 2f       	mov	r27, r25
    2c70:	99 27       	eor	r25, r25
    2c72:	b7 51       	subi	r27, 0x17	; 23
    2c74:	a0 f0       	brcs	.+40     	; 0x2c9e <__fixunssfsi+0x38>
    2c76:	d1 f0       	breq	.+52     	; 0x2cac <__fixunssfsi+0x46>
    2c78:	66 0f       	add	r22, r22
    2c7a:	77 1f       	adc	r23, r23
    2c7c:	88 1f       	adc	r24, r24
    2c7e:	99 1f       	adc	r25, r25
    2c80:	1a f0       	brmi	.+6      	; 0x2c88 <__fixunssfsi+0x22>
    2c82:	ba 95       	dec	r27
    2c84:	c9 f7       	brne	.-14     	; 0x2c78 <__fixunssfsi+0x12>
    2c86:	12 c0       	rjmp	.+36     	; 0x2cac <__fixunssfsi+0x46>
    2c88:	b1 30       	cpi	r27, 0x01	; 1
    2c8a:	81 f0       	breq	.+32     	; 0x2cac <__fixunssfsi+0x46>
    2c8c:	9f d0       	rcall	.+318    	; 0x2dcc <__fp_zero>
    2c8e:	b1 e0       	ldi	r27, 0x01	; 1
    2c90:	08 95       	ret
    2c92:	9c c0       	rjmp	.+312    	; 0x2dcc <__fp_zero>
    2c94:	67 2f       	mov	r22, r23
    2c96:	78 2f       	mov	r23, r24
    2c98:	88 27       	eor	r24, r24
    2c9a:	b8 5f       	subi	r27, 0xF8	; 248
    2c9c:	39 f0       	breq	.+14     	; 0x2cac <__fixunssfsi+0x46>
    2c9e:	b9 3f       	cpi	r27, 0xF9	; 249
    2ca0:	cc f3       	brlt	.-14     	; 0x2c94 <__fixunssfsi+0x2e>
    2ca2:	86 95       	lsr	r24
    2ca4:	77 95       	ror	r23
    2ca6:	67 95       	ror	r22
    2ca8:	b3 95       	inc	r27
    2caa:	d9 f7       	brne	.-10     	; 0x2ca2 <__fixunssfsi+0x3c>
    2cac:	3e f4       	brtc	.+14     	; 0x2cbc <__fixunssfsi+0x56>
    2cae:	90 95       	com	r25
    2cb0:	80 95       	com	r24
    2cb2:	70 95       	com	r23
    2cb4:	61 95       	neg	r22
    2cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    2cb8:	8f 4f       	sbci	r24, 0xFF	; 255
    2cba:	9f 4f       	sbci	r25, 0xFF	; 255
    2cbc:	08 95       	ret

00002cbe <__floatunsisf>:
    2cbe:	e8 94       	clt
    2cc0:	09 c0       	rjmp	.+18     	; 0x2cd4 <__floatsisf+0x12>

00002cc2 <__floatsisf>:
    2cc2:	97 fb       	bst	r25, 7
    2cc4:	3e f4       	brtc	.+14     	; 0x2cd4 <__floatsisf+0x12>
    2cc6:	90 95       	com	r25
    2cc8:	80 95       	com	r24
    2cca:	70 95       	com	r23
    2ccc:	61 95       	neg	r22
    2cce:	7f 4f       	sbci	r23, 0xFF	; 255
    2cd0:	8f 4f       	sbci	r24, 0xFF	; 255
    2cd2:	9f 4f       	sbci	r25, 0xFF	; 255
    2cd4:	99 23       	and	r25, r25
    2cd6:	a9 f0       	breq	.+42     	; 0x2d02 <__floatsisf+0x40>
    2cd8:	f9 2f       	mov	r31, r25
    2cda:	96 e9       	ldi	r25, 0x96	; 150
    2cdc:	bb 27       	eor	r27, r27
    2cde:	93 95       	inc	r25
    2ce0:	f6 95       	lsr	r31
    2ce2:	87 95       	ror	r24
    2ce4:	77 95       	ror	r23
    2ce6:	67 95       	ror	r22
    2ce8:	b7 95       	ror	r27
    2cea:	f1 11       	cpse	r31, r1
    2cec:	f8 cf       	rjmp	.-16     	; 0x2cde <__floatsisf+0x1c>
    2cee:	fa f4       	brpl	.+62     	; 0x2d2e <__floatsisf+0x6c>
    2cf0:	bb 0f       	add	r27, r27
    2cf2:	11 f4       	brne	.+4      	; 0x2cf8 <__floatsisf+0x36>
    2cf4:	60 ff       	sbrs	r22, 0
    2cf6:	1b c0       	rjmp	.+54     	; 0x2d2e <__floatsisf+0x6c>
    2cf8:	6f 5f       	subi	r22, 0xFF	; 255
    2cfa:	7f 4f       	sbci	r23, 0xFF	; 255
    2cfc:	8f 4f       	sbci	r24, 0xFF	; 255
    2cfe:	9f 4f       	sbci	r25, 0xFF	; 255
    2d00:	16 c0       	rjmp	.+44     	; 0x2d2e <__floatsisf+0x6c>
    2d02:	88 23       	and	r24, r24
    2d04:	11 f0       	breq	.+4      	; 0x2d0a <__floatsisf+0x48>
    2d06:	96 e9       	ldi	r25, 0x96	; 150
    2d08:	11 c0       	rjmp	.+34     	; 0x2d2c <__floatsisf+0x6a>
    2d0a:	77 23       	and	r23, r23
    2d0c:	21 f0       	breq	.+8      	; 0x2d16 <__floatsisf+0x54>
    2d0e:	9e e8       	ldi	r25, 0x8E	; 142
    2d10:	87 2f       	mov	r24, r23
    2d12:	76 2f       	mov	r23, r22
    2d14:	05 c0       	rjmp	.+10     	; 0x2d20 <__floatsisf+0x5e>
    2d16:	66 23       	and	r22, r22
    2d18:	71 f0       	breq	.+28     	; 0x2d36 <__floatsisf+0x74>
    2d1a:	96 e8       	ldi	r25, 0x86	; 134
    2d1c:	86 2f       	mov	r24, r22
    2d1e:	70 e0       	ldi	r23, 0x00	; 0
    2d20:	60 e0       	ldi	r22, 0x00	; 0
    2d22:	2a f0       	brmi	.+10     	; 0x2d2e <__floatsisf+0x6c>
    2d24:	9a 95       	dec	r25
    2d26:	66 0f       	add	r22, r22
    2d28:	77 1f       	adc	r23, r23
    2d2a:	88 1f       	adc	r24, r24
    2d2c:	da f7       	brpl	.-10     	; 0x2d24 <__floatsisf+0x62>
    2d2e:	88 0f       	add	r24, r24
    2d30:	96 95       	lsr	r25
    2d32:	87 95       	ror	r24
    2d34:	97 f9       	bld	r25, 7
    2d36:	08 95       	ret

00002d38 <__fp_inf>:
    2d38:	97 f9       	bld	r25, 7
    2d3a:	9f 67       	ori	r25, 0x7F	; 127
    2d3c:	80 e8       	ldi	r24, 0x80	; 128
    2d3e:	70 e0       	ldi	r23, 0x00	; 0
    2d40:	60 e0       	ldi	r22, 0x00	; 0
    2d42:	08 95       	ret

00002d44 <__fp_nan>:
    2d44:	9f ef       	ldi	r25, 0xFF	; 255
    2d46:	80 ec       	ldi	r24, 0xC0	; 192
    2d48:	08 95       	ret

00002d4a <__fp_pscA>:
    2d4a:	00 24       	eor	r0, r0
    2d4c:	0a 94       	dec	r0
    2d4e:	16 16       	cp	r1, r22
    2d50:	17 06       	cpc	r1, r23
    2d52:	18 06       	cpc	r1, r24
    2d54:	09 06       	cpc	r0, r25
    2d56:	08 95       	ret

00002d58 <__fp_pscB>:
    2d58:	00 24       	eor	r0, r0
    2d5a:	0a 94       	dec	r0
    2d5c:	12 16       	cp	r1, r18
    2d5e:	13 06       	cpc	r1, r19
    2d60:	14 06       	cpc	r1, r20
    2d62:	05 06       	cpc	r0, r21
    2d64:	08 95       	ret

00002d66 <__fp_round>:
    2d66:	09 2e       	mov	r0, r25
    2d68:	03 94       	inc	r0
    2d6a:	00 0c       	add	r0, r0
    2d6c:	11 f4       	brne	.+4      	; 0x2d72 <__fp_round+0xc>
    2d6e:	88 23       	and	r24, r24
    2d70:	52 f0       	brmi	.+20     	; 0x2d86 <__fp_round+0x20>
    2d72:	bb 0f       	add	r27, r27
    2d74:	40 f4       	brcc	.+16     	; 0x2d86 <__fp_round+0x20>
    2d76:	bf 2b       	or	r27, r31
    2d78:	11 f4       	brne	.+4      	; 0x2d7e <__fp_round+0x18>
    2d7a:	60 ff       	sbrs	r22, 0
    2d7c:	04 c0       	rjmp	.+8      	; 0x2d86 <__fp_round+0x20>
    2d7e:	6f 5f       	subi	r22, 0xFF	; 255
    2d80:	7f 4f       	sbci	r23, 0xFF	; 255
    2d82:	8f 4f       	sbci	r24, 0xFF	; 255
    2d84:	9f 4f       	sbci	r25, 0xFF	; 255
    2d86:	08 95       	ret

00002d88 <__fp_split3>:
    2d88:	57 fd       	sbrc	r21, 7
    2d8a:	90 58       	subi	r25, 0x80	; 128
    2d8c:	44 0f       	add	r20, r20
    2d8e:	55 1f       	adc	r21, r21
    2d90:	59 f0       	breq	.+22     	; 0x2da8 <__fp_splitA+0x10>
    2d92:	5f 3f       	cpi	r21, 0xFF	; 255
    2d94:	71 f0       	breq	.+28     	; 0x2db2 <__fp_splitA+0x1a>
    2d96:	47 95       	ror	r20

00002d98 <__fp_splitA>:
    2d98:	88 0f       	add	r24, r24
    2d9a:	97 fb       	bst	r25, 7
    2d9c:	99 1f       	adc	r25, r25
    2d9e:	61 f0       	breq	.+24     	; 0x2db8 <__fp_splitA+0x20>
    2da0:	9f 3f       	cpi	r25, 0xFF	; 255
    2da2:	79 f0       	breq	.+30     	; 0x2dc2 <__fp_splitA+0x2a>
    2da4:	87 95       	ror	r24
    2da6:	08 95       	ret
    2da8:	12 16       	cp	r1, r18
    2daa:	13 06       	cpc	r1, r19
    2dac:	14 06       	cpc	r1, r20
    2dae:	55 1f       	adc	r21, r21
    2db0:	f2 cf       	rjmp	.-28     	; 0x2d96 <__fp_split3+0xe>
    2db2:	46 95       	lsr	r20
    2db4:	f1 df       	rcall	.-30     	; 0x2d98 <__fp_splitA>
    2db6:	08 c0       	rjmp	.+16     	; 0x2dc8 <__fp_splitA+0x30>
    2db8:	16 16       	cp	r1, r22
    2dba:	17 06       	cpc	r1, r23
    2dbc:	18 06       	cpc	r1, r24
    2dbe:	99 1f       	adc	r25, r25
    2dc0:	f1 cf       	rjmp	.-30     	; 0x2da4 <__fp_splitA+0xc>
    2dc2:	86 95       	lsr	r24
    2dc4:	71 05       	cpc	r23, r1
    2dc6:	61 05       	cpc	r22, r1
    2dc8:	08 94       	sec
    2dca:	08 95       	ret

00002dcc <__fp_zero>:
    2dcc:	e8 94       	clt

00002dce <__fp_szero>:
    2dce:	bb 27       	eor	r27, r27
    2dd0:	66 27       	eor	r22, r22
    2dd2:	77 27       	eor	r23, r23
    2dd4:	cb 01       	movw	r24, r22
    2dd6:	97 f9       	bld	r25, 7
    2dd8:	08 95       	ret

00002dda <__udivmodsi4>:
    2dda:	a1 e2       	ldi	r26, 0x21	; 33
    2ddc:	1a 2e       	mov	r1, r26
    2dde:	aa 1b       	sub	r26, r26
    2de0:	bb 1b       	sub	r27, r27
    2de2:	fd 01       	movw	r30, r26
    2de4:	0d c0       	rjmp	.+26     	; 0x2e00 <__udivmodsi4_ep>

00002de6 <__udivmodsi4_loop>:
    2de6:	aa 1f       	adc	r26, r26
    2de8:	bb 1f       	adc	r27, r27
    2dea:	ee 1f       	adc	r30, r30
    2dec:	ff 1f       	adc	r31, r31
    2dee:	a2 17       	cp	r26, r18
    2df0:	b3 07       	cpc	r27, r19
    2df2:	e4 07       	cpc	r30, r20
    2df4:	f5 07       	cpc	r31, r21
    2df6:	20 f0       	brcs	.+8      	; 0x2e00 <__udivmodsi4_ep>
    2df8:	a2 1b       	sub	r26, r18
    2dfa:	b3 0b       	sbc	r27, r19
    2dfc:	e4 0b       	sbc	r30, r20
    2dfe:	f5 0b       	sbc	r31, r21

00002e00 <__udivmodsi4_ep>:
    2e00:	66 1f       	adc	r22, r22
    2e02:	77 1f       	adc	r23, r23
    2e04:	88 1f       	adc	r24, r24
    2e06:	99 1f       	adc	r25, r25
    2e08:	1a 94       	dec	r1
    2e0a:	69 f7       	brne	.-38     	; 0x2de6 <__udivmodsi4_loop>
    2e0c:	60 95       	com	r22
    2e0e:	70 95       	com	r23
    2e10:	80 95       	com	r24
    2e12:	90 95       	com	r25
    2e14:	9b 01       	movw	r18, r22
    2e16:	ac 01       	movw	r20, r24
    2e18:	bd 01       	movw	r22, r26
    2e1a:	cf 01       	movw	r24, r30
    2e1c:	08 95       	ret

00002e1e <__tablejump2__>:
    2e1e:	ee 0f       	add	r30, r30
    2e20:	ff 1f       	adc	r31, r31
    2e22:	00 24       	eor	r0, r0
    2e24:	00 1c       	adc	r0, r0
    2e26:	0b be       	out	0x3b, r0	; 59
    2e28:	07 90       	elpm	r0, Z+
    2e2a:	f6 91       	elpm	r31, Z
    2e2c:	e0 2d       	mov	r30, r0
    2e2e:	09 94       	ijmp

00002e30 <memcpy>:
    2e30:	fb 01       	movw	r30, r22
    2e32:	dc 01       	movw	r26, r24
    2e34:	02 c0       	rjmp	.+4      	; 0x2e3a <memcpy+0xa>
    2e36:	01 90       	ld	r0, Z+
    2e38:	0d 92       	st	X+, r0
    2e3a:	41 50       	subi	r20, 0x01	; 1
    2e3c:	50 40       	sbci	r21, 0x00	; 0
    2e3e:	d8 f7       	brcc	.-10     	; 0x2e36 <memcpy+0x6>
    2e40:	08 95       	ret

00002e42 <eeprom_read_byte>:
    2e42:	e1 99       	sbic	0x1c, 1	; 28
    2e44:	fe cf       	rjmp	.-4      	; 0x2e42 <eeprom_read_byte>
    2e46:	9f bb       	out	0x1f, r25	; 31
    2e48:	8e bb       	out	0x1e, r24	; 30
    2e4a:	e0 9a       	sbi	0x1c, 0	; 28
    2e4c:	99 27       	eor	r25, r25
    2e4e:	8d b3       	in	r24, 0x1d	; 29
    2e50:	08 95       	ret

00002e52 <eeprom_update_byte>:
    2e52:	26 2f       	mov	r18, r22

00002e54 <eeprom_update_r18>:
    2e54:	e1 99       	sbic	0x1c, 1	; 28
    2e56:	fe cf       	rjmp	.-4      	; 0x2e54 <eeprom_update_r18>
    2e58:	9f bb       	out	0x1f, r25	; 31
    2e5a:	8e bb       	out	0x1e, r24	; 30
    2e5c:	e0 9a       	sbi	0x1c, 0	; 28
    2e5e:	01 97       	sbiw	r24, 0x01	; 1
    2e60:	0d b2       	in	r0, 0x1d	; 29
    2e62:	02 16       	cp	r0, r18
    2e64:	31 f0       	breq	.+12     	; 0x2e72 <eeprom_update_r18+0x1e>
    2e66:	2d bb       	out	0x1d, r18	; 29
    2e68:	0f b6       	in	r0, 0x3f	; 63
    2e6a:	f8 94       	cli
    2e6c:	e2 9a       	sbi	0x1c, 2	; 28
    2e6e:	e1 9a       	sbi	0x1c, 1	; 28
    2e70:	0f be       	out	0x3f, r0	; 63
    2e72:	08 95       	ret

00002e74 <__do_global_dtors>:
    2e74:	10 e0       	ldi	r17, 0x00	; 0
    2e76:	c7 e4       	ldi	r28, 0x47	; 71
    2e78:	d0 e0       	ldi	r29, 0x00	; 0
    2e7a:	03 c0       	rjmp	.+6      	; 0x2e82 <__do_global_dtors+0xe>
    2e7c:	fe 01       	movw	r30, r28
    2e7e:	cf df       	rcall	.-98     	; 0x2e1e <__tablejump2__>
    2e80:	21 96       	adiw	r28, 0x01	; 1
    2e82:	c8 34       	cpi	r28, 0x48	; 72
    2e84:	d1 07       	cpc	r29, r17
    2e86:	d1 f7       	brne	.-12     	; 0x2e7c <__do_global_dtors+0x8>
    2e88:	f8 94       	cli

00002e8a <__stop_program>:
    2e8a:	ff cf       	rjmp	.-2      	; 0x2e8a <__stop_program>
